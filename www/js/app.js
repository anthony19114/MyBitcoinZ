'use strict';

var modules = [
  'angularMoment',
  'monospaced.qrcode',
  'gettext',
  'ionic',
  'ionic-toast',
  'angular-clipboard',
  'ngTouch',
  'ngLodash',
  'ngCsv',
  'angular-md5',
  'bwcModule',
  'bitauthModule',
  'copayApp.filters',
  'copayApp.services',
  'copayApp.controllers',
  'copayApp.directives',
  'copayApp.addons'
];

var copayApp = window.copayApp = angular.module('copayApp', modules);

angular.module('copayApp.filters', []);
angular.module('copayApp.services', []);
angular.module('copayApp.controllers', []);
angular.module('copayApp.directives', []);
angular.module('copayApp.addons', []);

'use strict';

var unsupported, isaosp;

if (window && window.navigator) {
  var rxaosp = window.navigator.userAgent.match(/Android.*AppleWebKit\/([\d.]+)/);
  isaosp = (rxaosp && rxaosp[1] < 537);
  if (!window.cordova && isaosp)
    unsupported = true;
  if (unsupported) {
    window.location = '#/unsupported';
  }
}

//Setting up route
angular.module('copayApp').config(function(historicLogProvider, $provide, $logProvider, $stateProvider, $urlRouterProvider, $compileProvider, $ionicConfigProvider) {
    $urlRouterProvider.otherwise('/starting');

    // NO CACHE
    //$ionicConfigProvider.views.maxCache(0);

    // TABS BOTTOM
    $ionicConfigProvider.tabs.position('bottom');

    // NAV TITTLE CENTERED
    $ionicConfigProvider.navBar.alignTitle('center');

    // NAV BUTTONS ALIGMENT
    $ionicConfigProvider.navBar.positionPrimaryButtons('left');
    $ionicConfigProvider.navBar.positionSecondaryButtons('right');

    // NAV BACK-BUTTON TEXT/ICON
    $ionicConfigProvider.backButton.icon('icon ion-ios-arrow-thin-left').text('');
    $ionicConfigProvider.backButton.previousTitleText(false);

    // CHECKBOX CIRCLE
    $ionicConfigProvider.form.checkbox('circle');

    // USE NATIVE SCROLLING
    $ionicConfigProvider.scrolling.jsScrolling(false);

    $logProvider.debugEnabled(true);
    $provide.decorator('$log', ['$delegate', 'platformInfo',
      function($delegate, platformInfo) {
        var historicLog = historicLogProvider.$get();

        historicLog.getLevels().forEach(function(levelDesc) {
          var level = levelDesc.level;
          if (platformInfo.isDevel && level == 'error') return;

          var orig = $delegate[level];
          $delegate[level] = function() {
            if (level == 'error')
              console.log(arguments);

            var args = Array.prototype.slice.call(arguments);

            args = args.map(function(v) {
              try {
                if (typeof v == 'undefined') v = 'undefined';
                if (!v) v = 'null';
                if (typeof v == 'object') {
                  if (v.message)
                    v = v.message;
                  else
                    v = JSON.stringify(v);
                }
                // Trim output in mobile
                if (platformInfo.isCordova) {
                  v = v.toString();
                  if (v.length > 3000) {
                    v = v.substr(0, 2997) + '...';
                  }
                }
              } catch (e) {
                console.log('Error at log decorator:', e);
                v = 'undefined';
              }
              return v;
            });

            try {
              if (platformInfo.isCordova)
                console.log(args.join(' '));

              historicLog.add(level, args.join(' '));
              orig.apply(null, args);
            } catch (e) {
              console.log('ERROR (at log decorator):', e, args[0]);
            }
          };
        });
        return $delegate;
      }
    ]);

    // whitelist 'chrome-extension:' for chromeApp to work with image URLs processed by Angular
    // link: http://stackoverflow.com/questions/15606751/angular-changes-urls-to-unsafe-in-extension-page?lq=1
    $compileProvider.imgSrcSanitizationWhitelist(/^\s*((https?|ftp|file|blob|chrome-extension):|data:image\/)/);

    $stateProvider

      /*
       *
       * Other pages
       *
       */

      .state('unsupported', {
        url: '/unsupported',
        templateUrl: 'views/unsupported.html'
      })

      .state('starting', {
        url: '/starting',
        template: '<ion-view id="starting"><ion-content><div class="block-spinner row"><ion-spinner class="spinner-stable" icon="crescent"></ion-spinner></div></ion-content></ion-view>'
      })

      /*
       *
       * URI
       *
       */

      .state('uri', {
        url: '/uri/:url',
        controller: function($stateParams, $log, openURLService, profileService) {
          profileService.whenAvailable(function() {
            $log.info('DEEP LINK from Browser:' + $stateParams.url);
            openURLService.handleURL({
              url: $stateParams.url
            });
          })
        }
      })

      /*
       *
       * Wallet
       *
       */

      .state('tabs.wallet', {
        url: '/wallet/:walletId/:fromOnboarding',
        views: {
          'tab-home@tabs': {
            controller: 'walletDetailsController',
            templateUrl: 'views/walletDetails.html'
          }
        }
      })
      .state('tabs.activity', {
        url: '/activity',
        views: {
          'tab-home@tabs': {
            controller: 'activityController',
            templateUrl: 'views/activity.html',
          }
        }
      })
      .state('tabs.proposals', {
        url: '/proposals',
        views: {
          'tab-home@tabs': {
            controller: 'proposalsController',
            templateUrl: 'views/proposals.html',
          }
        }
      })
      .state('tabs.wallet.tx-details', {
        url: '/tx-details/:txid',
        views: {
          'tab-home@tabs': {
            controller: 'txDetailsController',
            templateUrl: 'views/tx-details.html'
          }
        }
      })
      .state('tabs.wallet.backupWarning', {
        url: '/backupWarning/:from/:walletId',
        views: {
          'tab-home@tabs': {
            controller: 'backupWarningController',
            templateUrl: 'views/backupWarning.html'
          }
        }
      })
      .state('tabs.wallet.backup', {
        url: '/backup/:walletId',
        views: {
          'tab-home@tabs': {
            templateUrl: 'views/backup.html',
            controller: 'backupController'
          }
        }
      })

      .state('tabs.wallet.addresses', {
        url: '/addresses/:walletId/:toAddress',
        views: {
          'tab-home@tabs': {
            controller: 'addressesController',
            templateUrl: 'views/addresses.html'
          }
        }
      })
      .state('tabs.wallet.allAddresses', {
        url: '/allAddresses/:walletId',
        views: {
          'tab-home@tabs': {
            controller: 'addressesController',
            templateUrl: 'views/allAddresses.html'
          }
        }
      })

      /*
       *
       * Tabs
       *
       */

      .state('tabs', {
        url: '/tabs',
        abstract: true,
        controller: 'tabsController',
        templateUrl: 'views/tabs.html'
      })
      .state('tabs.home', {
        url: '/home/:fromOnboarding',
        views: {
          'tab-home': {
            controller: 'tabHomeController',
            templateUrl: 'views/tab-home.html',
          }
        }
      })
      .state('tabs.receive', {
        url: '/receive',
        views: {
          'tab-receive': {
            controller: 'tabReceiveController',
            templateUrl: 'views/tab-receive.html',
          }
        }
      })
      .state('tabs.scan', {
        url: '/scan',
        views: {
          'tab-scan': {
            controller: 'tabScanController',
            templateUrl: 'views/tab-scan.html',
          }
        }
      })
      .state('scanner', {
        url: '/scanner',
        params: {
          passthroughMode: null,
        },
        controller: 'tabScanController',
        templateUrl: 'views/tab-scan.html'
      })
      .state('tabs.send', {
        url: '/send',
        views: {
          'tab-send': {
            controller: 'tabSendController',
            templateUrl: 'views/tab-send.html',
          }
        }
      })
      .state('tabs.settings', {
        url: '/settings',
        views: {
          'tab-settings': {
            controller: 'tabSettingsController',
            templateUrl: 'views/tab-settings.html',
          }
        }
      })

      /*
       *
       * Send
       *
       */

      .state('tabs.send.amount', {
        url: '/amount/:recipientType/:toAddress/:toName/:toEmail/:toColor/:coin/:fixedUnit',
        views: {
          'tab-send@tabs': {
            controller: 'amountController',
            templateUrl: 'views/amount.html'
          }
        }
      })
      .state('tabs.send.confirm', {
        url: '/confirm/:recipientType/:toAddress/:toName/:toAmount/:toEmail/:toColor/:description/:coin/:useSendMax',
        views: {
          'tab-send@tabs': {
            controller: 'confirmController',
            templateUrl: 'views/confirm.html'
          }
        },
        params: {
          paypro: null
        }
      })
      .state('tabs.send.addressbook', {
        url: '/addressbook/add/:fromSendTab/:addressbookEntry',
        views: {
          'tab-send@tabs': {
            templateUrl: 'views/addressbook.add.html',
            controller: 'addressbookAddController'
          }
        }
      })

      /*
       *
       * Add
       *
       */

      .state('tabs.add', {
        url: '/add',
        views: {
          'tab-home@tabs': {
            templateUrl: 'views/add.html'
          }
        }
      })
      .state('tabs.add.join', {
        url: '/join/:url',
        views: {
          'tab-home@tabs': {
            templateUrl: 'views/join.html',
            controller: 'joinController'
          },
        }
      })
      .state('tabs.add.import', {
        url: '/import/:code',
        views: {
          'tab-home@tabs': {
            templateUrl: 'views/import.html',
            controller: 'importController'
          },
        },
      })
      .state('tabs.add.create-personal', {
        url: '/create-personal',
        views: {
          'tab-home@tabs': {
            templateUrl: 'views/tab-create-personal.html',
            controller: 'createController'
          },
        }
      })
      .state('tabs.add.create-shared', {
        url: '/create-shared',
        views: {
          'tab-home@tabs': {
            templateUrl: 'views/tab-create-shared.html',
            controller: 'createController'
          },
        }
      })

      /*
       *
       * Global Settings
       *
       */

      .state('tabs.preferencesCash', {
        url: '/preferencesCash',
        views: {
          'tab-settings@tabs': {
            controller: 'preferencesCashController',
            templateUrl: 'views/preferencesCash.html'
          }
        }
      })

      .state('tabs.notifications', {
        url: '/notifications',
        views: {
          'tab-settings@tabs': {
            controller: 'preferencesNotificationsController',
            templateUrl: 'views/preferencesNotifications.html'
          }
        }
      })
      .state('tabs.language', {
        url: '/language',
        views: {
          'tab-settings@tabs': {
            controller: 'preferencesLanguageController',
            templateUrl: 'views/preferencesLanguage.html'
          }
        }
      })
      .state('tabs.fee', {
        url: '/fee',
        views: {
          'tab-settings@tabs': {
            controller: 'preferencesFeeController',
            templateUrl: 'views/preferencesFee.html'
          }
        }
      })
      .state('tabs.altCurrency', {
        url: '/altCurrency',
        views: {
          'tab-settings@tabs': {
            controller: 'preferencesAltCurrencyController',
            templateUrl: 'views/preferencesAltCurrency.html'
          }
        }
      })
      .state('tabs.about', {
        url: '/about',
        views: {
          'tab-settings@tabs': {
            controller: 'preferencesAbout',
            templateUrl: 'views/preferencesAbout.html'
          }
        }
      })
      .state('tabs.about.logs', {
        url: '/logs',
        views: {
          'tab-settings@tabs': {
            controller: 'preferencesLogs',
            templateUrl: 'views/preferencesLogs.html'
          }
        }
      })
      .state('tabs.about.termsOfUse', {
        url: '/termsOfUse',
        views: {
          'tab-settings@tabs': {
            templateUrl: 'views/termsOfUse.html'
          }
        }
      })
      .state('tabs.advanced', {
        url: '/advanced',
        views: {
          'tab-settings@tabs': {
            controller: 'advancedSettingsController',
            templateUrl: 'views/advancedSettings.html'
          }
        }
      })
      .state('tabs.lockSetup', {
        url: '/lockSetup',
        views: {
          'tab-settings@tabs': {
            controller: 'lockSetupController',
            templateUrl: 'views/lockSetup.html',
          }
        }
      })
      .state('tabs.pin', {
        url: '/pin/:action',
        views: {
          'tab-settings@tabs': {
            controller: 'pinController',
            templateUrl: 'views/pin.html',
            cache: false
          }
        }
      })


      /*
       *
       * Wallet preferences
       *
       */

      .state('tabs.preferences', {
        url: '/preferences/:walletId',
        views: {
          'tab-settings@tabs': {
            controller: 'preferencesController',
            templateUrl: 'views/preferences.html'
          }
        }
      })
      .state('tabs.preferences.preferencesAlias', {
        url: '/preferencesAlias',
        views: {
          'tab-settings@tabs': {
            controller: 'preferencesAliasController',
            templateUrl: 'views/preferencesAlias.html'
          }
        }
      })
      .state('tabs.preferences.preferencesColor', {
        url: '/preferencesColor',
        views: {
          'tab-settings@tabs': {
            controller: 'preferencesColorController',
            templateUrl: 'views/preferencesColor.html'
          }
        }
      })
      .state('tabs.preferences.backupWarning', {
        url: '/backupWarning/:from',
        views: {
          'tab-settings@tabs': {
            controller: 'backupWarningController',
            templateUrl: 'views/backupWarning.html'
          }
        }
      })
      .state('tabs.preferences.backup', {
        url: '/backup',
        views: {
          'tab-settings@tabs': {
            controller: 'backupController',
            templateUrl: 'views/backup.html'
          }
        }
      })
      .state('tabs.preferences.preferencesAdvanced', {
        url: '/preferencesAdvanced',
        views: {
          'tab-settings@tabs': {
            controller: 'preferencesAdvancedController',
            templateUrl: 'views/preferencesAdvanced.html'
          }
        }
      })
      .state('tabs.preferences.information', {
        url: '/information',
        views: {
          'tab-settings@tabs': {
            controller: 'preferencesInformation',
            templateUrl: 'views/preferencesInformation.html'
          }
        }
      })
      .state('tabs.preferences.export', {
        url: '/export',
        views: {
          'tab-settings@tabs': {
            controller: 'exportController',
            templateUrl: 'views/export.html'
          }
        }
      })
      .state('tabs.preferences.preferencesBwsUrl', {
        url: '/preferencesBwsUrl',
        views: {
          'tab-settings@tabs': {
            controller: 'preferencesBwsUrlController',
            templateUrl: 'views/preferencesBwsUrl.html'
          }
        }
      })
      .state('tabs.preferences.preferencesHistory', {
        url: '/preferencesHistory',
        views: {
          'tab-settings@tabs': {
            controller: 'preferencesHistory',
            templateUrl: 'views/preferencesHistory.html'
          }
        }
      })
      .state('tabs.preferences.preferencesExternal', {
        url: '/preferencesExternal',
        views: {
          'tab-settings@tabs': {
            controller: 'preferencesExternalController',
            templateUrl: 'views/preferencesExternal.html'
          }
        }
      })
      .state('tabs.preferences.delete', {
        url: '/delete',
        views: {
          'tab-settings@tabs': {
            controller: 'preferencesDeleteWalletController',
            templateUrl: 'views/preferencesDeleteWallet.html'
          }
        }
      })

      .state('tabs.preferencesCash.scan', {
        url: '/cashScan',
        views: {
          'tab-settings@tabs': {
            controller: 'cashScanController',
            templateUrl: 'views/cashScan.html'
          }
        }
      })

      /*
       *
       * Addressbook
       *
       */


      .state('tabs.addressbook', {
        url: '/addressbook',
        views: {
          'tab-settings@tabs': {
            templateUrl: 'views/addressbook.html',
            controller: 'addressbookListController'
          }
        }
      })
      .state('tabs.addressbook.add', {
        url: '/add',
        views: {
          'tab-settings@tabs': {
            templateUrl: 'views/addressbook.add.html',
            controller: 'addressbookAddController'
          }
        }
      })
      .state('tabs.addressbook.view', {
        url: '/view/:address/:email/:name',
        views: {
          'tab-settings@tabs': {
            templateUrl: 'views/addressbook.view.html',
            controller: 'addressbookViewController'
          }
        }
      })

      /*
       *
       * Copayers
       *
       */

      .state('tabs.copayers', {
        url: '/copayers/:walletId',
        views: {
          'tab-home': {
            templateUrl: 'views/copayers.html',
            controller: 'copayersController'
          }
        }
      })

      /*
       *
       * Addresses
       *
       */

      .state('tabs.settings.addresses', {
        url: '/addresses/:walletId/:toAddress',
        views: {
          'tab-settings@tabs': {
            controller: 'addressesController',
            templateUrl: 'views/addresses.html'
          }
        }
      })
      .state('tabs.settings.allAddresses', {
        url: '/allAddresses/:walletId',
        views: {
          'tab-settings@tabs': {
            controller: 'addressesController',
            templateUrl: 'views/allAddresses.html'
          }
        }
      })

      /*
       *
       * Request Specific amount
       *
       */

      .state('tabs.paymentRequest', {
        url: '/payment-request',
        abstract: true,
        params: {
          id: null,
          nextStep: 'tabs.paymentRequest.confirm',
        }
      })

      .state('tabs.paymentRequest.amount', {
        url: '/amount/:coin',
        views: {
          'tab-receive@tabs': {
            controller: 'amountController',
            templateUrl: 'views/amount.html'
          }
        }
      })
      .state('tabs.paymentRequest.confirm', {
        url: '/confirm/:amount/:currency/:coin',
        views: {
          'tab-receive@tabs': {
            controller: 'customAmountController',
            templateUrl: 'views/customAmount.html'
          }
        }
      })

      /*
       *
       * Init backup flow
       *
       */

      .state('tabs.receive.backupWarning', {
        url: '/backupWarning/:from/:walletId',
        views: {
          'tab-receive@tabs': {
            controller: 'backupWarningController',
            templateUrl: 'views/backupWarning.html'
          }
        }
      })
      .state('tabs.receive.backup', {
        url: '/backup/:walletId',
        views: {
          'tab-receive@tabs': {
            controller: 'backupController',
            templateUrl: 'views/backup.html'
          }
        }
      })

      /*
       *
       * Paper Wallet
       *
       */

      .state('tabs.home.paperWallet', {
        url: '/paperWallet/:privateKey',
        views: {
          'tab-home@tabs': {
            controller: 'paperWalletController',
            templateUrl: 'views/paperWallet.html'
          }
        }
      })
      /*
       *
       * Onboarding
       *
       */

      .state('onboarding', {
        url: '/onboarding',
        abstract: true,
        template: '<ion-nav-view name="onboarding"></ion-nav-view>'
      })
      .state('onboarding.welcome', {
        url: '/welcome',
        views: {
          'onboarding': {
            templateUrl: 'views/onboarding/welcome.html',
            controller: 'welcomeController'
          }
        }
      })
      .state('onboarding.tour', {
        url: '/tour',
        views: {
          'onboarding': {
            templateUrl: 'views/onboarding/tour.html',
            controller: 'tourController'
          }
        }
      })
      .state('onboarding.collectEmail', {
        url: '/collectEmail/:walletId',
        views: {
          'onboarding': {
            templateUrl: 'views/onboarding/collectEmail.html',
            controller: 'collectEmailController'
          }
        }
      })
      .state('onboarding.backupRequest', {
        url: '/backupRequest/:walletId',
        views: {
          'onboarding': {
            templateUrl: 'views/onboarding/backupRequest.html',
            controller: 'backupRequestController'
          }
        }
      })
      .state('onboarding.backupWarning', {
        url: '/backupWarning/:from/:walletId',
        views: {
          'onboarding': {
            templateUrl: 'views/backupWarning.html',
            controller: 'backupWarningController'
          }
        }
      })
      .state('onboarding.backup', {
        url: '/backup/:walletId',
        views: {
          'onboarding': {
            templateUrl: 'views/backup.html',
            controller: 'backupController'
          }
        }
      })
      .state('onboarding.disclaimer', {
        url: '/disclaimer/:walletId/:backedUp/:resume',
        views: {
          'onboarding': {
            templateUrl: 'views/onboarding/disclaimer.html',
            controller: 'disclaimerController'
          }
        }
      })
      .state('onboarding.terms', {
        url: '/terms',
        views: {
          'onboarding': {
            templateUrl: 'views/onboarding/terms.html',
            controller: 'termsController'
          }
        }
      })
      .state('onboarding.import', {
        url: '/import',
        views: {
          'onboarding': {
            templateUrl: 'views/import.html',
            controller: 'importController'
          },
        },
        params: {
          code: null,
          fromOnboarding: null
        },
      })

      /*
       *
       * Feedback
       *
       */

      .state('tabs.feedback', {
        url: '/feedback',
        views: {
          'tab-settings@tabs': {
            templateUrl: 'views/feedback/send.html',
            controller: 'sendController'
          }
        }
      })
      .state('tabs.shareApp', {
        url: '/shareApp/:score/:skipped/:fromSettings',
        views: {
          'tab-settings@tabs': {
            controller: 'completeController',
            templateUrl: 'views/feedback/complete.html'
          }
        }
      })
      .state('tabs.rate', {
        url: '/rate',
        abstract: true
      })
      .state('tabs.rate.send', {
        url: '/send/:score',
        views: {
          'tab-home@tabs': {
            templateUrl: 'views/feedback/send.html',
            controller: 'sendController'
          }
        }
      })
      .state('tabs.rate.complete', {
        url: '/complete/:score/:skipped',
        views: {
          'tab-home@tabs': {
            controller: 'completeController',
            templateUrl: 'views/feedback/complete.html'
          }
        }
      })
      .state('tabs.rate.rateApp', {
        url: '/rateApp/:score',
        views: {
          'tab-home@tabs': {
            controller: 'rateAppController',
            templateUrl: 'views/feedback/rateApp.html'
          }
        }
      })

      /*
       *
       * Buy or Sell Bitcoin
       *
       */

      .state('tabs.buyandsell', {
        url: '/buyandsell',
        views: {
          'tab-home': {
            controller: 'buyandsellController',
            templateUrl: 'views/buyandsell.html'
          }
        }
      })

      /*
       *
       * Glidera
       *
       *
       */

      .state('tabs.buyandsell.glidera', {
        url: '/glidera/:code',
        views: {
          'tab-home@tabs': {
            controller: 'glideraController',
            controllerAs: 'glidera',
            templateUrl: 'views/glidera.html'
          }
        },
        params: {
          coin: 'btcz',
        }
      })
      .state('tabs.buyandsell.glidera.amount', {
        url: '/amount/:nextStep/:currency',
        views: {
          'tab-home@tabs': {
            controller: 'amountController',
            templateUrl: 'views/amount.html'
          }
        }
      })
      .state('tabs.buyandsell.glidera.buy', {
        url: '/buy/:amount/:currency',
        views: {
          'tab-home@tabs': {
            controller: 'buyGlideraController',
            templateUrl: 'views/buyGlidera.html'
          }
        }
      })
      .state('tabs.buyandsell.glidera.sell', {
        url: '/sell/:amount/:currency',
        views: {
          'tab-home@tabs': {
            controller: 'sellGlideraController',
            templateUrl: 'views/sellGlidera.html'
          }
        }
      })
      .state('tabs.preferences.glidera', {
        url: '/glidera',
        views: {
          'tab-settings@tabs': {
            controller: 'preferencesGlideraController',
            templateUrl: 'views/preferencesGlidera.html'
          }
        }
      })

      /*
       *
       * Coinbase
       *
       */

      .state('tabs.buyandsell.coinbase', {
        url: '/coinbase/:code',
        views: {
          'tab-home@tabs': {
            controller: 'coinbaseController',
            controllerAs: 'coinbase',
            templateUrl: 'views/coinbase.html'
          }
        },
        params: {
          coin: 'btcz',
        }
      })
      .state('tabs.preferences.coinbase', {
        url: '/coinbase',
        views: {
          'tab-settings@tabs': {
            controller: 'preferencesCoinbaseController',
            templateUrl: 'views/preferencesCoinbase.html'
          }
        }
      })
      .state('tabs.buyandsell.coinbase.amount', {
        url: '/amount/:nextStep/:currency',
        views: {
          'tab-home@tabs': {
            controller: 'amountController',
            templateUrl: 'views/amount.html'
          }
        }
      })
      .state('tabs.buyandsell.coinbase.buy', {
        url: '/buy/:amount/:currency',
        views: {
          'tab-home@tabs': {
            controller: 'buyCoinbaseController',
            templateUrl: 'views/buyCoinbase.html'
          }
        }
      })
      .state('tabs.buyandsell.coinbase.sell', {
        url: '/sell/:amount/:currency',
        views: {
          'tab-home@tabs': {
            controller: 'sellCoinbaseController',
            templateUrl: 'views/sellCoinbase.html'
          }
        }
      })

      /*
       *
       * Gift Cards
       *
       */

      .state('tabs.giftcards', {
        url: '/giftcards',
        abstract: true
      })

      /*
       *
       * Mercado Libre Gift Card
       *
       */

      .state('tabs.giftcards.mercadoLibre', {
        url: '/mercadoLibre',
        views: {
          'tab-home@tabs': {
            controller: 'mercadoLibreController',
            templateUrl: 'views/mercadoLibre.html'
          }
        }
      })
      .state('tabs.giftcards.mercadoLibre.cards', {
        url: '/cards',
        views: {
          'tab-home@tabs': {
            controller: 'mercadoLibreCardsController',
            templateUrl: 'views/mercadoLibreCards.html'
          }
        },
        params: {
          invoiceId: null
        }
      })
      .state('tabs.giftcards.mercadoLibre.amount', {
        url: '/amount',
        views: {
          'tab-home@tabs': {
            controller: 'amountController',
            templateUrl: 'views/amount.html'
          }
        },
        params: {
          nextStep: 'tabs.giftcards.mercadoLibre.buy',
          currency: 'BRL',
          coin: 'btcz',
          fixedUnit: 1,
        }
      })
      .state('tabs.giftcards.mercadoLibre.buy', {
        url: '/buy/:amount/:currency',
        views: {
          'tab-home@tabs': {
            controller: 'buyMercadoLibreController',
            templateUrl: 'views/buyMercadoLibre.html'
          }
        }
      })

      /*
       *
       * Amazon.com Gift Card
       *
       */

      .state('tabs.giftcards.amazon', {
        url: '/amazon',
        views: {
          'tab-home@tabs': {
            controller: 'amazonController',
            templateUrl: 'views/amazon.html'
          }
        }
      })
      .state('tabs.giftcards.amazon.cards', {
        url: '/cards',
        views: {
          'tab-home@tabs': {
            controller: 'amazonCardsController',
            templateUrl: 'views/amazonCards.html'
          }
        },
        params: {
          invoiceId: null
        }
      })
      .state('tabs.giftcards.amazon.amount', {
        url: '/amount',
        views: {
          'tab-home@tabs': {
            controller: 'amountController',
            templateUrl: 'views/amount.html'
          }
        },
        params: {
          nextStep: 'tabs.giftcards.amazon.buy',
          currency: 'USD',
          coin: 'btcz',
          fixedUnit: true,
        }
      })
      .state('tabs.giftcards.amazon.buy', {
        url: '/buy/:amount/:currency',
        views: {
          'tab-home@tabs': {
            controller: 'buyAmazonController',
            templateUrl: 'views/buyAmazon.html'
          }
        }
      })

      /*
       *
       * BitPay Card
       *
       */

      .state('tabs.bitpayCardIntro', {
        url: '/bitpay-card-intro/:secret/:email/:otp',
        views: {
          'tab-home@tabs': {
            controller: 'bitpayCardIntroController',
            templateUrl: 'views/bitpayCardIntro.html'
          }
        }
      })
      .state('tabs.bitpayCard', {
        url: '/bitpay-card',
        views: {
          'tab-home@tabs': {
            controller: 'bitpayCardController',
            controllerAs: 'bitpayCard',
            templateUrl: 'views/bitpayCard.html'
          }
        },
        params: {
          id: null,
          currency: 'USD',
          coin: 'btcz',
          useSendMax: null
        }
      })
      .state('tabs.bitpayCard.amount', {
        url: '/amount/:nextStep',
        views: {
          'tab-home@tabs': {
            controller: 'amountController',
            templateUrl: 'views/amount.html'
          }
        }
      })
      .state('tabs.bitpayCard.topup', {
        url: '/topup/:amount',
        views: {
          'tab-home@tabs': {
            controller: 'topUpController',
            templateUrl: 'views/topup.html'
          }
        }
      })
      .state('tabs.preferences.bitpayServices', {
        url: '/bitpay-services',
        views: {
          'tab-settings@tabs': {
            controller: 'preferencesBitpayServicesController',
            templateUrl: 'views/preferencesBitpayServices.html'
          }
        }
      });
  })
  .run(function($rootScope, $state, $location, $log, $timeout, startupService, ionicToast, fingerprintService, $ionicHistory, $ionicPlatform, $window, appConfigService, lodash, platformInfo, profileService, uxLanguage, gettextCatalog, openURLService, storageService, scannerService, configService, emailService, /* plugins START HERE => */ coinbaseService, glideraService, amazonService, bitpayCardService, applicationService, mercadoLibreService) {

    uxLanguage.init();

    $ionicPlatform.ready(function() {
      if (screen.width < 768 && platformInfo.isCordova)
        screen.lockOrientation('portrait');

      if (window.cordova && window.cordova.plugins && window.cordova.plugins.Keyboard && !platformInfo.isWP) {
        cordova.plugins.Keyboard.hideKeyboardAccessoryBar(false);
        cordova.plugins.Keyboard.disableScroll(true);
      }

      window.addEventListener('native.keyboardshow', function() {
        document.body.classList.add('keyboard-open');
      });

      $ionicPlatform.registerBackButtonAction(function(e) {

        //from root tabs view
        var matchHome = $ionicHistory.currentStateName() == 'tabs.home' ? true : false;
        var matchReceive = $ionicHistory.currentStateName() == 'tabs.receive' ? true : false;
        var matchScan = $ionicHistory.currentStateName() == 'tabs.scan' ? true : false;
        var matchSend = $ionicHistory.currentStateName() == 'tabs.send' ? true : false;
        var matchSettings = $ionicHistory.currentStateName() == 'tabs.settings' ? true : false;

        var fromTabs = matchHome | matchReceive | matchScan | matchSend | matchSettings;

        //onboarding with no back views
        var matchWelcome = $ionicHistory.currentStateName() == 'onboarding.welcome' ? true : false;
        var matchCollectEmail = $ionicHistory.currentStateName() == 'onboarding.collectEmail' ? true : false;
        var matchBackupRequest = $ionicHistory.currentStateName() == 'onboarding.backupRequest' ? true : false;
        var backedUp = $ionicHistory.backView().stateName == 'onboarding.backup' ? true : false;
        var noBackView = $ionicHistory.backView().stateName == 'starting' ? true : false;
        var matchDisclaimer = $ionicHistory.currentStateName() == 'onboarding.disclaimer' && (backedUp || noBackView) ? true : false;

        var fromOnboarding = matchCollectEmail | matchBackupRequest | matchWelcome | matchDisclaimer;

        //views with disable backbutton
        var matchComplete = $ionicHistory.currentStateName() == 'tabs.rate.complete' ? true : false;
        var matchLockedView = $ionicHistory.currentStateName() == 'lockedView' ? true : false;
        var matchPin = $ionicHistory.currentStateName() == 'pin' ? true : false;

        if ($ionicHistory.backView() && !fromTabs && !fromOnboarding && !matchComplete && !matchPin && !matchLockedView) {
          $ionicHistory.goBack();
        } else
        if ($rootScope.backButtonPressedOnceToExit) {
          navigator.app.exitApp();
        } else {
          $rootScope.backButtonPressedOnceToExit = true;
          $rootScope.$apply(function() {
            ionicToast.show(gettextCatalog.getString('Press again to exit'), 'bottom', false, 1000);
          });
          $timeout(function() {
            $rootScope.backButtonPressedOnceToExit = false;
          }, 3000);
        }
        e.preventDefault();
      }, 101);

      $ionicPlatform.on('pause', function() {
        // Nothing to do
      });

      $ionicPlatform.on('resume', function() {
        applicationService.appLockModal('check');
      });

      $ionicPlatform.on('menubutton', function() {
        window.location = '#/preferences';
      });

      $log.info('Init profile...');
      // Try to open local profile
      profileService.loadAndBindProfile(function(err) {
        $ionicHistory.nextViewOptions({
          disableAnimate: true
        });
        if (err) {
          if (err.message && err.message.match('NOPROFILE')) {
            $log.debug('No profile... redirecting');
            $state.go('onboarding.welcome');
          } else if (err.message && err.message.match('NONAGREEDDISCLAIMER')) {
            if (lodash.isEmpty(profileService.getWallets())) {
              $log.debug('No wallets and no disclaimer... redirecting');
              $state.go('onboarding.welcome');
            } else {
              $log.debug('Display disclaimer... redirecting');
              $state.go('onboarding.disclaimer', {
                resume: true
              });
            }
          } else {
            throw new Error(err); // TODO
          }
        } else {
          profileService.storeProfileIfDirty();
          $log.debug('Profile loaded ... Starting UX.');
          scannerService.gentleInitialize();
          // Reload tab-home if necessary (from root path: starting)
          $state.go('starting', {}, {
            'reload': true,
            'notify': $state.current.name == 'starting' ? false : true
          }).then(function() {
            $ionicHistory.nextViewOptions({
              disableAnimate: true,
              historyRoot: true
            });
            $state.transitionTo('tabs.home').then(function() {
              // Clear history
              $ionicHistory.clearHistory();
            });
            applicationService.appLockModal('check');
          });
        };
        // After everything have been loaded
        $timeout(function() {
          emailService.init(); // Update email subscription if necessary
          openURLService.init();
        }, 1000);
      });
    });

    if (platformInfo.isNW) {
      var gui = require('nw.gui');
      var win = gui.Window.get();
      var nativeMenuBar = new gui.Menu({
        type: "menubar"
      });
      try {
        nativeMenuBar.createMacBuiltin(appConfigService.nameCase);
      } catch (e) {
        $log.debug('This is not OSX');
      }
      win.menu = nativeMenuBar;
    }

    $rootScope.$on('$stateChangeStart', function(event, toState, toParams, fromState, fromParams) {
      $log.debug('Route change from:', fromState.name || '-', ' to:', toState.name);
      $log.debug('            toParams:' + JSON.stringify(toParams || {}));
      $log.debug('            fromParams:' + JSON.stringify(fromParams || {}));
    });
  });

'use strict';

angular.module('copayApp.directives')
  .directive('accountSelector', function($timeout) {
    return {
      restrict: 'E',
      templateUrl: 'views/includes/accountSelector.html',
      transclude: true,
      scope: {
        title: '=accountSelectorTitle',
        show: '=accountSelectorShow',
        accounts: '=accountSelectorAccounts',
        selectedAccount: '=accountSelectorSelectedAccount',
        onSelect: '=accountSelectorOnSelect'
      },
      link: function(scope, element, attrs) {
        scope.hide = function() {
          scope.show = false;
        };
        scope.selectAccount = function(account) {
          $timeout(function() {
            scope.hide();
          }, 100);
          scope.onSelect(account);
        };
      }
    };
  });

'use strict';

angular.module('copayApp.directives')
  .directive('actionSheet', function($rootScope, $timeout) {
    return {
      restrict: 'E',
      templateUrl: 'views/includes/actionSheet.html',
      transclude: true,
      scope: {
        show: '=actionSheetShow',
      },
      link: function(scope, element, attrs) {
        scope.$watch('show', function() {
          if (scope.show) {
            $timeout(function() {
              scope.revealMenu = true;
            }, 100);
          } else {
            scope.revealMenu = false;
          }
        });
        scope.hide = function() {
          scope.show = false;
          $rootScope.$broadcast('incomingDataMenu.menuHidden');
        };
      }
    };
  });

'use strict';

angular.module('copayApp.directives')
  .directive('clickToAccept', function() {
    return {
      restrict: 'E',
      templateUrl: 'views/includes/clickToAccept.html',
      transclude: true,
      scope: {
        sendStatus: '=clickSendStatus',
        isDisabled: '=isDisabled',
      },
      link: function(scope, element, attrs) {
        scope.$watch('sendStatus', function() {
          if (scope.sendStatus !== 'success') {
            scope.displaySendStatus = scope.sendStatus;
          }
        });
      }
    };
  });

'use strict';

angular.module('copayApp.directives')
  .directive('copyToClipboard', function(platformInfo, nodeWebkitService, gettextCatalog, ionicToast, clipboard) {
    return {
      restrict: 'A',
      scope: {
        copyToClipboard: '=copyToClipboard'
      },
      link: function(scope, elem, attrs, ctrl) {
        var isCordova = platformInfo.isCordova;
        var isChromeApp = platformInfo.isChromeApp;
        var isNW = platformInfo.isNW;
        elem.bind('mouseover', function() {
          elem.css('cursor', 'pointer');
        });

        var msg = gettextCatalog.getString('Copied to clipboard');
        elem.bind('click', function() {
          var data = scope.copyToClipboard;
          if (!data) return;

          if (isCordova) {
            cordova.plugins.clipboard.copy(data);
          } else if (isNW) {
            nodeWebkitService.writeToClipboard(data);
          } else if (clipboard.supported) {
            clipboard.copyText(data);
          } else {
            // No supported
            return;
          }
          scope.$apply(function() {
            ionicToast.show(msg, 'bottom', false, 1000);
          });
        });
      }
    }
  });

'use strict';

angular.module('copayApp.directives')
  .directive('timer', function() {
    return {
      restrict: 'EAC',
      replace: false,
      scope: {
        countdown: "=",
        interval: "=",
        active: "=",
        onZeroCallback: "="
      },
      template:"{{formatted}}",
      controller: function ($scope, $attrs, $timeout, lodash) {
        $scope.format = $attrs.outputFormat;

        var queueTick = function () {
          $scope.timer = $timeout(function () {
            if ($scope.countdown > 0) {
              $scope.countdown -= 1;

              if ($scope.countdown > 0) {
                queueTick();
              } else {
                $scope.countdown = 0;
                $scope.active = false;
                if (!lodash.isUndefined($scope.onZeroCallback)) {
                  $scope.onZeroCallback();
                }
              }
            }
          }, $scope.interval);
        };

        if ($scope.active) {
          queueTick();
        }

        $scope.$watch('active', function (newValue, oldValue) {
          if (newValue !== oldValue) {
            if (newValue === true) {
              if ($scope.countdown > 0) {
                queueTick();
              } else {
                $scope.active = false;
              }
            } else {
              $timeout.cancel($scope.timer);
            }
          }
        });
        $scope.$watch('countdown', function () {
          updateFormatted();
        });

        var updateFormatted = function () {
          $scope.formatted = moment($scope.countdown * $scope.interval).format($scope.format);
        };
        updateFormatted();

        $scope.$on('$destroy', function () {
          $timeout.cancel($scope.timer);
        });
      }
    };
  });

'use strict';
angular.module('copayApp.directives')
  .directive('validAddress', ['$rootScope', 'bitcore', 'bitcoreCash',
    function($rootScope, bitcore, bitcoreCash) {
      return {
        require: 'ngModel',
        link: function(scope, elem, attrs, ctrl) {
          // Bitcoin address
          var URI = bitcore.URI;
          var Address = bitcore.Address

          // Bitcoin Cash address
          var URICash = bitcoreCash.URI;
          var AddressCash = bitcoreCash.Address

          var validator = function(value) {

            // Regular url
            if (/^https?:\/\//.test(value)) {
              ctrl.$setValidity('validAddress', true);
              return value;
            }

            // Bip21 uri
            var uri, isAddressValidLivenet, isAddressValidTestnet;
            if (/^bitcoin:/.test(value)) {
              var isUriValid = URI.isValid(value);
              if (isUriValid) {
                uri = new URI(value);
                isAddressValidLivenet = Address.isValid(uri.address.toString(), 'livenet')
                isAddressValidTestnet = Address.isValid(uri.address.toString(), 'testnet')
              }
              ctrl.$setValidity('validAddress', isUriValid && (isAddressValidLivenet || isAddressValidTestnet));
              return value;
            } else if (/^bitcoincash:/.test(value)) {
              var isUriValid = URICash.isValid(value);
              if (isUriValid) {
                uri = new URICash(value);
                isAddressValidLivenet = AddressCash.isValid(uri.address.toString(), 'livenet')
              }
              ctrl.$setValidity('validAddress', isUriValid && (isAddressValidLivenet));
              return value;
            }

            if (typeof value == 'undefined') {
              ctrl.$pristine = true;
              return;
            }

            // Regular Address: try Bitcoin and Bitcoin Cash
            var regularAddressLivenet = Address.isValid(value, 'livenet');
            var regularAddressTestnet = Address.isValid(value, 'testnet');
            var regularAddressCashLivenet = AddressCash.isValid(value, 'livenet');
            ctrl.$setValidity('validAddress', (regularAddressLivenet || regularAddressTestnet || regularAddressCashLivenet));
            return value;
          };


          ctrl.$parsers.unshift(validator);
          ctrl.$formatters.unshift(validator);
        }
      };
    }
  ])
  .directive('validAmount', ['configService',
    function(configService) {

      return {
        require: 'ngModel',
        link: function(scope, element, attrs, ctrl) {
          var val = function(value) {
            var settings = configService.getSync().wallet.settings;
            var vNum = Number((value * settings.unitToSatoshi).toFixed(0));
            if (typeof value == 'undefined' || value == 0) {
              ctrl.$pristine = true;
            }



            if (typeof vNum == "number" && vNum > 0) {
              if (vNum > Number.MAX_SAFE_INTEGER) {
                ctrl.$setValidity('validAmount', false);
              } else {
                var decimals = Number(settings.unitDecimals);
                var sep_index = ('' + value).indexOf('.');
                var str_value = ('' + value).substring(sep_index + 1);
                if (sep_index >= 0 && str_value.length > decimals) {
                  ctrl.$setValidity('validAmount', false);
                  return;
                } else {
                  ctrl.$setValidity('validAmount', true);
                }
              }
            } else {
              ctrl.$setValidity('validAmount', false);
            }
            return value;
          }
          ctrl.$parsers.unshift(val);
          ctrl.$formatters.unshift(val);
        }
      };
    }
  ])
  .directive('walletSecret', function(bitcore) {
    return {
      require: 'ngModel',
      link: function(scope, elem, attrs, ctrl) {
        var validator = function(value) {
          if (value.length > 0) {
            var m = value.match(/^[0-9A-HJ-NP-Za-km-z]{70,80}$/);
            ctrl.$setValidity('walletSecret', m ? true : false);
          }
          return value;
        };

        ctrl.$parsers.unshift(validator);
      }
    };
  })
  .directive('ngFileSelect', function() {
    return {
      link: function($scope, el) {
        el.bind('change', function(e) {
          $scope.formData.file = (e.srcElement || e.target).files[0];
          $scope.getFile();
        });
      }
    }
  })
  .directive('contact', ['addressbookService', 'lodash',
    function(addressbookService, lodash) {
      return {
        restrict: 'E',
        link: function(scope, element, attrs) {
          var addr = attrs.address;
          addressbookService.get(addr, function(err, ab) {
            if (ab) {
              var name = lodash.isObject(ab) ? ab.name : ab;
              element.append(name);
            } else {
              element.append(addr);
            }
          });
        }
      };
    }
  ])
  .directive('ignoreMouseWheel', function($rootScope, $timeout) {
    return {
      restrict: 'A',
      link: function(scope, element, attrs) {
        element.bind('mousewheel', function(event) {
          element[0].blur();
          $timeout(function() {
            element[0].focus();
          }, 1);
        });
      }
    }
  });

'use strict';

angular.module('copayApp.directives')
  .directive('gravatar', function(md5) {
    return {
      restrict: 'AE',
      replace: true,
      scope: {
        name: '@',
        height: '@',
        width: '@',
        email: '@'
      },
      link: function(scope, el, attr) {
        if (typeof scope.email === "string") {
          scope.emailHash = md5.createHash(scope.email.toLowerCase() || '');
        }
      },
      template: '<img class="gravatar" alt="{{ name }}" height="{{ height }}"  width="{{ width }}" src="https://secure.gravatar.com/avatar/{{ emailHash }}.jpg?s={{ width }}&d=mm">'
    };
  });

'use strict';
angular.module('copayApp.directives')
.directive('hideTabs', function($rootScope, $timeout) {
  return {
    restrict: 'A',
    link: function($scope, $el) {
      $scope.$on("$ionicView.beforeEnter", function(event, data){
        $timeout(function() {
          $rootScope.hideTabs = 'tabs-item-hide';
          $rootScope.$apply();
        });
      });
    }
  };
});

'use strict';

angular.module('copayApp.directives')
  .directive('incomingDataMenu', function($timeout, $rootScope, $state, externalLinkService) {
    return {
      restrict: 'E',
      templateUrl: 'views/includes/incomingDataMenu.html',
      link: function(scope, element, attrs) {
        $rootScope.$on('incomingDataMenu.showMenu', function(event, data) {
          $timeout(function() {
            scope.data = data.data;
            scope.type = data.type;
            scope.showMenu = true;
            scope.https = false;

            if (scope.type === 'url') {
              if (scope.data.indexOf('https://') === 0) {
                scope.https = true;
              }
            }
          });
        });
        scope.hide = function() {
          scope.showMenu = false;
          $rootScope.$broadcast('incomingDataMenu.menuHidden');
        };
        scope.goToUrl = function(url) {
          externalLinkService.open(url);
        };
        scope.sendPaymentToAddress = function(bitcoinAddress) {
          scope.showMenu = false;
          $state.go('tabs.send').then(function() {
            $timeout(function() {
              $state.transitionTo('tabs.send.amount', {
                toAddress: bitcoinAddress
              });
            }, 50);
          });
        };
        scope.addToAddressBook = function(bitcoinAddress) {
          scope.showMenu = false;
          $timeout(function() {
            $state.go('tabs.send').then(function() {
              $timeout(function() {
                $state.transitionTo('tabs.send.addressbook', {
                  addressbookEntry: bitcoinAddress
                });
              });
            });
          }, 100);
        };
        scope.scanPaperWallet = function(privateKey) {
          scope.showMenu = false;
          $state.go('tabs.home').then(function() {
            $timeout(function() {
              $state.transitionTo('tabs.home.paperWallet', {
                privateKey: privateKey
              });
            }, 50);
          });
        };
      }
    };
  });

'use strict';

angular.module('copayApp.directives')
  .directive('itemSelector', function($timeout) {
    return {
      restrict: 'E',
      templateUrl: 'views/includes/itemSelector.html',
      transclude: true,
      scope: {
        show: '=itemSelectorShow',
        onSelect: '=itemSelectorOnSelect'
      },
      link: function(scope, element, attrs) {
        scope.hide = function() {
          scope.show = false;
        };
        scope.sendMax = function() {
          $timeout(function() {
            scope.hide();
          }, 100);
          scope.onSelect();
        };
      }
    };
  });

'use strict';

angular.module('copayApp.directives')
  .directive('logOptions', function($timeout, platformInfo) {
    return {
      restrict: 'E',
      templateUrl: 'views/includes/logOptions.html',
      transclude: true,
      scope: {
        show: '=logOptionsShow',
        options: '=logOptions',
        fillClass: '=logOptionsFillClass',
        onSelect: '=logOptionsOnSelect',
        onCopy: '=logOptionsOnCopy',
        onSend: '=logOptionsOnSend'
      },
      link: function(scope, element, attrs) {
        scope.isCordova = platformInfo.isCordova;

        scope.hide = function() {
          scope.show = false;
        };

        scope.getFillClass = function(index) {
          scope.onSelect(index);
        };
      }
    };
  });

'use strict';

angular.module('copayApp.directives')
  /**
   * Replaces img tag with its svg content to allow for CSS styling of the svg.
   */
  .directive('noLowFee', function($log, $ionicHistory, configService, popupService) {
    return {
      restrict: 'A',
      link: function(scope, elem, attrs, ctrl) {


        elem.bind('click', function() {
          configService.whenAvailable(function(config) {
            if (config.wallet.settings.feeLevel && config.wallet.settings.feeLevel.match(/conomy/)) {
              $log.debug('Economy Fee setting... disabling link:' + elem.text());
              popupService.showAlert('Low Fee Error', 'Please change your Bitcoin Network Fee Policy setting to Normal or higher to use this service', function() {
                $ionicHistory.goBack();
              });
            }
          });
        });
      }
    }
  });

'use strict';

angular.module('copayApp.directives')
  .directive('qrScanner', function($state, $rootScope, $log, $ionicHistory, platformInfo, scannerService, popupService) {

    return {
      restrict: 'E',
      scope: {
        onScan: "&"
      },
      replace: true,
      template: '<a on-tap="chooseScanner()" nav-transition="none"><i class="icon ion-qr-scanner"></i></a>',
      link: function(scope, el, attrs) {

        scope.chooseScanner = function() {
          var isWindowsPhoneApp = platformInfo.isCordova && platformInfo.isWP;

          if (!isWindowsPhoneApp) {
            scope.openScanner();
            return;
          }

          scannerService.useOldScanner(function(err, contents) {
            if (err) {
              popupService.showAlert(gettextCatalog.getString('Error'), err);
              return;
            }
            scope.onScan({
              data: contents
            });
          });
        };

        scope.openScanner = function() {
          $log.debug('Opening scanner by directive...');
          $ionicHistory.nextViewOptions({
            disableAnimate: true
          });
          $state.go('scanner', {
            passthroughMode: 1
          });
        };

        var afterEnter = $rootScope.$on('$ionicView.afterEnter', function() {
          if ($rootScope.scanResult) {
            scope.onScan({
              data: $rootScope.scanResult
            });
            $rootScope.scanResult = null;
          }
        });

        // Destroy event
        scope.$on('$destroy', function() {
          afterEnter();
        });
      }
    }
  });

'use strict';
angular.module('copayApp.directives')
  .directive('showTabs', function($rootScope, $timeout) {
    return {
      restrict: 'A',
      link: function($scope, $el) {
        $scope.$on("$ionicView.beforeEnter", function(event, data) {
          $timeout(function() {
            $rootScope.hideTabs = '';
            $rootScope.$apply();
          });
        });
      }
    };
  });

'use strict';

angular.module('copayApp.directives')
  .directive('slideToAccept', function($timeout, $window, $q) {
    return {
      restrict: 'E',
      templateUrl: 'views/includes/slideToAccept.html',
      transclude: true,
      scope: {
        sendStatus: '=slideSendStatus',
        onConfirm: '&slideOnConfirm',
        isDisabled: '=isDisabled'
      },
      link: function(scope, element, attrs) {

        var KNOB_WIDTH = 71;
        var MAX_SLIDE_START_PERCENTAGE = 50;
        var FULLY_SLID_PERCENTAGE = 72;
        var PERCENTAGE_BUMP = 5;
        var JIGGLE_EASING = linear;
        var JIGGLE_DURATION = 100;
        var RECEDE_DURATION = 250;
        var INITIAL_TAP_EASE_DURATION = 75;

        var elm = element[0];
        var isSliding = false;
        var curSliderPct = getKnobWidthPercentage();
        var curBitcoinPct = 0;
        var curTextPct = 0;
        var currentEaseStartTime;
        var bezier = $window.BezierEasing(0.175, 0.885, 0.320, 1.275);

        scope.isSlidFully = false;
        scope.displaySendStatus = '';

        scope.$watch('sendStatus', function() {
          if (!scope.sendStatus) {
            reset();
          } else if (scope.sendStatus === 'success') {
            scope.displaySendStatus = '';
            $timeout(function() {
              reset();
            }, 500);
          } else {
            scope.displaySendStatus = scope.sendStatus;
          }
        });

        function easePosition(fromPct, pct, duration, easeFx, animateFx) {
          var deferred = $q.defer();
          currentEaseStartTime = Date.now();
          var startTime = currentEaseStartTime;
          var initialPct = fromPct;
          var distance = pct - fromPct;

          function ease() {
            if (startTime !== currentEaseStartTime) {
              return;
            }
            $window.requestAnimationFrame(function() {
              var now = Date.now();
              var elapsed = now - startTime;
              var normalizedElapsedTime = elapsed / duration;
              var newVal = easeFx(normalizedElapsedTime);
              var newPct = newVal * distance + initialPct;
              animateFx(newPct);
              scope.$digest();
              if (elapsed < duration) {
                ease();
              } else {
                deferred.resolve();
              }
            });
          }
          ease();
          return deferred.promise;
        }

        function linear(t) {
          return t;
        }

        function easeInOutBack(t) {
          return bezier(t);
        }

        function reset() {
          scope.isSlidFully = false;
          isSliding = false;
          setNewSliderStyle(getKnobWidthPercentage());
          setNewBitcoinStyle(0);
          setNewTextStyle(0);
        }

        function setNewSliderStyle(pct) {
          var knobWidthPct = getKnobWidthPercentage();
          var translatePct = pct - knobWidthPct;
          if (isSliding) {
            translatePct += 0.35 * pct;
          }
          scope.sliderStyle = getTransformStyle(translatePct);
          curSliderPct = pct;
        }

        function setNewBitcoinStyle(pct) {
          var translatePct = -2.25 * pct;
          scope.bitcoinStyle = getTransformStyle(translatePct);
          curBitcoinPct = pct;
        }

        function setNewTextStyle(pct) {
          var translatePct = -0.1 * pct;
          scope.textStyle = getTransformStyle(translatePct);
          curTextPct = pct;
        }

        function getTransformStyle(translatePct) {
          return {
            'transform': 'translateX(' + translatePct + '%)'
          };
        }

        function getKnobWidthPercentage() {
          var knobWidthPct = (KNOB_WIDTH / elm.clientWidth) * 100;
          return knobWidthPct;
        }

        function setSliderPosition(pct) {
          setNewSliderStyle(pct);
          setNewBitcoinStyle(pct);
          setNewTextStyle(pct);
        }

        function easeSliderPosition(pct) {
          var duration = INITIAL_TAP_EASE_DURATION;
          easePosition(curSliderPct, pct, duration, JIGGLE_EASING, function(pct) {
            setNewSliderStyle(pct);
          });
          easePosition(curBitcoinPct, pct, duration, JIGGLE_EASING, function(pct) {
            setNewBitcoinStyle(pct);
          });
          easePosition(curTextPct, pct, duration, JIGGLE_EASING, function(pct) {
            setNewTextStyle(pct);
          });
        }

        function jiggleSlider() {
          var pct = getKnobWidthPercentage() + PERCENTAGE_BUMP;
          var duration = JIGGLE_DURATION;
          var p1 = easePosition(curSliderPct, pct, duration, JIGGLE_EASING, function(pct) {
            setNewSliderStyle(pct);
          });
          var p2 = easePosition(curBitcoinPct, pct, duration, JIGGLE_EASING, function(pct) {
            setNewBitcoinStyle(pct);
          });

          $q.all([p1, p2]).then(function() {
            recede();
          });
        }

        function recede() {
          var duration = RECEDE_DURATION;
          easePosition(curSliderPct, getKnobWidthPercentage(), duration, easeInOutBack, function(pct) {
            setNewSliderStyle(pct);
          });
          easePosition(curBitcoinPct, 0, duration, easeInOutBack, function(pct) {
            setNewBitcoinStyle(pct);
          });
          easePosition(curTextPct, 0, duration, easeInOutBack, function(pct) {
            setNewTextStyle(pct);
          });
        }

        function alertSlidFully() {
          scope.isSlidFully = true;
          scope.onConfirm();
        }

        function getTouchXPosition($event) {
          var x;
          if ($event.touches || $event.changedTouches) {
            if ($event.touches.length) {
              x = $event.touches[0].clientX;
            } else {
              x = $event.changedTouches[0].clientX;
            }
          } else {
            x = $event.clientX;
          }
          return x;
        }

        function getSlidPercentage($event) {
          var x = getTouchXPosition($event);
          var width = elm.clientWidth;
          var pct = (x / width) * 100;
          if (x >= width) {
            pct = 100;
          }
          return pct;
        }

        scope.onTouchstart = function($event) {
          if (scope.isSlidFully) {
            return;
          }
          if (!isSliding) {
            var pct = getSlidPercentage($event);
            if (pct > MAX_SLIDE_START_PERCENTAGE) {
              jiggleSlider();
              return;
            } else {
              isSliding = true;
              var knobWidthPct = getKnobWidthPercentage();
              if (pct < knobWidthPct) {
                pct = knobWidthPct;
              }
              pct += PERCENTAGE_BUMP;
              easeSliderPosition(pct);
            }
          }
        };

        scope.onTouchmove = function($event) {
          if (!isSliding || scope.isSlidFully) {
            return;
          }
          var pct = getSlidPercentage($event);
          var knobWidthPct = getKnobWidthPercentage();
          if (pct < knobWidthPct) {
            pct = knobWidthPct;
          }
          pct += PERCENTAGE_BUMP;
          currentEaseStartTime = null;
          setSliderPosition(pct);
        };

        scope.onTouchend = function($event) {
          if (scope.isSlidFully) {
            return;
          }
          var pct = getSlidPercentage($event);
          if (isSliding && pct > FULLY_SLID_PERCENTAGE) {
            pct = 100;
            setSliderPosition(pct);
            alertSlidFully();
          } else {
            recede();
          }
          isSliding = false;
        };
      }
    };
  });

'use strict';

angular.module('copayApp.directives')
  .directive('slideToAcceptSuccess', function($timeout, platformInfo) {
    return {
      restrict: 'E',
      templateUrl: 'views/includes/slideToAcceptSuccess.html',
      transclude: true,
      scope: {
        isShown: '=slideSuccessShow',
        onConfirm: '&slideSuccessOnConfirm',
        hideOnConfirm: '=slideSuccessHideOnConfirm'
      },
      link: function(scope, element, attrs) {

        scope.isWindowsPhoneApp = platformInfo.isCordova && platformInfo.isWP;

        var elm = element[0];
        elm.style.display = 'none';
        scope.$watch('isShown', function() {
          if (scope.isShown) {
            elm.style.display = 'flex';
            $timeout(function() {
              scope.fillScreen = true;
            }, 10);
          }
        });
        scope.onConfirmButtonClick = function() {
          scope.onConfirm();
          if (scope.hideOnConfirm) {
            scope.fillScreen = false;
            elm.style.display = 'none';
          }
        };
      }
    };
  });

'use strict';

angular.module('copayApp.directives')
  /**
   * Replaces img tag with its svg content to allow for CSS styling of the svg.
   */
  .directive('svg', function($http) {
    return {
      restrict: 'C',
      link: function(scope, element, attrs) {
        var imgId = attrs.id;
        var imgClass = attrs.class;
        var imgUrl = attrs.src || attrs.ngSrc;
        var svg;

        // Load svg content
        $http.get(imgUrl).success(function(data, status) {
          svg = angular.element(data);
          for (var i = svg.length - 1; i >= 0; i--) {
            if (svg[i].constructor == SVGSVGElement) {
              svg = angular.element(svg[i]);
              break;
            }
          }

          if (typeof imgId !== 'undefined') {
            svg.attr('id', imgId);
          }

          if (typeof imgClass !== 'undefined') {
            svg.attr('class', imgClass);
          }
          // Remove invalid attributes
          svg = svg.removeAttr('xmlns:a');
          element.replaceWith(svg);
        });

        scope.$on('$destroy', function() {
          if (svg) svg.remove();
        });
      }
    };
  });
    
'use strict';

angular.module('copayApp.directives')
  .directive('walletSelector', function($timeout) {
    return {
      restrict: 'E',
      templateUrl: 'views/includes/walletSelector.html',
      transclude: true,
      scope: {
        title: '=walletSelectorTitle',
        show: '=walletSelectorShow',
        wallets: '=walletSelectorWallets',
        selectedWallet: '=walletSelectorSelectedWallet',
        onSelect: '=walletSelectorOnSelect'
      },
      link: function(scope, element, attrs) {
        scope.hide = function() {
          scope.show = false;
        };
        scope.selectWallet = function(wallet) {
          $timeout(function() {
            scope.hide();
          }, 100);
          scope.onSelect(wallet);
        };
      }
    };
  });

'use strict';

angular.module('copayApp.filters', [])
  .filter('amTimeAgo', ['amMoment',
    function(amMoment) {
      return function(input) {
        return amMoment.preprocessDate(input).fromNow();
      };
    }
  ])
  .filter('paged', function() {
    return function(elements) {
      if (elements) {
        return elements.filter(Boolean);
      }

      return false;
    };
  })
  .filter('removeEmpty', function() {
    return function(elements) {
      elements = elements || [];
      // Hide empty change addresses from other copayers
      return elements.filter(function(e) {
        return !e.isChange || e.balance > 0;
      });
    }
  })
  .filter('formatFiatAmount', ['$filter', '$locale', 'configService',
    function(filter, locale) {
      var numberFilter = filter('number');
      var formats = locale.NUMBER_FORMATS;
      return function(amount) {

        var fractionSize = 2;
        var value = numberFilter(amount, fractionSize);
        var sep = value.indexOf(formats.DECIMAL_SEP);
        var group = value.indexOf(formats.GROUP_SEP);

        if (amount >= 0) {
          if (group > 0) {
            if (sep < 0) {
              return value;
            }
            var intValue = value.substring(0, sep);
            var floatValue = parseFloat(value.substring(sep));
            floatValue = floatValue.toFixed(2);
            floatValue = floatValue.toString().substring(1);
            var finalValue = intValue + floatValue;
            return finalValue;
          } else {
            value = parseFloat(value);
            return value.toFixed(2);
          }
        }
        return 0;
      };
    }
  ])
  .filter('orderObjectBy', function() {
    return function(items, field, reverse) {
      var filtered = [];
      angular.forEach(items, function(item) {
        filtered.push(item);
      });
      filtered.sort(function(a, b) {
        return (a[field] > b[field] ? 1 : -1);
      });
      if (reverse) filtered.reverse();
      return filtered;
    };
  })
  .filter('range', function() {
    return function(input, total) {
      total = parseInt(total);
      for (var i = 0; i < total; i++)
        input.push(i);
      return input;
    };
  });

'use strict';

/**
 * Profile
 *
 * credential: array of OBJECTS
 */
function Profile() {
  this.version = '1.0.0';
};

Profile.create = function(opts) {
  opts = opts || {};

  var x = new Profile();
  x.createdOn = Date.now();
  x.credentials = opts.credentials || [];
  x.disclaimerAccepted = false;
  x.checked = {};
  return x;
};

Profile.fromObj = function(obj) {
  var x = new Profile();

  x.createdOn = obj.createdOn;
  x.credentials = obj.credentials;
  x.disclaimerAccepted = obj.disclaimerAccepted;
  x.checked = obj.checked || {};
  x.checkedUA = obj.checkedUA || {};

  if (x.credentials[0] && typeof x.credentials[0] != 'object')
    throw ("credentials should be an object");

  return x;
};

Profile.fromString = function(str) {
  return Profile.fromObj(JSON.parse(str));
};

Profile.prototype.toObj = function() {
  delete this.dirty;
  return JSON.stringify(this);
};


Profile.prototype.hasWallet = function(walletId) {
  for (var i in this.credentials) {
    var c = this.credentials[i];
    if (c.walletId == walletId) return true;
  };
  return false;
};

Profile.prototype.isChecked = function(ua, walletId) {
  return !!(this.checkedUA == ua && this.checked[walletId]);
};


Profile.prototype.isDeviceChecked = function(ua) {
  return this.checkedUA == ua;
};


Profile.prototype.setChecked = function(ua, walletId) {
  if (this.checkedUA != ua) {
    this.checkedUA = ua;
    this.checked = {};
  }
  this.checked[walletId] = true;
  this.dirty = true;
};


Profile.prototype.addWallet = function(credentials) {
  if (!credentials.walletId)
    throw 'credentials must have .walletId';

  if (this.hasWallet(credentials.walletId))
    return false;

  this.credentials.push(credentials);
  this.dirty = true;
  return true;
};

Profile.prototype.updateWallet = function(credentials) {
  if (!credentials.walletId)
    throw 'credentials must have .walletId';

  if (!this.hasWallet(credentials.walletId))
    return false;

  this.credentials = this.credentials.map(function(c) {
    if(c.walletId != credentials.walletId ) {
      return c;
    } else {
      return credentials
    }
  });

  this.dirty = true;
  return true;
};

Profile.prototype.deleteWallet = function(walletId) {
  if (!this.hasWallet(walletId))
    return false;

  this.credentials = this.credentials.filter(function(c) {
    return c.walletId != walletId;
  });

  this.dirty = true;
  return true;
};

'use strict';

angular.module('copayApp.services').factory('addressbookService', function($log, bitcore, bitcoreCash, storageService, lodash) {
  var root = {};

  var getNetwork = function(address) {
    var network;
    try {
      network = (new bitcore.Address(address)).network.name;
    } catch(e) {
      $log.warn('No valid bitcoin address. Trying bitcoin cash...');
      network = (new bitcoreCash.Address(address)).network.name;
    }
    return network;
  };

  root.get = function(addr, cb) {
    storageService.getAddressbook('testnet', function(err, ab) {
      if (err) return cb(err);
      if (ab) ab = JSON.parse(ab);
      if (ab && ab[addr]) return cb(null, ab[addr]);

      storageService.getAddressbook('livenet', function(err, ab) {
        if (err) return cb(err);
        if (ab) ab = JSON.parse(ab);
        if (ab && ab[addr]) return cb(null, ab[addr]);
        return cb();
      });
    });
  };

  root.list = function(cb) {
    storageService.getAddressbook('testnet', function(err, ab) {
      if (err) return cb('Could not get the Addressbook');

      if (ab) ab = JSON.parse(ab);

      ab = ab || {};
      storageService.getAddressbook('livenet', function(err, ab2) {
        if (ab2) ab2 = JSON.parse(ab2);

        ab2 = ab2 || {};
        return cb(err, lodash.defaults(ab2, ab));
      });
    });
  };

  root.add = function(entry, cb) {
    var network = getNetwork(entry.address);
    if (lodash.isEmpty(network)) return cb('Not valid bitcoin address');
    storageService.getAddressbook(network, function(err, ab) {
      if (err) return cb(err);
      if (ab) ab = JSON.parse(ab);
      ab = ab || {};
      if (lodash.isArray(ab)) ab = {}; // No array
      if (ab[entry.address]) return cb('Entry already exist');
      ab[entry.address] = entry;
      storageService.setAddressbook(network, JSON.stringify(ab), function(err, ab) {
        if (err) return cb('Error adding new entry');
        root.list(function(err, ab) {
          return cb(err, ab);
        });
      });
    });
  };

  root.remove = function(addr, cb) {
    var network = getNetwork(addr);
    if (lodash.isEmpty(network)) return cb('Not valid bitcoin address');
    storageService.getAddressbook(network, function(err, ab) {
      if (err) return cb(err);
      if (ab) ab = JSON.parse(ab);
      ab = ab || {};
      if (lodash.isEmpty(ab)) return cb('Addressbook is empty');
      if (!ab[addr]) return cb('Entry does not exist');
      delete ab[addr];
      storageService.setAddressbook(network, JSON.stringify(ab), function(err) {
        if (err) return cb('Error deleting entry');
        root.list(function(err, ab) {
          return cb(err, ab);
        });
      });
    });
  };

  root.removeAll = function() {
    storageService.removeAddressbook('livenet', function(err) {
      storageService.removeAddressbook('testnet', function(err) {
        if (err) return cb('Error deleting addressbook');
        return cb();
      });
    });
  };

  return root;
});

'use strict';
angular.module('copayApp.services').factory('amazonService', function($http, $log, lodash, moment, storageService, configService, platformInfo, nextStepsService, homeIntegrationsService) {
  var root = {};
  var credentials = {};

  root.limitPerDay = 1000;

  /*
   * Development: 'testnet'
   * Production: 'livenet'
   */
  credentials.NETWORK = 'livenet';
  //credentials.NETWORK = 'testnet';

  if (credentials.NETWORK == 'testnet') {
    credentials.BITPAY_API_URL = "https://test.bitpay.com";
  } else {
    credentials.BITPAY_API_URL = "https://bitpay.com";
  };

  var homeItem = {
    name: 'amazon',
    title: 'Amazon.com Gift Cards',
    icon: 'icon-amazon',
    sref: 'tabs.giftcards.amazon',
  };

  var nextStepItem = {
    name: 'amazon',
    title: 'Buy Amazon.com Gift Cards',
    icon: 'icon-amazon',
    sref: 'tabs.giftcards.amazon',
  };

  var _getBitPay = function(endpoint) {
    return {
      method: 'GET',
      url: credentials.BITPAY_API_URL + endpoint,
      headers: {
        'content-type': 'application/json'
      }
    };
  };

  var _postBitPay = function(endpoint, data) {
    return {
      method: 'POST',
      url: credentials.BITPAY_API_URL + endpoint,
      headers: {
        'content-type': 'application/json'
      },
      data: data
    };
  };

  root.getNetwork = function() {
    return credentials.NETWORK;
  };

  root.savePendingGiftCard = function(gc, opts, cb) {
    var network = root.getNetwork();
    storageService.getAmazonGiftCards(network, function(err, oldGiftCards) {
      if (lodash.isString(oldGiftCards)) {
        oldGiftCards = JSON.parse(oldGiftCards);
      }
      if (lodash.isString(gc)) {
        gc = JSON.parse(gc);
      }
      var inv = oldGiftCards || {};
      inv[gc.invoiceId] = gc;
      if (opts && (opts.error || opts.status)) {
        inv[gc.invoiceId] = lodash.assign(inv[gc.invoiceId], opts);
      }
      if (opts && opts.remove) {
        delete(inv[gc.invoiceId]);
      }

      inv = JSON.stringify(inv);


      storageService.setAmazonGiftCards(network, inv, function(err) {

        homeIntegrationsService.register(homeItem);
        nextStepsService.unregister(nextStepItem.name);
        return cb(err);
      });
    });
  };

  root.getPendingGiftCards = function(cb) {
    var network = root.getNetwork();
    storageService.getAmazonGiftCards(network, function(err, giftCards) {
      var _gcds = giftCards ? JSON.parse(giftCards) : null;
      return cb(err, _gcds);
    });
  };

  root.createBitPayInvoice = function(data, cb) {

    var dataSrc = {
      currency: data.currency,
      amount: data.amount,
      clientId: data.uuid
    };

    $http(_postBitPay('/amazon-gift/pay', dataSrc)).then(function(data) {
      $log.info('BitPay Create Invoice: SUCCESS');
      return cb(null, data.data);
    }, function(data) {
      $log.error('BitPay Create Invoice: ERROR ' + data.data.message);
      return cb(data.data);
    });
  };

  root.getBitPayInvoice = function(id, cb) {
    $http(_getBitPay('/invoices/' + id)).then(function(data) {
      $log.info('BitPay Get Invoice: SUCCESS');
      return cb(null, data.data.data);
    }, function(data) {
      $log.error('BitPay Get Invoice: ERROR ' + data.data.error);
      return cb(data.data.error);
    });
  };

  root.createGiftCard = function(data, cb) {

    var dataSrc = {
      "clientId": data.uuid,
      "invoiceId": data.invoiceId,
      "accessKey": data.accessKey
    };

    $http(_postBitPay('/amazon-gift/redeem', dataSrc)).then(function(data) {
      var status = data.data.status == 'new' ? 'PENDING' : (data.data.status == 'paid') ? 'PENDING' : data.data.status;
      data.data.status = status;
      $log.info('Amazon.com Gift Card Create/Update: ' + status);
      return cb(null, data.data);
    }, function(data) {
      $log.error('Amazon.com Gift Card Create/Update: ' + data.data.message);
      return cb(data.data);
    });
  };

  root.cancelGiftCard = function(data, cb) {

    var dataSrc = {
      "clientId": data.uuid,
      "invoiceId": data.invoiceId,
      "accessKey": data.accessKey
    };

    $http(_postBitPay('/amazon-gift/cancel', dataSrc)).then(function(data) {
      $log.info('Amazon.com Gift Card Cancel: SUCCESS');
      return cb(null, data.data);
    }, function(data) {
      $log.error('Amazon.com Gift Card Cancel: ' + data.data.message);
      return cb(data.data);
    });
  };

  var register = function() {
    storageService.getAmazonGiftCards(root.getNetwork(), function(err, giftCards) {
      if (giftCards) {
        homeIntegrationsService.register(homeItem);
      } else {
        nextStepsService.register(nextStepItem);
      }
    });
  };

  register();
  return root;
});

'use strict';

angular.module('copayApp.services').factory('appConfigService', function($window) {
  return $window.appConfig;
});

'use strict';

angular.module('copayApp.services').factory('appIdentityService', function($log, lodash, storageService, bitauthService) {
  var root = {};

  root.getIdentity = function(network, cb) {
    var pubkey, sin, isNew;
    storageService.getAppIdentity(network, function(err, data) {
      if (err) return cb(err);
      var appIdentity = data || {};
      if (lodash.isEmpty(appIdentity) || (appIdentity && !appIdentity.priv)) {
        isNew = true;
        appIdentity = bitauthService.generateSin();
      }
      try {
        pubkey = bitauthService.getPublicKeyFromPrivateKey(appIdentity.priv);
        sin = bitauthService.getSinFromPublicKey(pubkey);
        if (isNew)
          storageService.setAppIdentity(network, JSON.stringify(appIdentity), function(err) {});
      }
      catch (e) {
        $log.error(e);
        return cb(e);
      };
      return cb(null, appIdentity);
    });
  };

  return root;
  
});
'use strict';
angular.module('copayApp.services')
  .factory('applicationService', function($rootScope, $timeout, $ionicHistory, $ionicModal, platformInfo, fingerprintService, openURLService, configService, $state) {
    var root = {};

    root.isPinModalOpen = false;

    var isChromeApp = platformInfo.isChromeApp;
    var isNW = platformInfo.isNW;

    root.restart = function() {
      var hashIndex = window.location.href.indexOf('#/');
      if (platformInfo.isCordova) {
        window.location = window.location.href.substr(0, hashIndex);
        $timeout(function() {
          $rootScope.$digest();
        }, 1);

      } else {
        // Go home reloading the application
        if (isChromeApp) {
          chrome.runtime.reload();
        } else if (isNW) {
          $ionicHistory.removeBackView();
          $state.go('tabs.home');
          $timeout(function() {
            var win = require('nw.gui').Window.get();
            win.reload(3);
            //or
            win.reloadDev();
          }, 100);
        } else {
          window.location = window.location.href.substr(0, hashIndex);
        }
      }
    };

    root.fingerprintModal = function() {

      var scope = $rootScope.$new(true);
      $ionicModal.fromTemplateUrl('views/modals/fingerprintCheck.html', {
        scope: scope,
        animation: 'none',
        backdropClickToClose: false,
        hardwareBackButtonClose: false
      }).then(function(modal) {
        scope.fingerprintCheckModal = modal;
        root.isModalOpen = true;
        scope.openModal();
      });
      scope.openModal = function() {
        scope.fingerprintCheckModal.show();
        scope.checkFingerprint();
      };
      scope.hideModal = function() {
        root.isModalOpen = false;
        scope.fingerprintCheckModal.hide();
      };
      scope.checkFingerprint = function() {
        fingerprintService.check('unlockingApp', function(err) {
          if (err) return;
          scope.hideModal();
        });
      }
    };

    root.pinModal = function(action) {

      var scope = $rootScope.$new(true);
      scope.action = action;
      $ionicModal.fromTemplateUrl('views/modals/pin.html', {
        scope: scope,
        animation: 'none',
        backdropClickToClose: false,
        hardwareBackButtonClose: false
      }).then(function(modal) {
        scope.pinModal = modal;
        root.isModalOpen = true;
        scope.openModal();
      });
      scope.openModal = function() {
        scope.pinModal.show();
      };
      scope.hideModal = function() {
        scope.$emit('pinModalClosed');
        root.isModalOpen = false;
        scope.pinModal.hide();
      };
    };

    root.appLockModal = function(action) {

      if (root.isModalOpen) return;

      configService.whenAvailable(function(config) {
        var lockMethod = config.lock && config.lock.method;
        if (!lockMethod || lockMethod == 'none') return;

        if (lockMethod == 'fingerprint' && fingerprintService.isAvailable()) root.fingerprintModal();
        if (lockMethod == 'pin') root.pinModal(action);

      });
    }
    return root;
  });

'use strict';
angular.module('copayApp.services')
  .factory('backupService', function backupServiceFactory($log, $timeout, $stateParams, profileService, sjcl, appConfigService) {

    var root = {};

    var _download = function(ew, filename, cb) {
      var NewBlob = function(data, datatype) {
        var out;

        try {
          out = new Blob([data], {
            type: datatype
          });
          $log.debug("case 1");
        } catch (e) {
          window.BlobBuilder = window.BlobBuilder ||
            window.WebKitBlobBuilder ||
            window.MozBlobBuilder ||
            window.MSBlobBuilder;

          if (e.name == 'TypeError' && window.BlobBuilder) {
            var bb = new BlobBuilder();
            bb.append(data);
            out = bb.getBlob(datatype);
            $log.debug("case 2");
          } else if (e.name == "InvalidStateError") {
            // InvalidStateError (tested on FF13 WinXP)
            out = new Blob([data], {
              type: datatype
            });
            $log.debug("case 3");
          } else {
            // We're screwed, blob constructor unsupported entirely
            $log.debug("Error");
          }
        }
        return out;
      };

      var a = angular.element('<a></a>');
      var blob = new NewBlob(ew, 'text/plain;charset=utf-8');
      a.attr('href', window.URL.createObjectURL(blob));
      a.attr('download', filename);
      a[0].click();
      return cb();
    };

    root.addMetadata = function(b, opts) {

      b = JSON.parse(b);
      if (opts.addressBook) b.addressBook = opts.addressBook;
      return JSON.stringify(b);
    }

    root.walletExport = function(password, opts) {
      if (!password) {
        return null;
      }
      var wallet = profileService.getWallet($stateParams.walletId);
      try {
        opts = opts || {};
        var b = wallet.export(opts);
        if (opts.addressBook) b = root.addMetadata(b, opts);

        var e = sjcl.encrypt(password, b, {
          iter: 10000
        });
        return e;
      } catch (err) {
        $log.debug('Error exporting wallet: ', err);
        return null;
      };
    };

    root.walletDownload = function(password, opts, cb) {
      var wallet = profileService.getWallet($stateParams.walletId);
      var ew = root.walletExport(password, opts);
      if (!ew) return cb('Could not create backup');

      var walletName = (wallet.alias || '') + (wallet.alias ? '-' : '') + wallet.credentials.walletName;
      if (opts.noSign) walletName = walletName + '-noSign'
      var filename = walletName + '-' + appConfigService.nameCase + 'backup.aes.json';
      _download(ew, filename, cb)
    };
    return root;
  });

'use strict';
angular.module('copayApp.services')
  .factory('bitcore', function bitcoreFactory(bwcService) {
    var bitcore = bwcService.getBitcore();
    return bitcore;
  });

'use strict';
angular.module('copayApp.services')
  .factory('bitcoreCash', function bitcoreFactory(bwcService) {
    var bitcoreCash = bwcService.getBitcoreCash();
    return bitcoreCash;
  });

'use strict';

angular.module('copayApp.services').factory('bitpayAccountService', function($log, lodash, platformInfo, appIdentityService, bitpayService, bitpayCardService, storageService, gettextCatalog, popupService) {
  var root = {};

  /*
   * Pair this app with the bitpay server using the specified pairing data.
   * An app identity will be created if one does not already exist.
   * Pairing data is provided by an input URI provided by the bitpay server.
   *
   * pairData - data needed to complete the pairing process
   * {
   *   secret: shared pairing secret
   *   email: email address associated with bitpay account
   *   otp: two-factor one-time use password
   * }
   *
   * pairingReason - text string to be embedded into popup message.  If `null` then the reason
   * message is not shown to the UI.
   *   "To {{reason}} you must pair this app with your BitPay account ({{email}})."
   *
   * cb - callback after completion
   *   callback(err, paired, apiContext)
   *
   *   err - something unexpected happened which prevented the pairing
   *
   *   paired - boolean indicating whether the pairing was compledted by the user
   *
   *   apiContext - the context needed for making future api calls
   *   {
   *     token: api token for use in future calls
   *     pairData: the input pair data
   *     appIdentity: the identity of this app
   *   }
   */

  root.pair = function(pairData, pairingReason, cb) {
    checkOtp(pairData, function(otp) {
      pairData.otp = otp;
	    var deviceName = 'Unknown device';
	    if (platformInfo.isNW) {
	      deviceName = require('os').platform();
	    } else if (platformInfo.isCordova) {
	      deviceName = device.model;
	    }
	    var json = {
	      method: 'createToken',
	      params: {
	        secret: pairData.secret,
	        version: 2,
	        deviceName: deviceName,
	        code: pairData.otp
	      }
	    };

      bitpayService.postAuth(json, function(data) {
        if (data && data.data.error) {
          return cb(data.data.error);
        }
        var apiContext = {
          token: data.data.data,
          pairData: pairData,
          appIdentity: data.appIdentity
        };
        $log.info('BitPay service BitAuth create token: SUCCESS');

        fetchBasicInfo(apiContext, function(err, basicInfo) {
          if (err) return cb(err);
          var title = gettextCatalog.getString('Add BitPay Account?');
          var msg;

          if (pairingReason) {
            msg = gettextCatalog.getString('To {{reason}} you must first add your BitPay account - {{email}}', {
              reason: pairingReason,
              email: pairData.email
            });
          } else {
            msg = gettextCatalog.getString('Add this BitPay account ({{email}})?', {
              email: pairData.email
            });
          }

          var ok = gettextCatalog.getString('Add Account');
          var cancel = gettextCatalog.getString('Go back');
          popupService.showConfirm(title, msg, ok, cancel, function(res) {
          	if (res) {
  		        var acctData = {
                token: apiContext.token,
                email: pairData.email,
                givenName: basicInfo.givenName,
                familyName: basicInfo.familyName
              };
  						setBitpayAccount(acctData, function(err) {
  			        return cb(err, true, apiContext);
  						});
          	} else {
  				    $log.info('User cancelled BitPay pairing process');
  		        return cb(null, false);
          	}
          });
        });
      }, function(data) {
        return cb(_setError('BitPay service BitAuth create token: ERROR ', data));
	    });
	  });
  };

  var checkOtp = function(pairData, cb) {
    if (pairData.otp) {
      var msg = gettextCatalog.getString('Enter Two Factor for your BitPay account');
      popupService.showPrompt(null, msg, null, function(res) {
        cb(res);
      });
    } else {
      cb();
    }
  };

  var fetchBasicInfo = function(apiContext, cb) {
    var json = {
      method: 'getBasicInfo'
    };
    // Get basic account information
    bitpayService.post('/api/v2/' + apiContext.token, json, function(data) {
      if (data && data.data.error) return cb(data.data.error);
      $log.info('BitPay Account Get Basic Info: SUCCESS');
      return cb(null, data.data.data);
    }, function(data) {
      return cb(_setError('BitPay Account Error: Get Basic Info', data));
    });
  };

  // Returns account objects as stored.
  root.getAccountsAsStored = function(cb) {
    storageService.getBitpayAccounts(bitpayService.getEnvironment().network, cb);
  };

  // Returns an array where each element represents an account including all information required for fetching data
  // from the server for each account (apiContext).
  root.getAccounts = function(cb) {
    root.getAccountsAsStored(function(err, accounts) {
      if (err || lodash.isEmpty(accounts)) {
        return cb(err, []);
      }
      appIdentityService.getIdentity(bitpayService.getEnvironment().network, function(err, appIdentity) {
        if (err) {
          return cb(err);
        }

        var accountsArray = [];
        lodash.forEach(Object.keys(accounts), function(key) {
          accounts[key].cards = accounts[key].cards;
          accounts[key].email = key;
          accounts[key].givenName = accounts[key].givenName || '';
          accounts[key].familyName = accounts[key].familyName || '';
          accounts[key].apiContext = {
            token: accounts[key].token,
            pairData: {
              email: key
            },
            appIdentity: appIdentity
          };

          accountsArray.push(accounts[key]);
        });
        return cb(null, accountsArray);
      });
    });
  };

  var setBitpayAccount = function(account, cb) {
    storageService.setBitpayAccount(bitpayService.getEnvironment().network, account, function(err) {
      return cb(err);
    });
  };

  root.removeAccount = function(account, cb) {
    storageService.removeBitpayAccount(bitpayService.getEnvironment().network, account, function(err) {
      bitpayCardService.registerNextStep();
      cb(err);
    });
  };

  var _setError = function(msg, e) {
    $log.error(msg);
    var error = (e && e.data && e.data.error) ? e.data.error : msg;
    return error;
  };

  return root;

});

'use strict';

angular.module('copayApp.services').factory('bitpayCardService', function($log, $rootScope, $filter, lodash, storageService, bitauthService, platformInfo, moment, appIdentityService, bitpayService, nextStepsService, txFormatService, appConfigService) {
  var root = {};

  var _setError = function(msg, e) {
    $log.error(msg);
    var error = (e && e.data && e.data.error) ? e.data.error : msg;
    return error;
  };

  var _buildDate = function(date, time) {
    date = date.match(/(\d{2})\/(\d{2})\/(\d{4})/);
    time = time.match(/(\d{2})(\d{2})(\d{2})/);
    var newDate = new Date(date[1] + '/' + date[2] + '/' + date[3]);
    newDate.setHours(time[1], time[2], time[3]);
    return newDate;
  };

  var _lowercaseMerchant = function(merchant) {
    if (merchant.name && merchant.name.toLowerCase) {
      merchant.name = merchant.name.toLowerCase();
    }
    if (merchant.city && merchant.city.toLowerCase) {
      merchant.city = merchant.city.toLowerCase();
    }

    return merchant;
  };

  var _getMerchantInfo = function(tx) {
    var bpTranCodes = root.bpTranCodes;
    lodash.keys(bpTranCodes).forEach(function(code) {
      if (tx.type.indexOf(code) === 0) {
        lodash.assign(tx, bpTranCodes[code]);
      }
    });
    return tx;
  };

  var _getIconName = function(tx) {
    var icon = tx.mcc || tx.category || null;
    if (!icon || root.iconMap[icon] == undefined) return 'default';
    return root.iconMap[icon];
  };

  var _processDescription = function(tx) {
    if (lodash.isArray(tx.description)) {
      return tx.description[0];
    }
    return tx.description;
  };

  var _processLocation = function(tx) {
    if (tx.merchant.city && tx.merchant.state) {
      return tx.merchant.city + ', ' + tx.merchant.state;
    } else {
      return tx.merchant.city || tx.merchant.state || '';
    }
  };

  var _fromTransaction = function(txn, runningBalance) {
    var dateTime = _buildDate(txn.date, txn.time);
    var merchant = _lowercaseMerchant(txn.merchant);
    return _getMerchantInfo({
      date: txn.timestamp || dateTime,
      category: txn.mcc,
      merchant: merchant,
      description: txn.description[0],
      price: parseFloat(txn.amount) + parseFloat(txn.fee),
      type: txn.type,
      runningBalance: runningBalance
    });
  };

  var _processTransactions = function(invoices, history) {

    var balance = history.endingBalance || history.currentCardBalance;
    var runningBalance = parseFloat(balance);
    var activityList = [];

    if(history && history.transactionList){
      for (var j = 0; j < history.transactionList.length; j++) {
        runningBalance -= parseFloat(history.transactionList[j].amount);
        activityList.push(_fromTransaction(history.transactionList[j], runningBalance));
      }
    }

    if (activityList.length > 0) {

      invoices = invoices || [];
      for (var i = 0; i < invoices.length; i++) {
        var matched = false;
        for (var j = 0; j < history.transactionList.length; j++) {
          var description = history.transactionList[j].description;
          for (var k = 0; k < description.length; k++) {
            if (description[k] && description[k].indexOf(invoices[i].id) > -1) {
              matched = true;
            }
          }
        }

        var isInvoiceLessThanOneDayOld = moment() < moment(new Date(invoices[i].invoiceTime)).add(1, 'day');

        if (!matched && isInvoiceLessThanOneDayOld) {
          var isInvoiceUnderpaid = invoices[i].exceptionStatus === 'paidPartial';

          if (['paid', 'confirmed', 'complete'].indexOf(invoices[i].status) >= 0 ||
            (invoices[i].status === 'invalid' || isInvoiceUnderpaid)) {

            activityList.unshift(_getMerchantInfo({
              date: new Date(invoices[i].invoiceTime),
              category: '',
              merchant: '',
              description: invoices[i].itemDesc,
              price: invoices[i].price,
              type: '00611 = Client Funded Deposit',
              runningBalance: null,
              pending: true,
              transactionId: invoices[i].transactions && invoices[i].transactions[0] ? invoices[i].transactions[0].txid : ''
            }));
          }
        }
      }
    }
    for (var i = 0; i < activityList.length; i++) {
      activityList[i].icon = _getIconName(activityList[i]);
      activityList[i].desc = _processDescription(activityList[i]);
      activityList[i].merchant['location'] = _processLocation(activityList[i]);
    }
    return activityList;
  };

  root.filterTransactions = function(type, txns) {
    var list,
      getPreAuth = lodash.filter(txns, function(txn) {
        return txn.type.indexOf('93') > -1;
      }),
      getPending = lodash.filter(txns, function(txn) {
        return txn.pending;
      }),
      getCompleted = lodash.filter(txns, function(txn) {
        return !txn.pending && txn.type.indexOf('93') == -1;
      });

    switch (type) {
      case "preAuth":
        list = lodash.filter(getPreAuth);
        break;
      case "confirming":
        list = lodash.filter(getPending);
        break;
      case "completed":
        list = lodash.filter(getCompleted);
        break;
      default:
        // code...
        break;
    }
    return list;
  };

  root.sync = function(apiContext, cb) {
    var json = {
      method: 'getDebitCards'
    };
    // Get Debit Cards
    bitpayService.post('/api/v2/' + apiContext.token, json, function(data) {
      if (data && data.data.error) return cb(data.data.error);
      $log.info('BitPay Get Debit Cards: SUCCESS');

      var cards = [];

      lodash.each(data.data.data, function(x) {
        var n = {};

        if (!x.eid || !x.id || !x.lastFourDigits || !x.token) {
          $log.warn('BAD data from BitPay card' + JSON.stringify(x));
          return;
        }

        n.eid = x.eid;
        n.id = x.id;
        n.lastFourDigits = x.lastFourDigits;
        n.token = x.token;
        n.currency = x.currency;
        n.country = x.country;
        cards.push(n);
      });

      storageService.setBitpayDebitCards(bitpayService.getEnvironment().network, apiContext.pairData.email, cards, function(err) {
        root.registerNextStep();
        return cb(err, cards);
      });
    }, function(data) {
      return cb(_setError('BitPay Card Error: Get Debit Cards', data));
    });
  };

  root.setCurrencySymbol = function(card) {
    // Sets a currency symbol.
    // Uses the currency code if no symbol is mapped (should never happen).
    // Backaward compatibility for FirstView cards (all USD).
    // This avoids users having to re-pair their account.
    if (!card.currency) {
      card.currency = 'USD';
    }
    card.currencySymbol = root.currencySymbols[card.currency] || card.currency + ' ';
  };

  // opts: range
  root.getHistory = function(cardId, opts, cb) {
    var invoices, history;
    opts = opts || {};

    var json = {
      method: 'getInvoiceHistory'
    };

    appIdentityService.getIdentity(bitpayService.getEnvironment().network, function(err, appIdentity) {
      if (err) return cb(err);

      root.getCards(function(err, data) {
        if (err) return cb(err);
        var card = lodash.find(data, {
          id: cardId
        });

        if (!card)
          return cb(_setError('Card not found'));

        // Get invoices
        bitpayService.post('/api/v2/' + card.token, json, function(data) {
          $log.info('BitPay Get Invoices: SUCCESS');
          invoices = data.data.data || [];

          if (lodash.isEmpty(invoices))
            $log.info('No invoices');

          json = {
            method: 'getTransactionHistory',
            params: JSON.stringify(opts)
          };
          // Get transactions History list
          bitpayService.post('/api/v2/' + card.token, json, function(data) {
            $log.info('BitPay Get History: SUCCESS');
            history = data.data.data || {};
            history['txs'] = _processTransactions(invoices, history);

            root.setLastKnownBalance(cardId, history.currentCardBalance, function() {});

            return cb(data.data.error, history);
          }, function(data) {
            return cb(_setError('BitPay Card Error: Get History', data));
          });
        }, function(data) {
          return cb(_setError('BitPay Card Error: Get Invoices', data));
        });
      });
    });
  };

  root.topUp = function(cardId, opts, cb) {
    opts = opts || {};
    var json = {
      method: 'generateTopUpInvoice',
      params: JSON.stringify(opts)
    };
    appIdentityService.getIdentity(bitpayService.getEnvironment().network, function(err, appIdentity) {
      if (err) return cb(err);

      root.getCards(function(err, data) {
        if (err) return cb(err);

        var card = lodash.find(data, {
          id: cardId
        });

        if (!card)
          return cb(_setError('Card not found'));

        bitpayService.post('/api/v2/' + card.token, json, function(data) {
          $log.info('BitPay TopUp: SUCCESS');
          if (data.data.error) {
            return cb(data.data.error);
          } else {
            return cb(null, data.data.data.invoice);
          }
        }, function(data) {
          return cb(_setError('BitPay Card Error: TopUp', data));
        });
      });
    });
  };

  root.getInvoice = function(id, cb) {
    bitpayService.get('/invoices/' + id, function(data) {
      $log.info('BitPay Get Invoice: SUCCESS');
      return cb(data.data.error, data.data.data);
    }, function(data) {
      return cb(_setError('BitPay Card Error: Get Invoice', data));
    });
  };

  // get all cards, for all accounts.
  root.getCards = function(cb) {
    storageService.getBitpayDebitCards(bitpayService.getEnvironment().network, cb);
  };

  root.getLastKnownBalance = function(cardId, cb) {
    storageService.getBalanceCache(cardId, cb);
  };

  root.addLastKnownBalance = function(card, cb) {
    var now = Math.floor(Date.now() / 1000);
    var showRange = 600; // 10min;

    root.getLastKnownBalance(card.eid, function(err, data) {
      if (data) {
        data = JSON.parse(data);
        card.balance = data.balance;
        card.updatedOn = (data.updatedOn < now - showRange) ? data.updatedOn : null;
      }
      return cb();
    });
  };

  root.setLastKnownBalance = function(cardId, balance, cb) {

    storageService.setBalanceCache(cardId, {
      balance: balance,
      updatedOn: Math.floor(Date.now() / 1000),
    }, cb);
  };

  root.remove = function(cardId, cb) {
    storageService.removeBitpayDebitCard(bitpayService.getEnvironment().network, cardId, function(err) {
      if (err) {
        $log.error('Error removing BitPay debit card: ' + err);
        return cb(err);
      }
      root.registerNextStep();
      storageService.removeBalanceCache(cardId, cb);
    });
  };

  root.getRates = function(currency, cb) {
    bitpayService.get('/rates/' + currency, function(data) {
      $log.info('BitPay Get Rates: SUCCESS');
      return cb(data.data.error, data.data.data);
    }, function(data) {
      return cb(_setError('BitPay Error: Get Rates', data));
    });
  };


  root.get = function(opts, cb) {
    root.getCards(function(err, cards) {
      if (err) return;

      if (lodash.isEmpty(cards)) {
        return cb();
      }

      if (opts.cardId) {
        cards = lodash.filter(cards, function(x) {
          return opts.cardId == x.eid;
        });
      }

      // Async, no problem
      lodash.each(cards, function(x) {

        root.setCurrencySymbol(x);
        root.addLastKnownBalance(x, function() {});

        // async refresh
        if (!opts.noRefresh) {
          root.getHistory(x.id, {}, function(err, data) {
            if (err) return;
            root.addLastKnownBalance(x, function() {});
          });
        }
      });

      return cb(null, cards);
    });
  };

  /*
   * CONSTANTS
   */

  root.currencySymbols = {
    'EUR': '',
    'GBP': '',
    'USD': '$'
  };

  root.bpTranCodes = {
    '00611': {
      merchant: {
        name: 'BitPay',
        city: 'Atlanta',
        state: 'GA'
      },
      category: 'bp001',
      description: 'Top-Up'
    },
    '602': {
      merchant: {
        name: 'ATM Withdrawal Fee',
      },
      category: 'bp002',
      description: ''
    },
    '604': {
      merchant: {
        name: 'Foreign Transaction Fee',
      },
      category: 'bp002',
      description: ''
    },
    '606': {
      merchant: {
        name: 'International ATM Fee',
      },
      category: 'bp002',
      description: ''
    },
    '00240': {
      merchant: {
        name: 'ACH Debit Fee',
      },
      category: 'bp002',
      description: ''
    },
    '5032': {
      merchant: {
        name: 'ACH Debit',
      },
      category: 'bp002',
      description: ''
    },
    '37': {
      merchant: {
        name: 'ACH / Payroll Deposit',
      },
      category: 'bp002',
      description: ''
    },
    '10036': {
      merchant: {
        name: 'Inactivity Fee (90 days)',
      },
      category: 'bp002',
      description: ''
    },
    'load': {
      merchant: {
        name: 'BitPay',
        city: 'Atlanta',
        state: 'GA'
      },
      category: 'bp001',
      description: 'Top-Up'
    },
    'unload | pos': {
      description: 'Purchase'
    },
    'unload | epos': {
      description: 'Online Purchase'
    },
    'transactionfee': {
      merchant: {
        name: 'Transaction Fee',
      },
      category: 'bp002',
      description: ''
    }
  };

  root.iconMap = {
    742: 'medical',
    763: 'plant',
    780: 'plant',
    1520: 'repair',
    1711: 'repair',
    1731: 'repair',
    1740: 'repair',
    1750: 'repair',
    1761: 'repair',
    1771: 'repair',
    1799: 'repair',
    2741: 'books',
    2791: 'books',
    2842: 'clean',
    3000: 'airplane',
    3001: 'airplane',
    3002: 'airplane',
    3003: 'airplane',
    3004: 'airplane',
    3005: 'airplane',
    3006: 'airplane',
    3007: 'airplane',
    3008: 'airplane',
    3009: 'airplane',
    3010: 'airplane',
    3011: 'airplane',
    3012: 'airplane',
    3013: 'airplane',
    3014: 'airplane',
    3015: 'airplane',
    3016: 'airplane',
    3017: 'airplane',
    3018: 'airplane',
    3019: 'airplane',
    3020: 'airplane',
    3021: 'airplane',
    3022: 'airplane',
    3023: 'airplane',
    3024: 'airplane',
    3025: 'airplane',
    3026: 'airplane',
    3027: 'airplane',
    3028: 'airplane',
    3029: 'airplane',
    3030: 'airplane',
    3031: 'airplane',
    3032: 'airplane',
    3033: 'airplane',
    3034: 'airplane',
    3035: 'airplane',
    3036: 'airplane',
    3037: 'airplane',
    3038: 'airplane',
    3039: 'airplane',
    3040: 'airplane',
    3041: 'airplane',
    3042: 'airplane',
    3043: 'airplane',
    3044: 'airplane',
    3045: 'airplane',
    3046: 'airplane',
    3047: 'airplane',
    3048: 'airplane',
    3049: 'airplane',
    3050: 'airplane',
    3051: 'airplane',
    3052: 'airplane',
    3053: 'airplane',
    3054: 'airplane',
    3055: 'airplane',
    3056: 'airplane',
    3057: 'airplane',
    3058: 'airplane',
    3059: 'airplane',
    3060: 'airplane',
    3061: 'airplane',
    3062: 'airplane',
    3063: 'airplane',
    3064: 'airplane',
    3065: 'airplane',
    3066: 'airplane',
    3067: 'airplane',
    3068: 'airplane',
    3069: 'airplane',
    3070: 'airplane',
    3071: 'airplane',
    3072: 'airplane',
    3073: 'airplane',
    3074: 'airplane',
    3075: 'airplane',
    3076: 'airplane',
    3077: 'airplane',
    3078: 'airplane',
    3079: 'airplane',
    3080: 'airplane',
    3081: 'airplane',
    3082: 'airplane',
    3083: 'airplane',
    3084: 'airplane',
    3085: 'airplane',
    3086: 'airplane',
    3087: 'airplane',
    3088: 'airplane',
    3089: 'airplane',
    3090: 'airplane',
    3091: 'airplane',
    3092: 'airplane',
    3093: 'airplane',
    3094: 'airplane',
    3095: 'airplane',
    3096: 'airplane',
    3097: 'airplane',
    3098: 'airplane',
    3099: 'airplane',
    3100: 'airplane',
    3101: 'airplane',
    3102: 'airplane',
    3103: 'airplane',
    3104: 'airplane',
    3105: 'airplane',
    3106: 'airplane',
    3107: 'airplane',
    3108: 'airplane',
    3109: 'airplane',
    3110: 'airplane',
    3111: 'airplane',
    3112: 'airplane',
    3113: 'airplane',
    3114: 'airplane',
    3115: 'airplane',
    3116: 'airplane',
    3117: 'airplane',
    3118: 'airplane',
    3119: 'airplane',
    3120: 'airplane',
    3121: 'airplane',
    3122: 'airplane',
    3123: 'airplane',
    3124: 'airplane',
    3125: 'airplane',
    3126: 'airplane',
    3127: 'airplane',
    3128: 'airplane',
    3129: 'airplane',
    3130: 'airplane',
    3131: 'airplane',
    3132: 'airplane',
    3133: 'airplane',
    3134: 'airplane',
    3135: 'airplane',
    3136: 'airplane',
    3137: 'airplane',
    3138: 'airplane',
    3139: 'airplane',
    3140: 'airplane',
    3141: 'airplane',
    3142: 'airplane',
    3143: 'airplane',
    3144: 'airplane',
    3145: 'airplane',
    3146: 'airplane',
    3147: 'airplane',
    3148: 'airplane',
    3149: 'airplane',
    3150: 'airplane',
    3151: 'airplane',
    3152: 'airplane',
    3153: 'airplane',
    3154: 'airplane',
    3155: 'airplane',
    3156: 'airplane',
    3157: 'airplane',
    3158: 'airplane',
    3159: 'airplane',
    3160: 'airplane',
    3161: 'airplane',
    3162: 'airplane',
    3163: 'airplane',
    3164: 'airplane',
    3165: 'airplane',
    3166: 'airplane',
    3167: 'airplane',
    3168: 'airplane',
    3169: 'airplane',
    3170: 'airplane',
    3171: 'airplane',
    3172: 'airplane',
    3173: 'airplane',
    3174: 'airplane',
    3175: 'airplane',
    3176: 'airplane',
    3177: 'airplane',
    3178: 'airplane',
    3179: 'airplane',
    3180: 'airplane',
    3181: 'airplane',
    3182: 'airplane',
    3183: 'airplane',
    3184: 'airplane',
    3185: 'airplane',
    3186: 'airplane',
    3187: 'airplane',
    3188: 'airplane',
    3189: 'airplane',
    3190: 'airplane',
    3191: 'airplane',
    3192: 'airplane',
    3193: 'airplane',
    3194: 'airplane',
    3195: 'airplane',
    3196: 'airplane',
    3197: 'airplane',
    3198: 'airplane',
    3199: 'airplane',
    3200: 'airplane',
    3201: 'airplane',
    3202: 'airplane',
    3203: 'airplane',
    3204: 'airplane',
    3205: 'airplane',
    3206: 'airplane',
    3207: 'airplane',
    3208: 'airplane',
    3209: 'airplane',
    3210: 'airplane',
    3211: 'airplane',
    3212: 'airplane',
    3213: 'airplane',
    3214: 'airplane',
    3215: 'airplane',
    3216: 'airplane',
    3217: 'airplane',
    3218: 'airplane',
    3219: 'airplane',
    3220: 'airplane',
    3221: 'airplane',
    3222: 'airplane',
    3223: 'airplane',
    3224: 'airplane',
    3225: 'airplane',
    3226: 'airplane',
    3227: 'airplane',
    3228: 'airplane',
    3229: 'airplane',
    3230: 'airplane',
    3231: 'airplane',
    3232: 'airplane',
    3233: 'airplane',
    3234: 'airplane',
    3235: 'airplane',
    3236: 'airplane',
    3237: 'airplane',
    3238: 'airplane',
    3239: 'airplane',
    3240: 'airplane',
    3241: 'airplane',
    3242: 'airplane',
    3243: 'airplane',
    3244: 'airplane',
    3245: 'airplane',
    3246: 'airplane',
    3247: 'airplane',
    3248: 'airplane',
    3249: 'airplane',
    3250: 'airplane',
    3251: 'airplane',
    3252: 'airplane',
    3253: 'airplane',
    3254: 'airplane',
    3255: 'airplane',
    3256: 'airplane',
    3257: 'airplane',
    3258: 'airplane',
    3259: 'airplane',
    3260: 'airplane',
    3261: 'airplane',
    3262: 'airplane',
    3263: 'airplane',
    3264: 'airplane',
    3265: 'airplane',
    3266: 'airplane',
    3267: 'airplane',
    3268: 'airplane',
    3269: 'airplane',
    3270: 'airplane',
    3271: 'airplane',
    3272: 'airplane',
    3273: 'airplane',
    3274: 'airplane',
    3275: 'airplane',
    3276: 'airplane',
    3277: 'airplane',
    3278: 'airplane',
    3279: 'airplane',
    3280: 'airplane',
    3281: 'airplane',
    3282: 'airplane',
    3283: 'airplane',
    3284: 'airplane',
    3285: 'airplane',
    3286: 'airplane',
    3287: 'airplane',
    3288: 'airplane',
    3289: 'airplane',
    3290: 'airplane',
    3291: 'airplane',
    3292: 'airplane',
    3293: 'airplane',
    3294: 'airplane',
    3295: 'airplane',
    3296: 'airplane',
    3297: 'airplane',
    3298: 'airplane',
    3299: 'airplane',
    3351: 'car',
    3352: 'car',
    3353: 'car',
    3354: 'car',
    3355: 'car',
    3356: 'car',
    3357: 'car',
    3358: 'car',
    3359: 'car',
    3360: 'car',
    3361: 'car',
    3362: 'car',
    3363: 'car',
    3364: 'car',
    3365: 'car',
    3366: 'car',
    3367: 'car',
    3368: 'car',
    3369: 'car',
    3370: 'car',
    3371: 'car',
    3372: 'car',
    3373: 'car',
    3374: 'car',
    3375: 'car',
    3376: 'car',
    3377: 'car',
    3378: 'car',
    3379: 'car',
    3380: 'car',
    3381: 'car',
    3382: 'car',
    3383: 'car',
    3384: 'car',
    3385: 'car',
    3386: 'car',
    3387: 'car',
    3388: 'car',
    3389: 'car',
    3390: 'car',
    3391: 'car',
    3392: 'car',
    3393: 'car',
    3394: 'car',
    3395: 'car',
    3396: 'car',
    3397: 'car',
    3398: 'car',
    3399: 'car',
    3400: 'car',
    3401: 'car',
    3402: 'car',
    3403: 'car',
    3404: 'car',
    3405: 'car',
    3406: 'car',
    3407: 'car',
    3408: 'car',
    3409: 'car',
    3410: 'car',
    3411: 'car',
    3412: 'car',
    3413: 'car',
    3414: 'car',
    3415: 'car',
    3416: 'car',
    3417: 'car',
    3418: 'car',
    3419: 'car',
    3420: 'car',
    3421: 'car',
    3422: 'car',
    3423: 'car',
    3424: 'car',
    3425: 'car',
    3426: 'car',
    3427: 'car',
    3428: 'car',
    3429: 'car',
    3430: 'car',
    3431: 'car',
    3432: 'car',
    3433: 'car',
    3434: 'car',
    3435: 'car',
    3436: 'car',
    3437: 'car',
    3438: 'car',
    3439: 'car',
    3440: 'car',
    3441: 'car',
    3501: 'hotel',
    3502: 'hotel',
    3503: 'hotel',
    3504: 'hotel',
    3505: 'hotel',
    3506: 'hotel',
    3507: 'hotel',
    3508: 'hotel',
    3509: 'hotel',
    3510: 'hotel',
    3511: 'hotel',
    3512: 'hotel',
    3513: 'hotel',
    3514: 'hotel',
    3515: 'hotel',
    3516: 'hotel',
    3517: 'hotel',
    3518: 'hotel',
    3519: 'hotel',
    3520: 'hotel',
    3521: 'hotel',
    3522: 'hotel',
    3523: 'hotel',
    3524: 'hotel',
    3525: 'hotel',
    3526: 'hotel',
    3527: 'hotel',
    3528: 'hotel',
    3529: 'hotel',
    3530: 'hotel',
    3531: 'hotel',
    3532: 'hotel',
    3533: 'hotel',
    3534: 'hotel',
    3535: 'hotel',
    3536: 'hotel',
    3537: 'hotel',
    3538: 'hotel',
    3539: 'hotel',
    3540: 'hotel',
    3541: 'hotel',
    3542: 'hotel',
    3543: 'hotel',
    3544: 'hotel',
    3545: 'hotel',
    3546: 'hotel',
    3547: 'hotel',
    3548: 'hotel',
    3549: 'hotel',
    3550: 'hotel',
    3551: 'hotel',
    3552: 'hotel',
    3553: 'hotel',
    3554: 'hotel',
    3555: 'hotel',
    3556: 'hotel',
    3557: 'hotel',
    3558: 'hotel',
    3559: 'hotel',
    3560: 'hotel',
    3561: 'hotel',
    3562: 'hotel',
    3563: 'hotel',
    3564: 'hotel',
    3565: 'hotel',
    3566: 'hotel',
    3567: 'hotel',
    3568: 'hotel',
    3569: 'hotel',
    3570: 'hotel',
    3571: 'hotel',
    3572: 'hotel',
    3573: 'hotel',
    3574: 'hotel',
    3575: 'hotel',
    3576: 'hotel',
    3577: 'hotel',
    3578: 'hotel',
    3579: 'hotel',
    3580: 'hotel',
    3581: 'hotel',
    3582: 'hotel',
    3583: 'hotel',
    3584: 'hotel',
    3585: 'hotel',
    3586: 'hotel',
    3587: 'hotel',
    3588: 'hotel',
    3589: 'hotel',
    3590: 'hotel',
    3591: 'hotel',
    3592: 'hotel',
    3593: 'hotel',
    3594: 'hotel',
    3595: 'hotel',
    3596: 'hotel',
    3597: 'hotel',
    3598: 'hotel',
    3599: 'hotel',
    3600: 'hotel',
    3601: 'hotel',
    3602: 'hotel',
    3603: 'hotel',
    3604: 'hotel',
    3605: 'hotel',
    3606: 'hotel',
    3607: 'hotel',
    3608: 'hotel',
    3609: 'hotel',
    3610: 'hotel',
    3611: 'hotel',
    3612: 'hotel',
    3613: 'hotel',
    3614: 'hotel',
    3615: 'hotel',
    3616: 'hotel',
    3617: 'hotel',
    3618: 'hotel',
    3619: 'hotel',
    3620: 'hotel',
    3621: 'hotel',
    3622: 'hotel',
    3623: 'hotel',
    3624: 'hotel',
    3625: 'hotel',
    3626: 'hotel',
    3627: 'hotel',
    3628: 'hotel',
    3629: 'hotel',
    3630: 'hotel',
    3631: 'hotel',
    3632: 'hotel',
    3633: 'hotel',
    3634: 'hotel',
    3635: 'hotel',
    3636: 'hotel',
    3637: 'hotel',
    3638: 'hotel',
    3639: 'hotel',
    3640: 'hotel',
    3641: 'hotel',
    3642: 'hotel',
    3643: 'hotel',
    3644: 'hotel',
    3645: 'hotel',
    3646: 'hotel',
    3647: 'hotel',
    3648: 'hotel',
    3649: 'hotel',
    3650: 'hotel',
    3651: 'hotel',
    3652: 'hotel',
    3653: 'hotel',
    3654: 'hotel',
    3655: 'hotel',
    3656: 'hotel',
    3657: 'hotel',
    3658: 'hotel',
    3659: 'hotel',
    3660: 'hotel',
    3661: 'hotel',
    3662: 'hotel',
    3663: 'hotel',
    3664: 'hotel',
    3665: 'hotel',
    3666: 'hotel',
    3667: 'hotel',
    3668: 'hotel',
    3669: 'hotel',
    3670: 'hotel',
    3671: 'hotel',
    3672: 'hotel',
    3673: 'hotel',
    3674: 'hotel',
    3675: 'hotel',
    3676: 'hotel',
    3677: 'hotel',
    3678: 'hotel',
    3679: 'hotel',
    3680: 'hotel',
    3681: 'hotel',
    3682: 'hotel',
    3683: 'hotel',
    3684: 'hotel',
    3685: 'hotel',
    3686: 'hotel',
    3687: 'hotel',
    3688: 'hotel',
    3689: 'hotel',
    3690: 'hotel',
    3691: 'hotel',
    3692: 'hotel',
    3693: 'hotel',
    3694: 'hotel',
    3695: 'hotel',
    3696: 'hotel',
    3697: 'hotel',
    3698: 'hotel',
    3699: 'hotel',
    3700: 'hotel',
    3701: 'hotel',
    3702: 'hotel',
    3703: 'hotel',
    3704: 'hotel',
    3705: 'hotel',
    3706: 'hotel',
    3707: 'hotel',
    3708: 'hotel',
    3709: 'hotel',
    3710: 'hotel',
    3711: 'hotel',
    3712: 'hotel',
    3713: 'hotel',
    3714: 'hotel',
    3715: 'hotel',
    3716: 'hotel',
    3717: 'hotel',
    3718: 'hotel',
    3719: 'hotel',
    3720: 'hotel',
    3721: 'hotel',
    3722: 'hotel',
    3723: 'hotel',
    3724: 'hotel',
    3725: 'hotel',
    3726: 'hotel',
    3727: 'hotel',
    3728: 'hotel',
    3729: 'hotel',
    3730: 'hotel',
    3731: 'hotel',
    3732: 'hotel',
    3733: 'hotel',
    3734: 'hotel',
    3735: 'hotel',
    3736: 'hotel',
    3737: 'hotel',
    3738: 'hotel',
    3739: 'hotel',
    3740: 'hotel',
    3741: 'hotel',
    3742: 'hotel',
    3743: 'hotel',
    3744: 'hotel',
    3745: 'hotel',
    3746: 'hotel',
    3747: 'hotel',
    3748: 'hotel',
    3749: 'hotel',
    3750: 'hotel',
    3751: 'hotel',
    3752: 'hotel',
    3753: 'hotel',
    3754: 'hotel',
    3755: 'hotel',
    3756: 'hotel',
    3757: 'hotel',
    3758: 'hotel',
    3759: 'hotel',
    3760: 'hotel',
    3761: 'hotel',
    3762: 'hotel',
    3763: 'hotel',
    3764: 'hotel',
    3765: 'hotel',
    3766: 'hotel',
    3767: 'hotel',
    3768: 'hotel',
    3769: 'hotel',
    3770: 'hotel',
    3771: 'hotel',
    3772: 'hotel',
    3773: 'hotel',
    3774: 'hotel',
    3775: 'hotel',
    3776: 'hotel',
    3777: 'hotel',
    3778: 'hotel',
    3779: 'hotel',
    3780: 'hotel',
    3781: 'hotel',
    3782: 'hotel',
    3783: 'hotel',
    3784: 'hotel',
    3785: 'hotel',
    3786: 'hotel',
    3787: 'hotel',
    3788: 'hotel',
    3789: 'hotel',
    3790: 'hotel',
    3816: 'hotel',
    3835: 'hotel',
    4011: 'car',
    4111: 'car',
    4112: 'car',
    4119: 'car',
    4121: 'car',
    4131: 'car',
    4214: 'car',
    4215: 'bus',
    4225: 'default',
    4411: 'boat',
    4457: 'boat',
    4468: 'boat',
    4511: 'airplane',
    4582: 'airplane',
    4722: 'airplane',
    4723: 'airplane',
    4784: 'car',
    4789: 'car',
    4812: 'car',
    4814: 'telephone',
    4815: 'telephone',
    4816: 'computer',
    4821: 'money',
    4829: 'money',
    4899: 'television',
    4900: 'gas',
    5013: 'car',
    5021: 'default',
    5039: 'repair',
    5044: 'computer',
    5045: 'computer',
    5046: 'default',
    5047: 'medical',
    5051: 'default',
    5065: 'default',
    5072: 'default',
    5074: 'default',
    5085: 'default',
    5094: 'diamond-ring',
    5099: 'default',
    5111: 'default',
    5122: 'medical',
    5131: 'default',
    5137: 'shirt',
    5139: 'shoes',
    5169: 'gas',
    5172: 'gas',
    5192: 'books',
    5193: 'plant',
    5198: 'repair',
    5199: 'repair',
    5200: 'repair',
    5211: 'repair',
    5231: 'repair',
    5251: 'default',
    5261: 'plant',
    5271: 'bus',
    5300: 'purchase',
    5309: 'purchase',
    5310: 'purchase',
    5311: 'purchase',
    5331: 'purchase',
    5399: 'purchase',
    5411: 'food',
    5422: 'food',
    5441: 'food',
    5451: 'food',
    5462: 'food',
    5499: 'food',
    5511: 'car',
    5521: 'car',
    5531: 'car',
    5532: 'car',
    5533: 'car',
    5541: 'gas',
    5542: 'gas',
    5551: 'boat',
    5561: 'motorcycle',
    5571: 'motorcycle',
    5592: 'default',
    5598: 'default',
    5599: 'car',
    5611: 'shirt',
    5621: 'shirt',
    5631: 'shirt',
    5641: 'shirt',
    5651: 'shirt',
    5655: 'shirt',
    5661: 'shoes',
    5681: 'default',
    5691: 'shirt',
    5697: 'default',
    5698: 'default',
    5699: 'default',
    5712: 'default',
    5713: 'default',
    5714: 'default',
    5718: 'default',
    5719: 'default',
    5722: 'default',
    5732: 'computer',
    5733: 'music',
    5734: 'computer',
    5735: 'music',
    5811: 'food',
    5812: 'food',
    5813: 'cocktail',
    5814: 'food',
    5815: 'books',
    5816: 'computer',
    5817: 'default',
    5818: 'default',
    5832: 'default',
    5912: 'medical',
    5921: 'cocktail',
    5931: 'default',
    5932: 'default',
    5933: 'default',
    5935: 'default',
    5937: 'default',
    5940: 'bicycle',
    5941: 'bicycle',
    5942: 'books',
    5943: 'default',
    5944: 'clock',
    5945: 'toy',
    5946: 'camera',
    5947: 'default',
    5948: 'default',
    5949: 'default',
    5950: 'default',
    5960: 'default',
    5961: 'mail',
    5962: 'telephone',
    5963: 'default',
    5964: 'telephone',
    5965: 'telephone',
    5966: 'telephone',
    5967: 'telephone',
    5968: 'telephone',
    5969: 'telephone',
    5970: 'art',
    5971: 'art',
    5972: 'coins',
    5973: 'default',
    5975: 'default',
    5976: 'default',
    5977: 'default',
    5978: 'default',
    5983: 'gas',
    5992: 'plant',
    5993: 'default',
    5994: 'newspaper',
    5995: 'pet',
    5996: 'cocktail',
    5997: 'purchase',
    5998: 'tent',
    5999: 'money',
    6010: 'money',
    6011: 'money',
    6012: 'money',
    6051: 'money',
    6211: 'money',
    6300: 'money',
    6381: 'money',
    6399: 'repair',
    6513: 'repair',
    7011: 'hotel',
    7012: 'hotel',
    7032: 'park',
    7033: 'park',
    7210: 'shirt',
    7211: 'shirt',
    7216: 'shirt',
    7217: 'default',
    7221: 'camera',
    7230: 'scissors',
    7251: 'shoe',
    7261: 'sadface',
    7273: 'smiley-face',
    7276: 'money',
    7277: 'people',
    7278: 'people',
    7296: 'shirt',
    7297: 'smiley-face',
    7298: 'smiley-face',
    7299: 'default',
    7311: 'default',
    7321: 'default',
    7332: 'computer',
    7333: 'camera',
    7338: 'computer',
    7339: 'people',
    7342: 'bug',
    7349: 'default',
    7361: 'people',
    7372: 'computer',
    7375: 'computer',
    7379: 'computer',
    7392: 'people',
    7393: 'search',
    7394: 'default',
    7395: 'car',
    7399: 'car',
    7511: 'truck',
    7512: 'car',
    7513: 'truck',
    7519: 'truck',
    7523: 'car',
    7531: 'car',
    7534: 'car',
    7535: 'car',
    7538: 'car',
    7542: 'car',
    7549: 'truck',
    7622: 'television',
    7623: 'default',
    7629: 'default',
    7631: 'watch',
    7641: 'furniture',
    7692: 'default',
    7699: 'default',
    7800: 'money',
    7801: 'money',
    7802: 'money',
    7829: 'money',
    7832: 'film',
    7841: 'film',
    7911: 'music',
    7922: 'ticket',
    7929: 'ticket',
    7932: 'music',
    7933: 'bowling',
    7941: 'football',
    7991: 'people',
    7992: 'golf',
    7993: 'game',
    7994: 'game',
    7995: 'coins',
    7996: 'ticket',
    7997: 'money',
    7998: 'ticket',
    7999: 'people',
    8011: 'medical',
    8021: 'medical',
    8031: 'medical',
    8041: 'medical',
    8042: 'medical',
    8043: 'medical',
    8044: 'medical',
    8049: 'medical',
    8050: 'medical',
    8062: 'medical',
    8071: 'medical',
    8099: 'medical',
    8111: 'law',
    8211: 'books',
    8220: 'books',
    8241: 'books',
    8244: 'books',
    8249: 'books',
    8299: 'people',
    8351: 'people',
    8398: 'people',
    8641: 'people',
    8651: 'people',
    8661: 'people',
    8675: 'car',
    8699: 'people',
    8734: 'medical',
    8911: 'tree',
    8931: 'books',
    8999: 'suitcase',
    9211: 'law',
    9222: 'law',
    9223: 'law',
    9311: 'law',
    9399: 'default',
    9402: 'mail',
    9405: 'default',
    9700: 'default',
    9701: 'default',
    9702: 'default',
    9950: 'default',
    'bp001': 'bitcoin-topup',
    'bp002': 'default'
  };

  var nextStepItem = {
    name: 'bitpaycard',
    title: 'Add BitPay Visa Card',
    icon: 'icon-bitpay-card',
    sref: 'tabs.bitpayCardIntro',
  };


  root.registerNextStep = function() {
    // Disable BitPay Card
    if (!appConfigService._enabledExtensions.debitcard) return;
    root.getCards(function(err, cards) {
      if (lodash.isEmpty(cards)) {
        nextStepsService.register(nextStepItem);
      } else {
        nextStepsService.unregister(nextStepItem.name);
      }
    });
  };

  root.registerNextStep();
  return root;

});

'use strict';

angular.module('copayApp.services').factory('bitpayService', function($log, $http, appIdentityService, bitauthService) {
  var root = {};

  var NETWORK = 'livenet';
  var BITPAY_API_URL = NETWORK == 'livenet' ? 'https://bitpay.com' : 'https://test.bitpay.com';

  root.getEnvironment = function() {
    return {
      network: NETWORK
    };
  };

  root.get = function(endpoint, successCallback, errorCallback) {
    $http(_get(endpoint)).then(function(data) {
      successCallback(data);
    }, function(data) {
      errorCallback(data);
    });
  };

  root.post = function(endpoint, json, successCallback, errorCallback) {
    appIdentityService.getIdentity(root.getEnvironment().network, function(err, appIdentity) {
      if (err) {
        return errorCallback(err);
      }
      $http(_post(endpoint, json, appIdentity)).then(function(data) {
        successCallback(data);
      }, function(data) {
        errorCallback(data);
      });
    });
  };

  root.postAuth = function(json, successCallback, errorCallback) {
    appIdentityService.getIdentity(root.getEnvironment().network, function(err, appIdentity) {
      if (err) {
        return errorCallback(err);
      }
      $http(_postAuth('/api/v2/', json, appIdentity)).then(function(data) {
        data.appIdentity = appIdentity;
        successCallback(data);
      }, function(data) {
        errorCallback(data);
      });
    });
  };

  var _get = function(endpoint) {
    return {
      method: 'GET',
      url: BITPAY_API_URL + endpoint,
      headers: {
        'content-type': 'application/json'
      }
    };
  };

  var _post = function(endpoint, json, appIdentity) {
    var dataToSign = BITPAY_API_URL + endpoint + JSON.stringify(json);
    var signedData = bitauthService.sign(dataToSign, appIdentity.priv);

    return {
      method: 'POST',
      url: BITPAY_API_URL + endpoint,
      headers: {
        'content-type': 'application/json',
        'x-identity': appIdentity.pub,
        'x-signature': signedData
      },
      data: json
    };
  };

  var _postAuth = function(endpoint, json, appIdentity) {
    json['params'].signature = bitauthService.sign(JSON.stringify(json.params), appIdentity.priv);
    json['params'].pubkey = appIdentity.pub;
    json['params'] = JSON.stringify(json.params);

    var ret = {
      method: 'POST',
      url: BITPAY_API_URL + endpoint,
      headers: {
        'content-type': 'application/json'
      },
      data: json
    };

    $log.debug('post auth:' + JSON.stringify(ret));
    return ret;
  };

  return root;
  
});

'use strict';

angular.module('copayApp.services').factory('buyAndSellService', function($log, nextStepsService, lodash, $ionicScrollDelegate, $timeout) {
  var root = {};
  var services = [];
  var linkedServices = [];

  root.update = function() {

    var newLinked = lodash.filter(services, function(x) {
      return x.linked;
    });

    // This is to preserve linkedServices pointer
    while (linkedServices.length)
      linkedServices.pop();

    while (newLinked.length)
      linkedServices.push(newLinked.pop());
    //

    $log.debug('buyAndSell Service, updating nextSteps. linked/total: ' + linkedServices.length + '/' + services.length);

    if (linkedServices.length == 0) {
      nextStepsService.register({
        title: 'Buy or Sell Bitcoin',
        name: 'buyandsell',
        icon: 'icon-buy-bitcoin',
        sref: 'tabs.buyandsell',
      });
    } else {
      nextStepsService.unregister({
        name: 'buyandsell',
      });
    };

    $timeout(function() {
      $ionicScrollDelegate.resize();
    }, 10);
  };

  var updateNextStepsDebunced = lodash.debounce(root.update, 1000);

  root.register = function(serviceInfo) {
    services.push(serviceInfo);
    $log.info('Adding Buy and Sell service:' + serviceInfo.name + ' linked:' + serviceInfo.linked);
    updateNextStepsDebunced();
  };


  root.updateLink = function(name, linked) {
    var service = lodash.find(services, function(x) {
      return x.name == name;
    });
    $log.info('Updating Buy and Sell service:' + name + ' linked:' + linked);
    service.linked = linked

    root.update();
  };


  root.get = function() {
    return services;
  };


  root.getLinked = function() {
    return linkedServices;
  };


  return root;
});

'use strict';
angular.module('copayApp.services')
  .factory('bwcError', function bwcErrorService($log, gettextCatalog) {
    var root = {};

    root.msg = function(err, prefix) {
      if (!err)
        return 'Unknown error';

      var name;

      if (err.name) {
        if (err.name == 'Error')
          name = err.message
        else
          name = err.name.replace(/^bwc.Error/g, '');
      } else
        name = err;

      var body = '';
      prefix = prefix || '';

      if (name) {
        switch (name) {
          case 'INVALID_BACKUP':
            body = gettextCatalog.getString('Wallet Recovery Phrase is invalid');
            break;
          case 'WALLET_DOES_NOT_EXIST':
            body = gettextCatalog.getString('Wallet not registered at the wallet service. Recreate it from "Create Wallet" using "Advanced Options" to set your recovery phrase');
            break;
          case 'MISSING_PRIVATE_KEY':
            body = gettextCatalog.getString('Missing private keys to sign');
            break;
          case 'ENCRYPTED_PRIVATE_KEY':
            body = gettextCatalog.getString('Private key is encrypted, cannot sign');
            break;
          case 'SERVER_COMPROMISED':
            body = gettextCatalog.getString('Server response could not be verified');
            break;
          case 'COULD_NOT_BUILD_TRANSACTION':
            body = gettextCatalog.getString('Could not build transaction');
            break;
          case 'INSUFFICIENT_FUNDS':
            body = gettextCatalog.getString('Insufficient funds');
            break;
          case 'CONNECTION_ERROR':
            body = gettextCatalog.getString('Network error');
            break;
          case 'NOT_FOUND':
            body = gettextCatalog.getString('Wallet service not found');
            break;
          case 'ECONNRESET_ERROR':
            body = gettextCatalog.getString('Connection reset by peer');
            break;
          case 'BAD_RESPONSE_CODE':
            body = gettextCatalog.getString('The request could not be understood by the server');
            break;
          case 'WALLET_ALREADY_EXISTS':
            body = gettextCatalog.getString('Wallet already exists');
            break;
          case 'COPAYER_IN_WALLET':
            body = gettextCatalog.getString('Copayer already in this wallet');
            break;
          case 'WALLET_FULL':
            body = gettextCatalog.getString('Wallet is full');
            break;
          case 'WALLET_NOT_FOUND':
            body = gettextCatalog.getString('Wallet not found');
            break;
          case 'INSUFFICIENT_FUNDS_FOR_FEE':
            body = gettextCatalog.getString('Insufficient funds for fee');
            break;
          case 'LOCKED_FUNDS':
            body = gettextCatalog.getString('Funds are locked by pending spend proposals');
            break;
          case 'COPAYER_VOTED':
            body = gettextCatalog.getString('Copayer already voted on this spend proposal');
            break;
          case 'NOT_AUTHORIZED':
            body = gettextCatalog.getString('Not authorized');
            break;
          case 'TX_ALREADY_BROADCASTED':
            body = gettextCatalog.getString('Transaction already broadcasted');
            break;
          case 'TX_CANNOT_CREATE':
            body = gettextCatalog.getString('Locktime in effect. Please wait to create a new spend proposal');
            break;
          case 'TX_CANNOT_REMOVE':
            body = gettextCatalog.getString('Locktime in effect. Please wait to remove this spend proposal');
            break;
          case 'TX_NOT_ACCEPTED':
            body = gettextCatalog.getString('Spend proposal is not accepted');
            break;
          case 'TX_NOT_FOUND':
            body = gettextCatalog.getString('Spend proposal not found');
            break;
          case 'TX_NOT_PENDING':
            body = gettextCatalog.getString('The spend proposal is not pending');
            break;
          case 'UPGRADE_NEEDED':
            body = gettextCatalog.getString('Please upgrade Copay to perform this action');
            break;
          case 'BAD_SIGNATURES':
            body = gettextCatalog.getString('Signatures rejected by server');
            break;
          case 'COPAYER_DATA_MISMATCH':
            body = gettextCatalog.getString('Copayer data mismatch');
            break;
          case 'DUST_AMOUNT':
            body = gettextCatalog.getString('Amount below minimum allowed');
            break;
          case 'INCORRECT_ADDRESS_NETWORK':
            body = gettextCatalog.getString('Incorrect network address');
            break;
          case 'COPAYER_REGISTERED':
            body = gettextCatalog.getString('Key already associated with an existing wallet');
            break;
          case 'INVALID_ADDRESS':
            body = gettextCatalog.getString('Invalid address');
            break;
          case 'MAIN_ADDRESS_GAP_REACHED':
            body = gettextCatalog.getString('Empty addresses limit reached. New addresses cannot be generated.');
            break;
          case 'WALLET_LOCKED':
            body = gettextCatalog.getString('Wallet is locked');
            break;
          case 'WALLET_NOT_COMPLETE':
            body = gettextCatalog.getString('Wallet is not complete');
            break;
          case 'WALLET_NEEDS_BACKUP':
            body = gettextCatalog.getString('Wallet needs backup');
            break;
          case 'MISSING_PARAMETER':
            body = gettextCatalog.getString('Missing parameter');
            break;
          case 'NO_PASSWORD_GIVEN':
            body = gettextCatalog.getString('Spending Password needed');
            break;
          case 'PASSWORD_INCORRECT':
            body = gettextCatalog.getString('Wrong spending password');
            break;
          case 'EXCEEDED_DAILY_LIMIT':
            body = gettextCatalog.getString('Exceeded daily limit of $500 per user');
            break;
          case 'ERROR':
            body = (err.message || err.error);
            break;

          default:
            $log.warn('Unknown error type:', name);
            body = err.message || name;
            break;
        }
      } else if (err.message) {
        body = err.message;
      } else {
        body = err;
      }

      var msg = prefix + (body ? (prefix ? ': ' : '') + body : '');
      return msg;
    };

    root.cb = function(err, prefix, cb) {
      return cb(root.msg(err, prefix));
    };

    return root;
  });

'use strict';

angular.module('copayApp.services').factory('coinbaseService', function($http, $log, $window, $filter, platformInfo, lodash, storageService, configService, appConfigService, txFormatService, buyAndSellService, $rootScope, feeService) {
  var root = {};
  var credentials = {};
  var isCordova = platformInfo.isCordova;
  var isNW = platformInfo.isNW;
  var isWindowsPhoneApp = platformInfo.isCordova && platformInfo.isWP;

  root.priceSensitivity = [{
    value: 0.5,
    name: '0.5%'
  }, {
    value: 1,
    name: '1%'
  }, {
    value: 2,
    name: '2%'
  }, {
    value: 5,
    name: '5%'
  }, {
    value: 10,
    name: '10%'
  }];

  root.selectedPriceSensitivity = root.priceSensitivity[1];

  var setCredentials = function() {

    if (!$window.externalServices || !$window.externalServices.coinbase) {
      return;
    }

    var coinbase = $window.externalServices.coinbase;

    /*
     * Development: 'testnet'
     * Production: 'livenet'
     */
    credentials.NETWORK = 'livenet';

    // Coinbase permissions
    credentials.SCOPE = '' +
      'wallet:accounts:read,' +
      'wallet:addresses:read,' +
      'wallet:addresses:create,' +
      'wallet:user:read,' +
      'wallet:user:email,' +
      'wallet:buys:read,' +
      'wallet:buys:create,' +
      'wallet:sells:read,' +
      'wallet:sells:create,' +
      'wallet:transactions:read,' +
      'wallet:transactions:send,' +
      'wallet:transactions:send:bypass-2fa,' +
      'wallet:payment-methods:read';

    // NW has a bug with Window Object
    if (isCordova) {
      credentials.REDIRECT_URI = coinbase.redirect_uri.mobile;
    } else {
      credentials.REDIRECT_URI = coinbase.redirect_uri.desktop;
    }

    if (credentials.NETWORK == 'testnet') {
      credentials.HOST = coinbase.sandbox.host;
      credentials.API = coinbase.sandbox.api;
      credentials.CLIENT_ID = coinbase.sandbox.client_id;
      credentials.CLIENT_SECRET = coinbase.sandbox.client_secret;
    } else {
      credentials.HOST = coinbase.production.host;
      credentials.API = coinbase.production.api;
      credentials.CLIENT_ID = coinbase.production.client_id;
      credentials.CLIENT_SECRET = coinbase.production.client_secret;
    };
  };

  var _afterTokenReceived = function(data, cb) {
    if (data && data.access_token && data.refresh_token) {
      storageService.setCoinbaseToken(credentials.NETWORK, data.access_token, function() {
        storageService.setCoinbaseRefreshToken(credentials.NETWORK, data.refresh_token, function() {
          buyAndSellService.updateLink('coinbase', true);
          return cb(null, data.access_token);
        });
      });
    } else {
      return cb('Could not get the access token');
    }
  };

  root.getNetwork = function() {
    return credentials.NETWORK;
  };

  root.getStoredToken = function(cb) {
    storageService.getCoinbaseToken(credentials.NETWORK, function(err, accessToken) {
      if (err || !accessToken) return cb();
      return cb(accessToken);
    });
  };

  root.getAvailableCurrency = function() {
    var config = configService.getSync().wallet.settings;
    // ONLY "USD"
    switch (config.alternativeIsoCode) {
      default: return 'USD'
    };
  };

  root.checkEnoughFundsForFee = function(amount, cb) {
    _getNetAmount(amount, function(err, reducedAmount) {
      if (err) return cb(err);

      // Check if transaction has enough funds to transfer bitcoin from Coinbase to Copay
      if (reducedAmount < 0) {
        return cb('Not enough funds for fee');
      }

      return cb();
    });
  };

  root.getSignupUrl = function() {
    return credentials.HOST + '/signup';
  }

  root.getSupportUrl = function() {
    return 'https://support.coinbase.com/';
  }

  root.getOauthCodeUrl = function() {
    return credentials.HOST +
      '/oauth/authorize?response_type=code&client_id=' +
      credentials.CLIENT_ID +
      '&redirect_uri=' +
      credentials.REDIRECT_URI +
      '&state=SECURE_RANDOM&scope=' +
      credentials.SCOPE +
      '&meta[send_limit_amount]=1000&meta[send_limit_currency]=USD&meta[send_limit_period]=day';
  };

  root.getToken = function(code, cb) {
    var req = {
      method: 'POST',
      url: credentials.HOST + '/oauth/token',
      headers: {
        'Content-Type': 'application/json',
        'Accept': 'application/json'
      },
      data: {
        grant_type: 'authorization_code',
        code: code,
        client_id: credentials.CLIENT_ID,
        client_secret: credentials.CLIENT_SECRET,
        redirect_uri: credentials.REDIRECT_URI
      }
    };

    $http(req).then(function(data) {
      $log.info('Coinbase Authorization Access Token: SUCCESS');
      // Show pending task from the UI
      _afterTokenReceived(data.data, cb);
    }, function(data) {
      $log.error('Coinbase Authorization Access Token: ERROR ' + data.statusText);
      return cb(data.data || 'Could not get the access token');
    });
  };

  var _getNetAmount = function(amount, cb) {
    // Fee Normal for a single transaction (450 bytes)
    var txNormalFeeKB = 450 / 1000;
    feeService.getFeeRate('btcz', 'livenet', 'normal', function(err, feePerKb) {
      if (err) return cb(err);
      var feeBTCZ = (feePerKb * txNormalFeeKB / 100000000).toFixed(8);

      return cb(null, amount - feeBTCZ, feeBTCZ);
    });
  };

  var _refreshToken = function(refreshToken, cb) {
    var req = {
      method: 'POST',
      url: credentials.HOST + '/oauth/token',
      headers: {
        'Content-Type': 'application/json',
        'Accept': 'application/json'
      },
      data: {
        grant_type: 'refresh_token',
        client_id: credentials.CLIENT_ID,
        client_secret: credentials.CLIENT_SECRET,
        redirect_uri: credentials.REDIRECT_URI,
        refresh_token: refreshToken
      }
    };

    $http(req).then(function(data) {
      $log.info('Coinbase Refresh Access Token: SUCCESS');
      _afterTokenReceived(data.data, cb);
    }, function(data) {
      $log.error('Coinbase Refresh Access Token: ERROR ' + data.statusText);
      return cb(data.data || 'Could not get the access token');
    });
  };

  var _getMainAccountId = function(accessToken, cb) {
    root.getAccounts(accessToken, function(err, a) {
      if (err) return cb(err);
      var data = a.data;
      for (var i = 0; i < data.length; i++) {
        if (data[i].primary && data[i].type == 'wallet') {
          return cb(null, data[i].id);
        }
      }
      root.logout(function() {});
      return cb('Your primary account should be a WALLET. Set your wallet account as primary and try again');
    });
  };

  root.isActive = function(cb) {

    if (isWindowsPhoneApp)
      return cb();

    if (lodash.isEmpty(credentials.CLIENT_ID))
      return cb();

    storageService.getCoinbaseToken(credentials.NETWORK, function(err, accessToken) {
      return cb(err, !!accessToken);
    });
  }

  root.init = lodash.throttle(function(cb) {
    if (lodash.isEmpty(credentials.CLIENT_ID)) {
      return cb('Coinbase is Disabled');
    }
    $log.debug('Trying to initialise Coinbase...');

    storageService.getCoinbaseToken(credentials.NETWORK, function(err, accessToken) {
      if (err || !accessToken) return cb();
      else {
        _getMainAccountId(accessToken, function(err, accountId) {
          if (err) {
            if (err.errors && err.errors[0] && err.errors[0].id == 'expired_token') {
              $log.debug('Refresh token');
              storageService.getCoinbaseRefreshToken(credentials.NETWORK, function(err, refreshToken) {
                if (err) return cb(err);
                _refreshToken(refreshToken, function(err, newToken) {
                  if (err) return cb(err);
                  _getMainAccountId(newToken, function(err, accountId) {
                    if (err) return cb(err);
                    return cb(null, {
                      accessToken: newToken,
                      accountId: accountId
                    });
                  });
                });
              });
            } else {
              return cb(err);
            }
          } else {
            return cb(null, {
              accessToken: accessToken,
              accountId: accountId
            });
          }
        });
      }
    });
  }, 10000);

  var _get = function(endpoint, token) {
    return {
      method: 'GET',
      url: credentials.API + '/v2' + endpoint,
      headers: {
        'Content-Type': 'application/json',
        'Accept': 'application/json',
        'Authorization': 'Bearer ' + token
      }
    };
  };

  root.getAccounts = function(token, cb) {
    if (!token) return cb('Invalid Token');
    $http(_get('/accounts', token)).then(function(data) {
      $log.info('Coinbase Get Accounts: SUCCESS');
      return cb(null, data.data);
    }, function(data) {
      $log.error('Coinbase Get Accounts: ERROR ' + data.statusText);
      return cb(data.data || 'Could not get the accounts');
    });
  };

  root.getAccount = function(token, accountId, cb) {
    if (!token) return cb('Invalid Token');
    $http(_get('/accounts/' + accountId, token)).then(function(data) {
      $log.info('Coinbase Get Account: SUCCESS');
      return cb(null, data.data);
    }, function(data) {
      $log.error('Coinbase Get Account: ERROR ' + data.statusText);
      return cb(data.data);
    });
  };

  root.getAuthorizationInformation = function(token, cb) {
    if (!token) return cb('Invalid Token');
    $http(_get('/user/auth', token)).then(function(data) {
      $log.info('Coinbase Autorization Information: SUCCESS');
      return cb(null, data.data);
    }, function(data) {
      $log.error('Coinbase Autorization Information: ERROR ' + data.statusText);
      return cb(data.data);
    });
  };

  root.getCurrentUser = function(token, cb) {
    if (!token) return cb('Invalid Token');
    $http(_get('/user', token)).then(function(data) {
      $log.info('Coinbase Get Current User: SUCCESS');
      return cb(null, data.data);
    }, function(data) {
      $log.error('Coinbase Get Current User: ERROR ' + data.statusText);
      return cb(data.data);
    });
  };

  root.getBuyOrder = function(token, accountId, buyId, cb) {
    if (!token) return cb('Invalid Token');
    $http(_get('/accounts/' + accountId + '/buys/' + buyId, token)).then(function(data) {
      $log.info('Coinbase Buy Info: SUCCESS');
      return cb(null, data.data);
    }, function(data) {
      $log.error('Coinbase Buy Info: ERROR ' + data.statusText);
      return cb(data.data);
    });
  };

  root.getTransaction = function(token, accountId, transactionId, cb) {
    if (!token) return cb('Invalid Token');
    $http(_get('/accounts/' + accountId + '/transactions/' + transactionId, token)).then(function(data) {
      $log.info('Coinbase Transaction: SUCCESS');
      return cb(null, data.data);
    }, function(data) {
      $log.error('Coinbase Transaction: ERROR ' + data.statusText);
      return cb(data.data);
    });
  };

  root.getAddressTransactions = function(token, accountId, addressId, cb) {
    if (!token) return cb('Invalid Token');
    $http(_get('/accounts/' + accountId + '/addresses/' + addressId + '/transactions', token)).then(function(data) {
      $log.info('Coinbase Address s Transactions: SUCCESS');
      return cb(null, data.data);
    }, function(data) {
      $log.error('Coinbase Address s Transactions: ERROR ' + data.statusText);
      return cb(data.data);
    });
  };

  root.getTransactions = function(token, accountId, cb) {
    if (!token) return cb('Invalid Token');
    $http(_get('/accounts/' + accountId + '/transactions', token)).then(function(data) {
      $log.info('Coinbase Transactions: SUCCESS');
      return cb(null, data.data);
    }, function(data) {
      $log.error('Coinbase Transactions: ERROR ' + data.statusText);
      return cb(data.data);
    });
  };

  root.paginationTransactions = function(token, Url, cb) {
    if (!token) return cb('Invalid Token');
    $http(_get(Url.replace('/v2', ''), token)).then(function(data) {
      $log.info('Coinbase Pagination Transactions: SUCCESS');
      return cb(null, data.data);
    }, function(data) {
      $log.error('Coinbase Pagination Transactions: ERROR ' + data.statusText);
      return cb(data.data);
    });
  };

  root.sellPrice = function(token, currency, cb) {
    $http(_get('/prices/sell?currency=' + currency, token)).then(function(data) {
      $log.info('Coinbase Sell Price: SUCCESS');
      return cb(null, data.data);
    }, function(data) {
      $log.error('Coinbase Sell Price: ERROR ' + data.statusText);
      return cb(data.data);
    });
  };

  root.buyPrice = function(token, currency, cb) {
    $http(_get('/prices/buy?currency=' + currency, token)).then(function(data) {
      $log.info('Coinbase Buy Price: SUCCESS');
      return cb(null, data.data);
    }, function(data) {
      $log.error('Coinbase Buy Price: ERROR ' + data.statusText);
      return cb(data.data);
    });
  };

  root.getPaymentMethods = function(token, cb) {
    $http(_get('/payment-methods', token)).then(function(data) {
      $log.info('Coinbase Get Payment Methods: SUCCESS');
      return cb(null, data.data);
    }, function(data) {
      $log.error('Coinbase Get Payment Methods: ERROR ' + data.statusText);
      return cb(data.data);
    });
  };

  root.getPaymentMethod = function(token, paymentMethodId, cb) {
    $http(_get('/payment-methods/' + paymentMethodId, token)).then(function(data) {
      $log.info('Coinbase Get Payment Method: SUCCESS');
      return cb(null, data.data);
    }, function(data) {
      $log.error('Coinbase Get Payment Method: ERROR ' + data.statusText);
      return cb(data.data);
    });
  };

  var _post = function(endpoint, token, data) {
    return {
      method: 'POST',
      url: credentials.API + '/v2' + endpoint,
      headers: {
        'Content-Type': 'application/json',
        'Accept': 'application/json',
        'Authorization': 'Bearer ' + token
      },
      data: data
    };
  };

  root.sellRequest = function(token, accountId, data, cb) {
    var data = {
      amount: data.amount,
      currency: data.currency,
      payment_method: data.payment_method || null,
      commit: data.commit || false,
      quote: data.quote || false
    };
    $http(_post('/accounts/' + accountId + '/sells', token, data)).then(function(data) {
      $log.info('Coinbase Sell Request: SUCCESS');
      return cb(null, data.data);
    }, function(data) {
      $log.error('Coinbase Sell Request: ERROR ' + data.statusText);
      return cb(data.data);
    });
  };

  root.sellCommit = function(token, accountId, sellId, cb) {
    $http(_post('/accounts/' + accountId + '/sells/' + sellId + '/commit', token)).then(function(data) {
      $log.info('Coinbase Sell Commit: SUCCESS');
      return cb(null, data.data);
    }, function(data) {
      $log.error('Coinbase Sell Commit: ERROR ' + data.statusText);
      return cb(data.data);
    });
  };

  root.buyRequest = function(token, accountId, data, cb) {
    var data = {
      amount: data.amount,
      currency: data.currency,
      payment_method: data.payment_method || null,
      commit: data.commit || false,
      quote: data.quote || false
    };
    $http(_post('/accounts/' + accountId + '/buys', token, data)).then(function(data) {
      $log.info('Coinbase Buy Request: SUCCESS');
      return cb(null, data.data);
    }, function(data) {
      $log.error('Coinbase Buy Request: ERROR ' + data.statusText);
      return cb(data.data);
    });
  };

  root.buyCommit = function(token, accountId, buyId, cb) {
    $http(_post('/accounts/' + accountId + '/buys/' + buyId + '/commit', token)).then(function(data) {
      $log.info('Coinbase Buy Commit: SUCCESS');
      return cb(null, data.data);
    }, function(data) {
      $log.error('Coinbase Buy Commit: ERROR ' + data.statusText);
      return cb(data.data);
    });
  };

  root.createAddress = function(token, accountId, data, cb) {
    var data = {
      name: data.name
    };
    $http(_post('/accounts/' + accountId + '/addresses', token, data)).then(function(data) {
      $log.info('Coinbase Create Address: SUCCESS');
      return cb(null, data.data);
    }, function(data) {
      $log.error('Coinbase Create Address: ERROR ' + data.statusText);
      return cb(data.data);
    });
  };

  root.sendTo = function(token, accountId, data, cb) {
    var data = {
      type: 'send',
      to: data.to,
      amount: data.amount,
      currency: data.currency,
      description: data.description
    };
    $http(_post('/accounts/' + accountId + '/transactions', token, data)).then(function(data) {
      $log.info('Coinbase Create Address: SUCCESS');
      return cb(null, data.data);
    }, function(data) {
      $log.error('Coinbase Create Address: ERROR ' + data.statusText);
      return cb(data.data);
    });
  };

  // Pending transactions

  root.savePendingTransaction = function(ctx, opts, cb) {
    _savePendingTransaction(ctx, opts, cb);
  };

  var _savePendingTransaction = function(ctx, opts, cb) {
    storageService.getCoinbaseTxs(credentials.NETWORK, function(err, oldTxs) {
      if (lodash.isString(oldTxs)) {
        oldTxs = JSON.parse(oldTxs);
      }
      if (lodash.isString(ctx)) {
        ctx = JSON.parse(ctx);
      }
      var tx = oldTxs || {};
      tx[ctx.id] = ctx;
      if (opts && (opts.error || opts.status)) {
        tx[ctx.id] = lodash.assign(tx[ctx.id], opts);
      }
      if (opts && opts.remove) {
        delete(tx[ctx.id]);
      }
      tx = JSON.stringify(tx);

      storageService.setCoinbaseTxs(credentials.NETWORK, tx, function(err) {
        return cb(err);
      });
    });
  };

  root.getPendingTransactions = function(coinbasePendingTransactions) {
    storageService.getCoinbaseTxs(credentials.NETWORK, function(err, txs) {
      txs = txs ? JSON.parse(txs) : {};
      coinbasePendingTransactions.data = lodash.isEmpty(txs) ? null : txs;

      root.init(function(err, data) {
        if (err || lodash.isEmpty(data)) {
          if (err) $log.error(err);
          return;
        }
        var accessToken = data.accessToken;
        var accountId = data.accountId;

        lodash.forEach(coinbasePendingTransactions.data, function(dataFromStorage, txId) {
          if ((dataFromStorage.type == 'sell' && dataFromStorage.status == 'completed') ||
            (dataFromStorage.type == 'buy' && dataFromStorage.status == 'completed') ||
            dataFromStorage.status == 'error' ||
            (dataFromStorage.type == 'send' && dataFromStorage.status == 'completed'))
            return;
          root.getTransaction(accessToken, accountId, txId, function(err, tx) {
            if (err || lodash.isEmpty(tx) || (tx.data && tx.data.error)) {
              _savePendingTransaction(dataFromStorage, {
                status: 'error',
                error: (tx.data && tx.data.error) ? tx.data.error : err
              }, function(err) {
                if (err) $log.debug(err);
                _updateTxs(coinbasePendingTransactions);
              });
              return;
            }
            _updateCoinbasePendingTransactions(dataFromStorage, tx.data);
            coinbasePendingTransactions.data[txId] = dataFromStorage;
            if (tx.data.type == 'send' && tx.data.status == 'completed' && tx.data.from) {
              root.sellPrice(accessToken, dataFromStorage.sell_price_currency, function(err, s) {
                if (err) {
                  _savePendingTransaction(dataFromStorage, {
                    status: 'error',
                    error: err
                  }, function(err) {
                    if (err) $log.debug(err);
                    _updateTxs(coinbasePendingTransactions);
                  });
                  return;
                }
                var newSellPrice = s.data.amount;
                var variance = Math.abs((newSellPrice - dataFromStorage.sell_price_amount) / dataFromStorage.sell_price_amount * 100);
                if (variance < dataFromStorage.price_sensitivity.value) {
                  _sellPending(dataFromStorage, accessToken, accountId, coinbasePendingTransactions);
                } else {
                  var error = {
                    errors: [{
                      message: 'Price falls over the selected percentage'
                    }]
                  };
                  _savePendingTransaction(dataFromStorage, {
                    status: 'error',
                    error: error
                  }, function(err) {
                    if (err) $log.debug(err);
                    _updateTxs(coinbasePendingTransactions);
                  });
                }
              });
            } else if (tx.data.type == 'buy' && tx.data.status == 'completed' && tx.data.buy) {
              _sendToWallet(dataFromStorage, accessToken, accountId, coinbasePendingTransactions);
            } else {
              _savePendingTransaction(dataFromStorage, {}, function(err) {
                if (err) $log.debug(err);
                _updateTxs(coinbasePendingTransactions);
              });
            }
          });
        });
      });
    });
  };

  root.updatePendingTransactions = lodash.throttle(function() {
    $log.debug('Updating coinbase pending transactions...');
    var pendingTransactions = {
      data: {}
    };
    root.getPendingTransactions(pendingTransactions);
  }, 20000);

  var _updateTxs = function(coinbasePendingTransactions) {
    storageService.getCoinbaseTxs(credentials.NETWORK, function(err, txs) {
      txs = txs ? JSON.parse(txs) : {};
      coinbasePendingTransactions.data = lodash.isEmpty(txs) ? null : txs;
    });
  };

  var _sellPending = function(tx, accessToken, accountId, coinbasePendingTransactions) {
    var data = tx.amount;
    data['payment_method'] = tx.payment_method || null;
    data['commit'] = true;
    root.sellRequest(accessToken, accountId, data, function(err, res) {
      if (err) {
        _savePendingTransaction(tx, {
          status: 'error',
          error: err
        }, function(err) {
          if (err) $log.debug(err);
          _updateTxs(coinbasePendingTransactions);
        });
      } else {
        if (res.data && !res.data.transaction) {
          _savePendingTransaction(tx, {
            status: 'error',
            error: err
          }, function(err) {
            if (err) $log.debug(err);
            _updateTxs(coinbasePendingTransactions);
          });
          return;
        }
        _savePendingTransaction(tx, {
          remove: true
        }, function(err) {
          root.getTransaction(accessToken, accountId, res.data.transaction.id, function(err, updatedTx) {
            _savePendingTransaction(updatedTx.data, {}, function(err) {
              if (err) $log.debug(err);
              _updateTxs(coinbasePendingTransactions);
            });
          });
        });
      }
    });
  };

  var _sendToWallet = function(tx, accessToken, accountId, coinbasePendingTransactions) {
    if (!tx) return;
    var desc = appConfigService.nameCase + ' Wallet';
    _getNetAmount(tx.amount.amount, function(err, amountBTCZ, feeBTCZ) {
      if (err) {
        _savePendingTransaction(tx, {
          status: 'error',
          error: err
        }, function(err) {
          if (err) $log.debug(err);
          _updateTxs(coinbasePendingTransactions);
        });
        return;
      }

      var data = {
        to: tx.toAddr,
        amount: amountBTCZ,
        currency: tx.amount.currency,
        description: desc,
        fee: feeBTCZ
      };
      root.sendTo(accessToken, accountId, data, function(err, res) {
        if (err) {
          _savePendingTransaction(tx, {
            status: 'error',
            error: err
          }, function(err) {
            if (err) $log.debug(err);
            _updateTxs(coinbasePendingTransactions);
          });
        } else {
          if (res.data && !res.data.id) {
            _savePendingTransaction(tx, {
              status: 'error',
              error: err
            }, function(err) {
              if (err) $log.debug(err);
              _updateTxs(coinbasePendingTransactions);
            });
            return;
          }
          root.getTransaction(accessToken, accountId, res.data.id, function(err, sendTx) {
            _savePendingTransaction(tx, {
              remove: true
            }, function(err) {
              _savePendingTransaction(sendTx.data, {}, function(err) {
                if (err) $log.debug(err);
                _updateTxs(coinbasePendingTransactions);
              });
            });
          });
        }
      });
    });
  };

  var _updateCoinbasePendingTransactions = function(obj /*, */ ) {
    for (var i = 1; i < arguments.length; i++) {
      for (var prop in arguments[i]) {
        var val = arguments[i][prop];
        if (typeof val == "object")
          _updateCoinbasePendingTransactions(obj[prop], val);
        else
          obj[prop] = val ? val : obj[prop];
      }
    }
    return obj;
  };

  root.logout = function(cb) {
    storageService.removeCoinbaseToken(credentials.NETWORK, function() {
      buyAndSellService.updateLink('coinbase', false);
      storageService.removeCoinbaseRefreshToken(credentials.NETWORK, function() {
        storageService.removeCoinbaseTxs(credentials.NETWORK, function() {
          return cb();
        });
      });
    });
  };

  var register = function() {

    root.isActive(function(err, isActive) {
      if (err) return;

      buyAndSellService.register({
        name: 'coinbase',
        logo: 'img/coinbase-logo.png',
        location: '33 Countries',
        sref: 'tabs.buyandsell.coinbase',
        configSref: 'tabs.preferences.coinbase',
        linked: isActive,
      });
    });
  };

  setCredentials();
  register();

  $rootScope.$on('bwsEvent', function(e, walletId, type, n) {
    if (type == 'NewBlock' && n && n.data && n.data.network == 'livenet') {
      root.isActive(function(err, isActive) {
        // Update Coinbase
        if (isActive)
          root.updatePendingTransactions();
      });
    }
  });
  return root;
});

'use strict';

angular.module('copayApp.services').factory('configService', function(storageService, lodash, $log, $timeout, $rootScope, platformInfo) {
  var root = {};

  var isWindowsPhoneApp = platformInfo.isCordova && platformInfo.isWP;

  var defaultConfig = {
    // wallet limits
    limits: {
      totalCopayers: 6,
      mPlusN: 100,
    },

    // Bitcore wallet service URL
    bws: {
      url: 'https://bws.bitcoinz.ph/bws/api',
    },

    download: {
      bitpay: {
        url: 'https://bitpay.com/wallet'
      },
      copay: {
        url: 'https://copay.io/#download'
      }
    },

    rateApp: {
      bitpay: {
        ios: 'http://itunes.apple.com/WebObjects/MZStore.woa/wa/viewContentsUserReviews?id=1149581638&pageNumber=0&sortOrdering=2&type=Purple+Software&mt=8',
        android: 'https://play.google.com/store/apps/details?id=com.bitpay.wallet',
        wp: ''
      },
      copay: {
        ios: 'http://itunes.apple.com/WebObjects/MZStore.woa/wa/viewContentsUserReviews?id=951330296&pageNumber=0&sortOrdering=2&type=Purple+Software&mt=8',
        android: 'https://play.google.com/store/apps/details?id=com.bitpay.copay',
        wp: ''
      }
    },
    // wallet default config
    wallet: {
      requiredCopayers: 2,
      totalCopayers: 3,
      spendUnconfirmed: false,
      reconnectDelay: 5000,
      idleDurationMin: 4,
      settings: {
        unitName: 'BTCZ',
        unitToSatoshi: 100000000,
        unitDecimals: 8,
        unitCode: 'btcz',
        alternativeName: 'US Dollar',
        alternativeIsoCode: 'USD',
      }
    },

    lock: {
      method: null,
      value: null,
      bannedUntil: null,
    },

    cashSupport: false,

    recentTransactions: {
      enabled: true,
    },

    hideNextSteps: {
      enabled: isWindowsPhoneApp ? true : false,
    },

    rates: {
      url: 'https://insight.bitpay.com:443/api/rates',
    },

    release: {
      url: 'https://api.github.com/repos/bitpay/copay/releases/latest'
    },

    pushNotificationsEnabled: true,

    confirmedTxsNotifications: {
      enabled: true,
    },

    emailNotifications: {
      enabled: false,
    },

    log: {
      filter: 'debug',
    },
  };

  var configCache = null;

  root.getSync = function() {
    if (!configCache)
      throw new Error('configService#getSync called when cache is not initialized');

    return configCache;
  };

  root._queue = [];
  root.whenAvailable = function(cb) {
    if (!configCache) {
      root._queue.push(cb);
      return;
    }
    return cb(configCache);
  };


  root.get = function(cb) {

    storageService.getConfig(function(err, localConfig) {
      if (localConfig) {
        configCache = JSON.parse(localConfig);

        //these ifs are to avoid migration problems
        if (!configCache.bws) {
          configCache.bws = defaultConfig.bws;
        }
        if (!configCache.wallet) {
          configCache.wallet = defaultConfig.wallet;
        }
        if (!configCache.wallet.settings.unitCode) {
          configCache.wallet.settings.unitCode = defaultConfig.wallet.settings.unitCode;
        }

        if (!configCache.hideNextSteps) {
          configCache.hideNextSteps = defaultConfig.hideNextSteps;
        }


        if (!configCache.cashSupport) {
          configCache.cashSupport = defaultConfig.cashSupport;
        }

        if (!configCache.recentTransactions) {
          configCache.recentTransactions = defaultConfig.recentTransactions;
        }
        if (!configCache.pushNotifications) {
          configCache.pushNotifications = defaultConfig.pushNotifications;
        }
        if (!configCache.bitpayAccount) {
          configCache.bitpayAccount = defaultConfig.bitpayAccount;
        }

        if (configCache.wallet.settings.unitCode == 'bit') {
          // Convert to BTCZ. Bits will be disabled
          configCache.wallet.settings.unitName = defaultConfig.wallet.settings.unitName;
          configCache.wallet.settings.unitToSatoshi = defaultConfig.wallet.settings.unitToSatoshi;
          configCache.wallet.settings.unitDecimals = defaultConfig.wallet.settings.unitDecimals;
          configCache.wallet.settings.unitCode = defaultConfig.wallet.settings.unitCode;
        }

      } else {
        configCache = lodash.clone(defaultConfig);
      };

      configCache.bwsFor = configCache.bwsFor || {};
      configCache.colorFor = configCache.colorFor || {};
      configCache.aliasFor = configCache.aliasFor || {};
      configCache.emailFor = configCache.emailFor || {};

      $log.debug('Preferences read:', configCache)

      lodash.each(root._queue, function(x) {
        $timeout(function() {
          return x(configCache);
        }, 1);
      });
      root._queue = [];

      return cb(err, configCache);
    });
  };

  root.set = function(newOpts, cb) {
    var config = lodash.cloneDeep(defaultConfig);
    storageService.getConfig(function(err, oldOpts) {
      oldOpts = oldOpts || {};

      if (lodash.isString(oldOpts)) {
        oldOpts = JSON.parse(oldOpts);
      }
      if (lodash.isString(config)) {
        config = JSON.parse(config);
      }
      if (lodash.isString(newOpts)) {
        newOpts = JSON.parse(newOpts);
      }

      lodash.merge(config, oldOpts, newOpts);
      configCache = config;

      $rootScope.$emit('Local/SettingsUpdated');

      storageService.storeConfig(JSON.stringify(config), cb);
    });
  };

  root.reset = function(cb) {
    configCache = lodash.clone(defaultConfig);
    storageService.removeConfig(cb);
  };

  root.getDefaults = function() {
    return lodash.clone(defaultConfig);
  };


  return root;
});

'use strict';

angular.module('copayApp.services').factory('derivationPathHelper', function(lodash) {
  var root = {};

  root.default = "m/44'/0'/0'";
  root.defaultTestnet = "m/44'/1'/0'";

  root.parse = function(str) {
    var arr = str.split('/');

    var ret = {};

    if (arr[0] != 'm')
      return false;

    switch (arr[1]) {
      case "44'":
        ret.derivationStrategy = 'BIP44';
        break;
      case "45'":
        return {
          derivationStrategy: 'BIP45',
          networkName: 'livenet',
          account: 0,
        }
        break;
      case "48'":
        ret.derivationStrategy = 'BIP48';
        break;
      default:
        return false;
    };

    switch (arr[2]) {
      case "0'":
        ret.networkName = 'livenet';
        break;
      case "1'":
        ret.networkName = 'testnet';
        break;
      default:
        return false;
    };

    var match = arr[3].match(/(\d+)'/);
    if (!match)
      return false;
    ret.account = +match[1]

    return ret;
  };

  return root;
});

'use strict';

angular.module('copayApp.services').factory('emailService', function($log, configService, lodash, walletService, profileService) {
  var root = {};

  root.updateEmail = function(opts) {
    opts = opts || {};
    if (!opts.email) return;

    var wallets = profileService.getWallets();

    configService.set({
      emailFor: null, // Backward compatibility
      emailNotifications: {
        enabled: opts.enabled,
        email: opts.enabled ? opts.email : null
      }
    }, function(err) {
      if (err) $log.warn(err);
      walletService.updateRemotePreferences(wallets);
    });
  };

  root.getEmailIfEnabled = function(config) {
    config = config || configService.getSync();
    
    if (config.emailNotifications) {
      if (!config.emailNotifications.enabled) return;

      if (config.emailNotifications.email) 
        return config.emailNotifications.email;
    }
    
    if (lodash.isEmpty(config.emailFor)) return;
    
    // Backward compatibility
    var emails = lodash.values(config.emailFor);
    for(var i = 0; i < emails.length; i++) {
      if (emails[i] !== null && typeof emails[i] !== 'undefined') {
        return emails[i];
      }
    }
  };

  root.init = function() {
    configService.whenAvailable(function(config) {

      if (config.emailNotifications && config.emailNotifications.enabled) {
        
        // If email already set
        if (config.emailNotifications.email) return;

        var currentEmail = root.getEmailIfEnabled(config);

        root.updateEmail({
          enabled: currentEmail ? true : false,
          email: currentEmail
        });
      }
    });
  };

  return root;
});

'use strict';

angular.module('copayApp.services').service('externalLinkService', function(platformInfo, nodeWebkitService, popupService, gettextCatalog, $window, $log, $timeout) {

  var _restoreHandleOpenURL = function(old) {
    $timeout(function() {
      $window.handleOpenURL = old;
    }, 500);
  };

  this.open = function(url, optIn, title, message, okText, cancelText) {
    var old = $window.handleOpenURL;

    $window.handleOpenURL = function(url) {
      // Ignore external URLs
      $log.debug('Skip: ' + url);
    };

    if (platformInfo.isNW) {
      nodeWebkitService.openExternalLink(url);
      _restoreHandleOpenURL(old);
    } else {
      if (optIn) {
        var openBrowser = function(res) {
          if (res) window.open(url, '_system');
          _restoreHandleOpenURL(old);
        };
        popupService.showConfirm(title, message, okText, cancelText, openBrowser);
      } else {
        window.open(url, '_system');
        _restoreHandleOpenURL(old);
      }
    }
  };

});

'use strict';
angular.module('copayApp.services').factory('feedbackService', function($http, $log, $httpParamSerializer, configService) {
  var root = {};
  var URL = "https://script.google.com/macros/s/AKfycbybtvNSQKUfgzgXcj3jYLlvCKrcBoktjiJ1V8_cwd2yVkpUBGe3/exec";

  root.send = function(dataSrc, cb) {
    $http(_post(dataSrc)).then(function() {
      $log.info("SUCCESS: Feedback sent");
      return cb();
    }, function(err) {
      $log.info("ERROR: Feedback sent anyway.");
      return cb(err);
    });
  };

  var _post = function(dataSrc) {
    return {
      method: 'POST',
      url: URL,
      headers: {
        'content-type': 'application/x-www-form-urlencoded; charset=UTF-8'
      },
      data: $httpParamSerializer(dataSrc)
    };
  };

  root.isVersionUpdated = function(currentVersion, savedVersion) {

    if (!verifyTagFormat(currentVersion))
      return 'Cannot verify the format of version tag: ' + currentVersion;
    if (!verifyTagFormat(savedVersion))
      return 'Cannot verify the format of the saved version tag: ' + savedVersion;

    var current = formatTagNumber(currentVersion);
    var saved = formatTagNumber(savedVersion);
    if (saved.major > current.major || (saved.major == current.major && saved.minor > current.minor))
      return false;

    return true;

    function verifyTagFormat(tag) {
      var regex = /^v?\d+\.\d+\.\d+$/i;
      return regex.exec(tag);
    };

    function formatTagNumber(tag) {
      var formattedNumber = tag.replace(/^v/i, '').split('.');
      return {
        major: +formattedNumber[0],
        minor: +formattedNumber[1],
        patch: +formattedNumber[2]
      };
    };

  };

  return root;
});

'use strict';

angular.module('copayApp.services').factory('feeService', function($log, $timeout, $stateParams, bwcService, walletService, configService, gettext, lodash, txFormatService, gettextCatalog) {
  var root = {};

  var CACHE_TIME_TS = 60; // 1 min

  // Constant fee options to translate
  root.feeOpts = {
    urgent: gettext('Urgent'),
    priority: gettext('Priority'),
    normal: gettext('Normal'),
    economy: gettext('Economy'),
    superEconomy: gettext('Super Economy'),
    custom: gettext('Custom')
  };

  var cache = {
    updateTs: 0,
    coin: ''
  };

  root.getCurrentFeeLevel = function() {
    return configService.getSync().wallet.settings.feeLevel || 'normal';
  };


  root.getFeeRate = function(coin, network, feeLevel, cb) {

    if (feeLevel == 'custom') return cb();

    network = network || 'livenet';

    root.getFeeLevels(coin, function(err, levels, fromCache) {
      if (err) return cb(err);

      var feeLevelRate = lodash.find(levels[network], {
        level: feeLevel
      });

      if (!feeLevelRate || !feeLevelRate.feePerKb) {
        return cb({
          message: gettextCatalog.getString("Could not get dynamic fee for level: {{feeLevel}}", {
            feeLevel: feeLevel
          })
        });
      }

      var feeRate = feeLevelRate.feePerKb;

      if (!fromCache) $log.debug('Dynamic fee: ' + feeLevel + '/' + network + ' ' + (feeLevelRate.feePerKb / 1000).toFixed() + ' SAT/B');

      return cb(null, feeRate);
    });
  };

  root.getCurrentFeeRate = function(coin, network, cb) {
    return root.getFeeRate(coin, network, root.getCurrentFeeLevel(), cb);
  };

  root.getFeeLevels = function(coin, cb) {
    coin = coin || 'btcz';

    if (cache.coin == coin && cache.updateTs > Date.now() - CACHE_TIME_TS * 1000) {
      return cb(null, cache.data, true);
    }

    var walletClient = bwcService.getClient();

    walletClient.getFeeLevels(coin, 'livenet', function(errLivenet, levelsLivenet) {
      walletClient.getFeeLevels('btcz', 'testnet', function(errTestnet, levelsTestnet) {
        if (errLivenet || errTestnet) {
          return cb(gettextCatalog.getString('Could not get dynamic fee'));
        }

        cache.updateTs = Date.now();
        cache.coin = coin;
        cache.data = {
          'livenet': levelsLivenet,
          'testnet': levelsTestnet
        };

        return cb(null, cache.data);
      });
    });
  };


  return root;
});

'use strict';

angular.module('copayApp.services')
  .factory('fileStorageService', function(lodash, $log) {
    var root = {},
      _fs, _dir;

    root.init = function(cb) {
      if (_dir) return cb(null, _fs, _dir);

      function onFileSystemSuccess(fileSystem) {
        console.log('File system started: ', fileSystem.name, fileSystem.root.name);
        _fs = fileSystem;
        root.getDir(function(err, newDir) {
          if (err || !newDir.nativeURL) return cb(err);
          _dir = newDir
          $log.debug("Got main dir:", _dir.nativeURL);
          return cb(null, _fs, _dir);
        });
      }

      function fail(evt) {
        var msg = 'Could not init file system: ' + evt.target.error.code;
        console.log(msg);
        return cb(msg);
      };

      window.requestFileSystem(LocalFileSystem.PERSISTENT, 0, onFileSystemSuccess, fail);
    };

    root.get = function(k, cb) {
      root.init(function(err, fs, dir) {
        if (err) return cb(err);
        dir.getFile(k, {
          create: false,
        }, function(fileEntry) {
          if (!fileEntry) return cb();
          fileEntry.file(function(file) {
            var reader = new FileReader();

            reader.onloadend = function(e) {
              return cb(null, this.result)
            }

            reader.readAsText(file);
          });
        }, function(err) {
          // Not found
          if (err.code == 1) return cb();
          else return cb(err);
        });
      })
    };

    var writelock = {};

    root.set = function(k, v, cb, delay) {

      delay = delay || 100;

      if (writelock[k]) {
        return setTimeout(function() {
          console.log('## Writelock for:' + k + ' Retrying in ' + delay);
          return root.set(k, v, cb, delay + 100);
        }, delay);
      }

      writelock[k] = true;
      root.init(function(err, fs, dir) {
        if (err) {
          writelock[k] = false;
          return cb(err);
        }
        dir.getFile(k, {
          create: true,
        }, function(fileEntry) {
          // Create a FileWriter object for our FileEntry (log.txt).
          fileEntry.createWriter(function(fileWriter) {

            fileWriter.onwriteend = function(e) {
              console.log('Write completed:' + k);
              writelock[k] = false;
              return cb();
            };

            fileWriter.onerror = function(e) {
              var err = e.error ? e.error : JSON.stringify(e);
              console.log('Write failed: ' + err);
              writelock[k] = false;
              return cb('Fail to write:' + err);
            };

            if (lodash.isObject(v))
              v = JSON.stringify(v);

            if (v && !lodash.isString(v)) {
              v = v.toString();
            }

            $log.debug('Writing:', k, v);
            fileWriter.write(v);

          }, cb);
        });
      });
    };


    // See https://github.com/apache/cordova-plugin-file/#where-to-store-files
    root.getDir = function(cb) {
      if (!cordova.file) {
        return cb('Could not write on device storage');
      }

      var url = cordova.file.dataDirectory;
      // This could be needed for windows
      // if (cordova.file === undefined) {
      //   url = 'ms-appdata:///local/';
      window.resolveLocalFileSystemURL(url, function(dir) {
        return cb(null, dir);
      }, function(err) {
        $log.warn(err);
        return cb(err || 'Could not resolve filesystem:' + url);
      });
    };

    root.remove = function(k, cb) {
      root.init(function(err, fs, dir) {
        if (err) return cb(err);
        dir.getFile(k, {
          create: false,
        }, function(fileEntry) {
          // Create a FileWriter object for our FileEntry (log.txt).
          fileEntry.remove(function() {
            console.log('File removed.');
            return cb();
          }, cb);
        }, cb);
      });
    };

    /**
     * Same as setItem, but fails if an item already exists
     */
    root.create = function(name, value, callback) {
      root.get(name,
        function(err, data) {
          if (data) {
            return callback('EEXISTS');
          } else {
            return root.set(name, value, callback);
          }
        });
    };

    return root;
  });

'use strict';

angular.module('copayApp.services').factory('fingerprintService', function($log, gettextCatalog, configService, platformInfo) {
  var root = {};

  var _isAvailable = false;

  if (platformInfo.isCordova && !platformInfo.isWP) {
    window.plugins.touchid = window.plugins.touchid || {};
    window.plugins.touchid.isAvailable(
      function(msg) {
        _isAvailable = 'IOS';
      },
      function(msg) {
        FingerprintAuth.isAvailable(function(result) {

          if (result.isAvailable)
            _isAvailable = 'ANDROID';

        }, function() {
          _isAvailable = false;
        });
      });
  };

  var requestFinger = function(cb) {
    try {
      FingerprintAuth.show({
          clientId: 'Copay',
          clientSecret: 'hVu1NvCZOyUuGgr46bFL',
        },
        function(result) {
          if (result.withFingerprint) {
            $log.debug('Finger OK');
            return cb();
          } else if (result.withPassword) {
            $log.debug("Finger: Authenticated with backup password");
            return cb();
          }
        },
        function(msg) {
          $log.debug('Finger Failed:' + JSON.stringify(msg));
          return cb(gettextCatalog.getString('Finger Scan Failed'));
        }
      );
    } catch (e) {
      $log.warn('Finger Scan Failed:' + JSON.stringify(e));
      return cb(gettextCatalog.getString('Finger Scan Failed'));
    };
  };


  var requestTouchId = function(cb) {
    try {
      window.plugins.touchid.verifyFingerprint(
        gettextCatalog.getString('Scan your fingerprint please'),
        function(msg) {
          $log.debug('Touch ID OK');
          return cb();
        },
        function(msg) {
          $log.debug('Touch ID Failed:' + JSON.stringify(msg));
          return cb(gettextCatalog.getString('Touch ID Failed'));
        }
      );
    } catch (e) {
      $log.debug('Touch ID Failed:' + JSON.stringify(e));
      return cb(gettextCatalog.getString('Touch ID Failed'));
    };
  };

  var isNeeded = function(client) {
    if (!_isAvailable) return false;
    if (client === 'unlockingApp') return true;

    var config = configService.getSync();
    config.touchIdFor = config.touchIdFor || {};

    return config.touchIdFor[client.credentials.walletId];
  };

  root.isAvailable = function(client) {
    return _isAvailable;
  };

  root.check = function(client, cb) {
    if (isNeeded(client)) {
      $log.debug('FingerPrint Service:', _isAvailable);
      if (_isAvailable == 'IOS')
        return requestTouchId(cb);
      else
        return requestFinger(cb);
    } else {
      return cb();
    }
  };

  return root;
});

'use strict';

angular.module('copayApp.services').factory('glideraService', function($http, $log, $window, $filter, platformInfo, storageService, buyAndSellService, lodash, configService, txFormatService) {
  var root = {};
  var credentials = {};
  var isCordova = platformInfo.isCordova;
  var isWindowsPhoneApp = platformInfo.isCordova && platformInfo.isWP;

  var setCredentials = function() {
    if (!$window.externalServices || !$window.externalServices.glidera) {
      return;
    }

    var glidera = $window.externalServices.glidera;

    /*
     * Development: 'testnet'
     * Production: 'livenet'
     */
    credentials.NETWORK = 'livenet';
    //credentials.NETWORK = 'testnet';

    if (credentials.NETWORK == 'testnet') {
      credentials.HOST = glidera.sandbox.host;
      if (isCordova) {
        credentials.REDIRECT_URI = glidera.sandbox.mobile.redirect_uri;
        credentials.CLIENT_ID = glidera.sandbox.mobile.client_id;
        credentials.CLIENT_SECRET = glidera.sandbox.mobile.client_secret;
      } else {
        credentials.REDIRECT_URI = glidera.sandbox.desktop.redirect_uri;
        credentials.CLIENT_ID = glidera.sandbox.desktop.client_id;
        credentials.CLIENT_SECRET = glidera.sandbox.desktop.client_secret;
      }
    } else {
      credentials.HOST = glidera.production.host;
      if (isCordova) {
        credentials.REDIRECT_URI = glidera.production.mobile.redirect_uri;
        credentials.CLIENT_ID = glidera.production.mobile.client_id;
        credentials.CLIENT_SECRET = glidera.production.mobile.client_secret;
      } else {
        credentials.REDIRECT_URI = glidera.production.desktop.redirect_uri;
        credentials.CLIENT_ID = glidera.production.desktop.client_id;
        credentials.CLIENT_SECRET = glidera.production.desktop.client_secret;
      }
    };
  };

  root.getNetwork = function() {
    return credentials.NETWORK;
  };

  root.getCurrency = function() {
    return 'USD';
  };

  root.getSignupUrl = function() {
    return credentials.HOST + '/register';
  }

  root.getSupportUrl = function() {
    return 'https://twitter.com/GlideraInc';
  }

  root.getOauthCodeUrl = function() {
    return credentials.HOST + '/oauth2/auth?response_type=code&client_id=' + credentials.CLIENT_ID + '&redirect_uri=' + credentials.REDIRECT_URI;
  };

  root.remove = function(cb) {
    storageService.removeGlideraToken(credentials.NETWORK, function() {
      storageService.removeGlideraPermissions(credentials.NETWORK, function() {
        storageService.removeGlideraStatus(credentials.NETWORK, function() {
          storageService.removeGlideraTxs(credentials.NETWORK, function() {
            buyAndSellService.updateLink('glidera', false);
            return cb();
          });
        });
      });
    });
  };

  root.getToken = function(code, cb) {
    var req = {
      method: 'POST',
      url: credentials.HOST + '/api/v1/oauth/token',
      headers: {
        'Content-Type': 'application/json',
        'Accept': 'application/json'
      },
      data: {
        grant_type: 'authorization_code',
        code: code,
        client_id: credentials.CLIENT_ID,
        client_secret: credentials.CLIENT_SECRET,
        redirect_uri: credentials.REDIRECT_URI
      }
    };

    $http(req).then(function(data) {
      $log.info('Glidera Authorization Access Token: SUCCESS');
      return cb(null, data.data);
    }, function(data) {
      $log.error('Glidera Authorization Access Token: ERROR ' + data.statusText);
      var message = data.data && data.data.message ? data.data.message : data.statusText;
      return cb(message);
    });
  };

  root.authorize = function(code, cb) {
    root.getToken(code, function(err, data) {
      if (err) return cb(err);
      if (data && !data.access_token) return cb('No access token');
      var accessToken = data.access_token;
      root.getAccessTokenPermissions(accessToken, function(err, p) {
        if (err) return cb(err);
        root.getStatus(accessToken, function(err, status) {
          if (err) $log.error(err);
          storageService.setGlideraToken(credentials.NETWORK, accessToken, function() {
            storageService.setGlideraPermissions(credentials.NETWORK, JSON.stringify(p), function() {
              storageService.setGlideraStatus(credentials.NETWORK, JSON.stringify(status), function() {
                return cb(null, {
                  token: accessToken,
                  permissions: p,
                  status: status
                });
              });
            });
          });
        });
      });
    });
  };

  var _get = function(endpoint, token) {
    return {
      method: 'GET',
      url: credentials.HOST + '/api/v1' + endpoint,
      headers: {
        'Content-Type': 'application/json',
        'Accept': 'application/json',
        'Authorization': 'Bearer ' + token
      }
    };
  };

  root.getAccessTokenPermissions = function(token, cb) {
    if (!token) return cb('Invalid Token');
    $http(_get('/oauth/token', token)).then(function(data) {
      $log.info('Glidera Access Token Permissions: SUCCESS');
      return cb(null, data.data);
    }, function(data) {
      var message = data.data && data.data.message ? data.data.message : data.statusText;
      $log.error('Glidera Access Token Permissions: ERROR ' + message);
      return cb(message);
    });
  };

  root.getEmail = function(token, cb) {
    if (!token) return cb('Invalid Token');
    $http(_get('/user/email', token)).then(function(data) {
      $log.info('Glidera Get Email: SUCCESS');
      return cb(null, data.data);
    }, function(data) {
      $log.error('Glidera Get Email: ERROR ' + data.statusText);
      var message = data.data && data.data.message ? data.data.message : data.statusText;
      return cb(message);
    });
  };

  root.getPersonalInfo = function(token, cb) {
    if (!token) return cb('Invalid Token');
    $http(_get('/user/personalinfo', token)).then(function(data) {
      $log.info('Glidera Get Personal Info: SUCCESS');
      return cb(null, data.data);
    }, function(data) {
      $log.error('Glidera Get Personal Info: ERROR ' + data.statusText);
      var message = data.data && data.data.message ? data.data.message : data.statusText;
      return cb(message);
    });
  };

  root.getStatus = function(token, cb) {
    if (!token) return cb('Invalid Token');
    $http(_get('/user/status', token)).then(function(data) {
      $log.info('Glidera User Status: SUCCESS');
      return cb(null, data.data);
    }, function(data) {
      $log.error('Glidera User Status: ERROR ' + data.statusText);
      var message = data.data && data.data.message ? data.data.message : data.statusText;
      return cb(message);
    });
  };

  root.getLimits = function(token, cb) {
    if (!token) return cb('Invalid Token');
    $http(_get('/user/limits', token)).then(function(data) {
      $log.info('Glidera Transaction Limits: SUCCESS');
      return cb(null, data.data);
    }, function(data) {
      $log.error('Glidera Transaction Limits: ERROR ' + data.statusText);
      var message = data.data && data.data.message ? data.data.message : data.statusText;
      return cb(message);
    });
  };

  root.getTransactions = function(token, cb) {
    if (!token) return cb('Invalid Token');
    $http(_get('/transaction', token)).then(function(data) {
      $log.info('Glidera Transactions: SUCCESS');
      return cb(null, data.data.transactions);
    }, function(data) {
      $log.error('Glidera Transactions: ERROR ' + data.statusText);
      var message = data.data && data.data.message ? data.data.message : data.statusText;
      return cb(message);
    });
  };

  root.getTransaction = function(token, txid, cb) {
    if (!token) return cb('Invalid Token');
    if (!txid) return cb('TxId required');
    $http(_get('/transaction/' + txid, token)).then(function(data) {
      $log.info('Glidera Transaction: SUCCESS');
      return cb(null, data.data);
    }, function(data) {
      $log.error('Glidera Transaction: ERROR ' + data.statusText);
      var message = data.data && data.data.message ? data.data.message : data.statusText;
      return cb(message);
    });
  };

  root.getSellAddress = function(token, cb) {
    if (!token) return cb('Invalid Token');
    $http(_get('/user/create_sell_address', token)).then(function(data) {
      $log.info('Glidera Create Sell Address: SUCCESS');
      return cb(null, data.data.sellAddress);
    }, function(data) {
      $log.error('Glidera Create Sell Address: ERROR ' + data.statusText);
      var message = data.data && data.data.message ? data.data.message : data.statusText;
      return cb(message);
    });
  };

  root.get2faCode = function(token, cb) {
    if (!token) return cb('Invalid Token');
    $http(_get('/authentication/get2faCode', token)).then(function(data) {
      $log.info('Glidera 2FA code: SUCCESS');
      return cb(null, data.data);
    }, function(data) {
      $log.error('Glidera 2FA code: ERROR ' + data.statusText);
      var message = data.data && data.data.message ? data.data.message : data.statusText;
      return cb(message);
    });
  };

  var _post = function(endpoint, token, twoFaCode, data) {
    return {
      method: 'POST',
      url: credentials.HOST + '/api/v1' + endpoint,
      headers: {
        'Content-Type': 'application/json',
        'Accept': 'application/json',
        'Authorization': 'Bearer ' + token,
        'X-2FA-CODE': twoFaCode
      },
      data: data
    };
  };

  root.sellPrice = function(token, price, cb) {
    var data = {
      qty: price.qty,
      fiat: price.fiat
    };
    $http(_post('/prices/sell', token, null, data)).then(function(data) {
      $log.info('Glidera Sell Price: SUCCESS');
      return cb(null, data.data);
    }, function(data) {
      $log.error('Glidera Sell Price: ERROR ' + data.statusText);
      var message = data.data && data.data.message ? data.data.message : data.statusText;
      return cb(message);
    });
  };

  root.sell = function(token, twoFaCode, data, cb) {
    var data = {
      refundAddress: data.refundAddress,
      signedTransaction: data.signedTransaction,
      priceUuid: data.priceUuid,
      useCurrentPrice: data.useCurrentPrice,
      ip: data.ip
    };
    $http(_post('/sell', token, twoFaCode, data)).then(function(data) {
      $log.info('Glidera Sell: SUCCESS');
      return cb(null, data.data);
    }, function(data) {
      $log.error('Glidera Sell Request: ERROR ' + data.statusText);
      var message = data.data && data.data.message ? data.data.message : data.statusText;
      return cb(message);
    });
  };

  root.buyPrice = function(token, price, cb) {
    var data = {
      qty: price.qty,
      fiat: price.fiat
    };
    $http(_post('/prices/buy', token, null, data)).then(function(data) {
      $log.info('Glidera Buy Price: SUCCESS');
      return cb(null, data.data);
    }, function(data) {
      $log.error('Glidera Buy Price: ERROR ' + data.statusText);
      var message = data.data && data.data.message ? data.data.message : data.statusText;
      return cb(message);
    });
  };

  root.buy = function(token, twoFaCode, data, cb) {
    var data = {
      destinationAddress: data.destinationAddress,
      qty: data.qty,
      priceUuid: data.priceUuid,
      useCurrentPrice: data.useCurrentPrice,
      ip: data.ip
    };
    $http(_post('/buy', token, twoFaCode, data)).then(function(data) {
      $log.info('Glidera Buy: SUCCESS');
      return cb(null, data.data);
    }, function(data) {
      $log.error('Glidera Buy Request: ERROR ' + data.statusText);
      var message = data.data && data.data.message ? data.data.message : data.statusText;
      return cb(message);
    });
  };

  var getPermissions = function(accessToken, network, force, cb) {
    storageService.getGlideraPermissions(network, function(err, permissions) {
      if (lodash.isString(permissions)) permissions = JSON.parse(permissions);
      if (force || lodash.isEmpty(permissions)) {
        root.getAccessTokenPermissions(accessToken, function(err, p) {
          if (err) {
            // Return error and remove token
            root.remove(function() {
              return cb(err);
            });
          } else {
            // Return permissions and store
            storageService.setGlideraPermissions(network, JSON.stringify(p), function() {
              return cb(null, p);
            });
          }
        });
      } else {
        return cb(null, permissions);
      }
    });
  };

  root.init = function(cb) {
    if (lodash.isEmpty(credentials.CLIENT_ID)) {
      return cb('Glidera is Disabled');
    }
    $log.debug('Trying to initialise Glidera...');

    storageService.getGlideraToken(credentials.NETWORK, function(err, accessToken) {
      if (lodash.isEmpty(accessToken)) return cb();

      getPermissions(accessToken, credentials.NETWORK, true, function(err, permissions) {
        if (err) return cb(err);

        storageService.getGlideraStatus(credentials.NETWORK, function(err, status) {
          if (lodash.isString(status)) status = JSON.parse(status);
          storageService.getGlideraTxs(credentials.NETWORK, function(err, txs) {
            if (lodash.isString(txs)) txs = JSON.parse(txs);
            buyAndSellService.updateLink('glidera', true);
            return cb(null, {
              token: accessToken,
              permissions: permissions,
              status: status,
              txs: txs
            });
          });
        });
      });
    });
  };

  root.updateStatus = function(data) {
    storageService.getGlideraToken(credentials.NETWORK, function(err, accessToken) {
      if (err) return;

      getPermissions(accessToken, credentials.NETWORK, false, function(err, permissions) {
        if (err) return;
        data.permissions = permissions;

        data.price = {};
        root.buyPrice(accessToken, {
          qty: 1
        }, function(err, buy) {
          if (err) return;
          data.price['buy'] = buy.price;
        });
        root.sellPrice(accessToken, {
          qty: 1
        }, function(err, sell) {
          if (err) return;
          data.price['sell'] = sell.price;
        });

        root.getStatus(accessToken, function(err, status) {
          if (err) return;
          data.status = status;
          storageService.setGlideraStatus(credentials.NETWORK, JSON.stringify(status), function() {});
        });

        root.getLimits(accessToken, function(err, limits) {
          data.limits = limits;
        });

        if (permissions.transaction_history) {
          root.getTransactions(accessToken, function(err, txs) {
            if (err) return;
            storageService.setGlideraTxs(credentials.NETWORK, JSON.stringify(txs), function() {});
            data.txs = txs;
          });
        }

        if (permissions.view_email_address) {
          root.getEmail(accessToken, function(err, email) {
            if (err) return;
            data.email = email;
          });
        }
        if (permissions.personal_info) {
          root.getPersonalInfo(accessToken, function(err, info) {
            if (err) return;
            data.personalInfo = info;
          });
        }
      });
    });
  };

  var register = function() {
    if (isWindowsPhoneApp) return;

    storageService.getGlideraToken(credentials.NETWORK, function(err, token) {
      if (err) return cb(err);

      buyAndSellService.register({
        name: 'glidera',
        logo: 'img/glidera-logo.png',
        location: 'US Only',
        sref: 'tabs.buyandsell.glidera',
        configSref: 'tabs.preferences.glidera',
        linked: !!token,
      });
    });
  };

  setCredentials();
  register();
  return root;
});

'use strict';
var logs = [];
angular.module('copayApp.services')
  .factory('historicLog', function historicLog(lodash) {
    var root = {};

    var levels = [
      { level: 'error', weight: 0, label: 'Error'},
      { level: 'warn',  weight: 1, label: 'Warning'},
      { level: 'info',  weight: 2, label: 'Info', default: true},
      { level: 'debug', weight: 3, label: 'Debug'}
    ];

    // Create an array of level weights for performant filtering.
    var weight = {};
    for (var i = 0; i < levels.length; i++) {
      weight[levels[i].level] = levels[i].weight;
    }

    root.getLevels = function() {
      return levels;
    };

    root.getLevel = function(level) {
      return lodash.find(levels, function(l) {
        return l.level == level;
      });
    };

    root.getDefaultLevel = function() {
      return lodash.find(levels, function(l) {
        return l.default;
      });
    };

    root.add = function(level, msg) {
      msg = msg.replace('/xpriv.*/', 'xpriv[Hidden]');
      logs.push({
        timestamp: new Date().toISOString(),
        level: level,
        msg: msg,
      });
    };

    root.get = function(filterWeight) {
      var filteredLogs = logs;
      if (filterWeight != undefined) {
        filteredLogs = lodash.filter(logs, function(l) {
          return weight[l.level] <= filterWeight;
        });
      }
      return filteredLogs;
    };

    return root;
  });

 'use strict';
 angular.module('copayApp.services').factory('homeIntegrationsService', function(lodash, configService, $log) {
   var root = {};
   var services = [];

   root.register = function(serviceInfo) {
     // Check if already exists
     if (lodash.find(services, { 'name': serviceInfo.name })) return;
     $log.info('Adding home Integrations entry:' + serviceInfo.name);
     services.push(serviceInfo);
   };

   root.unregister = function(serviceName) {
     services = lodash.filter(services, function(x) {
       return x.name != serviceName
     });
   };

   root.get = function() {
     return services;
   };

   return root;

 });

'use strict';

angular.module('copayApp.services')
  .factory('hwWallet', function($log, bwcService) {
    var root = {};

    // Ledger magic number to get xPub without user confirmation
    root.ENTROPY_INDEX_PATH = "0xb11e/";
    root.M = 'm/';
    root.UNISIG_ROOTPATH = 44;
    root.MULTISIG_ROOTPATH = 48;
    root.LIVENET_PATH = 0;
    root.TESTNET_PATH = 1;

    root._err = function(data) {
      var msg = data.error || data.message || 'unknown';
      return msg;
    };


    root.getRootPath = function(device, isMultisig, account) {
      var path;
      if (isMultisig) {
        path = root.MULTISIG_ROOTPATH;
      } else {
        if (device == 'ledger' && account > 0) {
          path = root.MULTISIG_ROOTPATH;
        } else {
          path = root.UNISIG_ROOTPATH;
        }
      }
      if (device == 'intelTEE') {
        path = root.M + path;
      }
      return path;
    };

    root.getAddressPath = function(device, isMultisig, account, network) {
      network = network || 'livenet';
      var networkPath = root.LIVENET_PATH;
      if (network == 'testnet') {
        networkPath = root.TESTNET_PATH;
      }
      return root.getRootPath(device, isMultisig, account) + "'/" + networkPath + "'/" + account + "'";
     };

    root.getEntropyPath = function(device, isMultisig, account) {
      var path = root.ENTROPY_INDEX_PATH;
      if (isMultisig) {
        path = path + "48'/"
      } else {
        path = path + "44'/"
      }

      // Old ledger wallet compat
      if (device == 'ledger' && account == 0) {
        return path + "0'/";
      }

      if (device == 'intelTEE') {
        path = root.M + path;
      }

      return path + account + "'";
    };

    root.pubKeyToEntropySource = function(xPubKey) {
      var b = bwcService.getBitcore();
      var x = b.HDPublicKey(xPubKey);
      return x.publicKey.toString();
    };

    return root;
  });

'use strict';

angular.module('copayApp.services').factory('incomingData', function($log, $state, $timeout, $ionicHistory, bitcore, bitcoreCash, $rootScope, payproService, scannerService, appConfigService, popupService, gettextCatalog) {

  var root = {};

  root.showMenu = function(data) {
    $rootScope.$broadcast('incomingDataMenu.showMenu', data);
  };

  root.redir = function(data) {
    $log.debug('Processing incoming data: ' + data);

    function sanitizeUri(data) {
      // Fixes when a region uses comma to separate decimals
      var regex = /[\?\&]amount=(\d+([\,\.]\d+)?)/i;
      var match = regex.exec(data);
      if (!match || match.length === 0) {
        return data;
      }
      var value = match[0].replace(',', '.');
      var newUri = data.replace(regex, value);

      // mobile devices, uris like copay://glidera
      newUri.replace('://', ':');

      return newUri;
    }

    function getParameterByName(name, url) {
      if (!url) return;
      name = name.replace(/[\[\]]/g, "\\$&");
      var regex = new RegExp("[?&]" + name + "(=([^&#]*)|&|#|$)"),
        results = regex.exec(url);
      if (!results) return null;
      if (!results[2]) return '';
      return decodeURIComponent(results[2].replace(/\+/g, " "));
    }

    function checkPrivateKey(privateKey) {
      try {
        new bitcore.PrivateKey(privateKey, 'livenet');
      } catch (err) {
        return false;
      }
      return true;
    }

    function goSend(addr, amount, message, coin) {
      $state.go('tabs.send', {}, {
        'reload': true,
        'notify': $state.current.name == 'tabs.send' ? false : true
      });
      // Timeout is required to enable the "Back" button
      $timeout(function() {
        if (amount) {
          $state.transitionTo('tabs.send.confirm', {
            toAmount: amount,
            toAddress: addr,
            description: message,
            coin: coin
          });
        } else {
          $state.transitionTo('tabs.send.amount', {
            toAddress: addr,
            coin: coin
          });
        }
      }, 100);
    }
    // data extensions for Payment Protocol with non-backwards-compatible request
    if ((/^bitcoin(cash)?:\?r=[\w+]/).exec(data)) {
      data = decodeURIComponent(data.replace(/bitcoin(cash)?:\?r=/, ''));
      $state.go('tabs.send', {}, {
        'reload': true,
        'notify': $state.current.name == 'tabs.send' ? false : true
      }).then(function() {
        $state.transitionTo('tabs.send.confirm', {
          paypro: data
        });
      });
      return true;
    }

    data = sanitizeUri(data);

    // Bitcoin  URL
    if (bitcore.URI.isValid(data)) {
        var coin = 'btcz';
        var parsed = new bitcore.URI(data);

        var addr = parsed.address ? parsed.address.toString() : '';
        var message = parsed.message;

        var amount = parsed.amount ? parsed.amount : '';

        if (parsed.r) {
          payproService.getPayProDetails(parsed.r, function(err, details) {
            if (err) {
              if (addr && amount) goSend(addr, amount, message, coin);
              else popupService.showAlert(gettextCatalog.getString('Error'), err);
            } else handlePayPro(details);
          });
        } else {
          goSend(addr, amount, message, coin);
        }
        return true;
    // Cash URI
    } else if (bitcoreCash.URI.isValid(data)) {
        var coin = 'bch';
        var parsed = new bitcoreCash.URI(data);

        var addr = parsed.address ? parsed.address.toString() : '';
        var message = parsed.message;

        var amount = parsed.amount ? parsed.amount : '';

        // paypro not yet supported on cash
        if (parsed.r) {
          payproService.getPayProDetails(parsed.r, function(err, details) {
            if (err) {
              if (addr && amount) 
                goSend(addr, amount, message, coin);
              else 
                popupService.showAlert(gettextCatalog.getString('Error'), err);
            } 
            handlePayPro(details, coin);
          });
        } else {
          goSend(addr, amount, message, coin);
        }
        return true;

    // Cash URI with bitcoin core address version number?
    } else if (bitcore.URI.isValid(data.replace(/^bitcoincash:/,'bitcoin:'))) {
        $log.debug('Handling bitcoincash URI with legacy address');
        var coin = 'bch';
        var parsed = new bitcore.URI(data.replace(/^bitcoincash:/,'bitcoin:'));

        var oldAddr = parsed.address ? parsed.address.toString() : '';
        if (!oldAddr) return false;

        var addr = '';

        var a = bitcore.Address(oldAddr).toObject();
        addr = bitcoreCash.Address.fromObject(a).toString();

        // Translate address
        $log.debug('address transalated to:' + addr);
        popupService.showConfirm(
          gettextCatalog.getString('Bitcoin cash Payment'), 
          gettextCatalog.getString('Payment address was translated to new Bitcoin Cash address format: ' + addr),
          gettextCatalog.getString('OK'), 
          gettextCatalog.getString('Cancel'), 
          function(ret) {
            if (!ret) return false;

            var message = parsed.message;
            var amount = parsed.amount ? parsed.amount : '';

            // paypro not yet supported on cash
            if (parsed.r) {
              payproService.getPayProDetails(parsed.r, function(err, details) {
                if (err) {
                  if (addr && amount) 
                    goSend(addr, amount, message, coin);
                  else 
                    popupService.showAlert(gettextCatalog.getString('Error'), err);
                } 
                handlePayPro(details, coin);
              });
            } else {
              goSend(addr, amount, message, coin);
            }
          }
        );
      return true;
      // Plain URL
    } else if (/^https?:\/\//.test(data)) {

      payproService.getPayProDetails(data, function(err, details) {
        if (err) {
          root.showMenu({
            data: data,
            type: 'url'
          });
          return;
        }
        handlePayPro(details);
        return true;
      });
      // Plain Address
    } else if (bitcore.Address.isValid(data, 'livenet') || bitcore.Address.isValid(data, 'testnet')) {
      if ($state.includes('tabs.scan')) {
        root.showMenu({
          data: data,
          type: 'bitcoinAddress'
        });
      } else {
        goToAmountPage(data);
      }
    } else if (bitcoreCash.Address.isValid(data, 'livenet')) {
      if ($state.includes('tabs.scan')) {
        root.showMenu({
          data: data,
          type: 'bitcoinAddress',
          coin: 'bch',
        });
      } else {
        goToAmountPage(data, 'bch');
      }
    } else if (data && data.indexOf(appConfigService.name + '://glidera') === 0) {
      var code = getParameterByName('code', data);
      $ionicHistory.nextViewOptions({
        disableAnimate: true
      });
      $state.go('tabs.home', {}, {
        'reload': true,
        'notify': $state.current.name == 'tabs.home' ? false : true
      }).then(function() {
        $ionicHistory.nextViewOptions({
          disableAnimate: true
        });
        $state.transitionTo('tabs.buyandsell.glidera', {
          code: code
        });
      });
      return true;

    } else if (data && data.indexOf(appConfigService.name + '://coinbase') === 0) {
      var code = getParameterByName('code', data);
      $ionicHistory.nextViewOptions({
        disableAnimate: true
      });
      $state.go('tabs.home', {}, {
        'reload': true,
        'notify': $state.current.name == 'tabs.home' ? false : true
      }).then(function() {
        $ionicHistory.nextViewOptions({
          disableAnimate: true
        });
        $state.transitionTo('tabs.buyandsell.coinbase', {
          code: code
        });
      });
      return true;

      // BitPayCard Authentication
    } else if (data && data.indexOf(appConfigService.name + '://') === 0) {

      // Disable BitPay Card
      if (!appConfigService._enabledExtensions.debitcard) return false;

      var secret = getParameterByName('secret', data);
      var email = getParameterByName('email', data);
      var otp = getParameterByName('otp', data);
      var reason = getParameterByName('r', data);

      $state.go('tabs.home', {}, {
        'reload': true,
        'notify': $state.current.name == 'tabs.home' ? false : true
      }).then(function() {
        switch (reason) {
          default:
            case '0':
            /* For BitPay card binding */
            $state.transitionTo('tabs.bitpayCardIntro', {
              secret: secret,
              email: email,
              otp: otp
            });
          break;
        }
      });
      return true;

      // Join
    } else if (data && data.match(/^copay:[0-9A-HJ-NP-Za-km-z]{70,80}$/)) {
      $state.go('tabs.home', {}, {
        'reload': true,
        'notify': $state.current.name == 'tabs.home' ? false : true
      }).then(function() {
        $state.transitionTo('tabs.add.join', {
          url: data
        });
      });
      return true;

      // Old join
    } else if (data && data.match(/^[0-9A-HJ-NP-Za-km-z]{70,80}$/)) {
      $state.go('tabs.home', {}, {
        'reload': true,
        'notify': $state.current.name == 'tabs.home' ? false : true
      }).then(function() {
        $state.transitionTo('tabs.add.join', {
          url: data
        });
      });
      return true;
    } else if (data && (data.substring(0, 2) == '6P' || checkPrivateKey(data))) {
      root.showMenu({
        data: data,
        type: 'privateKey'
      });
    } else if (data && ((data.substring(0, 2) == '1|') || (data.substring(0, 2) == '2|') || (data.substring(0, 2) == '3|'))) {
      $state.go('tabs.home').then(function() {
        $state.transitionTo('tabs.add.import', {
          code: data
        });
      });
      return true;

    } else {
      if ($state.includes('tabs.scan')) {
        root.showMenu({
          data: data,
          type: 'text'
        });
      }
    }
    return false;
  };

  function goToAmountPage(toAddress, coin) {
    $state.go('tabs.send', {}, {
      'reload': true,
      'notify': $state.current.name == 'tabs.send' ? false : true
    });
    $timeout(function() {
      $state.transitionTo('tabs.send.amount', {
        toAddress: toAddress,
        coin: coin,
      });
    }, 100);
  }

  function handlePayPro(payProDetails, coin) {
    var stateParams = {
      toAmount: payProDetails.amount,
      toAddress: payProDetails.toAddress,
      description: payProDetails.memo,
      paypro: payProDetails,
      coin: coin,
    };
    scannerService.pausePreview();
    $state.go('tabs.send', {}, {
      'reload': true,
      'notify': $state.current.name == 'tabs.send' ? false : true
    }).then(function() {
      $timeout(function() {
        $state.transitionTo('tabs.send.confirm', stateParams);
      });
    });
  }

  return root;
});

'use strict';

angular.module('copayApp.services')
  .factory('intelTEE', function($log, $timeout, gettext, lodash, bitcore, hwWallet, bwcService, platformInfo) {

    var root = {};

    root.description = {
      supported: platformInfo.supportsIntelTEE,
      version: platformInfo.versionIntelTEE,
      id: 'intelTEE',
      name: 'Intel TEE',
      longName: 'Intel TEE Hardware Wallet',
      derivationStrategy: 'BIP44',
      isEmbeddedHardware: true,
      supportsTestnet: true
    };

    if (!root.description.supported) {
      return root;
    }

    var IntelWallet = require('intelWalletCon');
    var TEE_APP_ID = '63279de1b6cb4dcf8c206716bd318092f8c206716bd31809263279de1b6cb4dc';

    root.walletEnclave = new IntelWallet.Wallet();
    var walletEnclaveStatus = root.walletEnclave.initializeEnclave();
    if (walletEnclaveStatus != 0) {
      $log.error('Failed to create Intel Wallet enclave');
    }

    root.getInfoForNewWallet = function(isMultisig, account, networkName, callback) {
      var opts = {};
      initSource(opts, function(err, opts) {
        if (err) return callback(err);

        root.getEntropySource(opts.hwInfo.id, isMultisig, account, function(err, entropySource) {
          if (err) return callback(err);

          opts.entropySource = entropySource;
          root.getXPubKey(opts.hwInfo.id, hwWallet.getAddressPath(root.description.id, isMultisig, account, networkName), function(data) {
            if (!data.success) {
              $log.warn(data.message);
              return callback(data);
            }
            opts.extendedPublicKey = data.xpubkey;
            opts.externalSource = root.description.id;
            opts.derivationStrategy = root.description.derivationStrategy;

            return callback(null, opts);
          });
        });
      });
    };

    root.getXPubKey = function(teeWalletId, path, callback) {
      $log.debug('TEE deriving xPub path:', path);

      // Expected to be a extended public key.
      var xpubkey = root.walletEnclave.getPublicKey(teeWalletId, path);

      // Error messages returned in value.
      var result = {
        success: false,
        message: xpubkey.ExtendedPublicKey
      };

      // Success indicated by status being equal to the tee wallet id.
      if (xpubkey.Status == teeWalletId) {
        result.success = true;
        result.message = 'OK';
        result.xpubkey = xpubkey.ExtendedPublicKey;
      } else {
        $log.error('Failed to get xpubkey from TEE wallet: ' + result.message);
      }

      callback(result);
    };

    root.getEntropySource = function(teeWalletId, isMultisig, account, callback) {
      root.getXPubKey(teeWalletId, hwWallet.getEntropyPath(root.description.id, isMultisig, account), function(data) {
        if (!data.success)
          return callback(hwWallet._err(data));

        return callback(null,  hwWallet.pubKeyToEntropySource(data.xpubkey));
      });
    };

    root.showMneumonic = function(teeWalletId, cb) {
      var result = root.walletEnclave.displayWordList(teeWalletId, 'en');
      if (result != teeWalletId) {
        cb(result);
      } else {
        cb();
      }
    };

    root.showReceiveAddress = function(teeWalletId, address, cb) {
      var isMultisig = false; // TODO
      var account = 0; // TODO
      var basePath = hwWallet.getAddressPath(root.description.id, isMultisig, account, address.network);
      var keyPath = address.path.replace('m', basePath);

      var result = root.walletEnclave.displayReceiveAddress(teeWalletId, keyPath);
      if (result != teeWalletId) {
        cb(result);
      } else {
        cb();
      }
    };

    root.signTx = function(teeWalletId, txp, callback) {
      var account = 0; // TODO
      var isMultisig = txp.requiredSignatures > 1;
      var basePath = hwWallet.getAddressPath(root.description.id, isMultisig, account, txp.network);

      var rawTx = bwcService.Client.getRawTx(txp);
      var keypaths = lodash.map(lodash.pluck(txp.inputs, 'path'), function(path) {
        return path.replace('m', basePath);
      });
      var publicKeys = lodash.pluck(txp.inputs, 'publicKeys');
      var changePublicKeys = txp.changeAddress.publicKeys;
      publicKeys.push(changePublicKeys);
      
      var changeaddrpath;
      if (txp.changeAddress) {
        changeaddrpath = txp.changeAddress.path.replace('m', basePath);
      }

      var result;
      if (txp.requiredSignatures == 1) {
        result = root.walletEnclave.signTransaction(teeWalletId, rawTx, changeaddrpath, keypaths);
      } else {
        result = root.walletEnclave.signTransaction(teeWalletId, rawTx, changeaddrpath, keypaths, publicKeys, txp.requiredSignatures, changePublicKeys, txp.requiredSignatures);
      }

      if (result.Status != teeWalletId) {
        return callback('TEE failed to sign transction: ' + result.Status);
      }
      return callback(null, result);
    };

    function initSource(opts, callback) {
        var args = {
          "Testnet" : (opts.networkName == 'livenet'? false : true),
          "PINUnlockRequired" : false,
          "PINSignatureDataRequired" : false,
          "PINSignatureTransaction" : 0,
          "ExportCount" : 10,
          "MaxPINAttempts" : 3,
          "PINTimeout" : 30
        };

        var teeStatus = root.walletEnclave.createWallet(TEE_APP_ID, args);
        switch (teeStatus) {
          case "CREATE WALLET FAILURE":
          case "CREATE WALLET FAILED TO INITIALIZE":
          case "CREATE WALLET FAILURE BAD INPUT":
          case "CREATE WALLET FAILURE case SERIALIZATION":
          case "DELETE_WALLET_AUTHORIZATION_UNSUCCESSFUL":
          case "LOAD_WALLET_FAILTURE":
          case "IMPORT WORD LIST FAILTURE":
          case "IMPORT WORD LIST FAILURE BAD INPUT":
          case "IMPORT WORD NOT IN DICTIONARY":
          case "INVALID PIN":
          case "INVALID APPLICATION ID":
          case "DISPLAY WORD LIST FAILURE":
          case "DELETE WALLET NO SUCH APPLICATION ID":
          case "SIGN DATA FAILURE":
          case "SIGN DATA INVALID HASH":
          case "SIGN DATA BUFFER TOO SMALL":
          case "SIGN DATA INVALID PIN":
          case "RECEIVE ADDRESS INVALID INPUT":
          case "RECEIVE ADDRESS NULL":
          case "RECEIVE ADDRESS BUFFER TOO SMALL":
          case "PUBLIC KEY BUFFER TOO SMALL":
          case "LOAD WALLET FAILURE":
          case "PUBLIC KEY FAILURE":
          case "PUBLIC KEY FAIL TO SERIALIZE":
          case "UKNOWN ERROR CODE":
            $log.error(teeStatus);
            return callback(teeStatus); // TODO: translate error text for display
            break;
          default:
            opts.hwInfo = {
              name: root.description.id,
              id: teeStatus
            };
            $log.debug('TEE wallet created: ' + opts.hwInfo.id);
            return callback(null, opts);
        }
    };

    return root;
});
'use strict';
angular.module('copayApp.services')
  .factory('latestReleaseService', function latestReleaseServiceFactory($log, $http, configService) {

    var root = {};

    root.checkLatestRelease = function(cb) {
      var releaseURL = configService.getDefaults().release.url;

      requestLatestRelease(releaseURL, function(err, release) {
        if (err) return cb(err);
        var currentVersion = window.version;
        var latestVersion = release.data.tag_name;

        if (!verifyTagFormat(currentVersion))
          return cb('Cannot verify the format of version tag: ' + currentVersion);
        if (!verifyTagFormat(latestVersion))
          return cb('Cannot verify the format of latest release tag: ' + latestVersion);

        var current = formatTagNumber(currentVersion);
        var latest = formatTagNumber(latestVersion);

        if (latest.major < current.major || (latest.major == current.major && latest.minor <= current.minor))
          return cb(null, false);

        $log.debug('A new version is available: ' + latestVersion);
        return cb(null, true);
      });

      function verifyTagFormat(tag) {
        var regex = /^v?\d+\.\d+\.\d+$/i;
        return regex.exec(tag);
      };

      function formatTagNumber(tag) {
        var formattedNumber = tag.replace(/^v/i, '').split('.');
        return {
          major: +formattedNumber[0],
          minor: +formattedNumber[1],
          patch: +formattedNumber[2]
        };
      };
    };

    function requestLatestRelease(releaseURL, cb) {
      $log.debug('Retrieving latest relsease information...');

      var request = {
        url: releaseURL,
        method: 'GET',
        json: true
      };

      $http(request).then(function(release) {
        $log.debug('Latest release: ' + release.data.name);
        return cb(null, release);
      }, function(err) {
        return cb('Cannot get the release information: ' + err);
      });
    };

    return root;
  });

'use strict';

angular.module('copayApp.services')
  .factory('ledger', function($log, bwcService, gettext, hwWallet, platformInfo) {
    var root = {};
    var LEDGER_CHROME_ID = "kkdpmhnladdopljabkgpacgpliggeeaf";

    root.description = {
      supported: platformInfo.supportsLedger,
      id: 'ledger',
      name: 'Ledger',
      longName: 'Ledger Hardware Wallet',
      isEmbeddedHardware: false,
      supportsTestnet: false
    };

    root.callbacks = {};
    root.hasSession = function() {
      root._message({
        command: "has_session"
      });
    }

    root.getEntropySource = function(isMultisig, account, callback) {
      root.getXPubKey(hwWallet.getEntropyPath(root.description.id, isMultisig, account), function(data) {
        if (!data.success)
          return callback(hwWallet._err(data));

        return callback(null, hwWallet.pubKeyToEntropySource(data.xpubkey));
      });
    };

    root.getXPubKey = function(path, callback) {
      $log.debug('Ledger deriving xPub path:', path);
      root.callbacks["get_xpubkey"] = callback;
      root._messageAfterSession({
        command: "get_xpubkey",
        path: path
      });
    };

    root.initSource = function(opts, callback) {
      // No initialization for this hardware source.
      return callback(opts);
    };

    root.getInfoForNewWallet = function(isMultisig, account, networkName, callback) {
      // networkName not used for this hardware (always livenet)
      root.getEntropySource(isMultisig, account, function(err, entropySource) {
        if (err) return callback(err);

        var opts = {};
        opts.entropySource = entropySource;
        root.getXPubKey(hwWallet.getAddressPath(root.description.id, isMultisig, account), function(data) {
          if (!data.success) {
            $log.warn(data.message);
            return callback(data);
          }
          opts.extendedPublicKey = data.xpubkey;
          opts.externalSource = root.description.id;

          // Old ledger compat
          opts.derivationStrategy = opts.account ? 'BIP48' : 'BIP44';
          return callback(null, opts);
        });
      });
    };

    root._signP2SH = function(txp, account, isMultisig, callback) {
      root.callbacks["sign_p2sh"] = callback;
      var redeemScripts = [];
      var paths = [];
      var tx = bwcService.getUtils().buildTx(txp);
      for (var i = 0; i < tx.inputs.length; i++) {
        redeemScripts.push(new ByteString(tx.inputs[i].redeemScript.toBuffer().toString('hex'), GP.HEX).toString());
        paths.push(hwWallet.getAddressPath(root.description.id, isMultisig, account) + txp.inputs[i].path.substring(1));
      }
      var splitTransaction = root._splitTransaction(new ByteString(tx.toString(), GP.HEX));
      var inputs = [];
      for (var i = 0; i < splitTransaction.inputs.length; i++) {
        var input = splitTransaction.inputs[i];
        inputs.push([
          root._reverseBytestring(input.prevout.bytes(0, 32)).toString(),
          root._reverseBytestring(input.prevout.bytes(32)).toString()
        ]);
      }
      $log.debug('Ledger signing  paths:', paths);
      root._messageAfterSession({
        command: "sign_p2sh",
        inputs: inputs,
        scripts: redeemScripts,
        outputs_number: splitTransaction.outputs.length,
        outputs_script: splitTransaction.outputScript.toString(),
        paths: paths
      });
    };

    root.signTx = function(txp, account, callback) {

      // TODO Compat
      var isMultisig = true;
      if (txp.addressType == 'P2PKH') {
        var msg = 'P2PKH wallets are not supported with ledger';
        $log.error(msg);
        return callback(msg);
      } else {
        root._signP2SH(txp, account, isMultisig, callback);
      }
    }

    root._message = function(data) {
      chrome.runtime.sendMessage(
        LEDGER_CHROME_ID, {
          request: data
        },
        function(response) {
          root._callback(response);
        }
      );
    }

    root._messageAfterSession = function(data) {
      root._after_session = data;
      root._message({
        command: "launch"
      });
      root._should_poll_session = true;
      root._do_poll_session();
    }

    root._do_poll_session = function() {
      root.hasSession();
      if (root._should_poll_session) {
        setTimeout(root._do_poll_session, 500);
      }
    }

    root._callback = function(data) {
      if (typeof data == "object") {
        if (data.command == "has_session" && data.success) {
          root._message(root._after_session);
          root._after_session = null;
          root._should_poll_session = false;
        } else if (typeof root.callbacks[data.command] == "function") {
          root.callbacks[data.command](data);
        } else {}
      } else {
        root._should_poll_session = false;
        Object.keys(root.callbacks).forEach(function(key) {
          root.callbacks[key]({
            success: false,
            message: gettext("The Ledger Chrome application is not installed"),
          });
        });
      }
    }

    root._splitTransaction = function(transaction) {
      var result = {};
      var inputs = [];
      var outputs = [];
      var offset = 0;
      var version = transaction.bytes(offset, 4);
      offset += 4;
      var varint = root._getVarint(transaction, offset);
      var numberInputs = varint[0];
      offset += varint[1];
      for (var i = 0; i < numberInputs; i++) {
        var input = {};
        input['prevout'] = transaction.bytes(offset, 36);
        offset += 36;
        varint = root._getVarint(transaction, offset);
        offset += varint[1];
        input['script'] = transaction.bytes(offset, varint[0]);
        offset += varint[0];
        input['sequence'] = transaction.bytes(offset, 4);
        offset += 4;
        inputs.push(input);
      }
      varint = root._getVarint(transaction, offset);
      var numberOutputs = varint[0];
      offset += varint[1];
      var outputStartOffset = offset;
      for (var i = 0; i < numberOutputs; i++) {
        var output = {};
        output['amount'] = transaction.bytes(offset, 8);
        offset += 8;
        varint = root._getVarint(transaction, offset);
        offset += varint[1];
        output['script'] = transaction.bytes(offset, varint[0]);
        offset += varint[0];
        outputs.push(output);
      }
      var locktime = transaction.bytes(offset, 4);
      result['version'] = version;
      result['inputs'] = inputs;
      result['outputs'] = outputs;
      result['locktime'] = locktime;
      result['outputScript'] = transaction.bytes(outputStartOffset, offset - outputStartOffset);
      return result;
    }

    root._getVarint = function(data, offset) {
      if (data.byteAt(offset) < 0xfd) {
        return [data.byteAt(offset), 1];
      }
      if (data.byteAt(offset) == 0xfd) {
        return [((data.byteAt(offset + 2) << 8) + data.byteAt(offset + 1)), 3];
      }
      if (data.byteAt(offset) == 0xfe) {
        return [((data.byteAt(offset + 4) << 24) + (data.byteAt(offset + 3) << 16) +
          (data.byteAt(offset + 2) << 8) + data.byteAt(offset + 1)), 5];
      }
    }

    root._reverseBytestring = function(x) {
      var res = "";
      for (var i = x.length - 1; i >= 0; i--) {
        res += Convert.toHexByte(x.byteAt(i));
      }
      return new ByteString(res, GP.HEX);
    }

    return root;
  });

var Convert = {};

/**
 * Convert a binary string to his hexadecimal representation
 * @param {String} src binary string
 * @static
 * @returns {String} hexadecimal representation
 */
Convert.stringToHex = function(src) {
  var r = "";
  var hexes = new Array("0", "1", "2", "3", "4", "5", "6", "7", "8", "9", "a", "b", "c", "d", "e", "f");
  for (var i = 0; i < src.length; i++) {
    r += hexes[src.charCodeAt(i) >> 4] + hexes[src.charCodeAt(i) & 0xf];
  }
  return r;
}

/**
 * Convert an hexadecimal string to its binary representation
 * @param {String} src hexadecimal string
 * @static
 * @return {Array} byte array
 * @throws {InvalidString} if the string isn't properly formatted
 */
Convert.hexToBin = function(src) {
  var result = "";
  var digits = "0123456789ABCDEF";
  if ((src.length % 2) != 0) {
    throw "Invalid string";
  }
  src = src.toUpperCase();
  for (var i = 0; i < src.length; i += 2) {
    var x1 = digits.indexOf(src.charAt(i));
    if (x1 < 0) {
      return "";
    }
    var x2 = digits.indexOf(src.charAt(i + 1));
    if (x2 < 0) {
      return "";
    }
    result += String.fromCharCode((x1 << 4) + x2);
  }
  return result;
}

/**
 * Convert a double digit hexadecimal number to an integer
 * @static
 * @param {String} data buffer containing the digit to parse
 * @param {Number} offset offset to the digit (default is 0)
 * @returns {Number} converted digit
 */
Convert.readHexDigit = function(data, offset) {
  var digits = '0123456789ABCDEF';
  if (typeof offset == "undefined") {
    offset = 0;
  }
  return (digits.indexOf(data.substring(offset, offset + 1).toUpperCase()) << 4) + (digits.indexOf(data.substring(offset + 1, offset + 2).toUpperCase()));
}

/**
 * Convert a number to a two digits hexadecimal string (deprecated)
 * @static
 * @param {Number} number number to convert
 * @returns {String} converted number
 */
Convert.toHexDigit = function(number) {
  var digits = '0123456789abcdef';
  return digits.charAt(number >> 4) + digits.charAt(number & 0x0F);
}

/**
 * Convert a number to a two digits hexadecimal string (similar to toHexDigit)
 * @static
 * @param {Number} number number to convert
 * @returns {String} converted number
 */
Convert.toHexByte = function(number) {
  return Convert.toHexDigit(number);
}

/**
 * Convert a BCD number to a two digits hexadecimal string
 * @static
 * @param {Number} number number to convert
 * @returns {String} converted number
 */
Convert.toHexByteBCD = function(numberBCD) {
  var number = ((numberBCD / 10) * 16) + (numberBCD % 10);
  return Convert.toHexDigit(number);
}


/**
 * Convert a number to an hexadecimal short number
 * @static
 * @param {Number} number number to convert
 * @returns {String} converted number
 */
Convert.toHexShort = function(number) {
  return Convert.toHexDigit((number >> 8) & 0xff) + Convert.toHexDigit(number & 0xff);
}

/**
 * Convert a number to an hexadecimal int number
 * @static
 * @param {Number} number number to convert
 * @returns {String} converted number
 */
Convert.toHexInt = function(number) {
  return Convert.toHexDigit((number >> 24) & 0xff) + Convert.toHexDigit((number >> 16) & 0xff) +
    Convert.toHexDigit((number >> 8) & 0xff) + Convert.toHexDigit(number & 0xff);
}


var GP = {};
GP.ASCII = 1;
GP.HEX = 5;

/**
 * @class GPScript ByteString implementation
 * @param {String} value initial value
 * @param {HEX|ASCII} encoding encoding to use
 * @property {Number} length length of the ByteString
 * @constructs
 */
var ByteString = function(value, encoding) {
  this.encoding = encoding;
  this.hasBuffer = (typeof Buffer != 'undefined');
  if (this.hasBuffer && (value instanceof Buffer)) {
    this.value = value;
    this.encoding = GP.HEX;
  } else {
    switch (encoding) {
      case GP.HEX:
        if (!this.hasBuffer) {
          this.value = Convert.hexToBin(value);
        } else {
          this.value = new Buffer(value, 'hex');
        }
        break;

      case GP.ASCII:
        if (!this.hasBuffer) {
          this.value = value;
        } else {
          this.value = new Buffer(value, 'ascii');
        }
        break;

      default:
        throw "Invalid arguments";
    }
  }
  this.length = this.value.length;
}

/**
 * Retrieve the byte value at the given index
 * @param {Number} index index
 * @returns {Number} byte value
 */
ByteString.prototype.byteAt = function(index) {
  if (arguments.length < 1) {
    throw "Argument missing";
  }
  if (typeof index != "number") {
    throw "Invalid index";
  }
  if ((index < 0) || (index >= this.value.length)) {
    throw "Invalid index offset";
  }
  if (!this.hasBuffer) {
    return Convert.readHexDigit(Convert.stringToHex(this.value.substring(index, index + 1)));
  } else {
    return this.value[index];
  }
}

/**
 * Retrieve a subset of the ByteString
 * @param {Number} offset offset to start at
 * @param {Number} [count] size of the target ByteString (default : use the remaining length)
 * @returns {ByteString} subset of the original ByteString
 */
ByteString.prototype.bytes = function(offset, count) {
  var result;
  if (arguments.length < 1) {
    throw "Argument missing";
  }
  if (typeof offset != "number") {
    throw "Invalid offset";
  }
  //if ((offset < 0) || (offset >= this.value.length)) {
  if (offset < 0) {
    throw "Invalid offset";
  }
  if (typeof count == "number") {
    if (count < 0) {
      throw "Invalid count";
    }
    if (!this.hasBuffer) {
      result = new ByteString(this.value.substring(offset, offset + count), GP.ASCII);
    } else {
      result = new Buffer(count);
      this.value.copy(result, 0, offset, offset + count);
    }
  } else
  if (typeof count == "undefined") {
    if (!this.hasBuffer) {
      result = new ByteString(this.value.substring(offset), GP.ASCII);
    } else {
      result = new Buffer(this.value.length - offset);
      this.value.copy(result, 0, offset, this.value.length);
    }
  } else {
    throw "Invalid count";
  }
  if (!this.hasBuffer) {
    result.encoding = this.encoding;
    return result;
  } else {
    return new ByteString(result, GP.HEX);
  }
}

/**
 * Appends two ByteString
 * @param {ByteString} target ByteString to append
 * @returns {ByteString} result of the concatenation
 */
ByteString.prototype.concat = function(target) {
  if (arguments.length < 1) {
    throw "Not enough arguments";
  }
  if (!(target instanceof ByteString)) {
    throw "Invalid argument";
  }
  if (!this.hasBuffer) {
    var result = this.value + target.value;
    var x = new ByteString(result, GP.ASCII);
    x.encoding = this.encoding;
    return x;
  } else {
    var result = Buffer.concat([this.value, target.value]);
    return new ByteString(result, GP.HEX);
  }
}

/**
 * Check if two ByteString are equal
 * @param {ByteString} target ByteString to check against
 * @returns {Boolean} true if the two ByteString are equal
 */
ByteString.prototype.equals = function(target) {
  if (arguments.length < 1) {
    throw "Not enough arguments";
  }
  if (!(target instanceof ByteString)) {
    throw "Invalid argument";
  }
  if (!this.hasBuffer) {
    return (this.value == target.value);
  } else {
    return Buffer.equals(this.value, target.value);
  }
}


/**
 * Convert the ByteString to a String using the given encoding
 * @param {HEX|ASCII|UTF8|BASE64|CN} encoding encoding to use
 * @return {String} converted content
 */
ByteString.prototype.toString = function(encoding) {
  var targetEncoding = this.encoding;
  if (arguments.length >= 1) {
    if (typeof encoding != "number") {
      throw "Invalid encoding";
    }
    switch (encoding) {
      case GP.HEX:
      case GP.ASCII:
        targetEncoding = encoding;
        break;

      default:
        throw "Unsupported arguments";
    }
    targetEncoding = encoding;
  }
  switch (targetEncoding) {
    case GP.HEX:
      if (!this.hasBuffer) {
        return Convert.stringToHex(this.value);
      } else {
        return this.value.toString('hex');
      }
    case GP.ASCII:
      if (!this.hasBuffer) {
        return this.value;
      } else {
        return this.value.toString();
      }
    default:
      throw "Unsupported";
  }
}

ByteString.prototype.toStringIE = function(encoding) {
  return this.toString(encoding);
}

ByteString.prototype.toBuffer = function() {
  return this.value;
}

'use strict';

angular.module('copayApp.services')
  .factory('localStorageService', function(platformInfo, $timeout, $log, lodash) {
    var isNW = platformInfo.isNW;
    var isChromeApp = platformInfo.isChromeApp;
    var root = {};
    var ls = ((typeof window.localStorage !== "undefined") ? window.localStorage : null);

    if (isChromeApp && !isNW && !ls) {
      $log.info('Using CHROME storage');
      ls = chrome.storage.local;
    }


    if (!ls)
      throw new Error('localstorage not available');

    root.get = function(k, cb) {
      if (isChromeApp || isNW) {
        chrome.storage.local.get(k,
          function(data) {
            //TODO check for errors
            return cb(null, data[k]);
          });
      } else {
        return cb(null, ls.getItem(k));
      }
    };

    /**
     * Same as setItem, but fails if an item already exists
     */
    root.create = function(name, value, callback) {
      root.get(name,
        function(err, data) {
          if (data) {
            return callback('EEXISTS');
          } else {
            return root.set(name, value, callback);
          }
        });
    };

    root.set = function(k, v, cb) {

      if (lodash.isObject(v)) {
        v = JSON.stringify(v);
      }
      if (v && !lodash.isString(v)) {
        v = v.toString();
      }

      if (isChromeApp || isNW) {
        var obj = {};

        obj[k] = v;

        chrome.storage.local.set(obj, cb);
      } else {
        ls.setItem(k, v);
        return cb();
      }
    };

    root.remove = function(k, cb) {
      if (isChromeApp || isNW) {
        chrome.storage.local.remove(k, cb);
      } else {
        ls.removeItem(k);
        return cb();
      }

    };


    if (isNW) {
      $log.info('Overwritting localstorage with chrome storage for NW.JS');

      var ts = ls.getItem('migrationToChromeStorage');
      var p = ls.getItem('profile');

      // Need migration?
      if (!ts && p) {
        $log.info('### MIGRATING DATA! TO CHROME STORAGE');

        var j = 0;
        for (var i = 0; i < localStorage.length; i++) {
          var k = ls.key(i);
          var v = ls.getItem(k);

          $log.debug('   Key: ' + k);
          root.set(k, v, function() {
            j++;
            if (j == localStorage.length) {
              $log.info('### MIGRATION DONE');
              ls.setItem('migrationToChromeStorage', Date.now())
              ls = chrome.storage.local;
            }
          })
        }
      } else if (p) {
        $log.info('# Data already migrated to Chrome storage on ' + ts);
      }
    }


    return root;
  });

'use strict';
angular.module('copayApp.services')
  .factory('logHeader', function($window, appConfigService, $log, platformInfo) {
    $log.info(appConfigService.nameCase + ' v' + $window.version + ' #' + $window.commitHash);
    $log.info('Client: ' + JSON.stringify(platformInfo));
    return {};
  });

'use strict';
angular.module('copayApp.services').factory('mercadoLibreService', function($http, $log, lodash, moment, storageService, configService, platformInfo, nextStepsService, homeIntegrationsService) {
  var root = {};
  var credentials = {};

  // Not used yet
  var availableCountries = [{
    'country': 'Brazil',
    'currency': 'BRL',
    'name': 'Mercado Livre',
    'url': 'https://www.mercadolivre.com.br'
  }];

  /*
   * Development: 'testnet'
   * Production: 'livenet'
   */
  credentials.NETWORK = 'livenet';
  //credentials.NETWORK = 'testnet';

  if (credentials.NETWORK == 'testnet') {
    credentials.BITPAY_API_URL = "https://test.bitpay.com";
  } else {
    credentials.BITPAY_API_URL = "https://bitpay.com";
  };

  var homeItem = {
    name: 'mercadoLibre',
    title: 'Vales-Presente do Mercado Livre Brasil',
    icon: 'icon-ml',
    sref: 'tabs.giftcards.mercadoLibre',
  };

  var nextStepItem = {
    name: 'mercadoLibre',
    title: 'Comprar um Vale-Presente Mercado Livre',
    icon: 'icon-ml',
    sref: 'tabs.giftcards.mercadoLibre',
  };

  var _getBitPay = function(endpoint) {
    return {
      method: 'GET',
      url: credentials.BITPAY_API_URL + endpoint,
      headers: {
        'content-type': 'application/json'
      }
    };
  };

  var _postBitPay = function(endpoint, data) {
    return {
      method: 'POST',
      url: credentials.BITPAY_API_URL + endpoint,
      headers: {
        'content-type': 'application/json'
      },
      data: data
    };
  };

  root.getNetwork = function() {
    return credentials.NETWORK;
  };

  root.savePendingGiftCard = function(gc, opts, cb) {
    var network = root.getNetwork();
    storageService.getMercadoLibreGiftCards(network, function(err, oldGiftCards) {
      if (lodash.isString(oldGiftCards)) {
        oldGiftCards = JSON.parse(oldGiftCards);
      }
      if (lodash.isString(gc)) {
        gc = JSON.parse(gc);
      }
      var inv = oldGiftCards || {};
      inv[gc.invoiceId] = gc;
      if (opts && (opts.error || opts.status)) {
        inv[gc.invoiceId] = lodash.assign(inv[gc.invoiceId], opts);
      }
      if (opts && opts.remove) {
        delete(inv[gc.invoiceId]);
      }

      inv = JSON.stringify(inv);


      storageService.setMercadoLibreGiftCards(network, inv, function(err) {

        homeIntegrationsService.register(homeItem);
        nextStepsService.unregister(nextStepItem.name);
        return cb(err);
      });
    });
  };

  root.getPendingGiftCards = function(cb) {
    var network = root.getNetwork();
    storageService.getMercadoLibreGiftCards(network, function(err, giftCards) {
      var _gcds = giftCards ? JSON.parse(giftCards) : null;
      return cb(err, _gcds);
    });
  };

  root.createBitPayInvoice = function(data, cb) {
    var dataSrc = {
      currency: data.currency,
      amount: data.amount,
      clientId: data.uuid
    };

    $http(_postBitPay('/mercado-libre-gift/pay', dataSrc)).then(function(data) {
      $log.info('BitPay Create Invoice: SUCCESS');
      return cb(null, data.data);
    }, function(data) {
      $log.error('BitPay Create Invoice: ERROR', JSON.stringify(data.data));
      return cb(data.data);
    });
  };

  root.getBitPayInvoice = function(id, cb) {
    $http(_getBitPay('/invoices/' + id)).then(function(data) {
      $log.info('BitPay Get Invoice: SUCCESS');
      return cb(null, data.data.data);
    }, function(data) {
      $log.error('BitPay Get Invoice: ERROR', JSON.stringify(data.data));
      return cb(data.data);
    });
  };

  root.createGiftCard = function(data, cb) {
    var dataSrc = {
      "clientId": data.uuid,
      "invoiceId": data.invoiceId,
      "accessKey": data.accessKey
    };

    $http(_postBitPay('/mercado-libre-gift/redeem', dataSrc)).then(function(data) {
      var status = data.data.status == 'new' ? 'PENDING' : (data.data.status == 'paid') ? 'PENDING' : data.data.status;
      data.data.status = status;
      $log.info('Mercado Libre Gift Card Create/Update: ' + status);
      return cb(null, data.data);
    }, function(data) {
      $log.error('Mercado Libre Gift Card Create/Update: ERROR', JSON.stringify(data.data));
      return cb(data.data);
    });
  };

  /*
   * Disabled for now *
   */
  /*
  root.cancelGiftCard = function(data, cb) {

    var dataSrc = {
      "clientId": data.uuid,
      "invoiceId": data.invoiceId,
      "accessKey": data.accessKey
    };

    $http(_postBitPay('/mercado-libre-gift/cancel', dataSrc)).then(function(data) {
      $log.info('Mercado Libre Gift Card Cancel: SUCCESS');
      return cb(null, data.data);
    }, function(data) {
      $log.error('Mercado Libre Gift Card Cancel: ' + data.data.message);
      return cb(data.data);
    });
  };
  */

  var register = function() {
    storageService.getMercadoLibreGiftCards(root.getNetwork(), function(err, giftCards) {
      if (giftCards) {
        homeIntegrationsService.register(homeItem);
      } else {
        nextStepsService.register(nextStepItem);
      }
    });
  };

  // Hide Mercado Libre
  // register();
  return root;
});

 'use strict';
 angular.module('copayApp.services').factory('nextStepsService', function(configService, $log, lodash) {
   var root = {};
   var services = [];

   root.register = function(serviceInfo) {
     $log.info('Adding NextSteps entry:' + serviceInfo.name);

     if (!lodash.find(services, function(x) {
         return x.name == serviceInfo.name;
       })) {
       services.push(serviceInfo);
     }
   };

   root.unregister = function(serviceName) {

     var newS = lodash.filter(services, function(x) {
       return x.name != serviceName;
     });

     // Found?
     if (newS.length == services.length) return;

     $log.info('Removing NextSteps entry:' + serviceName);
     // This is to preserve services pointer
     while (services.length)
       services.pop();

     while (newS.length)
       services.push(newS.pop());
   };

   root.get = function() {
     return services;
   };

   return root;

 });

'use strict';

angular.module('copayApp.services').service('nodeWebkitService', function() {

  this.readFromClipboard = function() {
    var gui = require('nw.gui');
    var clipboard = gui.Clipboard.get();
    return clipboard.get();
  };

  this.writeToClipboard = function(text) {
    var gui = require('nw.gui');
    var clipboard = gui.Clipboard.get();
    return clipboard.set(text);
  };

  this.openExternalLink = function(url) {
    var gui = require('nw.gui');
    return gui.Shell.openExternal(url);
  };

});

'use strict';

angular.module('copayApp.services').factory('ongoingProcess', function($log, $timeout, $filter, lodash, $ionicLoading, gettext, platformInfo) {
  var root = {};
  var isCordova = platformInfo.isCordova;
  var isWindowsPhoneApp = platformInfo.isCordova && platformInfo.isWP;

  var ongoingProcess = {};

  var processNames = {
    'broadcastingTx': gettext('Broadcasting transaction'),
    'calculatingFee': gettext('Calculating fee'),
    'connectingCoinbase': gettext('Connecting to Coinbase...'),
    'connectingGlidera': gettext('Connecting to Glidera...'),
    'connectingledger': gettext('Waiting for Ledger...'),
    'connectingtrezor': gettext('Waiting for Trezor...'),
    'creatingTx': gettext('Creating transaction'),
    'creatingWallet': gettext('Creating Wallet...'),
    'deletingWallet': gettext('Deleting Wallet...'),
    'extractingWalletInfo': gettext('Extracting Wallet information...'),
    'fetchingPayPro': gettext('Fetching payment information'),
    'generatingCSV': gettext('Generating .csv file...'),
    'gettingFeeLevels': gettext('Getting fee levels...'),
    'importingWallet': gettext('Importing Wallet...'),
    'joiningWallet': gettext('Joining Wallet...'),
    'recreating': gettext('Recreating Wallet...'),
    'rejectTx': gettext('Rejecting payment proposal'),
    'removeTx': gettext('Deleting payment proposal'),
    'retrievingInputs': gettext('Retrieving inputs information'),
    'scanning': gettext('Scanning Wallet funds...'),
    'sendingTx': gettext('Sending transaction'),
    'signingTx': gettext('Signing transaction'),
    'sweepingWallet': gettext('Sweeping Wallet...'),
    'validatingWords': gettext('Validating recovery phrase...'),
    'loadingTxInfo': gettext('Loading transaction info...'),
    'sendingFeedback': gettext('Sending feedback...'),
    'generatingNewAddress': gettext('Generating new address...'),
    'sendingByEmail': gettext('Preparing addresses...'),
    'sending2faCode': gettext('Sending 2FA code...'),
    'buyingBitcoin': gettext('Buying Bitcoin...'),
    'sellingBitcoin': gettext('Selling Bitcoin...'),
    'fetchingBitPayAccount': gettext('Fetching BitPay Account...'),
    'updatingGiftCards': 'Updating Gift Cards...',
    'updatingGiftCard': 'Updating Gift Card...',
    'cancelingGiftCard': 'Canceling Gift Card...',
    'creatingGiftCard': 'Creating Gift Card...',
    'buyingGiftCard': 'Buying Gift Card...',
    'topup': gettext('Top up in progress...'),
    'duplicatingWallet': gettext('Duplicating wallet...'),
  };

  root.clear = function() {
    ongoingProcess = {};
    if (isCordova && !isWindowsPhoneApp) {
      window.plugins.spinnerDialog.hide();
    } else {
      $ionicLoading.hide();
    }
  };

  root.get = function(processName) {
    return ongoingProcess[processName];
  };

  root.set = function(processName, isOn, customHandler) {
    $log.debug('ongoingProcess', processName, isOn);
    root[processName] = isOn;
    ongoingProcess[processName] = isOn;

    var name;
    root.any = lodash.any(ongoingProcess, function(isOn, processName) {
      if (isOn)
        name = name || processName;
      return isOn;
    });
    // The first one
    root.onGoingProcessName = name;

    var showName = $filter('translate')(processNames[name] || name);

    if (customHandler) {
      customHandler(processName, showName, isOn);
    } else if (root.onGoingProcessName) {
      if (isCordova && !isWindowsPhoneApp) {
        window.plugins.spinnerDialog.show(null, showName, root.clear);
      } else {

        var tmpl;
        if (isWindowsPhoneApp) tmpl = '<div>' + showName + '</div>';
        else tmpl = '<div class="item-icon-left">' + showName + '<ion-spinner class="spinner-stable" icon="lines"></ion-spinner></div>';
        $ionicLoading.show({
          template: tmpl
        });
      }
    } else {
      if (isCordova && !isWindowsPhoneApp) {
        window.plugins.spinnerDialog.hide();
      } else {
        $ionicLoading.hide();
      }
    }
  };

  return root;
});

'use strict';

angular.module('copayApp.services').factory('openURLService', function($rootScope, $ionicHistory, $document, $log, $state, platformInfo, lodash, profileService, incomingData, appConfigService) {
  var root = {};

  var handleOpenURL = function(args) {

    $log.info('Handling Open URL: ' + JSON.stringify(args));
    // Stop it from caching the first view as one to return when the app opens
    $ionicHistory.nextViewOptions({
      historyRoot: true,
      disableBack: false,
      disableAnimation: true
    });

    var url = args.url;
    if (!url) {
      $log.error('No url provided');
      return;
    };

    if (url) {
      if ('cordova' in window) {
        window.cordova.removeDocumentEventHandler('handleopenurl');
        window.cordova.addStickyDocumentEventHandler('handleopenurl');
      }
      document.removeEventListener('handleopenurl', handleOpenURL);
    }

    document.addEventListener('handleopenurl', handleOpenURL, false);

    if (!incomingData.redir(url)) {
      $log.warn('Unknown URL! : ' + url);
    }
  };

  var handleResume = function() {
    $log.debug('Handle Resume @ openURL...');
    document.addEventListener('handleopenurl', handleOpenURL, false);
  };

  root.init = function() {
    $log.debug('Initializing openURL');
    document.addEventListener('handleopenurl', handleOpenURL, false);
    document.addEventListener('resume', handleResume, false);

    if (platformInfo.isChromeApp) {
      $log.debug('Registering Chrome message listener');
      chrome.runtime.onMessage.addListener(
        function(request, sender, sendResponse) {
          if (request.url) {
            handleOpenURL(request.url);
          }
        });
    } else if (platformInfo.isNW) {
      var gui = require('nw.gui');

      // This event is sent to an existent instance of Copay (only for standalone apps)
      gui.App.on('open', function(pathData) {
        if (pathData.indexOf(/^bitcoin(cash)?:/) != -1) {
          $log.debug('Bitcoin URL found');
          handleOpenURL({
            url: pathData.substring(pathData.indexOf(/^bitcoin(cash)?:/))
          });
        } else if (pathData.indexOf(appConfigService.name + '://') != -1) {
          $log.debug(appConfigService.name + ' URL found');
          handleOpenURL({
            url: pathData.substring(pathData.indexOf(appConfigService.name + '://'))
          });
        }
      });

      // Used at the startup of Copay
      var argv = gui.App.argv;
      if (argv && argv[0]) {
        handleOpenURL({
          url: argv[0]
        });
      }
    } else if (platformInfo.isDevel) {
      var base = window.location.origin + '/';
      var url = base + '#/uri/%s';

      if (navigator.registerProtocolHandler) {
        $log.debug('Registering Browser handlers base:' + base);
        navigator.registerProtocolHandler('bitcoin', url, 'Copay Bitcoin Handler');
        navigator.registerProtocolHandler('web+bitcoincash', url, 'Copay Bitcoin Cash Handler');
        navigator.registerProtocolHandler('web+copay', url, 'Copay Wallet Handler');
        navigator.registerProtocolHandler('web+bitpay', url, 'BitPay Wallet Handler');
      }
    }
  };

  root.registerHandler = function(x) {
    $log.debug('Registering URL Handler: ' + x.name);
    root.registeredUriHandlers.push(x);
  };

  root.handleURL = function(args) {
    profileService.whenAvailable(function() {
      // Wait ux to settle
      setTimeout(function() {
        handleOpenURL(args);
      }, 1000);
    });
  };

  return root;
});

'use strict';

angular.module('copayApp.services').factory('payproService',
  function(profileService, platformInfo, gettextCatalog, ongoingProcess, $log) {

    var ret = {};

    ret.getPayProDetails = function(uri, cb, disableLoader) {
      if (!cb) cb = function() {};

      var wallet = profileService.getWallets({
        onlyComplete: true
      })[0];

      if (!wallet) return cb();

      if (platformInfo.isChromeApp) {
        return cb(gettextCatalog.getString('Payment Protocol not supported on Chrome App'));
      }

      $log.debug('Fetch PayPro Request...', uri);

      if (!disableLoader) ongoingProcess.set('fetchingPayPro', true);

      wallet.fetchPayPro({
        payProUrl: uri,
      }, function(err, paypro) {
        if (!disableLoader) ongoingProcess.set('fetchingPayPro', false);
        if (err) return cb(err);
        else if (!paypro.verified) {
          $log.warn('Failed to verify payment protocol signatures');
          return cb(gettextCatalog.getString('Payment Protocol Invalid'));
        }
        return cb(null, paypro);
      });
    };

    return ret;
  });

'use strict';

angular.module('copayApp.services').factory('platformInfo', function($window) {

  var ua = navigator ? navigator.userAgent : null;

  if (!ua) {
    console.log('Could not determine navigator. Using fixed string');
    ua = 'dummy user-agent';
  }

  // Fixes IOS WebKit UA
  ua = ua.replace(/\(\d+\)$/, '');

  var isNodeWebkit = function() {
    var isNode = (typeof process !== "undefined" && typeof require !== "undefined");
    if (isNode) {
      try {
        return (typeof require('nw.gui') !== "undefined");
      } catch (e) {
        return false;
      }
    }
  };

  var getVersionIntelTee = function() {
    var v = '';
    var isWindows = navigator.platform.indexOf('Win') > -1;

    if (!isNodeWebkit() || !isWindows) {
      return v;
    }

    try {
      var IntelWallet = require('intelWalletCon');
      if (IntelWallet.getVersion) {
        v = IntelWallet.getVersion();
      } else {
        v = 'Alpha';
      }
      if (v.length > 0) {
        $log.info('Intel TEE library ' + v);
      }
    } catch (e) {}
    return v;
  };

  // Detect mobile devices
  var ret = {
    isAndroid: ionic.Platform.isAndroid(),
    isIOS: ionic.Platform.isIOS(),
    isWP: ionic.Platform.isWindowsPhone() || ionic.Platform.platform() == 'edge',
    isSafari: Object.prototype.toString.call(window.HTMLElement).indexOf('Constructor') > 0,
    ua: ua,
    isCordova: !!$window.cordova,
    isNW: isNodeWebkit(),
  };

  ret.isMobile = ret.isAndroid || ret.isIOS || ret.isWP;
  ret.isChromeApp = $window.chrome && chrome.runtime && chrome.runtime.id && !ret.isNW;
  ret.isDevel = !ret.isMobile && !ret.isChromeApp && !ret.isNW;

  ret.supportsLedger = ret.isChromeApp;
  ret.supportsTrezor = ret.isChromeApp || ret.isDevel;

  ret.versionIntelTEE = getVersionIntelTee();
  ret.supportsIntelTEE = ret.versionIntelTEE.length > 0;

  return ret;
});

'use strict';

angular.module('copayApp.services').service('popupService', function($log, $ionicPopup, platformInfo, gettextCatalog) {

  var isCordova = platformInfo.isCordova;
  var isWindowsPhoneApp = platformInfo.isCordova && platformInfo.isWP;

  /*************** Ionic ****************/

  var _ionicAlert = function(title, message, cb, okText) {
    if (!cb) cb = function() {};
    $ionicPopup.alert({
      title: title,
      subTitle: message,
      okType: 'button-clear button-positive',
      okText: okText || gettextCatalog.getString('OK'),
    }).then(cb);
  };

  var _ionicConfirm = function(title, message, okText, cancelText, cb) {
    $ionicPopup.confirm({
      title: title,
      subTitle: message,
      cancelText: cancelText,
      cancelType: 'button-clear button-positive',
      okText: okText,
      okType: 'button-clear button-positive'
    }).then(function(res) {
      return cb(res);
    });
  };

  var _ionicPrompt = function(title, message, opts, cb) {
    opts = opts || {};
    $ionicPopup.prompt({
      title: title,
      subTitle: message,
      cssClass: opts.class,
      template: '<input ng-model="data.response" type="' + opts.inputType + '" value ="" autocomplete="off" autofocus>',
      inputPlaceholder: opts.inputPlaceholder,
      defaultText: opts.defaultText
    }).then(function(res) {
      return cb(res);
    });
  };

  /*************** Cordova ****************/

  var _cordovaAlert = function(title, message, cb, okText) {
    if (!cb) cb = function() {};
    title = title ? title : '';
    okText = okText || gettextCatalog.getString('OK');
    navigator.notification.alert(message, cb, title, okText);
  };

  var _cordovaConfirm = function(title, message, okText, cancelText, cb) {
    var onConfirm = function(buttonIndex) {
      if (buttonIndex == 2) return cb(true);
      else return cb(false);
    }
    okText = okText || gettextCatalog.getString('OK');
    cancelText = cancelText || gettextCatalog.getString('Cancel');
    title = title ? title : '';
    navigator.notification.confirm(message, onConfirm, title, [cancelText, okText]);
  };

  var _cordovaPrompt = function(title, message, opts, cb) {
    var onPrompt = function(results) {
      if (results.buttonIndex == 1) return cb(results.input1);
      else return cb();
    }
    var okText = gettextCatalog.getString('OK');
    var cancelText = gettextCatalog.getString('Cancel');
    title = title ? title : '';
    navigator.notification.prompt(message, onPrompt, title, [okText, cancelText], opts.defaultText);
  };

  /**
   * Show a simple alert popup
   *
   * @param {String} Title (optional)
   * @param {String} Message
   * @param {Callback} Function (optional)
   */

  this.showAlert = function(title, msg, cb, okText) {
    var message = (msg && msg.message) ? msg.message : msg;
    $log.warn(title ? (title + ': ' + message) : message);

    if (isCordova)
      _cordovaAlert(title, message, cb, okText);
    else
      _ionicAlert(title, message, cb, okText);
  };

  /**
   * Show a simple confirm popup
   *
   * @param {String} Title (optional)
   * @param {String} Message
   * @param {String} okText (optional)
   * @param {String} cancelText (optional)
   * @param {Callback} Function
   * @returns {Callback} OK: true, Cancel: false
   */

  this.showConfirm = function(title, message, okText, cancelText, cb) {
    $log.warn(title ? (title + ': ' + message) : message);

    if (isCordova)
      _cordovaConfirm(title, message, okText, cancelText, cb);
    else
      _ionicConfirm(title, message, okText, cancelText, cb);
  };

  /**
   * Show a simple prompt popup
   *
   * @param {String} Title (optional)
   * @param {String} Message
   * @param {Object} Object{ inputType, inputPlaceholder, defaultText } (optional)
   * @param {Callback} Function
   * @returns {Callback} Return the value of the input if user presses OK
   */

  this.showPrompt = function(title, message, opts, cb) {
    $log.warn(title ? (title + ': ' + message) : message);

    opts = opts || {};

    if (isCordova && !isWindowsPhoneApp && !opts.forceHTMLPrompt)
      _cordovaPrompt(title, message, opts, cb);
    else
      _ionicPrompt(title, message, opts, cb);
  };


});

'use strict';
angular.module('copayApp.services')
  .factory('profileService', function profileServiceFactory($rootScope, $timeout, $filter, $log, $state, sjcl, lodash, storageService, bwcService, configService, gettextCatalog, bwcError, uxLanguage, platformInfo, txFormatService, appConfigService) {


    var isChromeApp = platformInfo.isChromeApp;
    var isCordova = platformInfo.isCordova;
    var isWindowsPhoneApp = platformInfo.isCordova && platformInfo.isWP;
    var isIOS = platformInfo.isIOS;

    var root = {};
    var errors = bwcService.getErrors();
    var usePushNotifications = isCordova && !isWindowsPhoneApp;

    var UPDATE_PERIOD = 15;

    root.profile = null;

    Object.defineProperty(root, "focusedClient", {
      get: function() {
        throw "focusedClient is not used any more"
      },
      set: function() {
        throw "focusedClient is not used any more"
      }
    });


    root.wallet = {}; // decorated version of client

    root.updateWalletSettings = function(wallet) {
      var defaults = configService.getDefaults();
      configService.whenAvailable(function(config) {
        wallet.usingCustomBWS = config.bwsFor && config.bwsFor[wallet.id] && (config.bwsFor[wallet.id] != defaults.bws.url);
        wallet.name = (config.aliasFor && config.aliasFor[wallet.id]) || wallet.credentials.walletName;
        wallet.color = (config.colorFor && config.colorFor[wallet.id]);
        wallet.email = config.emailFor && config.emailFor[wallet.id];
      });
    }

    root.setBackupFlag = function(walletId) {
      storageService.setBackupFlag(walletId, function(err) {
        if (err) $log.error(err);
        $log.debug('Backup flag stored');
        root.wallet[walletId].needsBackup = false;
      });
    };

    function _requiresBackup(wallet) {
      if (wallet.isPrivKeyExternal()) return false;
      if (!wallet.credentials.mnemonic) return false;
      if (wallet.credentials.network == 'testnet') return false;

      return true;
    };

    function _needsBackup(wallet, cb) {
      if (!_requiresBackup(wallet))
        return cb(false);

      storageService.getBackupFlag(wallet.credentials.walletId, function(err, val) {
        if (err) $log.error(err);
        if (val) return cb(false);
        return cb(true);
      });
    };

    function _balanceIsHidden(wallet, cb) {
      storageService.getHideBalanceFlag(wallet.credentials.walletId, function(err, shouldHideBalance) {
        if (err) $log.error(err);
        var hideBalance = (shouldHideBalance == 'true') ? true : false;
        return cb(hideBalance);
      });
    };
    // Adds a wallet client to profileService
    root.bindWalletClient = function(wallet, opts) {
      var opts = opts || {};
      var walletId = wallet.credentials.walletId;

      if ((root.wallet[walletId] && root.wallet[walletId].started) && !opts.force) {
        return false;
      }

      // INIT WALLET VIEWMODEL
      wallet.id = walletId;
      wallet.started = true;
      wallet.doNotVerifyPayPro = isChromeApp;
      wallet.network = wallet.credentials.network;
      wallet.copayerId = wallet.credentials.copayerId;
      wallet.m = wallet.credentials.m;
      wallet.n = wallet.credentials.n;
      wallet.coin = wallet.credentials.coin;

      root.updateWalletSettings(wallet);
      root.wallet[walletId] = wallet;

      _needsBackup(wallet, function(val) {
        wallet.needsBackup = val;
      });

      _balanceIsHidden(wallet, function(val) {
        wallet.balanceHidden = val;
      });

      wallet.removeAllListeners();

      wallet.on('report', function(n) {
        $log.info('BWC Report:' + n);
      });

      wallet.on('notification', function(n) {

        $log.debug('BWC Notification:', n);

        if (n.type == "NewBlock" && n.data.network == "testnet") {
          throttledBwsEvent(n, wallet);
        } else newBwsEvent(n, wallet);
      });

      wallet.on('walletCompleted', function() {
        $log.debug('Wallet completed');

        root.updateCredentials(JSON.parse(wallet.export()), function() {
          $rootScope.$emit('Local/WalletCompleted', walletId);
        });
      });

      wallet.initialize({
        notificationIncludeOwn: true,
      }, function(err) {
        if (err) {
          $log.error('Could not init notifications err:', err);
          return;
        }
        wallet.setNotificationsInterval(UPDATE_PERIOD);
        wallet.openWallet(function(err) {
          if (wallet.status !== true)
            $log.debug('Wallet + ' + walletId + ' status:' + wallet.status)
        });
      });

      $rootScope.$on('Local/SettingsUpdated', function(e, walletId) {
        if (!walletId || walletId == wallet.id) {
          $log.debug('Updating settings for wallet:' + wallet.id);
          root.updateWalletSettings(wallet);
        }
      });

      return true;
    };

    var throttledBwsEvent = lodash.throttle(function(n, wallet) {
      newBwsEvent(n, wallet);
    }, 10000);

    var newBwsEvent = function(n, wallet) {
      if (wallet.cachedStatus)
        wallet.cachedStatus.isValid = false;

      if (wallet.completeHistory)
        wallet.completeHistory.isValid = false;

      if (wallet.cachedActivity)
        wallet.cachedActivity.isValid = false;

      if (wallet.cachedTxps)
        wallet.cachedTxps.isValid = false;

      $rootScope.$emit('bwsEvent', wallet.id, n.type, n);
    };

    var validationLock = false;

    root.runValidation = function(client, delay, retryDelay) {

      delay = delay || 500;
      retryDelay = retryDelay || 50;

      if (validationLock) {
        return $timeout(function() {
          $log.debug('ValidatingWallet Locked: Retrying in: ' + retryDelay);
          return root.runValidation(client, delay, retryDelay);
        }, retryDelay);
      }
      validationLock = true;

      // IOS devices are already checked
      var skipDeviceValidation = isIOS || root.profile.isDeviceChecked(platformInfo.ua);
      var walletId = client.credentials.walletId;

      $log.debug('ValidatingWallet: ' + walletId + ' skip Device:' + skipDeviceValidation);
      $timeout(function() {
        client.validateKeyDerivation({
          skipDeviceValidation: skipDeviceValidation,
        }, function(err, isOK) {
          validationLock = false;

          $log.debug('ValidatingWallet End:  ' + walletId + ' isOK:' + isOK);
          if (isOK) {
            root.profile.setChecked(platformInfo.ua, walletId);
          } else {
            $log.warn('Key Derivation failed for wallet:' + walletId);
            storageService.clearLastAddress(walletId, function() {});
          }

          root.storeProfileIfDirty();
        });
      }, delay);
    };

    var shouldSkipValidation = function(walletId) {
      return root.profile.isChecked(platformInfo.ua, walletId) || isIOS || isWindowsPhoneApp;
    }
    // Used when reading wallets from the profile
    root.bindWallet = function(credentials, cb) {
      if (!credentials.walletId || !credentials.m)
        return cb('bindWallet should receive credentials JSON');

      // Create the client
      var getBWSURL = function(walletId) {
        var config = configService.getSync();
        var defaults = configService.getDefaults();
        return ((config.bwsFor && config.bwsFor[walletId]) || defaults.bws.url);
      };

      var client = bwcService.getClient(JSON.stringify(credentials), {
        bwsurl: getBWSURL(credentials.walletId),
      });



      var skipKeyValidation = shouldSkipValidation(credentials.walletId);
      if (!skipKeyValidation)
        root.runValidation(client, 500);

      $log.info('Binding wallet:' + credentials.walletId + ' Validating?:' + !skipKeyValidation);
      return cb(null, root.bindWalletClient(client));
    };

    root.bindProfile = function(profile, cb) {
      root.profile = profile;

      configService.get(function(err) {
        $log.debug('Preferences read');
        if (err) return cb(err);

        function bindWallets(cb) {
          var l = root.profile.credentials.length;
          var i = 0,
            totalBound = 0;

          if (!l) return cb();

          lodash.each(root.profile.credentials, function(credentials) {
            root.bindWallet(credentials, function(err, bound) {
              i++;
              totalBound += bound;
              if (i == l) {
                $log.info('Bound ' + totalBound + ' out of ' + l + ' wallets');
                return cb();
              }
            });
          });
        }

        bindWallets(function() {
          root.isBound = true;

          lodash.each(root._queue, function(x) {
            $timeout(function() {
              return x();
            }, 1);
          });
          root._queue = [];



          root.isDisclaimerAccepted(function(val) {
            if (!val) {
              return cb(new Error('NONAGREEDDISCLAIMER: Non agreed disclaimer'));
            }
            return cb();
          });
        });
      });
    };

    root._queue = [];
    root.whenAvailable = function(cb) {
      if (!root.isBound) {
        root._queue.push(cb);
        return;
      }
      return cb();
    };

    root.loadAndBindProfile = function(cb) {
      storageService.getProfile(function(err, profile) {
        if (err) {
          $rootScope.$emit('Local/DeviceError', err);
          return cb(err);
        }
        if (!profile) {
          // Migration??
          storageService.tryToMigrate(function(err, migratedProfile) {
            if (err) return cb(err);
            if (!migratedProfile)
              return cb(new Error('NOPROFILE: No profile'));

            profile = migratedProfile;
            return root.bindProfile(profile, cb);
          })
        } else {
          $log.debug('Profile read');
          return root.bindProfile(profile, cb);
        }
      });
    };

    var seedWallet = function(opts, cb) {
      opts = opts || {};
      var walletClient = bwcService.getClient(null, opts);
      var network = opts.networkName || 'livenet';

      if (opts.mnemonic) {
        try {
          opts.mnemonic = root._normalizeMnemonic(opts.mnemonic);
          walletClient.seedFromMnemonic(opts.mnemonic, {
            network: network,
            passphrase: opts.passphrase,
            account: opts.account || 0,
            derivationStrategy: opts.derivationStrategy || 'BIP44',
            coin: opts.coin
          });

        } catch (ex) {
          $log.info(ex);
          return cb(gettextCatalog.getString('Could not create: Invalid wallet recovery phrase'));
        }
      } else if (opts.extendedPrivateKey) {
        try {
          walletClient.seedFromExtendedPrivateKey(opts.extendedPrivateKey, {
            network: network,
            account: opts.account || 0,
            derivationStrategy: opts.derivationStrategy || 'BIP44',
            coin: opts.coin,
          });
        } catch (ex) {
          $log.warn(ex);
          return cb(gettextCatalog.getString('Could not create using the specified extended private key'));
        }
      } else if (opts.extendedPublicKey) {
        try {
          walletClient.seedFromExtendedPublicKey(opts.extendedPublicKey, opts.externalSource, opts.entropySource, {
            account: opts.account || 0,
            derivationStrategy: opts.derivationStrategy || 'BIP44',
            coin: opts.coin
          });
          walletClient.credentials.hwInfo = opts.hwInfo;
        } catch (ex) {
          $log.warn("Creating wallet from Extended Public Key Arg:", ex, opts);
          return cb(gettextCatalog.getString('Could not create using the specified extended public key'));
        }
      } else {
        var lang = uxLanguage.getCurrentLanguage();
        try {
          walletClient.seedFromRandomWithMnemonic({
            network: network,
            passphrase: opts.passphrase,
            language: lang,
            account: 0,
            coin: opts.coin
          });
        } catch (e) {
          $log.info('Error creating recovery phrase: ' + e.message);
          if (e.message.indexOf('language') > 0) {
            $log.info('Using default language for recovery phrase');
            walletClient.seedFromRandomWithMnemonic({
              network: network,
              passphrase: opts.passphrase,
              account: 0,
              coin: opts.coin
            });
          } else {
            return cb(e);
          }
        }
      }
      return cb(null, walletClient);
    };

    // Creates a wallet on BWC/BWS
    var doCreateWallet = function(opts, cb) {
      var showOpts = lodash.clone(opts);
      if (showOpts.extendedPrivateKey) showOpts.extendedPrivateKey='[hidden]';
      if (showOpts.mnemonic) showOpts.mnemonic='[hidden]';

      $log.debug('Creating Wallet:', showOpts);
      $timeout(function() {
        seedWallet(opts, function(err, walletClient) {
          if (err) return cb(err);

          var name = opts.name || gettextCatalog.getString('Personal Wallet');
          var myName = opts.myName || gettextCatalog.getString('me');

          walletClient.createWallet(name, myName, opts.m, opts.n, {
            network: opts.networkName,
            singleAddress: opts.singleAddress,
            walletPrivKey: opts.walletPrivKey,
            coin: opts.coin
          }, function(err, secret) {
            if (err) return bwcError.cb(err, gettextCatalog.getString('Error creating wallet'), cb);
            return cb(null, walletClient, secret);
          });
        });
      }, 50);
    };

    // create and store a wallet
    root.createWallet = function(opts, cb) {
      doCreateWallet(opts, function(err, walletClient, secret) {
        if (err) return cb(err);

        addAndBindWalletClient(walletClient, {
          bwsurl: opts.bwsurl
        }, cb);
      });
    };

    // joins and stores a wallet
    root.joinWallet = function(opts, cb) {
      var walletClient = bwcService.getClient();
      $log.debug('Joining Wallet:', opts);

      try {
        var walletData = bwcService.parseSecret(opts.secret);

        // check if exist
        if (lodash.find(root.profile.credentials, {
            'walletId': walletData.walletId
          })) {
          return cb(gettextCatalog.getString('Cannot join the same wallet more that once'));
        }
      } catch (ex) {
        $log.debug(ex);
        return cb(gettextCatalog.getString('Bad wallet invitation'));
      }
      opts.networkName = walletData.network;
      $log.debug('Joining Wallet:', opts);

      seedWallet(opts, function(err, walletClient) {
        if (err) return cb(err);

        walletClient.joinWallet(opts.secret, opts.myName || 'me', {
          coin: opts.coin
        }, function(err) {
          if (err) return bwcError.cb(err, gettextCatalog.getString('Could not join wallet'), cb);
          addAndBindWalletClient(walletClient, {
            bwsurl: opts.bwsurl
          }, cb);
        });
      });
    };

    root.getWallet = function(walletId) {
      return root.wallet[walletId];
    };


    root.deleteWalletClient = function(client, cb) {
      var walletId = client.credentials.walletId;

      var config = configService.getSync();

      $log.debug('Deleting Wallet:', client.credentials.walletName);
      client.removeAllListeners();

      root.profile.deleteWallet(walletId);

      delete root.wallet[walletId];

      storageService.removeAllWalletData(walletId, function(err) {
        if (err) $log.warn(err);
      });

      storageService.storeProfile(root.profile, function(err) {
        if (err) return cb(err);
        return cb();
      });
    };

    root.setMetaData = function(walletClient, addressBook, cb) {
      storageService.getAddressbook(walletClient.credentials.network, function(err, localAddressBook) {
        var localAddressBook1 = {};
        try {
          localAddressBook1 = JSON.parse(localAddressBook);
        } catch (ex) {
          $log.warn(ex);
        }
        var mergeAddressBook = lodash.merge(addressBook, localAddressBook1);
        storageService.setAddressbook(walletClient.credentials.network, JSON.stringify(addressBook), function(err) {
          if (err) return cb(err);
          return cb(null);
        });
      });
    }

    // Adds and bind a new client to the profile
    var addAndBindWalletClient = function(client, opts, cb) {
      if (!client || !client.credentials)
        return cb(gettextCatalog.getString('Could not access wallet'));

      var walletId = client.credentials.walletId

      if (!root.profile.addWallet(JSON.parse(client.export())))
        return cb(gettextCatalog.getString("Wallet already in {{appName}}", {
          appName: appConfigService.nameCase
        }));


      var skipKeyValidation = shouldSkipValidation(walletId);
      if (!skipKeyValidation)
        root.runValidation(client);

      root.bindWalletClient(client);

      var saveBwsUrl = function(cb) {
        var defaults = configService.getDefaults();
        var bwsFor = {};
        bwsFor[walletId] = opts.bwsurl || defaults.bws.url;

        // Dont save the default
        if (bwsFor[walletId] == defaults.bws.url)
          return cb();

        configService.set({
          bwsFor: bwsFor,
        }, function(err) {
          if (err) $log.warn(err);
          return cb();
        });
      };

      saveBwsUrl(function() {
        storageService.storeProfile(root.profile, function(err) {
          return cb(err, client);
        });
      });
    };

    root.storeProfileIfDirty = function(cb) {
      if (root.profile.dirty) {
        storageService.storeProfile(root.profile, function(err) {
          $log.debug('Saved modified Profile');
          if (cb) return cb(err);
        });
      } else {
        if (cb) return cb();
      };
    };

    root.importWallet = function(str, opts, cb) {

      var walletClient = bwcService.getClient(null, opts);

      $log.debug('Importing Wallet:', opts);

      try {
        var c = JSON.parse(str);

        if (c.xPrivKey && c.xPrivKeyEncrypted) {
          $log.warn('Found both encrypted and decrypted key. Deleting the encrypted version');
          delete c.xPrivKeyEncrypted;
          delete c.mnemonicEncrypted;
        }

        str = JSON.stringify(c);

        walletClient.import(str, {
          compressed: opts.compressed,
          password: opts.password
        });
      } catch (err) {
        return cb(gettextCatalog.getString('Could not import. Check input file and spending password'));
      }

      str = JSON.parse(str);

      if (!str.n) {
        return cb("Backup format not recognized. If you are using a Copay Beta backup and version is older than 0.10, please see: https://github.com/bitpay/copay/issues/4730#issuecomment-244522614");
      }

      var addressBook = str.addressBook || {};

      addAndBindWalletClient(walletClient, {
        bwsurl: opts.bwsurl
      }, function(err, walletId) {
        if (err) return cb(err);
        root.setMetaData(walletClient, addressBook, function(error) {
          if (error) $log.warn(error);
          return cb(err, walletClient);
        });
      });
    };

    root.importExtendedPrivateKey = function(xPrivKey, opts, cb) {
      var walletClient = bwcService.getClient(null, opts);
      $log.debug('Importing Wallet xPrivKey');

      walletClient.importFromExtendedPrivateKey(xPrivKey, opts, function(err) {
        if (err) {
          if (err instanceof errors.NOT_AUTHORIZED)
            return cb(err);

          return bwcError.cb(err, gettextCatalog.getString('Could not import'), cb);
        }

        addAndBindWalletClient(walletClient, {
          bwsurl: opts.bwsurl
        }, cb);
      });
    };

    root._normalizeMnemonic = function(words) {
      if (!words || !words.indexOf) return words;
      var isJA = words.indexOf('\u3000') > -1;
      var wordList = words.split(/[\u3000\s]+/);

      return wordList.join(isJA ? '\u3000' : ' ');
    };

    root.importMnemonic = function(words, opts, cb) {
      var walletClient = bwcService.getClient(null, opts);

      $log.debug('Importing Wallet Mnemonic');

      words = root._normalizeMnemonic(words);
      walletClient.importFromMnemonic(words, {
        network: opts.networkName,
        passphrase: opts.passphrase,
        entropySourcePath: opts.entropySourcePath,
        derivationStrategy: opts.derivationStrategy || 'BIP44',
        account: opts.account || 0,
        coin: opts.coin
      }, function(err) {
        if (err) {
          if (err instanceof errors.NOT_AUTHORIZED)
            return cb(err);

          return bwcError.cb(err, gettextCatalog.getString('Could not import'), cb);
        }

        addAndBindWalletClient(walletClient, {
          bwsurl: opts.bwsurl
        }, cb);
      });
    };

    root.importExtendedPublicKey = function(opts, cb) {
      var walletClient = bwcService.getClient(null, opts);
      $log.debug('Importing Wallet XPubKey');

      walletClient.importFromExtendedPublicKey(opts.extendedPublicKey, opts.externalSource, opts.entropySource, {
        account: opts.account || 0,
        derivationStrategy: opts.derivationStrategy || 'BIP44',
        coin: opts.coin
      }, function(err) {
        if (err) {

          // in HW wallets, req key is always the same. They can't addAccess.
          if (err instanceof errors.NOT_AUTHORIZED)
            err.name = 'WALLET_DOES_NOT_EXIST';

          return bwcError.cb(err, gettextCatalog.getString('Could not import'), cb);
        }

        addAndBindWalletClient(walletClient, {
          bwsurl: opts.bwsurl
        }, cb);
      });
    };

    root.createProfile = function(cb) {
      $log.info('Creating profile');
      var defaults = configService.getDefaults();

      configService.get(function(err) {
        if (err) $log.debug(err);

        var p = Profile.create();
        storageService.storeNewProfile(p, function(err) {
          if (err) return cb(err);
          root.bindProfile(p, function(err) {
            // ignore NONAGREEDDISCLAIMER
            if (err && err.toString().match('NONAGREEDDISCLAIMER')) return cb();
            return cb(err);
          });
        });
      });
    };

    root.createDefaultWallet = function(cb) {
      var opts = {};
      opts.m = 1;
      opts.n = 1;
      opts.networkName = 'livenet';
      opts.coin = 'btcz';
      root.createWallet(opts, cb);
    };

    root.setDisclaimerAccepted = function(cb) {
      root.profile.disclaimerAccepted = true;
      storageService.storeProfile(root.profile, function(err) {
        return cb(err);
      });
    };

    root.isDisclaimerAccepted = function(cb) {
      var disclaimerAccepted = root.profile && root.profile.disclaimerAccepted;
      if (disclaimerAccepted)
        return cb(true);

      // OLD flag
      storageService.getCopayDisclaimerFlag(function(err, val) {
        if (val) {
          root.profile.disclaimerAccepted = true;
          return cb(true);
        } else {
          return cb();
        }
      });
    };

    root.updateCredentials = function(credentials, cb) {
      root.profile.updateWallet(credentials);
      storageService.storeProfile(root.profile, cb);
    };

    root.getLastKnownBalance = function(wid, cb) {
      storageService.getBalanceCache(wid, cb);
    };

    root.addLastKnownBalance = function(wallet, cb) {
      var now = Math.floor(Date.now() / 1000);
      var showRange = 600; // 10min;

      root.getLastKnownBalance(wallet.id, function(err, data) {
        if (data) {
          data = JSON.parse(data);
          wallet.cachedBalance = data.balance;
          wallet.cachedBalanceUpdatedOn = (data.updatedOn < now - showRange) ? data.updatedOn : null;
        }
        return cb();
      });
    };

    root.setLastKnownBalance = function(wid, balance, cb) {
      storageService.setBalanceCache(wid, {
        balance: balance,
        updatedOn: Math.floor(Date.now() / 1000),
      }, cb);
    };

    root.getWallets = function(opts) {

      if (opts && !lodash.isObject(opts))
        throw "bad argument";

      opts = opts || {};

      var ret = lodash.values(root.wallet);

      if (opts.coin) {
        ret = lodash.filter(ret, function(x) {
          return (x.credentials.coin == opts.coin);
        });
      }

      if (opts.network) {
        ret = lodash.filter(ret, function(x) {
          return (x.credentials.network == opts.network);
        });
      }

      if (opts.n) {
        ret = lodash.filter(ret, function(w) {
          return (w.credentials.n == opts.n);
        });
      }

      if (opts.m) {
        ret = lodash.filter(ret, function(w) {
          return (w.credentials.m == opts.m);
        });
      }

      if (opts.hasFunds) {
        ret = lodash.filter(ret, function(w) {
          if (!w.status) return;
          return (w.status.availableBalanceSat > 0);
        });
      }

      if (opts.minAmount) {
        ret = lodash.filter(ret, function(w) {
          if (!w.status) return;
          return (w.status.availableBalanceSat > opts.minAmount);
        });
      }

      if (opts.onlyComplete) {
        ret = lodash.filter(ret, function(w) {
          return w.isComplete();
        });
      } else {}

      // Add cached balance async
      lodash.each(ret, function(x) {
        root.addLastKnownBalance(x, function() {});
      });


      return lodash.sortBy(ret, [

        function(x) {
          return x.isComplete();
        }, 'createdOn'
      ]);
    };

    root.toggleHideBalanceFlag = function(walletId, cb) {
      root.wallet[walletId].balanceHidden = !root.wallet[walletId].balanceHidden;
      storageService.setHideBalanceFlag(walletId, root.wallet[walletId].balanceHidden.toString(), cb);
    };

    root.getNotifications = function(opts, cb) {
      opts = opts || {};

      var TIME_STAMP = 60 * 60 * 6;
      var MAX = 30;

      var typeFilter = {
        'NewOutgoingTx': 1,
        'NewIncomingTx': 1
      };

      var w = root.getWallets();
      if (lodash.isEmpty(w)) return cb();

      var l = w.length,
        j = 0,
        notifications = [];


      function isActivityCached(wallet) {
        return wallet.cachedActivity && wallet.cachedActivity.isValid;
      };


      function updateNotifications(wallet, cb2) {
        if (isActivityCached(wallet) && !opts.force) return cb2();

        wallet.getNotifications({
          timeSpan: TIME_STAMP,
          includeOwn: true,
        }, function(err, n) {
          if (err) return cb2(err);

          wallet.cachedActivity = {
            n: n.slice(-MAX),
            isValid: true,
          };

          return cb2();
        });
      };

      function process(notifications) {
        if (!notifications) return [];

        var shown = lodash.sortBy(notifications, 'createdOn').reverse();

        shown = shown.splice(0, opts.limit || MAX);

        lodash.each(shown, function(x) {
          x.txpId = x.data ? x.data.txProposalId : null;
          x.txid = x.data ? x.data.txid : null;
          x.types = [x.type];

          if (x.data && x.data.amount)
            x.amountStr = txFormatService.formatAmountStr(x.wallet.coin, x.data.amount);

          x.action = function() {
            // TODO?
            // $state.go('tabs.wallet', {
            //   walletId: x.walletId,
            //   txpId: x.txpId,
            //   txid: x.txid,
            // });
          };
        });

        var finale = shown; // GROUPING DISABLED!

        var finale = [],
          prev;


        // Item grouping... DISABLED.

        // REMOVE (if we want 1-to-1 notification) ????
        lodash.each(shown, function(x) {
          if (prev && prev.walletId === x.walletId && prev.txpId && prev.txpId === x.txpId && prev.creatorId && prev.creatorId === x.creatorId) {
            prev.types.push(x.type);
            prev.data = lodash.assign(prev.data, x.data);
            prev.txid = prev.txid || x.txid;
            prev.amountStr = prev.amountStr || x.amountStr;
            prev.creatorName = prev.creatorName || x.creatorName;
          } else {
            finale.push(x);
            prev = x;
          }
        });

        var u = bwcService.getUtils();
        lodash.each(finale, function(x) {
          if (x.data && x.data.message && x.wallet && x.wallet.credentials.sharedEncryptingKey) {
            // TODO TODO TODO => BWC
            x.message = u.decryptMessage(x.data.message, x.wallet.credentials.sharedEncryptingKey);
          }
        });

        return finale;
      };

      lodash.each(w, function(wallet) {
        updateNotifications(wallet, function(err) {
          j++;
          if (err) {
            $log.warn('Error updating notifications:' + err);
          } else {

            var n;

            n = lodash.filter(wallet.cachedActivity.n, function(x) {
              return typeFilter[x.type];
            });

            var idToName = {};
            if (wallet.cachedStatus) {
              lodash.each(wallet.cachedStatus.wallet.copayers, function(c) {
                idToName[c.id] = c.name;
              });
            }

            lodash.each(n, function(x) {
              x.wallet = wallet;
              if (x.creatorId && wallet.cachedStatus) {
                x.creatorName = idToName[x.creatorId];
              };
            });

            notifications.push(n);
          }
          if (j == l) {
            notifications = lodash.sortBy(notifications, 'createdOn');
            notifications = lodash.compact(lodash.flatten(notifications)).slice(0, MAX);
            var total = notifications.length;
            return cb(null, process(notifications), total);
          };
        });
      });
    };


    root.getTxps = function(opts, cb) {
      var MAX = 100;
      opts = opts || {};

      var w = root.getWallets();
      if (lodash.isEmpty(w)) return cb();

      var txps = [];

      lodash.each(w, function(x) {
        if (x.pendingTxps)
          txps = txps.concat(x.pendingTxps);
      });
      var n = txps.length;
      txps = lodash.sortBy(txps, 'pendingForUs', 'createdOn');
      txps = lodash.compact(lodash.flatten(txps)).slice(0, opts.limit || MAX);
      return cb(null, txps, n);
    };

    return root;
  });

'use strict';
angular.module('copayApp.services').factory('pushNotificationsService', function pushNotificationsService($log, $state, $ionicHistory, sjcl, platformInfo, lodash, appConfigService, profileService, configService) {
  var root = {};
  var isIOS = platformInfo.isIOS;
  var isAndroid = platformInfo.isAndroid;
  var usePushNotifications = platformInfo.isCordova && !platformInfo.isWP;

  var _token = null;

  root.init = function() {
    if (!usePushNotifications || _token) return;
    configService.whenAvailable(function(config) {
      if (!config.pushNotificationsEnabled) return;
    
      $log.debug('Starting push notification registration...'); 

      //Keep in mind the function will return null if the token has not been established yet.
      FCMPlugin.getToken(function(token) {
        $log.debug('Get token for push notifications: ' + token);
        _token = token;
        root.enable();
      }); 
    }); 
  };

  root.updateSubscription = function(walletClient) {
    if (!_token) {
      $log.warn('Push notifications disabled for this device. Nothing to do here.');
      return;
    }
    _subscribe(walletClient);
  };

  root.enable = function() {
    if (!_token) {
      $log.warn('No token available for this device. Cannot set push notifications. Needs registration.');
      return;
    }

    var wallets = profileService.getWallets();
    lodash.forEach(wallets, function(walletClient) {
      _subscribe(walletClient);
    });
  };

  root.disable = function() {
    if (!_token) {
      $log.warn('No token available for this device. Cannot disable push notifications.');
      return;
    }

    var wallets = profileService.getWallets();
    lodash.forEach(wallets, function(walletClient) {
      _unsubscribe(walletClient);
    });
    _token = null;
  };

  root.unsubscribe = function(walletClient) {
    if (!_token) return;
    _unsubscribe(walletClient);
  };

  var _subscribe = function(walletClient) {
    var opts = {
      token : _token,
      platform: isIOS ? 'ios' : isAndroid ? 'android' : null,
      packageName : appConfigService.packageNameId
    };
    walletClient.pushNotificationsSubscribe(opts, function(err) {
      if (err) $log.error(walletClient.name + ': Subscription Push Notifications error. ', JSON.stringify(err));
      else $log.debug(walletClient.name + ': Subscription Push Notifications success.');
    });
  };

  var _unsubscribe = function(walletClient, cb) {
    walletClient.pushNotificationsUnsubscribe(_token, function(err) {
      if (err) $log.error(walletClient.name + ': Unsubscription Push Notifications error. ', JSON.stringify(err));
      else $log.debug(walletClient.name + ': Unsubscription Push Notifications Success.');
    });
  };

  var _openWallet = function(walletIdHashed) {
    var wallets = profileService.getWallets();
    var wallet = lodash.find(wallets, function(w) {
      return (lodash.isEqual(walletIdHashed, sjcl.codec.hex.fromBits(sjcl.hash.sha256.hash(w.id))));
    });

    if (!wallet) return;
    
    if (!wallet.isComplete()) {
      return $state.go('tabs.copayers', {
        walletId: wallet.id 
      });
    }

    $state.go('tabs.wallet', {
      walletId: wallet.id
    });
  };

  if (usePushNotifications) {
    
    FCMPlugin.onTokenRefresh(function(token) {
      if (!_token) return;
      $log.debug('Refresh and update token for push notifications...');
      _token = token;
      root.enable();
    });

    FCMPlugin.onNotification(function(data) {
      if (!_token) return;
      $log.debug('New Event Push onNotification: ' + JSON.stringify(data));
      if(data.wasTapped) {
        // Notification was received on device tray and tapped by the user. 
        var walletIdHashed = data.walletId;
        if (!walletIdHashed) return;
        $ionicHistory.nextViewOptions({
          disableAnimate: true,
          historyRoot: true
        });
        $ionicHistory.clearHistory();
        $state.go('tabs.home', {}, {
          'reload': true,
          'notify': $state.current.name == 'tabs.home' ? false : true
        }).then(function() {
          _openWallet(walletIdHashed);
        });
      } else {
        // TODO
        // Notification was received in foreground. Maybe the user needs to be notified. 
      }
    });
  } 

  return root;

});

'use strict';

//var util = require('util');
//var _ = require('lodash');
//var log = require('../util/log');
//var preconditions = require('preconditions').singleton();
//var request = require('request');

/*
  This class lets interfaces with BitPay's exchange rate API.
*/

var RateService = function(opts) {
  var self = this;

  opts = opts || {};
  self.httprequest = opts.httprequest; // || request;
  self.lodash = opts.lodash;

  self.SAT_TO_BTCZ = 1 / 1e8;
  self.BTCZ_TO_SAT = 1e8;
  self.UNAVAILABLE_ERROR = 'Service is not available - check for service.isAvailable() or use service.whenAvailable()';
  self.UNSUPPORTED_CURRENCY_ERROR = 'Currency not supported';

  self._isAvailable = false;
  self._rates = {};
  self._alternatives = [];
  self._ratesBCH = {};
  self._queued = [];

  self.updateRates();
};


var _instance;
RateService.singleton = function(opts) {
  if (!_instance) {
    _instance = new RateService(opts);
  }
  return _instance;
};

RateService.prototype.updateRates = function() {
  var self = this;

  var backoffSeconds = 5;
  var updateFrequencySeconds = 5 * 60;
  var rateServiceUrl = 'https://bitpay.com/api/rates';
  var bchRateServiceUrl = 'https://api.kraken.com/0/public/Ticker?pair=BCHUSD,BCHEUR';


  function getBTCZ(cb, tries) {
    tries = tries || 0;
    if (!self.httprequest) return;
    if (tries > 5) return cb('could not get BTCZ rates');

    //log.info('Fetching exchange rates');
    self.httprequest.get(rateServiceUrl).success(function(res) {
      self.lodash.each(res, function(currency) {
        self._rates[currency.code] = currency.rate;
        self._alternatives.push({
          name: currency.name,
          isoCode: currency.code,
          rate: currency.rate
        });
      });

      return cb();
    }).error(function() {
      //log.debug('Error fetching exchange rates', err);
      setTimeout(function() {
        backoffSeconds *= 1.5;
        getBTCZ(cb, tries++);
      }, backoffSeconds * 1000);
      return;
    })
  }

  function getBCH(cb, tries) {
    tries = tries || 0;
    if (!self.httprequest) return;
    if (tries > 5) return cb('could not get BCH rates');

    function retry(tries) {
      //log.debug('Error fetching exchange rates', err);
      setTimeout(function() {
        backoffSeconds *= 1.5;
        getBTCZ(cb, tries++);
      }, backoffSeconds * 1000);
      return;
    }

    self.httprequest.get(bchRateServiceUrl).success(function(res) {
      self.lodash.each(res.result, function(data, paircode) {
        var code = paircode.substr(3,3);
        var rate =data.c[0];
        self._ratesBCH[code] = rate;
      })
      return cb();
    }).error(function() {
      return retry(tries);
    })
  }

  getBTCZ(function(err) {
    if (err) return;
    getBCH(function(err) {
      if (err) return;

      self._isAvailable = true;
      self.lodash.each(self._queued, function(callback) {
        setTimeout(callback, 1);
      });
      setTimeout( self.updateRates  , updateFrequencySeconds * 1000);
    })
  })

};

RateService.prototype.getRate = function(code, chain) {
  if (chain == 'bch')
    return this._ratesBCH[code];
  else
    return this._rates[code];
};

RateService.prototype.getAlternatives = function() {
  return this._alternatives;
};

RateService.prototype.isAvailable = function() {
  return this._isAvailable;
};

RateService.prototype.whenAvailable = function(callback) {
  if (this.isAvailable()) {
    setTimeout(callback, 10);
  } else {
    this._queued.push(callback);
  }
};

RateService.prototype.toFiat = function(satoshis, code, chain) {
  if (!this.isAvailable()) {
    return null;
  }

  return satoshis * this.SAT_TO_BTCZ * this.getRate(code, chain);
};

RateService.prototype.fromFiat = function(amount, code, chain) {
  if (!this.isAvailable()) {
    return null;
  }
  return amount / this.getRate(code, chain) * this.BTCZ_TO_SAT;
};

RateService.prototype.listAlternatives = function(sort) {
  var self = this;
  if (!this.isAvailable()) {
    return [];
  }

  var alternatives = self.lodash.map(this.getAlternatives(), function(item) {
    return {
      name: item.name,
      isoCode: item.isoCode
    }
  });
  if (sort) {
    alternatives.sort(function(a, b) {
      return a.name.toLowerCase() > b.name.toLowerCase() ? 1 : -1;
    });
  }
  return self.lodash.uniq(alternatives, 'isoCode');
};

angular.module('copayApp.services').factory('rateService', function($http, lodash) {
  // var cfg = _.extend(config.rates, {
  //   httprequest: $http
  // });

  var cfg = {
    httprequest: $http,
    lodash: lodash
  };
  return RateService.singleton(cfg);
});

'use strict';

angular.module('copayApp.services').service('scannerService', function($log, $timeout, platformInfo, $rootScope, $window) {

  var isDesktop = !platformInfo.isCordova;
  var QRScanner = $window.QRScanner;
  var lightEnabled = false;
  var backCamera = true; // the plugin defaults to the back camera

  // Initalize known capabilities
  // Assume camera is available. If init fails, we'll set this to false.
  var isAvailable = true;
  var hasPermission = false;
  var isDenied = false;
  var isRestricted = false;
  var canEnableLight = false;
  var canChangeCamera = false;
  var canOpenSettings = false;

  function _checkCapabilities(status) {
    $log.debug('scannerService is reviewing platform capabilities...');
    // Permission can be assumed on the desktop builds
    hasPermission = (isDesktop || status.authorized) ? true : false;
    isDenied = status.denied ? true : false;
    isRestricted = status.restricted ? true : false;
    canEnableLight = status.canEnableLight ? true : false;
    canChangeCamera = status.canChangeCamera ? true : false;
    canOpenSettings = status.canOpenSettings ? true : false;
    _logCapabilities();
  }

  function _logCapabilities() {
    function _orIsNot(bool) {
      return bool ? '' : 'not ';
    }
    $log.debug('A camera is ' + _orIsNot(isAvailable) + 'available to this app.');
    var access = 'not authorized';
    if (hasPermission) access = 'authorized';
    if (isDenied) access = 'denied';
    if (isRestricted) access = 'restricted';
    $log.debug('Camera access is ' + access + '.');
    $log.debug('Support for opening device settings is ' + _orIsNot(canOpenSettings) + 'available on this platform.');
    $log.debug('A light is ' + _orIsNot(canEnableLight) + 'available on this platform.');
    $log.debug('A second camera is ' + _orIsNot(canChangeCamera) + 'available on this platform.');
  }

  /**
   * Immediately return known capabilities of the current platform.
   */
  this.getCapabilities = function() {
    return {
      isAvailable: isAvailable,
      hasPermission: hasPermission,
      isDenied: isDenied,
      isRestricted: isRestricted,
      canEnableLight: canEnableLight,
      canChangeCamera: canChangeCamera,
      canOpenSettings: canOpenSettings
    };
  };

  var initializeStarted = false;
  /**
   * If camera access has been granted, pre-initialize the QRScanner. This method
   * can be safely called before the scanner is visible to improve perceived
   * scanner loading times.
   *
   * The `status` of QRScanner is returned to the callback.
   */
  this.gentleInitialize = function(callback) {
    if (initializeStarted && !isDesktop) {
      QRScanner.getStatus(function(status) {
        _completeInitialization(status, callback);
      });
      return;
    }
    initializeStarted = true;
    $log.debug('Trying to pre-initialize QRScanner.');
    if (!isDesktop) {
      QRScanner.getStatus(function(status) {
        _checkCapabilities(status);
        if (status.authorized) {
          $log.debug('Camera permission already granted.');
          initialize(callback);
        } else {
          $log.debug('QRScanner not authorized, waiting to initalize.');
          _completeInitialization(status, callback);
        }
      });
    } else {
      $log.debug('To avoid flashing the privacy light, we do not pre-initialize the camera on desktop.');
    }
  };

  function initialize(callback) {
    $log.debug('Initializing scanner...');
    QRScanner.prepare(function(err, status) {
      if (err) {
        isAvailable = false;
        $log.error(err);
        // does not return `status` if there is an error
        QRScanner.getStatus(function(status) {
          _completeInitialization(status, callback);
        });
      } else {
        _completeInitialization(status, callback);
      }
    });
  }
  this.initialize = initialize;

  // This could be much cleaner with a Promise API
  // (needs a polyfill for some platforms)
  var initializeCompleted = false;

  function _completeInitialization(status, callback) {
    _checkCapabilities(status);
    initializeCompleted = true;
    $rootScope.$emit('scannerServiceInitialized');
    if (typeof callback === "function") {
      callback(status);
    }
  }
  this.isInitialized = function() {
    return initializeCompleted;
  };
  this.initializeStarted = function() {
    return initializeStarted;
  };

  var nextHide = null;
  var nextDestroy = null;
  var hideAfterSeconds = 5;
  var destroyAfterSeconds = 60;

  /**
   * (Re)activate the QRScanner, and cancel the timeouts if present.
   *
   * The `status` of QRScanner is passed to the callback when activation
   * is complete.
   */
  this.activate = function(callback) {
    $log.debug('Activating scanner...');
    QRScanner.show(function(status) {
      initializeCompleted = true;
      _checkCapabilities(status);
      if (typeof callback === "function") {
        callback(status);
      }
    });
    if (nextHide !== null) {
      $timeout.cancel(nextHide);
      nextHide = null;
    }
    if (nextDestroy !== null) {
      $timeout.cancel(nextDestroy);
      nextDestroy = null;
    }
  };

  /**
   * Start a new scan.
   *
   * The callback receives: (err, contents)
   */
  this.scan = function(callback) {
    $log.debug('Scanning...');
    QRScanner.scan(callback);
  };

  this.pausePreview = function() {
    QRScanner.pausePreview();
  };

  this.resumePreview = function() {
    QRScanner.resumePreview();
  };

  /**
   * Deactivate the QRScanner. To balance user-perceived performance and power
   * consumption, this kicks off a countdown which will "sleep" the scanner
   * after a certain amount of time.
   *
   * The `status` of QRScanner is passed to the callback when deactivation
   * is complete.
   */
  this.deactivate = function(callback) {
    $log.debug('Deactivating scanner...');
    QRScanner.cancelScan();
    nextHide = $timeout(_hide, hideAfterSeconds * 1000);
    nextDestroy = $timeout(_destroy, destroyAfterSeconds * 1000);
  };

  // Natively hide the QRScanner's preview
  // On mobile platforms, this can reduce GPU/power usage
  // On desktop, this fully turns off the camera (and any associated privacy lights)
  function _hide() {
    $log.debug('Scanner not in use for ' + hideAfterSeconds + ' seconds, hiding...');
    QRScanner.hide();
  }

  // Reduce QRScanner power/processing consumption by the maximum amount
  function _destroy() {
    $log.debug('Scanner not in use for ' + destroyAfterSeconds + ' seconds, destroying...');
    QRScanner.destroy();
  }

  this.reinitialize = function(callback) {
    initializeCompleted = false;
    QRScanner.destroy();
    initialize(callback);
  };

  /**
   * Toggle the device light (if available).
   *
   * The callback receives a boolean which is `true` if the light is enabled.
   */
  this.toggleLight = function(callback) {
    $log.debug('Toggling light...');
    if (lightEnabled) {
      QRScanner.disableLight(_handleResponse);
    } else {
      QRScanner.enableLight(_handleResponse);
    }

    function _handleResponse(err, status) {
      if (err) {
        $log.error(err);
      } else {
        lightEnabled = status.lightEnabled;
        var state = lightEnabled ? 'enabled' : 'disabled';
        $log.debug('Light ' + state + '.');
      }
      callback(lightEnabled);
    }
  };

  /**
   * Switch cameras (if a second camera is available).
   *
   * The `status` of QRScanner is passed to the callback when activation
   * is complete.
   */
  this.toggleCamera = function(callback) {
    var nextCamera = backCamera ? 1 : 0;

    function cameraToString(index) {
      return index === 1 ? 'front' : 'back'; // front = 1, back = 0
    }
    $log.debug('Toggling to the ' + cameraToString(nextCamera) + ' camera...');
    QRScanner.useCamera(nextCamera, function(err, status) {
      if (err) {
        $log.error(err);
      }
      backCamera = status.currentCamera === 1 ? false : true;
      $log.debug('Camera toggled. Now using the ' + cameraToString(backCamera) + ' camera.');
      callback(status);
    });
  };

  this.openSettings = function() {
    $log.debug('Attempting to open device settings...');
    QRScanner.openSettings();
  };

  this.useOldScanner = function(callback) {
    cordova.plugins.barcodeScanner.scan(
      function(result) {
        callback(null, result.text);
      },
      function(error) {
        callback(error);
      }
    );
  }
});

'use strict';

angular.module('copayApp.services').service('sendMaxService', function(feeService, configService, walletService) {

  /**
   * Get sendMaxInfo
   *
   * @param {Obj} Wallet
   * @param {Callback} Function (optional)
   *
   */
  this.getInfo = function(wallet, cb) {
    feeService.getCurrentFeeRate(wallet.coin, wallet.credentials.network, function(err, feePerKb) {
      if (err) return cb(err);

      var config = configService.getSync().wallet;

      walletService.getSendMaxInfo(wallet, {
        feePerKb: feePerKb,
        excludeUnconfirmedUtxos: !config.spendUnconfirmed,
        returnInputs: true,
      }, function(err, resp) {
        if (err) return cb(err);

        return cb(null, {
          sendMax: true,
          amount: resp.amount,
          inputs: resp.inputs,
          fee: resp.fee,
          feePerKb: feePerKb,
        });
      });
    });
  };

});


'use strict';
angular.module('copayApp.services')
  .factory('sjcl', function bitcoreFactory(bwcService) {
    var sjcl = bwcService.getSJCL();
    return sjcl;
  });

'use strict';

angular.module('copayApp.services').service('startupService', function($log, $timeout) {

  var splashscreenVisible = true;
  var statusBarVisible = false;

  function _hideSplash(){
    if(typeof navigator.splashscreen !== "undefined" && splashscreenVisible){
      $log.debug('startupService is hiding the splashscreen...');
      $timeout(function(){
        navigator.splashscreen.hide();
      }, 20);
      splashscreenVisible = false;
    }
  }
  function _showStatusBar(){
    if(typeof StatusBar !== "undefined" && !statusBarVisible){
      $log.debug('startupService is showing the StatusBar...');
      StatusBar.show();
      statusBarVisible = true;
    }
  }
  this.ready = function() {
    _showStatusBar();
    _hideSplash();
  };
});

'use strict';
angular.module('copayApp.services')
  .factory('storageService', function(logHeader, fileStorageService, localStorageService, sjcl, $log, lodash, platformInfo, $timeout) {

    var root = {};
    var storage;

    // File storage is not supported for writing according to
    // https://github.com/apache/cordova-plugin-file/#supported-platforms
    var shouldUseFileStorage = platformInfo.isCordova && !platformInfo.isWP;

    if (shouldUseFileStorage) {
      $log.debug('Using: FileStorage');
      storage = fileStorageService;
    } else {
      $log.debug('Using: LocalStorage');
      storage = localStorageService;
    }

    var getUUID = function(cb) {
      // TO SIMULATE MOBILE
      //return cb('hola');
      if (!window || !window.plugins || !window.plugins.uniqueDeviceID)
        return cb(null);

      window.plugins.uniqueDeviceID.get(
        function(uuid) {
          return cb(uuid);
        }, cb);
    };

    // This is only used in Copay, we used to encrypt profile
    // using device's UUID.

    var decryptOnMobile = function(text, cb) {
      var json;
      try {
        json = JSON.parse(text);
      } catch (e) {
        $log.warn('Could not open profile:' + text);

        var i = text.lastIndexOf('}{');
        if (i > 0) {
          text = text.substr(i + 1);
          $log.warn('trying last part only:' + text);
          try {
            json = JSON.parse(text);
            $log.warn('Worked... saving.');
            storage.set('profile', text, function() {});
          } catch (e) {
            $log.warn('Could not open profile (2nd try):' + e);
          };
        };

      };

      if (!json) return cb('Could not access storage')

      if (!json.iter || !json.ct) {
        $log.debug('Profile is not encrypted');
        return cb(null, text);
      }

      $log.debug('Profile is encrypted');
      getUUID(function(uuid) {
        $log.debug('Device UUID:' + uuid);
        if (!uuid)
          return cb('Could not decrypt storage: could not get device ID');

        try {
          text = sjcl.decrypt(uuid, text);

          $log.info('Migrating to unencrypted profile');
          return storage.set('profile', text, function(err) {
            return cb(err, text);
          });
        } catch (e) {
          $log.warn('Decrypt error: ', e);
          return cb('Could not decrypt storage: device ID mismatch');
        };
        return cb(null, text);
      });
    };

    // This is only use in Copay, for very old instalations
    // in which we use to use localStorage instead of fileStorage
    root.tryToMigrate = function(cb) {
      if (!shouldUseFileStorage) return cb();

      localStorageService.get('profile', function(err, str) {
        if (err) return cb(err);
        if (!str) return cb();

        $log.info('Starting Migration profile to File storage...');

        fileStorageService.create('profile', str, function(err) {
          if (err) cb(err);
          $log.info('Profile Migrated successfully');

          localStorageService.get('config', function(err, c) {
            if (err) return cb(err);
            if (!c) return root.getProfile(cb);

            fileStorageService.create('config', c, function(err) {

              if (err) {
                $log.info('Error migrating config: ignoring', err);
                return root.getProfile(cb);
              }
              $log.info('Config Migrated successfully');
              return root.getProfile(cb);
            });
          });
        });
      });
    };

    root.storeNewProfile = function(profile, cb) {
      storage.create('profile', profile.toObj(), cb);
    };

    root.storeProfile = function(profile, cb) {
      storage.set('profile', profile.toObj(), cb);
    };

    root.getProfile = function(cb) {
      storage.get('profile', function(err, str) {
        if (err || !str)
          return cb(err);

        decryptOnMobile(str, function(err, str) {
          if (err) return cb(err);
          var p, err;
          try {
            p = Profile.fromString(str);
          } catch (e) {
            $log.debug('Could not read profile:', e);
            err = new Error('Could not read profile:' + p);
          }
          return cb(err, p);
        });
      });
    };

    root.deleteProfile = function(cb) {
      storage.remove('profile', cb);
    };

    root.setFeedbackInfo = function(feedbackValues, cb) {
      storage.set('feedback', feedbackValues, cb);
    };

    root.getFeedbackInfo = function(cb) {
      storage.get('feedback', cb);
    };

    root.storeFocusedWalletId = function(id, cb) {
      storage.set('focusedWalletId', id || '', cb);
    };

    root.getFocusedWalletId = function(cb) {
      storage.get('focusedWalletId', cb);
    };

    root.getLastAddress = function(walletId, cb) {
      storage.get('lastAddress-' + walletId, cb);
    };

    root.storeLastAddress = function(walletId, address, cb) {
      storage.set('lastAddress-' + walletId, address, cb);
    };

    root.clearLastAddress = function(walletId, cb) {
      storage.remove('lastAddress-' + walletId, cb);
    };

    root.setBackupFlag = function(walletId, cb) {
      storage.set('backup-' + walletId, Date.now(), cb);
    };

    root.getBackupFlag = function(walletId, cb) {
      storage.get('backup-' + walletId, cb);
    };

    root.clearBackupFlag = function(walletId, cb) {
      storage.remove('backup-' + walletId, cb);
    };

    root.setCleanAndScanAddresses = function(walletId, cb) {
      storage.set('CleanAndScanAddresses', walletId, cb);
    };

    root.getCleanAndScanAddresses = function(cb) {
      storage.get('CleanAndScanAddresses', cb);
    };

    root.removeCleanAndScanAddresses = function(cb) {
      storage.remove('CleanAndScanAddresses', cb);
    };

    root.getConfig = function(cb) {
      storage.get('config', cb);
    };

    root.storeConfig = function(val, cb) {
      $log.debug('Storing Preferences', val);
      storage.set('config', val, cb);
    };

    root.clearConfig = function(cb) {
      storage.remove('config', cb);
    };

    root.getHomeTipAccepted = function(cb) {
      storage.get('homeTip', cb);
    };

    root.setHomeTipAccepted = function(val, cb) {
      storage.set('homeTip', val, cb);
    };

    root.setHideBalanceFlag = function(walletId, val, cb) {
      storage.set('hideBalance-' + walletId, val, cb);
    };

    root.getHideBalanceFlag = function(walletId, cb) {
      storage.get('hideBalance-' + walletId, cb);
    };

    //for compatibility
    root.getCopayDisclaimerFlag = function(cb) {
      storage.get('agreeDisclaimer', cb);
    };

    root.setRemotePrefsStoredFlag = function(cb) {
      storage.set('remotePrefStored', true, cb);
    };

    root.getRemotePrefsStoredFlag = function(cb) {
      storage.get('remotePrefStored', cb);
    };

    root.setGlideraToken = function(network, token, cb) {
      storage.set('glideraToken-' + network, token, cb);
    };

    root.getGlideraToken = function(network, cb) {
      storage.get('glideraToken-' + network, cb);
    };

    root.removeGlideraToken = function(network, cb) {
      storage.remove('glideraToken-' + network, cb);
    };

    root.setGlideraPermissions = function(network, p, cb) {
      storage.set('glideraPermissions-' + network, p, cb);
    };

    root.getGlideraPermissions = function(network, cb) {
      storage.get('glideraPermissions-' + network, cb);
    };

    root.removeGlideraPermissions = function(network, cb) {
      storage.remove('glideraPermissions-' + network, cb);
    };

    root.setGlideraStatus = function(network, status, cb) {
      storage.set('glideraStatus-' + network, status, cb);
    };

    root.getGlideraStatus = function(network, cb) {
      storage.get('glideraStatus-' + network, cb);
    };

    root.removeGlideraStatus = function(network, cb) {
      storage.remove('glideraStatus-' + network, cb);
    };

    root.setGlideraTxs = function(network, txs, cb) {
      storage.set('glideraTxs-' + network, txs, cb);
    };

    root.getGlideraTxs = function(network, cb) {
      storage.get('glideraTxs-' + network, cb);
    };

    root.removeGlideraTxs = function(network, cb) {
      storage.remove('glideraTxs-' + network, cb);
    };

    root.setCoinbaseRefreshToken = function(network, token, cb) {
      storage.set('coinbaseRefreshToken-' + network, token, cb);
    };

    root.getCoinbaseRefreshToken = function(network, cb) {
      storage.get('coinbaseRefreshToken-' + network, cb);
    };

    root.removeCoinbaseRefreshToken = function(network, cb) {
      storage.remove('coinbaseRefreshToken-' + network, cb);
    };

    root.setCoinbaseToken = function(network, token, cb) {
      storage.set('coinbaseToken-' + network, token, cb);
    };

    root.getCoinbaseToken = function(network, cb) {
      storage.get('coinbaseToken-' + network, cb);
    };

    root.removeCoinbaseToken = function(network, cb) {
      storage.remove('coinbaseToken-' + network, cb);
    };

    root.setAddressbook = function(network, addressbook, cb) {
      storage.set('addressbook-' + network, addressbook, cb);
    };

    root.getAddressbook = function(network, cb) {
      storage.get('addressbook-' + network, cb);
    };

    root.removeAddressbook = function(network, cb) {
      storage.remove('addressbook-' + network, cb);
    };

    root.setLastCurrencyUsed = function(lastCurrencyUsed, cb) {
      storage.set('lastCurrencyUsed', lastCurrencyUsed, cb)
    };

    root.getLastCurrencyUsed = function(cb) {
      storage.get('lastCurrencyUsed', cb)
    };

    root.checkQuota = function() {
      var block = '';
      // 50MB
      for (var i = 0; i < 1024 * 1024; ++i) {
        block += '12345678901234567890123456789012345678901234567890';
      }
      storage.set('test', block, function(err) {
        $log.error('CheckQuota Return:' + err);
      });
    };

    root.setTxHistory = function(txs, walletId, cb) {
      try {
        storage.set('txsHistory-' + walletId, txs, cb);
      } catch (e) {
        $log.error('Error saving tx History. Size:' + txs.length);
        $log.error(e);
        return cb(e);
      }
    }

    root.getTxHistory = function(walletId, cb) {
      storage.get('txsHistory-' + walletId, cb);
    }

    root.removeTxHistory = function(walletId, cb) {
      storage.remove('txsHistory-' + walletId, cb);
    }

    root.setCoinbaseTxs = function(network, ctx, cb) {
      storage.set('coinbaseTxs-' + network, ctx, cb);
    };

    root.getCoinbaseTxs = function(network, cb) {
      storage.get('coinbaseTxs-' + network, cb);
    };

    root.removeCoinbaseTxs = function(network, cb) {
      storage.remove('coinbaseTxs-' + network, cb);
    };

    root.setBalanceCache = function(cardId, data, cb) {
      storage.set('balanceCache-' + cardId, data, cb);
    };

    root.getBalanceCache = function(cardId, cb) {
      storage.get('balanceCache-' + cardId, cb);
    };

    root.removeBalanceCache = function(cardId, cb) {
      storage.remove('balanceCache-' + cardId, cb);
    };

    // cards: [
    //   eid: card id
    //   id: card id
    //   lastFourDigits: card number
    //   token: card token
    // ]
    root.setBitpayDebitCards = function(network, email, cards, cb) {
      root.getBitpayAccounts(network, function(err, allAccounts) {
        if (err) return cb(err);

        if (!allAccounts[email]) {
          return cb('Cannot set cards for unknown account ' + email);
        }

        allAccounts[email].cards = cards;
        storage.set('bitpayAccounts-v2-' + network, allAccounts, cb);
      });
    };

    // cb(err, cards)
    // cards: [
    //   eid: card id
    //   id: card id
    //   lastFourDigits: card number
    //   token: card token
    //   email: account email
    // ]
    root.getBitpayDebitCards = function(network, cb) {
      root.getBitpayAccounts(network, function(err, allAccounts) {
        if (err) return cb(err);

        var allCards = [];

        lodash.each(allAccounts, function(account, email) {

          if (account.cards) {
            // Add account's email to each card
            var cards = lodash.clone(account.cards);
            lodash.each(cards, function(x) {
              x.email = email;
            });

            allCards = allCards.concat(cards);
          }
        });

        return cb(null, allCards);
      });
    };

    root.removeBitpayDebitCard = function(network, cardEid, cb) {
      root.getBitpayAccounts(network, function(err, allAccounts) {

        lodash.each(allAccounts, function(account) {
          account.cards = lodash.reject(account.cards, {
            'eid': cardEid
          });
        });

        storage.set('bitpayAccounts-v2-' + network, allAccounts, cb);
      });
    };

    // cb(err, accounts)
    // accounts: {
    //   email_1: {
    //     token: account token
    //     cards: {
    //       <card-data>
    //     }
    //   }
    //   ...
    //   email_n: {
    //    token: account token
    //    cards: {
    //       <card-data>
    //     }
    //   }
    // }
    //
    root.getBitpayAccounts = function(network, cb) {
      storage.get('bitpayAccounts-v2-' + network, function(err, allAccountsStr) {
        if (err) return cb(err);

        if (!allAccountsStr)
          return cb(null, {});

        var allAccounts = {};
        try {
          allAccounts = JSON.parse(allAccountsStr);
        } catch (e) {
          $log.error('Bad storage value for bitpayAccount-v2' + allAccountsStr)
          return cb(null, {});
        };

        var anyMigration;

        lodash.each(allAccounts, function(account, email) {

          // Migrate old `'bitpayApi-' + network` key, if exists
          if (!account.token && account['bitpayApi-' + network].token) {

            $log.info('Migrating all bitpayApi-network branch');
            account.token = account['bitpayApi-' + network].token;
            account.cards = lodash.clone(account['bitpayApi-' + network].cards);
            if (!account.cards) {
              account.cards = lodash.clone(account['bitpayDebitCards-' + network]);
            }

            delete account['bitpayDebitCards-' + network];
            delete account['bitpayApi-' + network];
            anyMigration = true;

          }
        });

        if (anyMigration) {
          storage.set('bitpayAccounts-v2-' + network, allAccounts, function() {
            return cb(err, allAccounts);
          });
        } else
          return cb(err, allAccounts);

      });
    };

    // data: {
    //   email: account email
    //   token: account token
    //   familyName: account family (last) name
    //   givenName: account given (first) name
    // }
    root.setBitpayAccount = function(network, data, cb) {
      if (!lodash.isObject(data) || !data.email || !data.token)
        return cb('No account to set');

      root.getBitpayAccounts(network, function(err, allAccounts) {
        if (err) return cb(err);

        allAccounts = allAccounts || {};
        var account = allAccounts[data.email] || {};
        account.token = data.token;
        account.familyName = data.familyName;
        account.givenName = data.givenName;

        allAccounts[data.email] = account;

        $log.info('Storing BitPay accounts with new account:' + data.email);
        storage.set('bitpayAccounts-v2-' + network, allAccounts, cb);
      });
    };

    // account: {
    //   email: account email
    //   apiContext: the context needed for making future api calls
    //   cards: an array of cards
    // }
    root.removeBitpayAccount = function(network, account, cb) {
      if (lodash.isString(account)) {
        account = JSON.parse(account);
      }
      account = account || {};
      if (lodash.isEmpty(account)) return cb('No account to remove');
      storage.get('bitpayAccounts-v2-' + network, function(err, bitpayAccounts) {
        if (err) cb(err);
        if (lodash.isString(bitpayAccounts)) {
          bitpayAccounts = JSON.parse(bitpayAccounts);
        }
        bitpayAccounts = bitpayAccounts || {};
        delete bitpayAccounts[account.email];
        storage.set('bitpayAccounts-v2-' + network, JSON.stringify(bitpayAccounts), cb);
      });
    };

    root.setAppIdentity = function(network, data, cb) {
      storage.set('appIdentity-' + network, data, cb);
    };

    root.getAppIdentity = function(network, cb) {
      storage.get('appIdentity-' + network, function(err, data) {
        if (err) return cb(err);
        cb(err, JSON.parse(data || '{}'));
      });
    };

    root.removeAppIdentity = function(network, cb) {
      storage.remove('appIdentity-' + network, cb);
    };

    root.removeAllWalletData = function(walletId, cb) {
      root.clearLastAddress(walletId, function(err) {
        if (err) return cb(err);
        root.removeTxHistory(walletId, function(err) {
          if (err) return cb(err);
          root.clearBackupFlag(walletId, function(err) {
            return cb(err);
          });
        });
      });
    };

    root.setAmazonGiftCards = function(network, gcs, cb) {
      storage.set('amazonGiftCards-' + network, gcs, cb);
    };

    root.getAmazonGiftCards = function(network, cb) {
      storage.get('amazonGiftCards-' + network, cb);
    };

    root.removeAmazonGiftCards = function(network, cb) {
      storage.remove('amazonGiftCards-' + network, cb);
    };

    root.setTxConfirmNotification = function(txid, val, cb) {
      storage.set('txConfirmNotif-' + txid, val, cb);
    };

    root.getTxConfirmNotification = function(txid, cb) {
      storage.get('txConfirmNotif-' + txid, cb);
    };

    root.removeTxConfirmNotification = function(txid, cb) {
      storage.remove('txConfirmNotif-' + txid, cb);
    };

    root.setMercadoLibreGiftCards = function(network, gcs, cb) {
      storage.set('mercadoLibreGiftCards-' + network, gcs, cb);
    };

    root.getMercadoLibreGiftCards = function(network, cb) {
      storage.get('mercadoLibreGiftCards-' + network, cb);
    };

    root.removeMercadoLibreGiftCards = function(network, cb) {
      storage.remove('MercadoLibreGiftCards-' + network, cb);
    };

    return root;
  });

'use strict';

angular.module('copayApp.services').factory('timeService', function() {
  var root = {};

  root.withinSameMonth = function(time1, time2) {
    if (!time1 || !time2) return false;
    var date1 = new Date(time1);
    var date2 = new Date(time2);
    return root.getMonthYear(date1) === root.getMonthYear(date2);
  }

  root.withinPastDay = function(time) {
    var now = new Date();
    var date = new Date(time);
    return (now.getTime() - date.getTime()) < (1000 * 60 * 60 * 24);
  };

  root.isDateInCurrentMonth = function(date) {
    var now = new Date();
    return root.getMonthYear(now) === root.getMonthYear(date);
  };

  root.getMonthYear = function(date) {
    return date.getMonth() + date.getFullYear();
  }

  return root;

});

'use strict';

angular.module('copayApp.services')
  .factory('trezor', function($log, $timeout, lodash, bitcore, hwWallet, platformInfo) {
    var root = {};

    var SETTLE_TIME = 3000;
    root.callbacks = {};

    root.description = {
      supported: platformInfo.supportsTrezor,
      id: 'trezor',
      name: 'Trezor',
      longName: 'Trezor Hardware Wallet',
      derivationStrategy: 'BIP48',
      isEmbeddedHardware: false,
      supportsTestnet: false
    };

    root.getEntropySource = function(isMultisig, account, callback) {
      root.getXPubKey(hwWallet.getEntropyPath(root.description.id, isMultisig, account), function(data) {
        if (!data.success)
          return callback(hwWallet._err(data));

        return callback(null, hwWallet.pubKeyToEntropySource(data.xpubkey));
      });
    };


    root.getXPubKey = function(path, callback) {
      $log.debug('TREZOR deriving xPub path:', path);
      try {
        TrezorConnect.getXPubKey(path, callback);
      } catch (e) {
        callback('Error connecting Trezor');
      }
    };

    root.initSource = function(opts, callback) {
      // No initialization for this hardware source.
      return callback(opts);
    };

    root.getInfoForNewWallet = function(isMultisig, account, networkName, callback) {
      // networkName not used for this hardware (always livenet)
      var opts = {};
      root.getEntropySource(isMultisig, account, function(err, data) {
        if (err) return callback(err);
        opts.entropySource = data;
        $log.debug('Waiting TREZOR to settle...');
        $timeout(function() {

          root.getXPubKey(hwWallet.getAddressPath(root.description.id, isMultisig, account), function(data) {
            if (!data.success)
              return callback(hwWallet._err(data));

            opts.extendedPublicKey = data.xpubkey;
            opts.externalSource = root.description.id;

            if (isMultisig)
              opts.derivationStrategy = 'BIP48';

            return callback(null, opts);
          });
        }, SETTLE_TIME);
      });
    };

    root._orderPubKeys = function(xPub, np) {
      var xPubKeys = lodash.clone(xPub);
      var path = lodash.clone(np);
      path.unshift('m');
      path = path.join('/');

      var keys = lodash.map(xPubKeys, function(x) {
        var pub = (new bitcore.HDPublicKey(x)).derive(path).publicKey;
        return {
          xpub: x,
          pub: pub.toString('hex'),
        };
      });

      var sorted = lodash.sortBy(keys, function(x) {
        return x.pub;
      });

      return lodash.pluck(sorted, 'xpub');
    };

    root.signTx = function(xPubKeys, txp, account, callback) {

      var inputs = [],
        outputs = [];
      var tmpOutputs = [];

      if (txp.type && txp.type != 'simple') {
        return callback('Only TXPs type SIMPLE are supported in TREZOR');
      } else if (txp.outputs) {
        if (txp.outputs.length > 1)
          return callback('Only single output TXPs are supported in TREZOR');
      } else {
        return callback('Unknown TXP at TREZOR');
      }

      if (txp.outputs) {

        if (!txp.toAddress)
          txp.toAddress = txp.outputs[0].toAddress;

        if (!txp.amount)
          txp.amount = txp.outputs[0].amount;
      }

      if (!txp.toAddress || !txp.amount)
        return callback('No address or amount at TREZOR signing');


      var toScriptType = 'PAYTOADDRESS';
      if (txp.toAddress.charAt(0) == '2' || txp.toAddress.charAt(0) == '3')
        toScriptType = 'PAYTOSCRIPTHASH';


      // Add to
      tmpOutputs.push({
        address: txp.toAddress,
        amount: txp.amount,
        script_type: toScriptType,
      });



      if (txp.addressType == 'P2PKH') {

        $log.debug("Trezor signing uni-sig p2pkh. Account:", account);

        var inAmount = 0;
        inputs = lodash.map(txp.inputs, function(i) {
          $log.debug("Trezor TX input path:", i.path);
          var pathArr = i.path.split('/');
          var n = [hwWallet.UNISIG_ROOTPATH | 0x80000000, 0 | 0x80000000, account | 0x80000000, parseInt(pathArr[1]), parseInt(pathArr[2])];
          inAmount += i.satoshis;
          return {
            address_n: n,
            prev_index: i.vout,
            prev_hash: i.txid,
          };
        });

        var change = inAmount - txp.fee - txp.amount;
        if (change > 0) {
          $log.debug("Trezor TX change path:", txp.changeAddress.path);
          var pathArr = txp.changeAddress.path.split('/');
          var n = [hwWallet.UNISIG_ROOTPATH | 0x80000000, 0 | 0x80000000, account | 0x80000000, parseInt(pathArr[1]), parseInt(pathArr[2])];

          tmpOutputs.push({
            address_n: n,
            amount: change,
            script_type: 'PAYTOADDRESS'
          });
        }

      } else {

        // P2SH Wallet, multisig wallet
        var inAmount = 0;
        $log.debug("Trezor signing multi-sig p2sh. Account:", account);

        var sigs = xPubKeys.map(function(v) {
          return '';
        });

        inputs = lodash.map(txp.inputs, function(i) {
          $log.debug("Trezor TX input path:", i.path);
          var pathArr = i.path.split('/');
          var n = [hwWallet.MULTISIG_ROOTPATH | 0x80000000, 0 | 0x80000000, account | 0x80000000, parseInt(pathArr[1]), parseInt(pathArr[2])];
          var np = n.slice(3);

          inAmount += i.satoshis;

          var orderedPubKeys = root._orderPubKeys(xPubKeys, np);
          var pubkeys = orderedPubKeys.map(function(v) {
            return {
              node: v,
              address_n: np,
            };
          });

          return {
            address_n: n,
            prev_index: i.vout,
            prev_hash: i.txid,
            script_type: 'SPENDMULTISIG',
            multisig: {
              pubkeys: pubkeys,
              signatures: sigs,
              m: txp.requiredSignatures,
            }
          };
        });

        var change = inAmount - txp.fee - txp.amount;
        if (change > 0) {
          $log.debug("Trezor TX change path:", txp.changeAddress.path);
          var pathArr = txp.changeAddress.path.split('/');
          var n = [hwWallet.MULTISIG_ROOTPATH | 0x80000000, 0 | 0x80000000, account | 0x80000000, parseInt(pathArr[1]), parseInt(pathArr[2])];
          var np = n.slice(3);

          var orderedPubKeys = root._orderPubKeys(xPubKeys, np);
          var pubkeys = orderedPubKeys.map(function(v) {
            return {
              node: v,
              address_n: np,
            };
          });

          tmpOutputs.push({
            address_n: n,
            amount: change,
            script_type: 'PAYTOMULTISIG',
            multisig: {
              pubkeys: pubkeys,
              signatures: sigs,
              m: txp.requiredSignatures,
            }
          });
        }
      }

      // Shuffle outputs for improved privacy
      if (tmpOutputs.length > 1) {
        outputs = new Array(tmpOutputs.length);
        lodash.each(txp.outputOrder, function(order) {
          outputs[order] = tmpOutputs.shift();
        });

        if (tmpOutputs.length)
          return cb("Error creating transaction: tmpOutput order");
      } else {
        outputs = tmpOutputs;
      }

      // Prevents: Uncaught DataCloneError: Failed to execute 'postMessage' on 'Window': An object could not be cloned.
      inputs = JSON.parse(JSON.stringify(inputs));
      outputs = JSON.parse(JSON.stringify(outputs));

      $log.debug('Signing with TREZOR', inputs, outputs);
      TrezorConnect.signTx(inputs, outputs, function(res) {
        if (!res.success)
          return callback(hwWallet._err(res));

        callback(null, res);
      });
    };

    return root;
  });

'use strict';
angular.module('copayApp.services').factory('txConfirmNotification', function txConfirmNotification($log, storageService) {
  var root = {};

  root.checkIfEnabled = function(txid, cb) {
    storageService.getTxConfirmNotification(txid, function(err, res) {
      if (err) $log.error(err);
      return cb(!!res);
    });
  };

  root.subscribe = function(client, opts) {
    client.txConfirmationSubscribe(opts, function(err, res) {
      if (err) $log.error(err);
      storageService.setTxConfirmNotification(opts.txid, true, function(err) {
        if (err) $log.error(err);
      });
    });
  };

  root.unsubscribe = function(client, txId) {
    client.txConfirmationUnsubscribe(txId, function(err, res) {
      if (err) $log.error(err);
      storageService.removeTxConfirmNotification(txId, function(err) {
        if (err) $log.error(err);
      });
    });
  };

  return root;

});

'use strict';

angular.module('copayApp.services').factory('txFormatService', function($filter, bwcService, rateService, configService, lodash) {
  var root = {};

  root.Utils = bwcService.getUtils();


  root.formatAmount = function(satoshis, fullPrecision) {
    var config = configService.getDefaults().wallet.settings;
    if (config.unitCode == 'sat') return satoshis;

    //TODO : now only works for english, specify opts to change thousand separator and decimal separator
    var opts = {
      fullPrecision: !!fullPrecision
    };
    return this.Utils.formatAmount(satoshis, config.unitCode, opts);
  };

  root.formatAmountStr = function(coin, satoshis) {
    if (isNaN(satoshis)) return;
    return root.formatAmount(satoshis) + ' ' + (coin).toUpperCase();
  };

  root.toFiat = function(coin, satoshis, code, cb) {
    if (isNaN(satoshis)) return;
    var val = function() {
      var v1 = rateService.toFiat(satoshis, code, coin);
      if (!v1) return null;

      return v1.toFixed(2);
    };

    // Async version
    if (cb) {
      rateService.whenAvailable(function() {
        return cb(val());
      });
    } else {
      if (!rateService.isAvailable()) return null;
      return val();
    };
  };

  root.formatToUSD = function(coin, satoshis, cb) {
    if (isNaN(satoshis)) return;
    var val = function() {
      var v1 = rateService.toFiat(satoshis, 'USD', coin);
      if (!v1) return null;

      return v1.toFixed(2);
    };

    // Async version
    if (cb) {
      rateService.whenAvailable(function() {
        return cb(val());
      });
    } else {
      if (!rateService.isAvailable()) return null;
      return val();
    };
  };

  root.formatAlternativeStr = function(coin, satoshis, cb) {
    if (isNaN(satoshis)) return;
    var config = configService.getSync().wallet.settings;

    var val = function() {
      var v1 = parseFloat((rateService.toFiat(satoshis, config.alternativeIsoCode, coin)).toFixed(2));
      v1 = $filter('formatFiatAmount')(v1);
      if (!v1) return null;

      return v1 + ' ' + config.alternativeIsoCode;
    };

    // Async version
    if (cb) {
      rateService.whenAvailable(function() {
        return cb(val());
      });
    } else {
      if (!rateService.isAvailable()) return null;
      return val();
    };
  };

  root.processTx = function(coin, tx) {
    if (!tx || tx.action == 'invalid')
      return tx;

    // New transaction output format
    if (tx.outputs && tx.outputs.length) {

      var outputsNr = tx.outputs.length;

      if (tx.action != 'received') {
        if (outputsNr > 1) {
          tx.recipientCount = outputsNr;
          tx.hasMultiplesOutputs = true;
        }
        tx.amount = lodash.reduce(tx.outputs, function(total, o) {
          o.amountStr = root.formatAmountStr(coin, o.amount);
          o.alternativeAmountStr = root.formatAlternativeStr(coin, o.amount);
          return total + o.amount;
        }, 0);
      }
      tx.toAddress = tx.outputs[0].toAddress;
    }

    tx.amountStr = root.formatAmountStr(coin, tx.amount);
    tx.alternativeAmountStr = root.formatAlternativeStr(coin, tx.amount);
    tx.feeStr = root.formatAmountStr(coin, tx.fee || tx.fees);

    if (tx.amountStr) {
      tx.amountValueStr = tx.amountStr.split(' ')[0];
      tx.amountUnitStr = tx.amountStr.split(' ')[1];
    }

    return tx;
  };

  root.formatPendingTxps = function(txps) {
    $scope.pendingTxProposalsCountForUs = 0;
    var now = Math.floor(Date.now() / 1000);

    /* To test multiple outputs...
    var txp = {
      message: 'test multi-output',
      fee: 1000,
      createdOn: new Date() / 1000,
      outputs: []
    };
    function addOutput(n) {
      txp.outputs.push({
        amount: 600,
        toAddress: '2N8bhEwbKtMvR2jqMRcTCQqzHP6zXGToXcK',
        message: 'output #' + (Number(n) + 1)
      });
    };
    lodash.times(150, addOutput);
    txps.push(txp);
    */

    lodash.each(txps, function(tx) {

      // no future transactions...
      if (tx.createdOn > now)
        tx.createdOn = now;

      tx.wallet = profileService.getWallet(tx.walletId);
      if (!tx.wallet) {
        $log.error("no wallet at txp?");
        return;
      }

      tx = txFormatService.processTx(tx.wallet.coin, tx);

      var action = lodash.find(tx.actions, {
        copayerId: tx.wallet.copayerId
      });

      if (!action && tx.status == 'pending') {
        tx.pendingForUs = true;
      }

      if (action && action.type == 'accept') {
        tx.statusForUs = 'accepted';
      } else if (action && action.type == 'reject') {
        tx.statusForUs = 'rejected';
      } else {
        tx.statusForUs = 'pending';
      }

      if (!tx.deleteLockTime)
        tx.canBeRemoved = true;
    });

    return txps;
  };

  root.parseAmount = function(coin, amount, currency) {
    var config = configService.getSync().wallet.settings;
    var satToBtc = 1 / 100000000;
    var unitToSatoshi = config.unitToSatoshi;
    var amountUnitStr;
    var amountSat;
    var alternativeIsoCode = config.alternativeIsoCode;

    // If fiat currency
    if (currency != 'BCH' && currency != 'BTCZ' && currency != 'sat') {
      amountUnitStr = $filter('formatFiatAmount')(amount) + ' ' + currency;
      amountSat = rateService.fromFiat(amount, currency, coin).toFixed(0);
    } else if (currency == 'sat') {
      amountSat = amount;
      amountUnitStr = root.formatAmountStr(coin, amountSat);
      // convert sat to BTCZ or BCH
      amount = (amountSat * satToBtc).toFixed(8);
      currency = (coin).toUpperCase();
    } else {
      amountSat = parseInt((amount * unitToSatoshi).toFixed(0));
      amountUnitStr = root.formatAmountStr(coin, amountSat);
      // convert unit to BTCZ or BCH
      amount = (amountSat * satToBtc).toFixed(8);
      currency = (coin).toUpperCase();
    }

    return {
      amount: amount,
      currency: currency,
      alternativeIsoCode: alternativeIsoCode,
      amountSat: amountSat,
      amountUnitStr: amountUnitStr
    };
  };

  root.satToUnit = function(amount) {
    var config = configService.getSync().wallet.settings;
    var unitToSatoshi = config.unitToSatoshi;
    var satToUnit = 1 / unitToSatoshi;
    var unitDecimals = config.unitDecimals;
    return parseFloat((amount * satToUnit).toFixed(unitDecimals));
  };

  return root;
});

'use strict';

angular.module('copayApp.services').factory('txpModalService', function(configService, profileService, $rootScope, $ionicModal) {

  var root = {};


  var glideraActive = true; // TODO TODO TODO
  // isGlidera flag is a security measure so glidera status is not
  // only determined by the tx.message


  root.open = function(tx) {
    var wallet = tx.wallet ? tx.wallet : profileService.getWallet(tx.walletId);
    var config = configService.getSync().wallet;
    var scope = $rootScope.$new(true);
    scope.tx = tx;
    if (!scope.tx.toAddress) scope.tx.toAddress = tx.outputs[0].toAddress;
    scope.wallet = wallet;
    scope.copayers = wallet ? wallet.copayers : null;
    scope.isGlidera = glideraActive;
    scope.currentSpendUnconfirmed = config.spendUnconfirmed;
    // scope.tx.hasMultiplesOutputs = true;  // Uncomment to test multiple outputs

    $ionicModal.fromTemplateUrl('views/modals/txp-details.html', {
      scope: scope
    }).then(function(modal) {
      scope.txpDetailsModal = modal;
      scope.txpDetailsModal.show();
    });
  };

  return root;
});

'use strict';
angular.module('copayApp.services')
  .factory('uxLanguage', function languageService($log, lodash, gettextCatalog, amMoment, configService) {
    var root = {};

    root.currentLanguage = null;

    root.availableLanguages = [{
      name: 'English',
      isoCode: 'en',
    }, {
      name: 'Espaol',
      isoCode: 'es',
    }, {
      name: 'Franais',
      isoCode: 'fr',
    }, {
      name: 'Italiano',
      isoCode: 'it',
    }, {
      name: 'Nederlands',
      isoCode: 'nl',
    }, {
      name: 'Polski',
      isoCode: 'pl',
    }, {
      name: 'Deutsch',
      isoCode: 'de',
    }, {
      name: '',
      isoCode: 'ja',
      useIdeograms: true,
    }, {
      name: '',
      isoCode: 'zh',
      useIdeograms: true,
    }, {
      name: 'P',
      isoCode: 'ru',
    }, {
      name: 'Portugus',
      isoCode: 'pt',
    }];

    // }, {
    //   name: 'esk',
    //   isoCode: 'cs',
    // }

    root._detect = function(cb) {
      var userLang, androidLang;
      if (navigator && navigator.globalization) {

        navigator.globalization.getPreferredLanguage(function(preferedLanguage) {
          // works for iOS and Android 4.x
          userLang = preferedLanguage.value;
          userLang = userLang ? (userLang.split('-', 1)[0] || 'en') : 'en';
          // Set only available languages
          userLang = root.isAvailableLanguage(userLang);
          return cb(userLang);
        });
      } else {
        // Auto-detect browser language
        userLang = navigator.userLanguage || navigator.language;
        userLang = userLang ? (userLang.split('-', 1)[0] || 'en') : 'en';
        // Set only available languages
        userLang = root.isAvailableLanguage(userLang);
        return cb(userLang);
      }
    };

    root.isAvailableLanguage = function(userLang) {
      return lodash.find(root.availableLanguages, {
        'isoCode': userLang
      }) ? userLang : 'en';
    };

    root._set = function(lang) {
      $log.debug('Setting default language: ' + lang);
      gettextCatalog.setCurrentLanguage(lang);
      root.currentLanguage = lang;

      if (lang == 'zh') lang = lang + '-CN'; // Fix for Chinese Simplified
      amMoment.changeLocale(lang);
    };

    root.getCurrentLanguage = function() {
      return root.currentLanguage;
    };

    root.getCurrentLanguageName = function() {
      return root.getName(root.currentLanguage);
    };

    root.getCurrentLanguageInfo = function() {
      return lodash.find(root.availableLanguages, {
        'isoCode': root.currentLanguage
      });
    };

    root.getLanguages = function() {
      return root.availableLanguages;
    };

    root.init = function(cb) {
      configService.whenAvailable(function(config) {
        var userLang = config.wallet.settings.defaultLanguage;

        if (userLang && userLang != root.currentLanguage) {
          root._set(userLang);
        } else {
          root._detect(function(lang) {
            root._set(lang);
          });
        }
        if (cb) return cb();
      });
    };

    root.getName = function(lang) {
      return lodash.result(lodash.find(root.availableLanguages, {
        'isoCode': lang
      }), 'name');
    };

    return root;
  });

'use strict';

angular.module('copayApp.services').factory('walletService', function($log, $timeout, lodash, trezor, ledger, intelTEE, storageService, configService, rateService, uxLanguage, $filter, gettextCatalog, bwcError, $ionicPopup, fingerprintService, ongoingProcess, gettext, $rootScope, txFormatService, $ionicModal, $state, bwcService, bitcore, popupService) {

  // Ratio low amount warning (fee/amount) in incoming TX
  var LOW_AMOUNT_RATIO = 0.15;

  // Ratio of "many utxos" warning in total balance (fee/amount)
  var TOTAL_LOW_WARNING_RATIO = .3;

  var root = {};

  root.externalSource = {
    ledger: ledger.description,
    trezor: trezor.description,
    intelTEE: intelTEE.description
  }

  root.WALLET_STATUS_MAX_TRIES = 7;
  root.WALLET_STATUS_DELAY_BETWEEN_TRIES = 1.4 * 1000;
  root.SOFT_CONFIRMATION_LIMIT = 12;
  root.SAFE_CONFIRMATIONS = 6;

  var errors = bwcService.getErrors();

  var _signWithLedger = function(wallet, txp, cb) {
    $log.info('Requesting Ledger Chrome app to sign the transaction');

    ledger.signTx(txp, wallet.credentials.account, function(result) {
      $log.debug('Ledger response', result);
      if (!result.success)
        return cb(result.message || result.error);

      txp.signatures = lodash.map(result.signatures, function(s) {
        return s.substring(0, s.length - 2);
      });
      return wallet.signTxProposal(txp, cb);
    });
  };

  var _signWithTrezor = function(wallet, txp, cb) {
    $log.info('Requesting Trezor  to sign the transaction');

    var xPubKeys = lodash.pluck(wallet.credentials.publicKeyRing, 'xPubKey');
    trezor.signTx(xPubKeys, txp, wallet.credentials.account, function(err, result) {
      if (err) return cb(err);

      $log.debug('Trezor response', result);
      txp.signatures = result.signatures;
      return wallet.signTxProposal(txp, cb);
    });
  };

  var _signWithIntelTEE = function(wallet, txp, cb) {
    $log.info('Requesting Intel TEE to sign the transaction');

    intelTEE.signTx(wallet.credentials.hwInfo.id, txp, function(err, result) {
      if (err) return cb(err);

      $log.debug('Intel TEE response', result);
      txp.signatures = result.Signatures;
      return wallet.signTxProposal(txp, cb);
    });
  };

  root.showMneumonicFromHardware = function(wallet, cb) {
    switch (wallet.getPrivKeyExternalSourceName()) {
      case root.externalSource.intelTEE.id:
        return intelTEE.showMneumonic(wallet.credentials.hwInfo.id, cb);
        break;
      default:
        cb('Error: unrecognized external source');
        break;
    }
  };

  root.showReceiveAddressFromHardware = function(wallet, address, cb) {
    switch (wallet.getPrivKeyExternalSourceName()) {
      case root.externalSource.intelTEE.id:
        root.getAddressObj(wallet, address, function(err, addrObj) {
          if (err) return cb(err);
          return intelTEE.showReceiveAddress(wallet.credentials.hwInfo.id, addrObj, cb);
        });
        break;
      default:
        cb('Error: unrecognized external source');
        break;
    }
  };

  root.invalidateCache = function(wallet) {
    if (wallet.cachedStatus)
      wallet.cachedStatus.isValid = false;

    if (wallet.completeHistory)
      wallet.completeHistory.isValid = false;

    if (wallet.cachedActivity)
      wallet.cachedActivity.isValid = false;

    if (wallet.cachedTxps)
      wallet.cachedTxps.isValid = false;
  };

  root.getStatus = function(wallet, opts, cb) {
    opts = opts || {};


    function processPendingTxps(status) {
      var txps = status.pendingTxps;
      var now = Math.floor(Date.now() / 1000);

      /* To test multiple outputs...
      var txp = {
        message: 'test multi-output',
        fee: 1000,
        createdOn: new Date() / 1000,
        outputs: []
      };
      function addOutput(n) {
        txp.outputs.push({
          amount: 600,
          toAddress: '2N8bhEwbKtMvR2jqMRcTCQqzHP6zXGToXcK',
          message: 'output #' + (Number(n) + 1)
        });
      };
      lodash.times(150, addOutput);
      txps.push(txp);
      */

      lodash.each(txps, function(tx) {

        tx = txFormatService.processTx(wallet.coin, tx);

        // no future transactions...
        if (tx.createdOn > now)
          tx.createdOn = now;

        tx.wallet = wallet;

        if (!tx.wallet) {
          $log.error("no wallet at txp?");
          return;
        }

        var action = lodash.find(tx.actions, {
          copayerId: tx.wallet.copayerId
        });

        if (!action && tx.status == 'pending') {
          tx.pendingForUs = true;
        }

        if (action && action.type == 'accept') {
          tx.statusForUs = 'accepted';
        } else if (action && action.type == 'reject') {
          tx.statusForUs = 'rejected';
        } else {
          tx.statusForUs = 'pending';
        }

        if (!tx.deleteLockTime)
          tx.canBeRemoved = true;
      });

      wallet.pendingTxps = txps;
    };


    function get(cb) {
      wallet.getStatus({
        twoStep: true
      }, function(err, ret) {
        if (err) {
          if (err instanceof errors.NOT_AUTHORIZED) {
            return cb('WALLET_NOT_REGISTERED');
          }
          return cb(err);
        }

        return cb(null, ret);
      });
    };

    function cacheBalance(wallet, balance) {
      if (!balance) return;

      var config = configService.getSync().wallet;

      var cache = wallet.cachedStatus;

      // Address with Balance
      cache.balanceByAddress = balance.byAddress;

      // Total wallet balance is same regardless of 'spend unconfirmed funds' setting.
      cache.totalBalanceSat = balance.totalAmount;

      // Spend unconfirmed funds
      if (config.spendUnconfirmed) {
        cache.lockedBalanceSat = balance.lockedAmount;
        cache.availableBalanceSat = balance.availableAmount;
        cache.totalBytesToSendMax = balance.totalBytesToSendMax;
        cache.pendingAmount = 0;
        cache.spendableAmount = balance.totalAmount - balance.lockedAmount;
      } else {
        cache.lockedBalanceSat = balance.lockedConfirmedAmount;
        cache.availableBalanceSat = balance.availableConfirmedAmount;
        cache.totalBytesToSendMax = balance.totalBytesToSendConfirmedMax;
        cache.pendingAmount = balance.totalAmount - balance.totalConfirmedAmount;
        cache.spendableAmount = balance.totalConfirmedAmount - balance.lockedAmount;
      }

      // Selected unit
      cache.unitToSatoshi = config.settings.unitToSatoshi;
      cache.satToUnit = 1 / cache.unitToSatoshi;

      //STR
      cache.totalBalanceStr = txFormatService.formatAmountStr(wallet.coin, cache.totalBalanceSat);
      cache.lockedBalanceStr = txFormatService.formatAmountStr(wallet.coin, cache.lockedBalanceSat);
      cache.availableBalanceStr = txFormatService.formatAmountStr(wallet.coin, cache.availableBalanceSat);
      cache.spendableBalanceStr = txFormatService.formatAmountStr(wallet.coin, cache.spendableAmount);
      cache.pendingBalanceStr = txFormatService.formatAmountStr(wallet.coin, cache.pendingAmount);

      cache.alternativeName = config.settings.alternativeName;
      cache.alternativeIsoCode = config.settings.alternativeIsoCode;

      // Check address
      root.isAddressUsed(wallet, balance.byAddress, function(err, used) {
        if (used) {
          $log.debug('Address used. Creating new');
          // Force new address
          root.getAddress(wallet, true, function(err, addr) {
            $log.debug('New address: ', addr);
          });
        }
      });

      rateService.whenAvailable(function() {

        var totalBalanceAlternative = rateService.toFiat(cache.totalBalanceSat, cache.alternativeIsoCode, wallet.coin);
        var pendingBalanceAlternative = rateService.toFiat(cache.pendingAmount, cache.alternativeIsoCode, wallet.coin);
        var lockedBalanceAlternative = rateService.toFiat(cache.lockedBalanceSat, cache.alternativeIsoCode, wallet.coin);
        var spendableBalanceAlternative = rateService.toFiat(cache.spendableAmount, cache.alternativeIsoCode, wallet.coin);
        var alternativeConversionRate = rateService.toFiat(100000000, cache.alternativeIsoCode, wallet.coin);

        cache.totalBalanceAlternative = $filter('formatFiatAmount')(totalBalanceAlternative);
        cache.pendingBalanceAlternative = $filter('formatFiatAmount')(pendingBalanceAlternative);
        cache.lockedBalanceAlternative = $filter('formatFiatAmount')(lockedBalanceAlternative);
        cache.spendableBalanceAlternative = $filter('formatFiatAmount')(spendableBalanceAlternative);
        cache.alternativeConversionRate = $filter('formatFiatAmount')(alternativeConversionRate);

        cache.alternativeBalanceAvailable = true;
        cache.isRateAvailable = true;
      });
    };

    function isStatusCached() {
      return wallet.cachedStatus && wallet.cachedStatus.isValid;
    };

    function cacheStatus(status) {
      if (status.wallet && status.wallet.scanStatus == 'running') return;

      wallet.cachedStatus = status || {};
      var cache = wallet.cachedStatus;
      cache.statusUpdatedOn = Date.now();
      cache.isValid = true;
      cache.email = status.preferences ? status.preferences.email : null;
      cacheBalance(wallet, status.balance);
    };

    function walletStatusHash(status) {
      return status ? status.balance.totalAmount : wallet.totalBalanceSat;
    };

    function _getStatus(initStatusHash, tries, cb) {
      if (isStatusCached() && !opts.force) {
        $log.debug('Wallet status cache hit:' + wallet.id);
        cacheStatus(wallet.cachedStatus);
        processPendingTxps(wallet.cachedStatus);
        return cb(null, wallet.cachedStatus);
      };

      tries = tries || 0;

      $log.debug('Updating Status:', wallet.credentials.walletName, tries);
      get(function(err, status) {
        if (err) return cb(err);

        var currentStatusHash = walletStatusHash(status);
        $log.debug('Status update. hash:' + currentStatusHash + ' Try:' + tries);
        if (opts.untilItChanges &&
          initStatusHash == currentStatusHash &&
          tries < root.WALLET_STATUS_MAX_TRIES &&
          walletId == wallet.credentials.walletId) {
          return $timeout(function() {
            $log.debug('Retrying update... ' + walletId + ' Try:' + tries)
            return _getStatus(initStatusHash, ++tries, cb);
          }, root.WALLET_STATUS_DELAY_BETWEEN_TRIES * tries);
        }

        processPendingTxps(status);

        $log.debug('Got Wallet Status for:' + wallet.credentials.walletName);

        cacheStatus(status);

        wallet.scanning = status.wallet && status.wallet.scanStatus == 'running';

        return cb(null, status);
      });
    };

    _getStatus(walletStatusHash(), 0, cb);
  };

  var getSavedTxs = function(walletId, cb) {
    storageService.getTxHistory(walletId, function(err, txs) {
      if (err) return cb(err);

      var localTxs = [];

      if (!txs) {
        return cb(null, localTxs);
      }

      try {
        localTxs = JSON.parse(txs);
      } catch (ex) {
        $log.warn(ex);
      }
      return cb(null, lodash.compact(localTxs));
    });
  };

  var getTxsFromServer = function(wallet, skip, endingTxid, limit, cb) {
    var res = [];

    wallet.getTxHistory({
      skip: skip,
      limit: limit
    }, function(err, txsFromServer) {
      if (err) return cb(err);

      if (!txsFromServer.length)
        return cb();

      var res = lodash.takeWhile(txsFromServer, function(tx) {
        return tx.txid != endingTxid;
      });

      return cb(null, res, res.length >= limit);
    });
  };

  var removeAndMarkSoftConfirmedTx = function(txs) {
    return lodash.filter(txs, function(tx) {
      if (tx.confirmations >= root.SOFT_CONFIRMATION_LIMIT)
        return tx;
      tx.recent = true;
    });
  }

  var processNewTxs = function(wallet, txs) {
    var config = configService.getSync().wallet.settings;
    var now = Math.floor(Date.now() / 1000);
    var txHistoryUnique = {};
    var ret = [];
    wallet.hasUnsafeConfirmed = false;

    lodash.each(txs, function(tx) {
      tx = txFormatService.processTx(wallet.coin, tx);

      // no future transactions...
      if (tx.time > now)
        tx.time = now;

      if (tx.confirmations >= root.SAFE_CONFIRMATIONS) {
        tx.safeConfirmed = root.SAFE_CONFIRMATIONS + '+';
      } else {
        tx.safeConfirmed = false;
        wallet.hasUnsafeConfirmed = true;
      }

      if (tx.note) {
        delete tx.note.encryptedEditedByName;
        delete tx.note.encryptedBody;
      }

      if (!txHistoryUnique[tx.txid]) {
        ret.push(tx);
        txHistoryUnique[tx.txid] = true;
      } else {
        $log.debug('Ignoring duplicate TX in history: ' + tx.txid)
      }
    });

    return ret;
  };

  var updateLocalTxHistory = function(wallet, opts, cb) {
    var FIRST_LIMIT = 5;
    var LIMIT = 50;
    var requestLimit = FIRST_LIMIT;
    var walletId = wallet.credentials.walletId;

    var opts = opts || {};
    var progressFn = opts.progressFn || function() {};
    var foundLimitTx = false;


    if (opts.feeLevels) {
      opts.lowAmount = root.getLowAmount(wallet, opts.feeLevels);
    }

    var fixTxsUnit = function(txs) {
      if (!txs || !txs[0] || !txs[0].amountStr) return;

      var cacheCoin = txs[0].amountStr.split(' ')[1];

      if (cacheCoin == 'bits') {

        $log.debug('Fixing Tx Cache Unit to: ' + wallet.coin)
        lodash.each(txs, function(tx) {
          tx.amountStr = txFormatService.formatAmountStr(wallet.coin, tx.amount);
          tx.feeStr = txFormatService.formatAmountStr(wallet.coin, tx.fees);
        });
      }
    };

    getSavedTxs(walletId, function(err, txsFromLocal) {
      if (err) return cb(err);

      fixTxsUnit(txsFromLocal);

      var confirmedTxs = removeAndMarkSoftConfirmedTx(txsFromLocal);
      var endingTxid = confirmedTxs[0] ? confirmedTxs[0].txid : null;
      var endingTs = confirmedTxs[0] ? confirmedTxs[0].time : null;

      // First update
      progressFn(txsFromLocal, 0);
      wallet.completeHistory = txsFromLocal;

      function getNewTxs(newTxs, skip, next) {
        getTxsFromServer(wallet, skip, endingTxid, requestLimit, function(err, res, shouldContinue) {
          if (err) {
            $log.warn(bwcError.msg(err, 'Server Error')); //TODO
            if (err instanceof errors.CONNECTION_ERROR || (err.message && err.message.match(/5../))) {
              $log.info('Retrying history download in 5 secs...');
              return $timeout(function() {
                return getNewTxs(newTxs, skip, next);
              }, 5000);
            };
            return next(err);
          }

          newTxs = newTxs.concat(processNewTxs(wallet, lodash.compact(res)));

          progressFn(newTxs.concat(txsFromLocal), newTxs.length);

          skip = skip + requestLimit;

          $log.debug('Syncing TXs. Got:' + newTxs.length + ' Skip:' + skip, ' EndingTxid:', endingTxid, ' Continue:', shouldContinue);

          // TODO Dirty <HACK>
          // do not sync all history, just looking for a single TX.
          if (opts.limitTx) {

            foundLimitTx = lodash.find(newTxs, {
              txid: opts.limitTx,
            });

            if (foundLimitTx) {
              $log.debug('Found limitTX: ' + opts.limitTx);
              return next(null, [foundLimitTx]);
            }
          }
          // </HACK>


          if (!shouldContinue) {
            $log.debug('Finished Sync: New / soft confirmed Txs: ' + newTxs.length);
            return next(null, newTxs);
          }

          requestLimit = LIMIT;
          getNewTxs(newTxs, skip, next);
        });
      };

      getNewTxs([], 0, function(err, txs) {
        if (err) return cb(err);

        var newHistory = lodash.uniq(lodash.compact(txs.concat(confirmedTxs)), function(x) {
          return x.txid;
        });


        function updateNotes(cb2) {
          if (!endingTs) return cb2();

          $log.debug('Syncing notes from: ' + endingTs);
          wallet.getTxNotes({
            minTs: endingTs
          }, function(err, notes) {
            if (err) {
              $log.warn(err);
              return cb2();
            };
            lodash.each(notes, function(note) {
              $log.debug('Note for ' + note.txid);
              lodash.each(newHistory, function(tx) {
                if (tx.txid == note.txid) {
                  $log.debug('...updating note for ' + note.txid);
                  tx.note = note;
                }
              });
            });
            return cb2();
          });
        }

        function updateLowAmount(txs) {
          if (!opts.lowAmount) return;

          lodash.each(txs, function(tx) {
            tx.lowAmount = tx.amount < opts.lowAmount;
          });
        };

        updateLowAmount(txs);

        updateNotes(function() {

          // <HACK>
          if (foundLimitTx) {
            $log.debug('Tx history read until limitTx: ' + opts.limitTx);
            return cb(null, newHistory);
          }
          // </HACK>

          var historyToSave = JSON.stringify(newHistory);

          lodash.each(txs, function(tx) {
            tx.recent = true;
          })

          $log.debug('Tx History synced. Total Txs: ' + newHistory.length);

          // Final update
          if (walletId == wallet.credentials.walletId) {
            wallet.completeHistory = newHistory;
          }

          return storageService.setTxHistory(historyToSave, walletId, function() {
            $log.debug('Tx History saved.');

            return cb();
          });
        });
      });
    });
  };

  root.getTxNote = function(wallet, txid, cb) {
    wallet.getTxNote({
      txid: txid
    }, function(err, note) {
      if (err) return cb(err);
      return cb(null, note);
    });
  };

  root.editTxNote = function(wallet, args, cb) {
    wallet.editTxNote(args, function(err, res) {
      return cb(err, res);
    });
  };

  root.getTxp = function(wallet, txpid, cb) {
    wallet.getTx(txpid, function(err, txp) {
      if (err) return cb(err);
      return cb(null, txp);
    });
  };

  root.getTx = function(wallet, txid, cb) {

    function finish(list) {
      var tx = lodash.find(list, {
        txid: txid
      });

      if (!tx) return cb('Could not get transaction');
      return cb(null, tx);
    };

    if (wallet.completeHistory && wallet.completeHistory.isValid) {
      finish(wallet.completeHistory);
    } else {
      root.getTxHistory(wallet, {
        limitTx: txid
      }, function(err, txHistory) {
        if (err) return cb(err);

        finish(txHistory);
      });
    }
  };


  root.clearTxHistory = function(wallet, cb) {
    root.invalidateCache(wallet);

    storageService.removeTxHistory(wallet.id, function(err) {
      if (err) {
        $log.error(err);
        return cb(err);
      }
      return cb();
    });
  };



  root.getTxHistory = function(wallet, opts, cb) {
    opts = opts || {};

    var walletId = wallet.credentials.walletId;

    if (!wallet.isComplete()) return cb();

    function isHistoryCached() {
      return wallet.completeHistory && wallet.completeHistory.isValid;
    };

    if (isHistoryCached() && !opts.force) return cb(null, wallet.completeHistory);

    $log.debug('Updating Transaction History');

    updateLocalTxHistory(wallet, opts, function(err, txs) {
      if (err) return cb(err);

      if (opts.limitTx) {
        return cb(err, txs);
      }

      wallet.completeHistory.isValid = true;
      return cb(err, wallet.completeHistory);
    });
  };

  root.isEncrypted = function(wallet) {
    if (lodash.isEmpty(wallet)) return;
    var isEncrypted = wallet.isPrivKeyEncrypted();
    if (isEncrypted) $log.debug('Wallet is encrypted');
    return isEncrypted;
  };

  root.createTx = function(wallet, txp, cb) {
    if (lodash.isEmpty(txp) || lodash.isEmpty(wallet))
      return cb('MISSING_PARAMETER');

    wallet.createTxProposal(txp, function(err, createdTxp) {
      if (err) return cb(err);
      else {
        $log.debug('Transaction created');
        return cb(null, createdTxp);
      }
    });
  };

  root.publishTx = function(wallet, txp, cb) {
    if (lodash.isEmpty(txp) || lodash.isEmpty(wallet))
      return cb('MISSING_PARAMETER');

    wallet.publishTxProposal({
      txp: txp
    }, function(err, publishedTx) {
      if (err) return cb(err);
      else {
        $log.debug('Transaction published');
        return cb(null, publishedTx);
      }
    });
  };

  root.signTx = function(wallet, txp, password, cb) {
    if (!wallet || !txp || !cb)
      return cb('MISSING_PARAMETER');

    if (wallet.isPrivKeyExternal()) {
      switch (wallet.getPrivKeyExternalSourceName()) {
        case root.externalSource.ledger.id:
          return _signWithLedger(wallet, txp, cb);
        case root.externalSource.trezor.id:
          return _signWithTrezor(wallet, txp, cb);
        case root.externalSource.intelTEE.id:
          return _signWithIntelTEE(wallet, txp, cb);
        default:
          var msg = 'Unsupported External Key:' + wallet.getPrivKeyExternalSourceName();
          $log.error(msg);
          return cb(msg);
      }
    } else {

      try {
        wallet.signTxProposal(txp, password, function(err, signedTxp) {
          $log.debug('Transaction signed err:' + err);
          return cb(err, signedTxp);
        });
      } catch (e) {
        $log.warn('Error at signTxProposal:', e);
        return cb(e);
      }
    }
  };

  root.broadcastTx = function(wallet, txp, cb) {
    if (lodash.isEmpty(txp) || lodash.isEmpty(wallet))
      return cb('MISSING_PARAMETER');

    if (txp.status != 'accepted')
      return cb('TX_NOT_ACCEPTED');

    wallet.broadcastTxProposal(txp, function(err, broadcastedTxp, memo) {
      if (err)
        return cb(err);

      $log.debug('Transaction broadcasted');
      if (memo) $log.info(memo);

      return cb(null, broadcastedTxp);
    });
  };

  root.rejectTx = function(wallet, txp, cb) {
    if (lodash.isEmpty(txp) || lodash.isEmpty(wallet))
      return cb('MISSING_PARAMETER');

    wallet.rejectTxProposal(txp, null, function(err, rejectedTxp) {
      $log.debug('Transaction rejected');
      return cb(err, rejectedTxp);
    });
  };

  root.removeTx = function(wallet, txp, cb) {
    if (lodash.isEmpty(txp) || lodash.isEmpty(wallet))
      return cb('MISSING_PARAMETER');

    wallet.removeTxProposal(txp, function(err) {
      $log.debug('Transaction removed');

      root.invalidateCache(wallet);
      $rootScope.$emit('Local/TxAction', wallet.id);

      return cb(err);
    });
  };

  root.updateRemotePreferences = function(clients, prefs, cb) {
    prefs = prefs || {};
    cb = cb || function() {};

    if (!lodash.isArray(clients))
      clients = [clients];

    function updateRemotePreferencesFor(clients, prefs, next) {
      var wallet = clients.shift();
      if (!wallet) return next();
      $log.debug('Saving remote preferences', wallet.credentials.walletName, prefs);

      wallet.savePreferences(prefs, function(err) {

        if (err) {
          popupService.showAlert(bwcError.msg(err, gettextCatalog.getString('Could not save preferences on the server')));
          return next(err);
        }

        updateRemotePreferencesFor(clients, prefs, next);
      });
    };

    // Update this JIC.
    var config = configService.getSync();
    var walletSettings = config.wallet.settings;

    //prefs.email  (may come from arguments)
    prefs.email = config.emailNotifications.email;
    prefs.language = uxLanguage.getCurrentLanguage();
    // prefs.unit = walletSettings.unitCode; // TODO: remove, not used

    updateRemotePreferencesFor(lodash.clone(clients), prefs, function(err) {
      if (err) return cb(err);

      $log.debug('Remote preferences saved for' + lodash.map(clients, function(x) {
        return x.credentials.walletId;
      }).join(','));

      lodash.each(clients, function(c) {
        c.preferences = lodash.assign(prefs, c.preferences);
      });
      return cb();
    });
  };

  root.recreate = function(wallet, cb) {
    $log.debug('Recreating wallet:', wallet.id);
    ongoingProcess.set('recreating', true);
    wallet.recreateWallet(function(err) {
      wallet.notAuthorized = false;
      ongoingProcess.set('recreating', false);
      return cb(err);
    });
  };

  root.startScan = function(wallet, cb) {
    cb = cb || function() {};

    $log.debug('Scanning wallet ' + wallet.id);
    if (!wallet.isComplete()) return;

    wallet.scanning = true;
    wallet.startScan({
      includeCopayerBranches: true,
    }, function(err) {
      return cb(err);
    });
  };


  root.expireAddress = function(wallet, cb) {
    $log.debug('Cleaning Address ' + wallet.id);
    storageService.clearLastAddress(wallet.id, function(err) {
      return cb(err);
    });
  };

  // Check address
  root.isAddressUsed = function(wallet, byAddress, cb) {
    storageService.getLastAddress(wallet.id, function(err, addr) {
      var used = lodash.find(byAddress, {
        address: addr
      });
      return cb(err, used);
    });
  };

  var createAddress = function(wallet, cb) {
    $log.debug('Creating address for wallet:', wallet.id);

    wallet.createAddress({}, function(err, addr) {
      if (err) {
        var prefix = gettextCatalog.getString('Could not create address');
        if (err instanceof errors.CONNECTION_ERROR || (err.message && err.message.match(/5../))) {
          $log.warn(err);
          return $timeout(function() {
            createAddress(wallet, cb);
          }, 5000);
        } else if (err instanceof errors.MAIN_ADDRESS_GAP_REACHED || (err.message && err.message == 'MAIN_ADDRESS_GAP_REACHED')) {
          $log.warn(err);
          prefix = null;
          wallet.getMainAddresses({
            reverse: true,
            limit: 1
          }, function(err, addr) {
            if (err) return cb(err);
            return cb(null, addr[0].address);
          });
        }
        return bwcError.cb(err, prefix, cb);
      }
      return cb(null, addr.address);
    });
  };

  root.getMainAddresses = function(wallet, opts, cb) {
    opts = opts || {};
    opts.reverse = true;
    wallet.getMainAddresses(opts, function(err, addresses) {
      return cb(err, addresses);
    });
  };

  root.getBalance = function(wallet, opts, cb) {
    opts = opts || {};
    wallet.getBalance(opts, function(err, resp) {
      return cb(err, resp);
    });
  };


  // These 2 functions were taken from
  // https://github.com/bitpay/bitcore-wallet-service/blob/master/lib/model/txproposal.js#L243

  function getEstimatedSizeForSingleInput(wallet) {
    switch (wallet.credentials.addressType) {
      case 'P2PKH':
        return 147;
      default:
      case 'P2SH':
        return wallet.m * 72 + wallet.n * 36 + 44;
    }
  };


  root.getEstimatedTxSize = function(wallet, nbOutputs) {
    // Note: found empirically based on all multisig P2SH inputs and within m & n allowed limits.
    var safetyMargin = 0.02;

    var overhead = 4 + 4 + 9 + 9;
    var inputSize = getEstimatedSizeForSingleInput(wallet);
    var outputSize = 34;
    var nbInputs = 1; //Assume 1 input
    var nbOutputs = nbOutputs || 2; // Assume 2 outputs

    var size = overhead + inputSize * nbInputs + outputSize * nbOutputs;
    return parseInt((size * (1 + safetyMargin)).toFixed(0));
  };


  // Approx utxo amount, from which the uxto is economically redeemable
  root.getMinFee = function(wallet, feeLevels, nbOutputs) {
    var lowLevelRate = (lodash.find(feeLevels[wallet.network], {
      level: 'normal',
    }).feePerKb / 1000).toFixed(0);

    var size = root.getEstimatedTxSize(wallet, nbOutputs);
    return size * lowLevelRate;
  };


  // Approx utxo amount, from which the uxto is economically redeemable
  root.getLowAmount = function(wallet, feeLevels, nbOutputs) {
    var minFee = root.getMinFee(wallet, feeLevels, nbOutputs);
    return parseInt(minFee / LOW_AMOUNT_RATIO);
  };



  root.getLowUtxos = function(wallet, levels, cb) {

    wallet.getUtxos({
      coin: wallet.coin
    }, function(err, resp) {
      if (err || !resp || !resp.length) return cb();

      var minFee = root.getMinFee(wallet, levels, resp.length);

      var balance = lodash.sum(resp, 'satoshis');

      // for 2 outputs
      var lowAmount = root.getLowAmount(wallet, levels);
      var lowUtxos = lodash.filter(resp, function(x) {
        return x.satoshis < lowAmount;
      });

      var totalLow = lodash.sum(lowUtxos, 'satoshis');

      return cb(err, {
        allUtxos: resp || [],
        lowUtxos: lowUtxos || [],
        warning: minFee / balance > TOTAL_LOW_WARNING_RATIO,
        minFee: minFee,
      });
    });
  };

  root.getAddress = function(wallet, forceNew, cb) {
    storageService.getLastAddress(wallet.id, function(err, addr) {
      if (err) return cb(err);

      if (!forceNew && addr) return cb(null, addr);

      if (!wallet.isComplete())
        return cb('WALLET_NOT_COMPLETE');

      createAddress(wallet, function(err, _addr) {
        if (err) return cb(err, addr);
        storageService.storeLastAddress(wallet.id, _addr, function() {
          if (err) return cb(err);
          return cb(null, _addr);
        });
      });
    });
  };

  root.getAddressObj = function(wallet, address, cb) {
    wallet.getMainAddresses({
      reverse: true
    }, function(err, addr) {
      if (err) return cb(err);
      var addrObj = lodash.find(addr, function(a) {
        return a.address == address;
      });
      var err = null;
      if (!addrObj) {
        err = 'Error: specified address not in wallet';
      }
      return cb(err, addrObj);
    });
  };

  root.isReady = function(wallet, cb) {
    if (!wallet.isComplete())
      return cb('WALLET_NOT_COMPLETE');

    if (wallet.needsBackup)
      return cb('WALLET_NEEDS_BACKUP');
    return cb();
  };


  // An alert dialog
  var askPassword = function(name, title, cb) {
    var opts = {
      inputType: 'password',
      forceHTMLPrompt: true,
      class: 'text-warn'
    };
    popupService.showPrompt(title, name, opts, function(res) {
      if (!res) return cb();
      if (res) return cb(res)
    });
  };


  root.encrypt = function(wallet, cb) {
    var title = gettextCatalog.getString('Enter new spending password');
    var warnMsg = gettextCatalog.getString('Your wallet key will be encrypted. The Spending Password cannot be recovered. Be sure to write it down.');
    askPassword(warnMsg, title, function(password) {
      if (!password) return cb('no password');
      title = gettextCatalog.getString('Confirm your new spending password');
      askPassword(warnMsg, title, function(password2) {
        if (!password2 || password != password2)
          return cb('password mismatch');

        wallet.encryptPrivateKey(password);
        return cb();
      });
    });
  };


  root.decrypt = function(wallet, cb) {
    $log.debug('Disabling private key encryption for' + wallet.name);
    askPassword(null, gettextCatalog.getString('Enter Spending Password'), function(password) {
      if (!password) return cb('no password');

      try {
        wallet.decryptPrivateKey(password);
      } catch (e) {
        return cb(e);
      }
      return cb();
    });
  };

  root.handleEncryptedWallet = function(wallet, cb) {
    if (!root.isEncrypted(wallet)) return cb();

    askPassword(wallet.name, gettextCatalog.getString('Enter Spending Password'), function(password) {
      if (!password) return cb('No password');
      if (!wallet.checkPassword(password)) return cb('Wrong password');

      return cb(null, password);
    });
  };


  root.reject = function(wallet, txp, cb) {
    ongoingProcess.set('rejectTx', true);
    root.rejectTx(wallet, txp, function(err, txpr) {
      root.invalidateCache(wallet);
      ongoingProcess.set('rejectTx', false);

      if (err) return cb(err);

      $rootScope.$emit('Local/TxAction', wallet.id);
      return cb(null, txpr);
    });
  };


  root.onlyPublish = function(wallet, txp, cb, customStatusHandler) {
    ongoingProcess.set('sendingTx', true, customStatusHandler);
    root.publishTx(wallet, txp, function(err, publishedTxp) {
      root.invalidateCache(wallet);
      ongoingProcess.set('sendingTx', false, customStatusHandler);
      if (err) return cb(bwcError.msg(err));
      $rootScope.$emit('Local/TxAction', wallet.id);
      return cb();
    });
  };


  root.prepare = function(wallet, cb) {
    fingerprintService.check(wallet, function(err) {
      if (err) return cb(err);

      root.handleEncryptedWallet(wallet, function(err, password) {
        if (err) return cb(err);

        return cb(null, password);
      });
    });
  };

  root.publishAndSign = function(wallet, txp, cb, customStatusHandler) {

    var publishFn = root.publishTx;

    // Already published?
    if (txp.status == 'pending') {
      publishFn = function(wallet, txp, cb) {
        return cb(null, txp);
      };
    }

    root.prepare(wallet, function(err, password) {
      if (err) return cb(bwcError.msg(err));

      ongoingProcess.set('sendingTx', true, customStatusHandler);

      publishFn(wallet, txp, function(err, publishedTxp) {
        ongoingProcess.set('sendingTx', false, customStatusHandler);
        if (err) return cb(bwcError.msg(err));

        ongoingProcess.set('signingTx', true, customStatusHandler);
        root.signTx(wallet, publishedTxp, password, function(err, signedTxp) {
          ongoingProcess.set('signingTx', false, customStatusHandler);
          root.invalidateCache(wallet);


          if (err) {
            $log.warn('sign error:' + err);
            var msg = err && err.message ?
              err.message :
              gettextCatalog.getString('The payment was created but could not be completed. Please try again from home screen');

            $rootScope.$emit('Local/TxAction', wallet.id);
            return cb(msg);
          }

          if (signedTxp.status == 'accepted') {
            ongoingProcess.set('broadcastingTx', true, customStatusHandler);
            root.broadcastTx(wallet, signedTxp, function(err, broadcastedTxp) {
              ongoingProcess.set('broadcastingTx', false, customStatusHandler);
              if (err) return cb(bwcError.msg(err));

              $rootScope.$emit('Local/TxAction', wallet.id);
              return cb(null, broadcastedTxp);
            });
          } else {
            $rootScope.$emit('Local/TxAction', wallet.id);
            return cb(null, signedTxp);
          }
        });
      });
    });
  };

  root.getEncodedWalletInfo = function(wallet, password, cb) {
    var derivationPath = wallet.credentials.getBaseAddressDerivationPath();
    var encodingType = {
      mnemonic: 1,
      xpriv: 2,
      xpub: 3
    };
    var info;

    // not supported yet
    if (wallet.credentials.derivationStrategy != 'BIP44' || !wallet.canSign())
      return cb(gettextCatalog.getString('Exporting via QR not supported for this wallet'));

    var keys = root.getKeysWithPassword(wallet, password);

    if (keys.mnemonic) {
      info = {
        type: encodingType.mnemonic,
        data: keys.mnemonic,
      }
    } else {
      info = {
        type: encodingType.xpriv,
        data: keys.xPrivKey
      }
    }

    return cb(null, info.type + '|' + info.data + '|' + wallet.credentials.network.toLowerCase() + '|' + derivationPath + '|' + (wallet.credentials.mnemonicHasPassphrase));
  };

  root.setTouchId = function(wallet, enabled, cb) {

    var opts = {
      touchIdFor: {}
    };
    opts.touchIdFor[wallet.id] = enabled;

    fingerprintService.check(wallet, function(err) {
      if (err) {
        opts.touchIdFor[wallet.id] = !enabled;
        $log.debug('Error with fingerprint:' + err);
        return cb(err);
      }
      configService.set(opts, cb);
    });
  };

  root.getKeys = function(wallet, cb) {
    root.prepare(wallet, function(err, password) {
      if (err) return cb(err);
      var keys;

      try {
        keys = wallet.getKeys(password);
      } catch (e) {
        return cb(e);
      }

      return cb(null, keys);
    });
  };

  root.getKeysWithPassword = function(wallet, password) {
    try {
      return wallet.getKeys(password);
    } catch (e) {}
  }

  root.getSendMaxInfo = function(wallet, opts, cb) {
    opts = opts || {};
    wallet.getSendMaxInfo(opts, function(err, res) {
      return cb(err, res);
    });
  };

  root.getProtocolHandler = function(wallet) {
    if (wallet.coin== 'bch') return 'bitcoincash';
    else return 'bitcoin';
  }


  root.copyCopayers = function(wallet, newWallet, cb) {
    var c = wallet.credentials;

    var walletPrivKey = bitcore.PrivateKey.fromString(c.walletPrivKey);

    var copayer = 1,
      i = 0,
      l = c.publicKeyRing.length;
    var mainErr = null;

    lodash.each(c.publicKeyRing, function(item) {
      var name = item.copayerName || ('copayer ' + copayer++);
      newWallet._doJoinWallet(newWallet.credentials.walletId, walletPrivKey, item.xPubKey, item.requestPubKey, name, {
        coin: newWallet.credentials.coin,
      }, function(err) {
        //Ignore error is copayer already in wallet
        if (err && !(err instanceof errors.COPAYER_IN_WALLET)) {
          mainErr = err;
        }

        if (++i == l) {
          return cb(mainErr);
        }
      });
    });
  };

  return root;
});

'use strict';

angular.module('copayApp.controllers').controller('activityController',
  function($timeout, $scope, $log, $ionicModal, lodash, txpModalService, profileService, walletService, ongoingProcess, popupService, gettextCatalog, $state) {
    $scope.openTxpModal = txpModalService.open;
    $scope.fetchingNotifications = true;

    $scope.$on("$ionicView.enter", function(event, data) {
      profileService.getNotifications(50, function(err, n) {
        if (err) {
          $log.error(err);
          return;
        }
        $scope.fetchingNotifications = false;
        $scope.notifications = n;

        profileService.getTxps({}, function(err, txps, n) {
          if (err) $log.error(err);
          $scope.txps = txps;
          $timeout(function() {
            $scope.$apply();
          });
        });
      });
    });

    $scope.openNotificationModal = function(n) {
      if (n.txid) {
        $state.transitionTo('tabs.wallet.tx-details', {
          txid: n.txid,
          walletId: n.walletId
        });
      } else {
        var txp = lodash.find($scope.txps, {
          id: n.txpId
        });
        if (txp) txpModalService.open(txp);
        else {
          ongoingProcess.set('loadingTxInfo', true);
          walletService.getTxp(n.wallet, n.txpId, function(err, txp) {
            var _txp = txp;
            ongoingProcess.set('loadingTxInfo', false);
            if (err) {
              $log.warn('No txp found');
              return popupService.showAlert(gettextCatalog.getString('Error'), gettextCatalog.getString('Transaction not found'));
            }
            txpModalService.open(_txp);
          });
        }
      }
    };
  });

'use strict';

angular.module('copayApp.controllers').controller('addressbookListController', function($scope, $log, $timeout, addressbookService, lodash, popupService, gettextCatalog, platformInfo) {

  var contacts;

  var initAddressbook = function() {
    addressbookService.list(function(err, ab) {
      if (err) $log.error(err);

      $scope.isEmptyList = lodash.isEmpty(ab);

      if (!$scope.isEmptyList) $scope.showAddIcon = true;
      else $scope.showAddIcon = false;

      contacts = [];
      lodash.each(ab, function(v, k) {
        contacts.push({
          name: lodash.isObject(v) ? v.name : v,
          address: k,
          email: lodash.isObject(v) ? v.email : null
        });
      });

      $scope.addressbook = lodash.clone(contacts);
      $timeout(function() {
        $scope.$apply();
      });
    });
  };

  $scope.findAddressbook = function(search) {
    if (!search || search.length < 2) {
      $scope.addressbook = contacts;
      $timeout(function() {
        $scope.$apply();
      }, 10);
      return;
    }

    var result = lodash.filter(contacts, function(item) {
      var val = item.name;
      return lodash.includes(val.toLowerCase(), search.toLowerCase());
    });

    $scope.addressbook = result;
  };

  $scope.$on("$ionicView.beforeEnter", function(event, data) {
    $scope.isChromeApp = platformInfo.isChromeApp;
    $scope.showAddIcon = false;
    $scope.addrSearch = { value: null };
    initAddressbook();
  });

});

'use strict';

angular.module('copayApp.controllers').controller('addressbookAddController', function($scope, $state, $stateParams, $timeout, $ionicHistory, gettextCatalog, addressbookService, popupService) {

  $scope.fromSendTab = $stateParams.fromSendTab;

  $scope.addressbookEntry = {
    'address': $stateParams.addressbookEntry || '',
    'name': '',
    'email': ''
  };

  $scope.onQrCodeScannedAddressBook = function(data, addressbookForm) {
    $timeout(function() {
      var form = addressbookForm;
      if (data && form) {
        data = data.replace(/^bitcoin(cash)?:/, '');
        form.address.$setViewValue(data);
        form.address.$isValid = true;
        form.address.$render();
      }
      $scope.$digest();
    }, 100);
  };

  $scope.add = function(addressbook) {
    $timeout(function() {
      addressbookService.add(addressbook, function(err, ab) {
        if (err) {
          popupService.showAlert(gettextCatalog.getString('Error'), err);
          return;
        }
        if ($scope.fromSendTab) $scope.goHome();
        else $ionicHistory.goBack();
      });
    }, 100);
  };

  $scope.goHome = function() {
    $ionicHistory.removeBackView();
    $state.go('tabs.home');
  };

});

'use strict';

angular.module('copayApp.controllers').controller('addressbookViewController', function($scope, $state, $timeout, lodash, addressbookService, popupService, $ionicHistory, platformInfo, gettextCatalog, bitcoreCash) {
  $scope.isChromeApp = platformInfo.isChromeApp;
  $scope.addressbookEntry = {};
  var coin;

  $scope.$on("$ionicView.beforeEnter", function(event, data) {
    $scope.addressbookEntry = {};
    $scope.addressbookEntry.name = data.stateParams.name;
    $scope.addressbookEntry.email = data.stateParams.email;
    $scope.addressbookEntry.address = data.stateParams.address;

    var cashAddress = bitcoreCash.Address.isValid($scope.addressbookEntry.address, 'livenet');
    if (cashAddress) {
      coin = 'bch';
    } else {
      coin = 'btcz';
    }
  });

  $scope.sendTo = function() {
    $ionicHistory.removeBackView();
    $state.go('tabs.send');
    $timeout(function() {
      $state.transitionTo('tabs.send.amount', {
        toAddress: $scope.addressbookEntry.address,
        toName: $scope.addressbookEntry.name,
        toEmail: $scope.addressbookEntry.email,
        coin: coin
      });
    }, 100);
  };

  $scope.remove = function(addr) {
    var title = gettextCatalog.getString('Warning!');
    var message = gettextCatalog.getString('Are you sure you want to delete this contact?');
    popupService.showConfirm(title, message, null, null, function(res) {
      if (!res) return;
      addressbookService.remove(addr, function(err, ab) {
        if (err) {
          popupService.showAlert(gettextCatalog.getString('Error'), err);
          return;
        }
        $ionicHistory.goBack();
      });
    });
  };

});

'use strict';

angular.module('copayApp.controllers').controller('addressesController', function($scope, $log, $stateParams, $state, $timeout, $ionicHistory, $ionicScrollDelegate, popupService, gettextCatalog, ongoingProcess, lodash, profileService, walletService, bwcError, platformInfo, appConfigService, txFormatService, feeService) {
  var UNUSED_ADDRESS_LIMIT = 5;
  var BALANCE_ADDRESS_LIMIT = 5;
  var withBalance, cachedWallet;

  $scope.isCordova = platformInfo.isCordova;
  $scope.wallet = profileService.getWallet($stateParams.walletId);

  function resetValues() {
    $scope.loading = false;
    $scope.showInfo = false;
    $scope.showMore = false;
    $scope.allAddressesView = false;
    $scope.latestUnused = $scope.latestWithBalance = null;
    $scope.viewAll = {
      value: false
    };
  };

  $scope.init = function() {
    resetValues();
    $scope.loading = true;

    walletService.getMainAddresses($scope.wallet, {}, function(err, addresses) {
      if (err) {
        $scope.loading = false;
        return popupService.showAlert(bwcError.msg(err, gettextCatalog.getString('Could not update wallet')));
      }

      var allAddresses = addresses;

      walletService.getBalance($scope.wallet, {}, function(err, resp) {
        if (err) {
          $scope.loading = false;
          return popupService.showAlert(bwcError.msg(err, gettextCatalog.getString('Could not update wallet')));
        }

        withBalance = resp.byAddress;
        var idx = lodash.indexBy(withBalance, 'address');
        $scope.noBalance = lodash.reject(allAddresses, function(x) {
          return idx[x.address];
        });

        processPaths($scope.noBalance);
        processPaths(withBalance);

        $scope.latestUnused = lodash.slice($scope.noBalance, 0, UNUSED_ADDRESS_LIMIT);
        $scope.latestWithBalance = lodash.slice(withBalance, 0, BALANCE_ADDRESS_LIMIT);

        lodash.each(withBalance, function(a) {
          a.balanceStr = txFormatService.formatAmountStr($scope.wallet.coin, a.amount);
        });

        $scope.viewAll = {
          value: $scope.noBalance.length > UNUSED_ADDRESS_LIMIT || withBalance.length > BALANCE_ADDRESS_LIMIT
        };
        $scope.allAddresses = $scope.noBalance.concat(withBalance);

        cachedWallet = $scope.wallet.id;
        $scope.loading = false;
        $log.debug('Addresses cached for Wallet:', cachedWallet);
        $timeout(function() {
          $ionicScrollDelegate.resize();
          $scope.$digest();
        });
      });
    });



    feeService.getFeeLevels($scope.wallet.coin, function(err, levels){
      walletService.getLowUtxos($scope.wallet, levels, function(err, resp) {
        if (err) return;

        if (resp && resp.allUtxos && resp.allUtxos.length) {


          var allSum = lodash.sum(resp.allUtxos || 0, 'satoshis');
          var per = (resp.minFee / allSum) * 100;

          $scope.lowWarning = resp.warning;
          $scope.lowUtxosNb = resp.lowUtxos.length;
          $scope.allUtxosNb = resp.allUtxos.length;
          $scope.lowUtxosSum = txFormatService.formatAmountStr($scope.wallet.coin, lodash.sum(resp.lowUtxos || 0, 'satoshis'));
          $scope.allUtxosSum = txFormatService.formatAmountStr($scope.wallet.coin, allSum);
          $scope.minFee = txFormatService.formatAmountStr($scope.wallet.coin, resp.minFee || 0);
          $scope.minFeePer = per.toFixed(2) + '%';


        }
      });
    });
  };

  function processPaths(list) {
    lodash.each(list, function(n) {
      n.path = n.path.replace(/^m/g, 'xpub');
    });
  };

  $scope.newAddress = function() {
    if ($scope.gapReached) return;

    ongoingProcess.set('generatingNewAddress', true);
    walletService.getAddress($scope.wallet, true, function(err, addr) {
      if (err) {
        ongoingProcess.set('generatingNewAddress', false);
        if (err.toString().match('MAIN_ADDRESS_GAP_REACHED')) {
          $scope.gapReached = true;
        } else {
          popupService.showAlert(err);
        }
        $timeout(function() {
          $scope.$digest();
        });
        return;
      }

      walletService.getMainAddresses($scope.wallet, {
        limit: 1
      }, function(err, _addr) {
        ongoingProcess.set('generatingNewAddress', false);
        if (err) return popupService.showAlert(gettextCatalog.getString('Error'), err);
        if (addr != _addr[0].address) return popupService.showAlert(gettextCatalog.getString('Error'), gettextCatalog.getString('New address could not be generated. Please try again.'));

        $scope.noBalance = [_addr[0]].concat($scope.noBalance);
        $scope.latestUnused = lodash.slice($scope.noBalance, 0, UNUSED_ADDRESS_LIMIT);
        $scope.viewAll = {
          value: $scope.noBalance.length > UNUSED_ADDRESS_LIMIT
        };
        $scope.$digest();
      });
    });
  };

  $scope.viewAllAddresses = function() {
    var fromView = $ionicHistory.currentStateName();
    var path;
    if (fromView.indexOf('settings') !== -1) {
      path = 'tabs.settings.allAddresses';
    } else {
      path = 'tabs.wallet.allAddresses';
    }
    $state.go(path, {
      walletId: $scope.wallet.id
    });
  };

  $scope.showInformation = function() {
    $timeout(function() {
      $scope.showInfo = !$scope.showInfo;
      $ionicScrollDelegate.resize();
    }, 10);
  };

  $scope.readMore = function() {
    $timeout(function() {
      $scope.showMore = !$scope.showMore;
      $ionicScrollDelegate.resize();
    }, 10);
  };

  $scope.scan = function() {
    walletService.startScan($scope.wallet);
    $ionicHistory.nextViewOptions({
      disableAnimate: true,
      historyRoot: true
    });
    $ionicHistory.clearHistory();
    $state.go('tabs.home').then(function() {
      $state.transitionTo('tabs.wallet', {
        walletId: $scope.wallet.credentials.walletId
      });
    });
  };

  $scope.sendByEmail = function() {
    function formatDate(ts) {
      var dateObj = new Date(ts * 1000);
      if (!dateObj) {
        $log.debug('Error formating a date');
        return 'DateError';
      }
      if (!dateObj.toJSON()) {
        return '';
      }
      return dateObj.toJSON();
    };

    ongoingProcess.set('sendingByEmail', true);
    $timeout(function() {
      var appName = appConfigService.nameCase;
      var body = appName + ' Wallet "' + $scope.wallet.name + '" Addresses\n  Only Main Addresses are  shown.\n\n';
      body += "\n";
      body += $scope.allAddresses.map(function(v) {
        return ('* ' + v.address + ' xpub' + v.path.substring(1) + ' ' + formatDate(v.createdOn));
      }).join("\n");
      ongoingProcess.set('sendingByEmail', false);

      window.plugins.socialsharing.shareViaEmail(
        body,
        appName + ' Addresses',
        null, // TO: must be null or an array
        null, // CC: must be null or an array
        null, // BCC: must be null or an array
        null, // FILES: can be null, a string, or an array
        function() {},
        function() {}
      );
    });
  };

  function isCachedWallet(walletId) {
    if (cachedWallet && cachedWallet == walletId) return true;
    else return false;
  };

  $scope.$on("$ionicView.afterEnter", function(event, data) {
    $scope.allAddressesView = data.stateName == 'tabs.receive.allAddresses' ? true : false;
    if (!isCachedWallet($stateParams.walletId)) $scope.init();
    else $log.debug('Addresses cached for Wallet:', $stateParams.walletId);
  });
});

'use strict';

angular.module('copayApp.controllers').controller('advancedSettingsController', function($scope, $log, configService, platformInfo, externalLinkService, gettextCatalog) {

  var updateConfig = function() {
    var config = configService.getSync();

    $scope.spendUnconfirmed = {
      value: config.wallet.spendUnconfirmed
    };
    $scope.recentTransactionsEnabled = {
      value: config.recentTransactions.enabled
    };
    $scope.hideNextSteps = {
      value: config.hideNextSteps.enabled
    };

  };

  $scope.spendUnconfirmedChange = function() {
    var opts = {
      wallet: {
        spendUnconfirmed: $scope.spendUnconfirmed.value
      }
    };
    configService.set(opts, function(err) {
      if (err) $log.debug(err);
    });
  };

  $scope.nextStepsChange = function() {
    var opts = {
      hideNextSteps: {
        enabled: $scope.hideNextSteps.value
      },
    };
    configService.set(opts, function(err) {
      if (err) $log.debug(err);
    });
  };

  $scope.recentTransactionsChange = function() {
    var opts = {
      recentTransactions: {
        enabled: $scope.recentTransactionsEnabled.value
      }
    };
    configService.set(opts, function(err) {
      if (err) $log.debug(err);
    });
  };

  $scope.$on("$ionicView.beforeEnter", function(event, data) {
    $scope.isWindowsPhoneApp = platformInfo.isCordova && platformInfo.isWP;
    updateConfig();
  });

});

'use strict';

angular.module('copayApp.controllers').controller('amazonController',
  function($scope, $timeout, $ionicModal, $log, $state, $ionicHistory, lodash, amazonService, externalLinkService, popupService) {

    $scope.openExternalLink = function(url) {
      externalLinkService.open(url);
    };

    var initAmazon = function() {
      amazonService.getPendingGiftCards(function(err, gcds) {
        if (err) $log.error(err);
        $scope.giftCards = gcds;
        $timeout(function() {
          $scope.$digest();
        });
      });
    };

    $scope.$on("$ionicView.beforeEnter", function(event, data) {
      $scope.network = amazonService.getNetwork();
      initAmazon();
    });
  });

'use strict';

angular.module('copayApp.controllers').controller('amazonCardsController',
  function($scope, $timeout, $ionicModal, $log, $ionicScrollDelegate, lodash, amazonService, platformInfo, externalLinkService, popupService, ongoingProcess) {

    $scope.openExternalLink = function(url) {
      externalLinkService.open(url);
    };

    var updateGiftCards = function(cb) {
      amazonService.getPendingGiftCards(function(err, gcds) {
        if (err) {
          popupService.showAlert('Could not get gift cards', err);
          if (cb) return cb();
          else return;
        }
        $scope.giftCards = gcds;
        $timeout(function() {
          $scope.$digest();
          $ionicScrollDelegate.resize();
          if (cb) return cb();
        }, 100);
      });
    };

    $scope.updatePendingGiftCards = lodash.debounce(function() {
      $scope.updatingPending = {};
      updateGiftCards(function() {
        var index = 0;
        var gcds = $scope.giftCards;
        lodash.forEach(gcds, function(dataFromStorage) {
          if (dataFromStorage.status == 'PENDING' || dataFromStorage.status == 'invalid') {
            $log.debug("Creating / Updating gift card");
            $scope.updatingPending[dataFromStorage.invoiceId] = true;

            amazonService.createGiftCard(dataFromStorage, function(err, giftCard) {

              $scope.updatingPending[dataFromStorage.invoiceId] = false;
              if (err) {
                popupService.showAlert('Error creating gift card', err);
                return;
              }

              if (giftCard.status != 'PENDING') {
                var newData = {};

                lodash.merge(newData, dataFromStorage, giftCard);

                if (newData.status == 'expired') {
                  amazonService.savePendingGiftCard(newData, {
                    remove: true
                  }, function(err) {
                    updateGiftCards();
                  });
                  return;
                }

                amazonService.savePendingGiftCard(newData, null, function(err) {
                  $log.debug("Saving new gift card");
                  updateGiftCards();
                });
              }
            });
          }
        });
      });

    }, 1000, {
      'leading': true
    });

    $scope.openCardModal = function(card) {
      $scope.card = card;

      $ionicModal.fromTemplateUrl('views/modals/amazon-card-details.html', {
        scope: $scope
      }).then(function(modal) {
        $scope.amazonCardDetailsModal = modal;
        $scope.amazonCardDetailsModal.show();
      });

      $scope.$on('modal.hidden', function() {
        $scope.updatePendingGiftCards();
      });
    };

    $scope.$on("$ionicView.beforeEnter", function(event, data) {
      $scope.invoiceId = data.stateParams.invoiceId;
      updateGiftCards(function() {
        if ($scope.invoiceId) {
          var card = lodash.find($scope.giftCards, {
            invoiceId: $scope.invoiceId
          });
          if (lodash.isEmpty(card)) {
            popupService.showAlert(null, 'Card not found');
            return;
          }
          $scope.openCardModal(card);
        }
      });
    });

    $scope.$on("$ionicView.afterEnter", function(event, data) {
      $scope.updatePendingGiftCards();
    });
  });

'use strict';

angular.module('copayApp.controllers').controller('amountController', function($scope, $filter, $timeout, $ionicScrollDelegate, $ionicHistory, gettextCatalog, platformInfo, lodash, configService, rateService, $stateParams, $window, $state, $log, txFormatService, ongoingProcess, popupService, bwcError, payproService, profileService, bitcore, amazonService, nodeWebkitService) {
  var _id;
  var unitToSatoshi;
  var satToUnit;
  var unitDecimals;
  var satToBtc;
  var SMALL_FONT_SIZE_LIMIT = 10;
  var LENGTH_EXPRESSION_LIMIT = 19;
  var isNW = platformInfo.isNW;

  var unitIndex = 0;
  var altUnitIndex = 0;
  var availableUnits = [];
  var fiatCode;

  var fixedUnit;

  $scope.isChromeApp = platformInfo.isChromeApp;

  $scope.$on('$ionicView.leave', function() {
    angular.element($window).off('keydown');
  });

  $scope.$on("$ionicView.beforeEnter", function(event, data) {
    var config = configService.getSync().wallet.settings;

    function setAvailableUnits() {

      availableUnits = [];

      var hasBTCZWallets = profileService.getWallets({
        coin: 'btcz'
      }).length;

      if (hasBTCZWallets) {
        availableUnits.push({
          name: 'Bitcoin',
          id: 'btcz',
          shortName: 'BTCZ',
        });
      }


      var hasBCHWallets = profileService.getWallets({
        coin: 'bch'
      }).length;



      if (hasBCHWallets) {
        availableUnits.push({
          name: 'Bitcoin Cash',
          id: 'bch',
          shortName: 'BCH',
        });
      };

      unitIndex = 0;

      if (data.stateParams.coin) {
        var coins = data.stateParams.coin.split(',');
        var newAvailableUnits = [];

        lodash.each(coins, function(c) {
          var coin = lodash.find(availableUnits, {
            id: c
          });
          if (!coin) {
            $log.warn('Could not find desired coin:' + data.stateParams.coin)
          } else {
            newAvailableUnits.push(coin);
          }
        });

        if (newAvailableUnits.length > 0) {
          availableUnits = newAvailableUnits;
        }
      }


      //  currency have preference
      var fiatName;
      if (data.stateParams.currency) {
        fiatCode = data.stateParams.currency;
        altUnitIndex = unitIndex
        unitIndex = availableUnits.length;
      } else {
        fiatCode = config.alternativeIsoCode || 'USD';
        fiatName = config.alternanativeName || fiatCode;
        altUnitIndex = availableUnits.length;
      }

      availableUnits.push({
        name: fiatName || fiatCode,
        // TODO
        id: fiatCode,
        shortName: fiatCode,
        isFiat: true,
      });

      if (data.stateParams.fixedUnit) {
        fixedUnit = true;
      }
    };

    // Go to...
    _id = data.stateParams.id; // Optional (BitPay Card ID or Wallet ID)
    $scope.nextStep = data.stateParams.nextStep;


    setAvailableUnits();
    updateUnitUI();

    $scope.showMenu = $ionicHistory.backView() && ($ionicHistory.backView().stateName == 'tabs.send' || $ionicHistory.backView().stateName == 'tabs.bitpayCard');
    $scope.recipientType = data.stateParams.recipientType || null;
    $scope.toAddress = data.stateParams.toAddress;
    $scope.toName = data.stateParams.toName;
    $scope.toEmail = data.stateParams.toEmail;
    $scope.toColor = data.stateParams.toColor;
    $scope.showSendMax = false;

    if (!$scope.nextStep && !data.stateParams.toAddress) {
      $log.error('Bad params at amount')
      throw ('bad params');
    }

    var reNr = /^[1234567890\.]$/;
    var reOp = /^[\*\+\-\/]$/;

    var disableKeys = angular.element($window).on('keydown', function(e) {
      if (!e.key) return;
      if (e.which === 8) { // you can add others here inside brackets.
        e.preventDefault();
        $scope.removeDigit();
      }

      if (e.key.match(reNr)) {
        $scope.pushDigit(e.key);
      } else if (e.key.match(reOp)) {
        $scope.pushOperator(e.key);
      } else if (e.keyCode === 86) {
        if (e.ctrlKey || e.metaKey) processClipboard();
      } else if (e.keyCode === 13) $scope.finish();

      $timeout(function() {
        $scope.$apply();
      });
    });
    $scope.specificAmount = $scope.specificAlternativeAmount = '';
    $scope.isCordova = platformInfo.isCordova;
    unitToSatoshi = config.unitToSatoshi;
    satToUnit = 1 / unitToSatoshi;
    satToBtc = 1 / 100000000;
    unitDecimals = config.unitDecimals;

    $scope.resetAmount();

    // in SAT ALWAYS
    if ($stateParams.toAmount) {
      $scope.amount = (($stateParams.toAmount) * satToUnit).toFixed(unitDecimals);
    }

    processAmount();

    $timeout(function() {
      $ionicScrollDelegate.resize();
    }, 10);
  });

  function paste(value) {
    $scope.amount = value;
    processAmount();
    $timeout(function() {
      $scope.$apply();
    });
  };

  function processClipboard() {
    if (!isNW) return;
    var value = nodeWebkitService.readFromClipboard();
    if (value && evaluate(value) > 0) paste(evaluate(value));
  };

  $scope.showSendMaxMenu = function() {
    $scope.showSendMax = true;
  };

  $scope.sendMax = function() {
    $scope.showSendMax = false;
    $scope.useSendMax = true;
    $scope.finish();
  };


  $scope.toggleAlternative = function() {
    if ($scope.amount && isExpression($scope.amount)) {
      var amount = evaluate(format($scope.amount));
      $scope.globalResult = '= ' + processResult(amount);
    }
  };

  function updateUnitUI() {
    $scope.unit = availableUnits[unitIndex].shortName;
    $scope.alternativeUnit = availableUnits[altUnitIndex].shortName;

    processAmount();
    $log.debug('Update unit coin @amount unit:' + $scope.unit + " alternativeUnit:" + $scope.alternativeUnit);
  };

  $scope.changeUnit = function() {
    if (fixedUnit) return;

    unitIndex++;
    if (unitIndex >= availableUnits.length) unitIndex = 0;


    if (availableUnits[unitIndex].isFiat) {
      // Always return to BTCZ... TODO?
      altUnitIndex = 0;
    } else {
      altUnitIndex = lodash.findIndex(availableUnits, {
        isFiat: true
      });
    }

    updateUnitUI();
  };


  $scope.changeAlternativeUnit = function() {

    // Do nothing is fiat is not main unit
    if (!availableUnits[unitIndex].isFiat) return;

    var nextCoin = lodash.findIndex(availableUnits, function(x) {
      if (x.isFiat) return false;
      if (x.id == availableUnits[altUnitIndex].id) return false;
      return true;
    });

    if (nextCoin >= 0) {
      altUnitIndex = nextCoin;
      updateUnitUI();
    }
  };

  function checkFontSize() {
    if ($scope.amount && $scope.amount.length >= SMALL_FONT_SIZE_LIMIT) $scope.smallFont = true;
    else $scope.smallFont = false;
  };

  $scope.pushDigit = function(digit) {
    if ($scope.amount && $scope.amount.length >= LENGTH_EXPRESSION_LIMIT) return;
    if ($scope.amount.indexOf('.') > -1 && digit == '.') return;
    if (availableUnits[unitIndex].isFiat && $scope.amount.indexOf('.') > -1 && $scope.amount[$scope.amount.indexOf('.') + 2]) return;

    $scope.amount = ($scope.amount + digit).replace('..', '.');
    checkFontSize();
    processAmount();
  };

  $scope.pushOperator = function(operator) {
    if (!$scope.amount || $scope.amount.length == 0) return;
    $scope.amount = _pushOperator($scope.amount);

    function _pushOperator(val) {
      if (!isOperator(lodash.last(val))) {
        return val + operator;
      } else {
        return val.slice(0, -1) + operator;
      }
    };
  };

  function isOperator(val) {
    var regex = /[\/\-\+\x\*]/;
    return regex.test(val);
  };

  function isExpression(val) {
    var regex = /^\.?\d+(\.?\d+)?([\/\-\+\*x]\d?\.?\d+)+$/;
    return regex.test(val);
  };

  $scope.removeDigit = function() {
    $scope.amount = ($scope.amount).toString().slice(0, -1);
    processAmount();
    checkFontSize();
  };

  $scope.resetAmount = function() {
    $scope.amount = $scope.alternativeAmount = $scope.globalResult = '';
    $scope.allowSend = false;
    checkFontSize();
  };

  function processAmount() {
    var formatedValue = format($scope.amount);
    var result = evaluate(formatedValue);
    $scope.allowSend = lodash.isNumber(result) && +result > 0;
    if (lodash.isNumber(result)) {
      $scope.globalResult = isExpression($scope.amount) ? '= ' + processResult(result) : '';

      if (availableUnits[unitIndex].isFiat) {

        var a = fromFiat(result);
        if (a) {
          $scope.alternativeAmount = txFormatService.formatAmount(a * unitToSatoshi, true);
        } else {
          if (result) {
            $scope.alternativeAmount = 'N/A'; 
          } else {
            $scope.alternativeAmount = null;
          }
          $scope.allowSend = false;
        }
      } else {
        $scope.alternativeAmount = $filter('formatFiatAmount')(toFiat(result));
      }
    }
  };

  function processResult(val) {
    if (availableUnits[unitIndex].isFiat) return $filter('formatFiatAmount')(val);
    else return txFormatService.formatAmount(val.toFixed(unitDecimals) * unitToSatoshi, true);
  };

  function fromFiat(val) {
    return parseFloat((rateService.fromFiat(val, fiatCode, availableUnits[altUnitIndex].id) * satToUnit).toFixed(unitDecimals));
  };

  function toFiat(val) {
    if (!rateService.getRate(fiatCode)) return;

    return parseFloat((rateService.toFiat(val * unitToSatoshi, fiatCode, availableUnits[unitIndex].id)).toFixed(2));
  };

  function evaluate(val) {
    var result;
    try {
      result = $scope.$eval(val);
    } catch (e) {
      return 0;
    }
    if (!lodash.isFinite(result)) return 0;
    return result;
  };

  function format(val) {
    if (!val) return;

    var result = val.toString();

    if (isOperator(lodash.last(val))) result = result.slice(0, -1);

    return result.replace('x', '*');
  };

  $scope.finish = function() {

    var unit = availableUnits[unitIndex];
    var _amount = evaluate(format($scope.amount));
    var coin = unit.id;
    if (unit.isFiat) {
      coin = availableUnits[altUnitIndex].id;
    }

    if ($scope.nextStep) {

      $state.transitionTo($scope.nextStep, {
        id: _id,
        amount: $scope.useSendMax ? null : _amount,
        currency: unit.id.toUpperCase(),
        coin: coin,
        useSendMax: $scope.useSendMax
      });
    } else {
      var amount = _amount;

      if (unit.isFiat) {
        amount = (fromFiat(amount) * unitToSatoshi).toFixed(0);
      } else {
        amount = (amount * unitToSatoshi).toFixed(0);
      }

      $state.transitionTo('tabs.send.confirm', {
        recipientType: $scope.recipientType,
        toAmount: amount,
        toAddress: $scope.toAddress,
        toName: $scope.toName,
        toEmail: $scope.toEmail,
        toColor: $scope.toColor,
        coin: coin,
        useSendMax: $scope.useSendMax
      });
    }
    $scope.useSendMax = null;
  };
});

'use strict';

angular.module('copayApp.controllers').controller('backController', function($scope, $state, $stateParams) {

  $scope.importGoBack = function() {
    if ($stateParams.fromOnboarding) $state.go('onboarding.welcome');
    else $state.go('tabs.add');
  };

  $scope.onboardingMailSkip = function() {
    $state.go('onboarding.backupRequest');
  }

});

'use strict';

angular.module('copayApp.controllers').controller('backupController',
  function($scope, $timeout, $log, $state, $stateParams, $ionicHistory, lodash, profileService, bwcService, walletService, ongoingProcess, popupService, gettextCatalog, $ionicModal) {
    $scope.wallet = profileService.getWallet($stateParams.walletId);
    $scope.viewTitle = $scope.wallet.name || $scope.wallet.credentials.walletName;
    $scope.n = $scope.wallet.n;
    var keys;

    $scope.credentialsEncrypted = $scope.wallet.isPrivKeyEncrypted();

    var isDeletedSeed = function() {
      if (!$scope.wallet.credentials.mnemonic && !$scope.wallet.credentials.mnemonicEncrypted)
        return true;

      return false;
    };

    var shuffledWords = function(words) {
      var sort = lodash.sortBy(words);

      return lodash.map(sort, function(w) {
        return {
          word: w,
          selected: false
        };
      });
    };

    $scope.setFlow = function(step) {
      if (!keys) return;

      var words = keys.mnemonic;
      $scope.data = {};

      $scope.mnemonicWords = words.split(/[\u3000\s]+/);
      $scope.shuffledMnemonicWords = shuffledWords($scope.mnemonicWords);
      $scope.mnemonicHasPassphrase = $scope.wallet.mnemonicHasPassphrase();
      $scope.useIdeograms = words.indexOf("\u3000") >= 0;
      $scope.data.passphrase = null;
      $scope.customWords = [];
      $scope.step = step || 1;
      $scope.selectComplete = false;
      $scope.backupError = false;

      words = lodash.repeat('x', 300);
      $timeout(function() {
        $scope.$apply();
      }, 10);
    };

    var backupError = function(err) {
      ongoingProcess.set('validatingWords', false);
      $log.debug('Failed to verify backup: ', err);
      $scope.backupError = true;

      $timeout(function() {
        $scope.$apply();
      }, 1);
    };

    function openConfirmBackupModal() {
      $ionicModal.fromTemplateUrl('views/includes/confirmBackupPopup.html', {
        scope: $scope,
        backdropClickToClose: false,
        hardwareBackButtonClose: false
      }).then(function(modal) {
        $scope.confirmBackupModal = modal;
        $scope.confirmBackupModal.show();
      });
    };

    var showBackupResult = function() {
      if ($scope.backupError) {
        var title = gettextCatalog.getString('Uh oh...');
        var message = gettextCatalog.getString("It's important that you write your backup phrase down correctly. If something happens to your wallet, you'll need this backup to recover your money. Please review your backup and try again.");
        popupService.showAlert(title, message, function() {
          $scope.setFlow(2);
        })
      } else {
        openConfirmBackupModal();
      }
    };

    $scope.closeBackupResultModal = function() {
      $scope.confirmBackupModal.hide();
      $scope.confirmBackupModal.remove();

      profileService.isDisclaimerAccepted(function(val) {
        if (val) {
          $ionicHistory.removeBackView();
          $state.go('tabs.home');
        } else $state.go('onboarding.disclaimer', {
          walletId: $stateParams.walletId,
          backedUp: true
        });
      });
    };

    $scope.copyRecoveryPhrase = function() {
      if ($scope.wallet.network == 'livenet') return null;
      else if (!$scope.wallet.credentials.mnemonic) return null;
      else return $scope.wallet.credentials.mnemonic;
    };

    var confirm = function(cb) {
      $scope.backupError = false;

      var customWordList = lodash.pluck($scope.customWords, 'word');

      if (!lodash.isEqual($scope.mnemonicWords, customWordList)) {
        return cb('Mnemonic string mismatch');
      }

      $timeout(function() {
        if ($scope.mnemonicHasPassphrase) {
          var walletClient = bwcService.getClient();
          var separator = $scope.useIdeograms ? '\u3000' : ' ';
          var customSentence = customWordList.join(separator);
          var passphrase = $scope.data.passphrase || '';

          try {
            walletClient.seedFromMnemonic(customSentence, {
              network: $scope.wallet.credentials.network,
              passphrase: passphrase,
              account: $scope.wallet.credentials.account
            });
          } catch (err) {
            walletClient.credentials.xPrivKey = lodash.repeat('x', 64);
            return cb(err);
          }

          if (walletClient.credentials.xPrivKey.substr(walletClient.credentials.xPrivKey) != keys.xPrivKey) {
            delete walletClient.credentials;
            return cb('Private key mismatch');
          }
        }

        profileService.setBackupFlag($scope.wallet.credentials.walletId);
        return cb();
      }, 1);
    };

    var finalStep = function() {
      ongoingProcess.set('validatingWords', true);
      confirm(function(err) {
        ongoingProcess.set('validatingWords', false);
        if (err) {
          backupError(err);
        }
        $timeout(function() {
          showBackupResult();
          return;
        }, 1);
      });
    };

    $scope.goToStep = function(n) {
      if (n == 1)
        $scope.setFlow();
      if (n == 2)
        $scope.step = 2;
      if (n == 3) {
        if (!$scope.mnemonicHasPassphrase)
          finalStep();
        else
          $scope.step = 3;
      }
      if (n == 4)
        finalStep();
    };

    $scope.addButton = function(index, item) {
      var newWord = {
        word: item.word,
        prevIndex: index
      };
      $scope.customWords.push(newWord);
      $scope.shuffledMnemonicWords[index].selected = true;
      $scope.shouldContinue();
    };

    $scope.removeButton = function(index, item) {
      if ($scope.loading) return;
      $scope.customWords.splice(index, 1);
      $scope.shuffledMnemonicWords[item.prevIndex].selected = false;
      $scope.shouldContinue();
    };

    $scope.shouldContinue = function() {
      if ($scope.customWords.length == $scope.shuffledMnemonicWords.length)
        $scope.selectComplete = true;
      else
        $scope.selectComplete = false;
    };

    $scope.$on("$ionicView.enter", function(event, data) {
      $scope.deleted = isDeletedSeed();
      if ($scope.deleted) {
        $log.debug('no mnemonics');
        return;
      }

      walletService.getKeys($scope.wallet, function(err, k) {
        if (err || !k) {
          $log.error('Could not get keys: ', err);
          $ionicHistory.goBack();
          return;
        }
        $scope.credentialsEncrypted = false;
        keys = k;
        $scope.setFlow();
      });
    });

  });

'use strict';

angular.module('copayApp.controllers').controller('bitpayCardController', function($scope, $timeout, $log, $state, lodash, bitpayCardService, moment, popupService, gettextCatalog, $ionicHistory, bitpayService, externalLinkService, timeService) {

  var self = this;
  $scope.dateRange = {
    value: 'last30Days'
  };
  $scope.network = bitpayService.getEnvironment().network;

  var setDateRange = function(preset) {
    var startDate, endDate;
    preset = preset || 'last30Days';
    switch (preset) {
      case 'last30Days':
        startDate = moment().subtract(30, 'days').toISOString();
        endDate = moment().toISOString();
        break;
      case 'lastMonth':
        startDate = moment().startOf('month').subtract(1, 'month').toISOString();
        endDate = moment().startOf('month').toISOString();
        break;
      case 'all':
        startDate = null;
        endDate = null;
        break;
      default:
        return;
    }
    return {
      startDate: startDate,
      endDate: endDate
    };
  };

  var setGetStarted = function(history, cb) {

    // Is the card new?
    if (!lodash.isEmpty(history.transactionList))
      return cb();

    var dateRange = setDateRange('all');
    bitpayCardService.getHistory($scope.cardId, dateRange, function(err, history) {

      if (!err && lodash.isEmpty(history.transactionList))
        self.getStarted = true;

      return cb();
    });
  };

  this.update = function() {
    var dateRange = setDateRange($scope.dateRange.value);

    $scope.loadingHistory = true;
    bitpayCardService.getHistory($scope.cardId, dateRange, function(err, history) {

      $scope.loadingHistory = false;

      if (err) {
        $log.error(err);
        self.bitpayCardTransactionHistoryCompleted = null;
        self.bitpayCardTransactionHistoryConfirming = null;
        self.bitpayCardTransactionHistoryPreAuth = null;
        self.balance = null;
        popupService.showAlert(gettextCatalog.getString('Error'), gettextCatalog.getString('Could not get transactions'));
        return;
      }

      setGetStarted(history, function() {

        var txs = lodash.clone(history.txs);

        self.bitpayCardTransactionHistoryConfirming = bitpayCardService.filterTransactions('confirming', txs);
        self.bitpayCardTransactionHistoryCompleted = bitpayCardService.filterTransactions('completed', txs);
        self.bitpayCardTransactionHistoryPreAuth = bitpayCardService.filterTransactions('preAuth', txs);

        self.balance = history.currentCardBalance;
        self.updatedOn = null;

        if ($scope.dateRange.value == 'last30Days') {

          // TODO?
          // $log.debug('BitPay Card: storing cache history');
          // var cacheHistory = {
          //   balance: history.currentCardBalance,
          //   transactions: history.txs
          // };
          // bitpayCardService.setHistory($scope.cardId, cacheHistory, {}, function(err) {
          //   if (err) $log.error(err);
          //   $scope.historyCached = true;
          // });
        }
        $timeout(function() {
          $scope.$apply();
        });
      });
    });
  };

  $scope.createdWithinPastDay = function(tx) {
    var result = false;
    if (tx.date) {
      result = timeService.withinPastDay(tx.date);
    }
    return result;
  };

  this.openExternalLink = function(url) {
    var optIn = true;
    var title = null;
    var message = gettextCatalog.getString('Help and support information is available at the website.');
    var okText = gettextCatalog.getString('Open');
    var cancelText = gettextCatalog.getString('Go Back');
    externalLinkService.open(url, optIn, title, message, okText, cancelText);
  };

  this.viewOnBlockchain = function(transactionId) {
    var url = 'https://insight.bitpay.com/tx/' + transactionId;
    var optIn = true;
    var title = null;
    var message = gettextCatalog.getString('View Transaction on Insight');
    var okText = gettextCatalog.getString('Open Insight');
    var cancelText = gettextCatalog.getString('Go Back');
    externalLinkService.open(url, optIn, title, message, okText, cancelText);
  };

  $scope.$on("$ionicView.beforeEnter", function(event, data) {
    $scope.cardId = data.stateParams.id;

    if (!$scope.cardId) {
      $ionicHistory.nextViewOptions({
        disableAnimate: true
      });
      $state.go('tabs.home');
    }


    bitpayCardService.get({
      cardId: $scope.cardId,
      noRefresh: true,
    }, function(err, cards) {

      if (cards && cards[0]) {
        self.lastFourDigits = cards[0].lastFourDigits;
        self.balance = cards[0].balance;
        self.currencySymbol = cards[0].currencySymbol;
        self.updatedOn = cards[0].updatedOn;
        self.currency = cards[0].currency;
      }
      self.update();
    });
  });
});

'use strict';
angular.module('copayApp.controllers').controller('bitpayCardIntroController', function($scope, $log, $state, $ionicHistory, storageService, externalLinkService, bitpayCardService, gettextCatalog, popupService, bitpayAccountService) {

  $scope.$on("$ionicView.beforeEnter", function(event, data) {
    if (data.stateParams && data.stateParams.secret) {
      var pairData = {
        secret: data.stateParams.secret,
        email: data.stateParams.email,
        otp: data.stateParams.otp
      };
      var pairingReason = gettextCatalog.getString('add your BitPay Visa card(s)');
      bitpayAccountService.pair(pairData, pairingReason, function(err, paired, apiContext) {
        if (err) {
          popupService.showAlert(gettextCatalog.getString('Error pairing BitPay Account'), err);
          return;
        }
        if (paired) {
          bitpayCardService.sync(apiContext, function(err, cards) {
            if (err) {
              popupService.showAlert(gettextCatalog.getString('Error updating Debit Cards'), err);
              return;
            }
            $ionicHistory.nextViewOptions({
              disableAnimate: true
            });
            $state.go('tabs.home').then(function() {
              if (cards[0]) {
                $state.transitionTo('tabs.bitpayCard', {
                  id: cards[0].id
                });
              }
            });
          });
        }
      });
    }

    bitpayAccountService.getAccounts(function(err, accounts) {
      if (err) {
        popupService.showAlert(gettextCatalog.getString('Error'), err);
        return;
      }
      $scope.accounts = accounts;
    });
  });

  $scope.bitPayCardInfo = function() {
    var url = 'https://bitpay.com/visa/faq';
    externalLinkService.open(url);
  };

  $scope.orderBitPayCard = function() {
    var url = 'https://bitpay.com/visa/get-started';
    externalLinkService.open(url);
  };

  $scope.connectBitPayCard = function() {
    if ($scope.accounts.length == 0) {
      startPairBitPayAccount();
    } else {
      showAccountSelector();
    }
  };

  var startPairBitPayAccount = function() {
    var url = 'https://bitpay.com/visa/dashboard/add-to-bitpay-wallet-confirm';
    externalLinkService.open(url);
  };

  var showAccountSelector = function() {
    $scope.accountSelectorTitle = gettextCatalog.getString('From BitPay account');
    $scope.showAccounts = ($scope.accounts != undefined);
  };

  $scope.onAccountSelect = function(account) {
    if (account == undefined) {
      startPairBitPayAccount();
    } else {
      bitpayCardService.sync(account.apiContext, function(err, data) {
        if (err) {
          popupService.showAlert(gettextCatalog.getString('Error'), err);
          return;
        }
        $state.go('tabs.home');
      });
    }
  };

});

'use strict';

angular.module('copayApp.controllers').controller('buyAmazonController', function($scope, $log, $state, $timeout, $filter, $ionicHistory, $ionicConfig, lodash, amazonService, popupService, profileService, ongoingProcess, configService, walletService, payproService, bwcError, externalLinkService, platformInfo, gettextCatalog, txFormatService) {

  var coin = 'btcz';
  var amount;
  var currency;
  var createdTx;
  var message;
  var invoiceId;
  var configWallet = configService.getSync().wallet;
  $scope.isCordova = platformInfo.isCordova;

  $scope.openExternalLink = function(url) {
    externalLinkService.open(url);
  };

  var _resetValues = function() {
    $scope.totalAmountStr = $scope.amount = $scope.invoiceFee = $scope.networkFee = $scope.totalAmount = $scope.wallet = null;
    createdTx = message = invoiceId = null;
  };

  var showErrorAndBack = function(title, msg) {
    title = title || gettextCatalog.getString('Error');
    $scope.sendStatus = '';
    $log.error(msg);
    msg = (msg && msg.errors) ? msg.errors[0].message : msg;
    popupService.showAlert(title, msg, function() {
      $ionicHistory.goBack();
    });
  };

  var showError = function(title, msg, cb) {
    cb = cb || function() {};
    title = title || gettextCatalog.getString('Error');
    $scope.sendStatus = '';
    $log.error(msg);
    msg = (msg && msg.errors) ? msg.errors[0].message : msg;
    popupService.showAlert(title, msg, cb);
  };

  var publishAndSign = function(wallet, txp, onSendStatusChange, cb) {
    if (!wallet.canSign() && !wallet.isPrivKeyExternal()) {
      var err = gettextCatalog.getString('No signing proposal: No private key');
      $log.info(err);
      return cb(err);
    }

    walletService.publishAndSign(wallet, txp, function(err, txp) {
      if (err) return cb(err);
      return cb(null, txp);
    }, onSendStatusChange);
  };

  var statusChangeHandler = function(processName, showName, isOn) {
    $log.debug('statusChangeHandler: ', processName, showName, isOn);
    if (processName == 'buyingGiftCard' && !isOn) {
      $scope.sendStatus = 'success';
      $timeout(function() {
        $scope.$digest();
      }, 100);
    } else if (showName) {
      $scope.sendStatus = showName;
    }
  };

  var satToFiat = function(sat, cb) {
    txFormatService.toFiat(coin, sat, $scope.currencyIsoCode, function(value) {
      return cb(value);
    });
  };

  var setTotalAmount = function(amountSat, invoiceFeeSat, networkFeeSat) {
    satToFiat(amountSat, function(a) {
      $scope.amount = Number(a);

      satToFiat(invoiceFeeSat, function(i) {
        $scope.invoiceFee = Number(i);

        satToFiat(networkFeeSat, function(n) {
          $scope.networkFee = Number(n);
          $scope.totalAmount = $scope.amount + $scope.invoiceFee + $scope.networkFee;
          $timeout(function() {
            $scope.$digest();
          });
        });
      });
    });
  };

  var createInvoice = function(data, cb) {
    amazonService.createBitPayInvoice(data, function(err, dataInvoice) {
      if (err) {
        var err_title = gettextCatalog.getString('Error creating the invoice');
        var err_msg;
        if (err && err.message && err.message.match(/suspended/i)) {
          err_title = gettextCatalog.getString('Service not available');
          err_msg = gettextCatalog.getString('Amazon.com is not available at this moment. Please try back later.');
        } else if (err && err.message) {
          err_msg = err.message;
        } else {
          err_msg = gettextCatalog.getString('Could not access to Amazon.com');
        };

        return cb({
          title: err_title,
          message: err_msg
        });
      }

      var accessKey = dataInvoice ? dataInvoice.accessKey : null;

      if (!accessKey) {
        return cb({
          message: gettextCatalog.getString('No access key defined')
        });
      }

      amazonService.getBitPayInvoice(dataInvoice.invoiceId, function(err, invoice) {
        if (err) {
          return cb({
            message: gettextCatalog.getString('Could not get the invoice')
          });
        }

        return cb(null, invoice, accessKey);
      });
    });
  };

  var createTx = function(wallet, invoice, message, cb) {
    var payProUrl = (invoice && invoice.paymentUrls) ? invoice.paymentUrls.BIP73 : null;

    if (!payProUrl) {
      return cb({
        title: gettextCatalog.getString('Error in Payment Protocol'),
        message: gettextCatalog.getString('Invalid URL')
      });
    }

    var outputs = [];
    var toAddress = invoice.bitcoinAddress;
    var amountSat = parseInt((invoice.btczDue * 100000000).toFixed(0)); // BTCZ to Satoshi

    outputs.push({
      'toAddress': toAddress,
      'amount': amountSat,
      'message': message
    });

    var txp = {
      toAddress: toAddress,
      amount: amountSat,
      outputs: outputs,
      message: message,
      payProUrl: payProUrl,
      excludeUnconfirmedUtxos: configWallet.spendUnconfirmed ? false : true,
      feeLevel: configWallet.settings.feeLevel || 'normal'
    };

    walletService.createTx(wallet, txp, function(err, ctxp) {
      if (err) {
        return cb({
          title: gettextCatalog.getString('Could not create transaction'),
          message: bwcError.msg(err)
        });
      }
      return cb(null, ctxp);
    });
  };

  var checkTransaction = lodash.throttle(function(count, dataSrc) {
    amazonService.createGiftCard(dataSrc, function(err, giftCard) {
      $log.debug("creating gift card " + count);
      if (err) {
        ongoingProcess.set('buyingGiftCard', false, statusChangeHandler);
        giftCard = {};
        giftCard.status = 'FAILURE';
        showError(gettextCatalog.getString('Error creating gift card'), err);
      }

      if (giftCard.status == 'PENDING' && count < 3) {
        $log.debug("Waiting for payment confirmation");
        checkTransaction(count + 1, dataSrc);
        return;
      }

      var now = moment().unix() * 1000;

      var newData = giftCard;
      newData['invoiceId'] = dataSrc.invoiceId;
      newData['accessKey'] = dataSrc.accessKey;
      newData['invoiceUrl'] = dataSrc.invoiceUrl;
      newData['amount'] = dataSrc.amount;
      newData['date'] = dataSrc.invoiceTime || now;
      newData['uuid'] = dataSrc.uuid;

      if (newData.status == 'expired') {
        amazonService.savePendingGiftCard(newData, {
          remove: true
        }, function(err) {
          $log.error(err);
          ongoingProcess.set('buyingGiftCard', false, statusChangeHandler);
          showError(null, gettextCatalog.getString('Gift card expired'));
        });
        return;
      }

      amazonService.savePendingGiftCard(newData, null, function(err) {
        ongoingProcess.set('buyingGiftCard', false, statusChangeHandler);
        $log.debug("Saving new gift card with status: " + newData.status);
        $scope.amazonGiftCard = newData;
      });
    });
  }, 8000, {
    'leading': true
  });

  var initialize = function(wallet) {
    var parsedAmount = txFormatService.parseAmount(coin, amount, currency);
    $scope.currencyIsoCode = parsedAmount.currency;
    $scope.amountUnitStr = parsedAmount.amountUnitStr;
    var dataSrc = {
      amount: parsedAmount.amount,
      currency: parsedAmount.currency,
      uuid: wallet.id
    };
    ongoingProcess.set('loadingTxInfo', true);
    createInvoice(dataSrc, function(err, invoice, accessKey) {
      if (err) {
        ongoingProcess.set('loadingTxInfo', false);
        showErrorAndBack(err.title, err.message);
        return;
      }
      // Sometimes API does not return this element;
      invoice['buyerPaidBtcMinerFee'] = invoice.buyerPaidBtcMinerFee || 0;
      var invoiceFeeSat = (invoice.buyerPaidBtcMinerFee * 100000000).toFixed();

      message = gettextCatalog.getString("{{amountStr}} for Amazon.com Gift Card", {
        amountStr: $scope.amountUnitStr
      });

      createTx(wallet, invoice, message, function(err, ctxp) {
        ongoingProcess.set('loadingTxInfo', false);
        if (err) {
          _resetValues();
          showError(err.title, err.message);
          return;
        }

        // Save in memory
        createdTx = ctxp;
        invoiceId = invoice.id;

        createdTx['giftData'] = {
          currency: dataSrc.currency,
          amount: dataSrc.amount,
          uuid: dataSrc.uuid,
          accessKey: accessKey,
          invoiceId: invoice.id,
          invoiceUrl: invoice.url,
          invoiceTime: invoice.invoiceTime
        };
        $scope.totalAmountStr = txFormatService.formatAmountStr(coin, ctxp.amount);
        setTotalAmount(parsedAmount.amountSat, invoiceFeeSat, ctxp.fee);
      });
    });
  };

  $scope.$on("$ionicView.beforeLeave", function(event, data) {
    $ionicConfig.views.swipeBackEnabled(true);
  });

  $scope.$on("$ionicView.enter", function(event, data) {
    $ionicConfig.views.swipeBackEnabled(false);
  });

  $scope.$on("$ionicView.beforeEnter", function(event, data) {
    amount = data.stateParams.amount;
    currency = data.stateParams.currency;

    $scope.limitPerDayMessage = gettextCatalog.getString('Purchase Amount is limited to {{limitPerDay}} {{currency}} per day', {
      limitPerDay: amazonService.limitPerDay,
      currency: currency
    });

    if (amount > amazonService.limitPerDay) {
      showErrorAndBack(null, $scope.limitPerDayMessage);
      return;
    }

    $scope.network = amazonService.getNetwork();
    $scope.wallets = profileService.getWallets({
      onlyComplete: true,
      network: $scope.network,
      hasFunds: true,
      coin: coin
    });
    if (lodash.isEmpty($scope.wallets)) {
      showErrorAndBack(null, gettextCatalog.getString('No wallets available'));
      return;
    }
    $scope.onWalletSelect($scope.wallets[0]); // Default first wallet
  });

  $scope.buyConfirm = function() {
    if (!createdTx) {
      showError(null, gettextCatalog.getString('Transaction has not been created'));
      return;
    }
    var title = gettextCatalog.getString('Confirm');
    var okText = gettextCatalog.getString('OK');
    var cancelText = gettextCatalog.getString('Cancel');
    popupService.showConfirm(title, message, okText, cancelText, function(ok) {
      if (!ok) {
        $scope.sendStatus = '';
        return;
      }

      ongoingProcess.set('buyingGiftCard', true, statusChangeHandler);
      publishAndSign($scope.wallet, createdTx, function() {}, function(err, txSent) {
        if (err) {
          _resetValues();
          ongoingProcess.set('buyingGiftCard', false, statusChangeHandler);
          showError(gettextCatalog.getString('Could not send transaction'), err);
          return;
        }
        checkTransaction(1, createdTx.giftData);
      });
    });
  };

  $scope.showWalletSelector = function() {
    $scope.walletSelectorTitle = gettextCatalog.getString('Buy from');
    $scope.showWallets = true;
  };

  $scope.onWalletSelect = function(wallet) {
    $scope.wallet = wallet;
    initialize(wallet);
  };

  $scope.goBackHome = function() {
    $scope.sendStatus = '';
    $ionicHistory.nextViewOptions({
      disableAnimate: true,
      historyRoot: true
    });
    $ionicHistory.clearHistory();
    $state.go('tabs.home').then(function() {
      $ionicHistory.nextViewOptions({
        disableAnimate: true
      });
      $state.transitionTo('tabs.giftcards.amazon').then(function() {
        $state.transitionTo('tabs.giftcards.amazon.cards', {
          invoiceId: invoiceId
        });
      });
    });
  };
});

'use strict';

angular.module('copayApp.controllers').controller('buyAndSellCardController', function($scope, nextStepsService, $ionicScrollDelegate, buyAndSellService) {

  $scope.services = buyAndSellService.getLinked();

  $scope.toggle = function() {
    $scope.hide = !$scope.hide;
    $timeout(function() {
      $ionicScrollDelegate.resize();
      $scope.$apply();
    }, 10);
  };
});

'use strict';

angular.module('copayApp.controllers').controller('buyandsellController', function($scope, $ionicHistory, buyAndSellService, lodash) {

  $scope.$on("$ionicView.beforeEnter", function(event, data) {
    $scope.services = buyAndSellService.get();

    if (lodash.isEmpty($scope.services))
      $ionicHistory.goBack();
  });
});

'use strict';

angular.module('copayApp.controllers').controller('buyCoinbaseController', function($scope, $log, $state, $timeout, $ionicHistory, $ionicScrollDelegate, $ionicConfig, lodash, coinbaseService, popupService, profileService, ongoingProcess, walletService, txFormatService) {

  var coin = 'btcz';
  var amount;
  var currency;

  var showErrorAndBack = function(err) {
    $scope.sendStatus = '';
    $log.error(err);
    err = err.errors ? err.errors[0].message : err;
    popupService.showAlert('Error', err, function() {
      $ionicHistory.goBack();
    });
  };

  var showError = function(err) {
    $scope.sendStatus = '';
    $log.error(err);
    err = err.errors ? err.errors[0].message : err;
    popupService.showAlert('Error', err);
  };

  var statusChangeHandler = function (processName, showName, isOn) {
    $log.debug('statusChangeHandler: ', processName, showName, isOn);
    if ( processName == 'buyingBitcoin' && !isOn) {
      $scope.sendStatus = 'success';
      $timeout(function() {
        $scope.$digest();
      }, 100);
    } else if (showName) {
      $scope.sendStatus = showName;
    }
  };

  var processPaymentInfo = function() {
    ongoingProcess.set('connectingCoinbase', true);
    coinbaseService.init(function(err, res) {
      if (err) {
        ongoingProcess.set('connectingCoinbase', false);
        showErrorAndBack(err);
        return;
      }
      var accessToken = res.accessToken;

      coinbaseService.buyPrice(accessToken, coinbaseService.getAvailableCurrency(), function(err, b) {
        $scope.buyPrice = b.data || null;
      });

      $scope.paymentMethods = [];
      $scope.selectedPaymentMethodId = { value : null };
      coinbaseService.getPaymentMethods(accessToken, function(err, p) {
        if (err) {
          ongoingProcess.set('connectingCoinbase', false);
          showErrorAndBack(err);
          return;
        }

        var hasPrimary;
        var pm;
        for(var i = 0; i < p.data.length; i++) {
          pm = p.data[i];
          if (pm.allow_buy) {
            $scope.paymentMethods.push(pm);
          }
          if (pm.allow_buy && pm.primary_buy) {
            hasPrimary = true;
            $scope.selectedPaymentMethodId.value = pm.id;
          }
        }
        if (lodash.isEmpty($scope.paymentMethods)) {
          ongoingProcess.set('connectingCoinbase', false);
          showErrorAndBack('No payment method available to buy');
          return;
        }
        if (!hasPrimary) $scope.selectedPaymentMethodId.value = $scope.paymentMethods[0].id;
        $scope.buyRequest();
      });
    });
  };

  $scope.$on("$ionicView.beforeLeave", function(event, data) {
    $ionicConfig.views.swipeBackEnabled(true);
  });

  $scope.$on("$ionicView.enter", function(event, data) {
    $ionicConfig.views.swipeBackEnabled(false);
  });

  $scope.$on("$ionicView.beforeEnter", function(event, data) {
    $scope.isFiat = data.stateParams.currency != 'BTCZ' ? true : false;
    amount = data.stateParams.amount;
    currency = data.stateParams.currency;

    $scope.network = coinbaseService.getNetwork();
    $scope.wallets = profileService.getWallets({
      onlyComplete: true,
      network: $scope.network,
      coin: coin
    });

    if (lodash.isEmpty($scope.wallets)) {
      showErrorAndBack('No wallets available');
      return;
    }
    $scope.onWalletSelect($scope.wallets[0]); // Default first wallet
  });

  $scope.buyRequest = function() {
    ongoingProcess.set('connectingCoinbase', true);
    coinbaseService.init(function(err, res) {
      if (err) {
        ongoingProcess.set('connectingCoinbase', false);
        showErrorAndBack(err);
        return;
      }
      var accessToken = res.accessToken;
      var accountId = res.accountId;
      var dataSrc = {
        amount: amount,
        currency: currency,
        payment_method: $scope.selectedPaymentMethodId.value,
        quote: true
      };
      coinbaseService.buyRequest(accessToken, accountId, dataSrc, function(err, data) {
        ongoingProcess.set('connectingCoinbase', false);
        if (err) {
          showErrorAndBack(err);
          return;
        }
        $scope.buyRequestInfo = data.data;
        $timeout(function() {
          $scope.$apply();
        }, 100);
      });
    });
  };

  $scope.buyConfirm = function() {
    var message = 'Buy bitcoin for ' + $scope.amountUnitStr;
    var okText = 'Confirm';
    var cancelText = 'Cancel';
    popupService.showConfirm(null, message, okText, cancelText, function(ok) {
      if (!ok) return;

      ongoingProcess.set('buyingBitcoin', true, statusChangeHandler);
      coinbaseService.init(function(err, res) {
        if (err) {
          ongoingProcess.set('buyingBitcoin', false, statusChangeHandler);
          showError(err);
          return;
        }
        var accessToken = res.accessToken;
        var accountId = res.accountId;
        var dataSrc = {
          amount: amount,
          currency: currency,
          payment_method: $scope.selectedPaymentMethodId.value,
          commit: true
        };
        coinbaseService.buyRequest(accessToken, accountId, dataSrc, function(err, b) {
          if (err) {
            ongoingProcess.set('buyingBitcoin', false, statusChangeHandler);
            showError(err);
            return;
          }

          var processBuyTx = function (tx) {
            if (!tx) {
              ongoingProcess.set('buyingBitcoin', false, statusChangeHandler);
              showError('Transaction not found');
              return;
            }

            coinbaseService.getTransaction(accessToken, accountId, tx.id, function(err, updatedTx) {
              if (err) {
                ongoingProcess.set('buyingBitcoin', false, statusChangeHandler);
                showError(err);
                return;
              }
              walletService.getAddress($scope.wallet, false, function(err, walletAddr) {
                if (err) {
                  ongoingProcess.set('buyingBitcoin', false, statusChangeHandler);
                  showError(err);
                  return;
                }
                updatedTx.data['toAddr'] = walletAddr;
                updatedTx.data['status'] = 'pending'; // Forcing "pending" status to process later

                $log.debug('Saving transaction to process later...');
                coinbaseService.savePendingTransaction(updatedTx.data, {}, function(err) {
                  ongoingProcess.set('buyingBitcoin', false, statusChangeHandler);
                  if (err) $log.debug(err);
                });
              });
            });
          };

          var _processBuyOrder = function() {
            coinbaseService.getBuyOrder(accessToken, accountId, b.data.id, function (err, buyResp) {
              if (err) {
                ongoingProcess.set('buyingBitcoin', false, statusChangeHandler);
                showError(err);
                return;
              }
              var tx = buyResp.data ? buyResp.data.transaction : null;
              if (tx && tx.id) {
                processBuyTx(tx);
              } else {
                $timeout(function() {
                  _processBuyOrder();
                }, 5000);
              }
            });
          }

          $timeout(function() {
            var tx = b.data ? b.data.transaction : null;
            if (tx && tx.id) {
              processBuyTx(tx);
            }
            else {
              _processBuyOrder();
            }
          }, 8000);
        });
      });
    });
  };

  $scope.showWalletSelector = function() {
    $scope.walletSelectorTitle = 'Receive in';
    $scope.showWallets = true;
  };

  $scope.onWalletSelect = function(wallet) {
    $scope.wallet = wallet;
    var parsedAmount = txFormatService.parseAmount(
      coin,
      amount,
      currency);

    // Buy always in BTCZ
    amount = (parsedAmount.amountSat / 100000000).toFixed(8);
    currency = 'BTCZ';

    $scope.amountUnitStr = parsedAmount.amountUnitStr;
    ongoingProcess.set('calculatingFee', true);
    coinbaseService.checkEnoughFundsForFee(amount, function(err) {
      ongoingProcess.set('calculatingFee', false);
      if (err) {
        showErrorAndBack(err);
        return;
      }
      processPaymentInfo();
    });
  };

  $scope.goBackHome = function() {
    $scope.sendStatus = '';
    $ionicHistory.nextViewOptions({
      disableAnimate: true,
      historyRoot: true
    });
    $ionicHistory.clearHistory();
    $state.go('tabs.home').then(function() {
      $state.transitionTo('tabs.buyandsell.coinbase');
    });
  };
});

'use strict';

angular.module('copayApp.controllers').controller('buyGlideraController', function($scope, $log, $state, $timeout, $ionicHistory, $ionicConfig, lodash, glideraService, popupService, profileService, ongoingProcess, walletService, platformInfo, txFormatService) {

  var coin = 'btcz';
  var amount;
  var currency;

  $scope.isCordova = platformInfo.isCordova;

  var showErrorAndBack = function(err) {
    $scope.sendStatus = '';
    $log.error(err);
    err = err.errors ? err.errors[0].message : err || '';
    popupService.showAlert('Error', err, function() {
      $ionicHistory.goBack();
    });
  };

  var showError = function(err) {
    $scope.sendStatus = '';
    $log.error(err);
    err = err.errors ? err.errors[0].message : err;
    popupService.showAlert('Error', err);
  };

  var statusChangeHandler = function (processName, showName, isOn) {
    $log.debug('statusChangeHandler: ', processName, showName, isOn);
    if ( processName == 'buyingBitcoin' && !isOn) {
      $scope.sendStatus = 'success';
      $timeout(function() {
        $scope.$digest();
      }, 100);
    } else if (showName) {
      $scope.sendStatus = showName;
    }
  };

  var processPaymentInfo = function() {
    ongoingProcess.set('connectingGlidera', true);
    glideraService.init(function(err, data) {
      if (err) {
        ongoingProcess.set('connectingGlidera', false);
        showErrorAndBack(err);
        return;
      }
      $scope.token = data.token;
      var price = {};
      if ($scope.isFiat) {
        price['fiat'] = amount;
      } else {
        price['qty'] = amount;
      }
      glideraService.buyPrice($scope.token, price, function(err, buy) {
        ongoingProcess.set('connectingGlidera', false);
        if (err) {
          showErrorAndBack(err);
          return;
        }
        $scope.buyInfo = buy;
      });
    });
  };

  $scope.$on("$ionicView.beforeLeave", function(event, data) {
    $ionicConfig.views.swipeBackEnabled(true);
  });

  $scope.$on("$ionicView.enter", function(event, data) {
    $ionicConfig.views.swipeBackEnabled(false);
  });

  $scope.$on("$ionicView.beforeEnter", function(event, data) {
    $scope.isFiat = data.stateParams.currency != 'BTCZ' ? true : false;
    amount = data.stateParams.amount;
    currency = data.stateParams.currency;

    $scope.network = glideraService.getNetwork();
    $scope.wallets = profileService.getWallets({
      onlyComplete: true,
      network: $scope.network,
      coin: coin
    });

    if (lodash.isEmpty($scope.wallets)) {
      showErrorAndBack('No wallets available');
      return;
    }
    $scope.onWalletSelect($scope.wallets[0]); // Default first wallet
  });

  var ask2FaCode = function(mode, cb) {
    if (mode != 'NONE') {
      // SHOW PROMPT
      var title = 'Please, enter the code below';
      var message;
      if (mode == 'PIN') {
        message = 'You have enabled PIN based two-factor authentication.';
      } else if (mode == 'AUTHENTICATOR') {
        message = 'Use an authenticator app (Authy or Google Authenticator).';
      } else {
        message = 'A SMS containing a confirmation code was sent to your phone.';
      }
      popupService.showPrompt(title, message, null, function(twoFaCode) {
        if (typeof twoFaCode == 'undefined') return cb();
        return cb(twoFaCode);
      });
    } else {
      return cb();
    }
  };

  $scope.buyConfirm = function() {
    var message = 'Buy bitcoin for ' + amount + ' ' + currency;
    var okText = 'Confirm';
    var cancelText = 'Cancel';
    popupService.showConfirm(null, message, okText, cancelText, function(ok) {
      if (!ok) return;
      ongoingProcess.set('buyingBitcoin', true, statusChangeHandler);
      glideraService.get2faCode($scope.token, function(err, tfa) {
        if (err) {
          ongoingProcess.set('buyingBitcoin', false, statusChangeHandler);
          showError(err);
          return;
        }
        ask2FaCode(tfa.mode, function(twoFaCode) {
          if (tfa.mode != 'NONE' && lodash.isEmpty(twoFaCode)) {
            ongoingProcess.set('buyingBitcoin', false, statusChangeHandler);
            showError('No code entered');
            return;
          }

          walletService.getAddress($scope.wallet, false, function(err, walletAddr) {
            if (err) {
              ongoingProcess.set('buyingBitcoin', false, statusChangeHandler);
              showError(err);
              return;
            }
            var data = {
              destinationAddress: walletAddr,
              qty: $scope.buyInfo.qty,
              priceUuid: $scope.buyInfo.priceUuid,
              useCurrentPrice: false,
              ip: null
            };
            glideraService.buy($scope.token, twoFaCode, data, function(err, data) {
              ongoingProcess.set('buyingBitcoin', false, statusChangeHandler);
              if (err) return showError(err);
              $log.info(data);
            });
          });
        });
      });
    });
  };

  $scope.showWalletSelector = function() {
    $scope.walletSelectorTitle = 'Receive in';
    $scope.showWallets = true;
  };

  $scope.onWalletSelect = function(wallet) {
    $scope.wallet = wallet;
    var parsedAmount = txFormatService.parseAmount(
      coin,
      amount,
      currency);

    amount = parsedAmount.amount;
    currency = parsedAmount.currency;
    $scope.amountUnitStr = parsedAmount.amountUnitStr;
    processPaymentInfo();
  };

  $scope.goBackHome = function() {
    $scope.sendStatus = '';
    $ionicHistory.nextViewOptions({
      disableAnimate: true,
      historyRoot: true
    });
    $ionicHistory.clearHistory();
    $state.go('tabs.home').then(function() {
      $state.transitionTo('tabs.buyandsell.glidera');
    });
  };
});

'use strict';

angular.module('copayApp.controllers').controller('buyMercadoLibreController', function($scope, $log, $state, $timeout, $filter, $ionicHistory, $ionicConfig, lodash, mercadoLibreService, popupService, profileService, ongoingProcess, configService, walletService, payproService, bwcError, externalLinkService, platformInfo, txFormatService, gettextCatalog) {

  var coin = 'btcz';
  var amount;
  var currency;
  var createdTx;
  var message;
  var invoiceId;
  var configWallet = configService.getSync().wallet;
  $scope.isCordova = platformInfo.isCordova;

  $scope.openExternalLink = function(url) {
    externalLinkService.open(url);
  };

  var _resetValues = function() {
    $scope.totalAmountStr = $scope.amount = $scope.invoiceFee = $scope.networkFee = $scope.totalAmount = $scope.wallet = null;
    createdTx = message = invoiceId = null;
  };

  var showErrorAndBack = function(title, msg) {
    title = title || gettextCatalog.getString('Error');
    $scope.sendStatus = '';
    $log.error(msg);
    msg = (msg && msg.errors) ? msg.errors[0].message : msg;
    popupService.showAlert(title, msg, function() {
      $ionicHistory.goBack();
    });
  };

  var showError = function(title, msg, cb) {
    cb = cb || function() {};
    title = title || gettextCatalog.getString('Error');
    $scope.sendStatus = '';
    $log.error(msg);
    msg = (msg && msg.errors) ? msg.errors[0].message : msg;
    popupService.showAlert(title, msg, cb);
  };

  var publishAndSign = function(wallet, txp, onSendStatusChange, cb) {
    if (!wallet.canSign() && !wallet.isPrivKeyExternal()) {
      var err = 'No signing proposal: No private key';
      $log.info(err);
      return cb(err);
    }

    walletService.publishAndSign(wallet, txp, function(err, txp) {
      if (err) return cb(err);
      return cb(null, txp);
    }, onSendStatusChange);
  };

  var statusChangeHandler = function(processName, showName, isOn) {
    $log.debug('statusChangeHandler: ', processName, showName, isOn);
    if (processName == 'Comprando Vale-presente' && !isOn) {
      $scope.sendStatus = 'success';
      $timeout(function() {
        $scope.$digest();
      }, 100);
    } else if (showName) {
      $scope.sendStatus = showName;
    }
  };

  var satToFiat = function(sat, cb) {
    txFormatService.toFiat(coin, sat, $scope.currencyIsoCode, function(value) {
      return cb(value);
    });
  };

  var setTotalAmount = function(amountSat, invoiceFeeSat, networkFeeSat) {
    satToFiat(amountSat, function(a) {
      $scope.amount = Number(a);

      satToFiat(invoiceFeeSat, function(i) {
        $scope.invoiceFee = Number(i);

        satToFiat(networkFeeSat, function(n) {
          $scope.networkFee = Number(n);
          $scope.totalAmount = $scope.amount + $scope.invoiceFee + $scope.networkFee;
          $timeout(function() {
            $scope.$digest();
          });
        });
      });
    });
  };

  var createInvoice = function(data, cb) {
    mercadoLibreService.createBitPayInvoice(data, function(err, dataInvoice) {
      if (err) {
        var err_title = gettextCatalog.getString('Error creating the invoice');
        var err_msg;
        if (err && err.message && err.message.match(/suspended/i)) {
          err_title = gettextCatalog.getString('Service not available');
          err_msg = gettextCatalog.getString('Mercadolibre Gift Card Service is not available at this moment. Please try back later.');
        } else if (err && err.message) {
          err_msg = err.message;
        } else {
          err_msg = gettextCatalog.getString('Could not access Gift Card Service');
        };

        return cb({
          title: err_title,
          message: err_msg
        });
      }

      var accessKey = dataInvoice ? dataInvoice.accessKey : null;

      if (!accessKey) {
        return cb({
          message: gettextCatalog.getString('No access key defined')
        });
      }

      mercadoLibreService.getBitPayInvoice(dataInvoice.invoiceId, function(err, invoice) {
        if (err) {
          return cb({
            message: gettextCatalog.getString('Could not get the invoice')
          });
        }

        return cb(null, invoice, accessKey);
      });
    });
  };

  var createTx = function(wallet, invoice, message, cb) {
    var payProUrl = (invoice && invoice.paymentUrls) ? invoice.paymentUrls.BIP73 : null;

    if (!payProUrl) {
      return cb({
        title: gettextCatalog.getString('Error in Payment Protocol'),
        message: gettextCatalog.getString('Invalid URL')
      });
    }

    var outputs = [];
    var toAddress = invoice.bitcoinAddress;
    var amountSat = parseInt((invoice.btczDue * 100000000).toFixed(0)); // BTCZ to Satoshi

    outputs.push({
      'toAddress': toAddress,
      'amount': amountSat,
      'message': message
    });

    var txp = {
      toAddress: toAddress,
      amount: amountSat,
      outputs: outputs,
      message: message,
      payProUrl: payProUrl,
      excludeUnconfirmedUtxos: configWallet.spendUnconfirmed ? false : true,
      feeLevel: configWallet.settings.feeLevel || 'normal'
    };

    walletService.createTx(wallet, txp, function(err, ctxp) {
      if (err) {
        return cb({
          title: gettextCatalog.getString('Could not create transaction'),
          message: bwcError.msg(err)
        });
      }
      return cb(null, ctxp);
    });
  };

  var checkTransaction = lodash.throttle(function(count, dataSrc) {
    mercadoLibreService.createGiftCard(dataSrc, function(err, giftCard) {
      $log.debug("creating gift card " + count);
      if (err) {
        $scope.sendStatus = '';
        ongoingProcess.set('Comprando Vale-presente', false, statusChangeHandler);
        giftCard = {};
        giftCard.status = 'FAILURE';
      }

      if (giftCard && giftCard.cardStatus && (giftCard.cardStatus != 'active' && giftCard.cardStatus != 'inactive' && giftCard.cardStatus != 'expired')) {
        $scope.sendStatus = '';
        ongoingProcess.set('Comprando Vale-presente', false, statusChangeHandler);
        giftCard = {};
        giftCard.status = 'FAILURE';
      }


      if (giftCard.status == 'PENDING' && count < 3) {
        $log.debug("Waiting for payment confirmation");
        checkTransaction(count + 1, dataSrc);
        return;
      }

      var now = moment().unix() * 1000;

      var newData = giftCard;
      newData['invoiceId'] = dataSrc.invoiceId;
      newData['accessKey'] = dataSrc.accessKey;
      newData['invoiceUrl'] = dataSrc.invoiceUrl;
      newData['amount'] = dataSrc.amount;
      newData['currency'] = dataSrc.currency;
      newData['date'] = dataSrc.invoiceTime || now;
      newData['uuid'] = dataSrc.uuid;

      mercadoLibreService.savePendingGiftCard(newData, null, function(err) {
        ongoingProcess.set('Comprando Vale-presente', false, statusChangeHandler);
        $log.debug("Saving new gift card with status: " + newData.status);
        $scope.mlGiftCard = newData;
      });
    });
  }, 8000, {
    'leading': true
  });

  var initialize = function(wallet) {
    var parsedAmount = txFormatService.parseAmount(coin, amount, currency);
    $scope.currencyIsoCode = parsedAmount.currency;
    $scope.amountUnitStr = parsedAmount.amountUnitStr;
    var dataSrc = {
      amount: parsedAmount.amount,
      currency: parsedAmount.currency,
      uuid: wallet.id
    };
    ongoingProcess.set('loadingTxInfo', true);
    createInvoice(dataSrc, function(err, invoice, accessKey) {
      if (err) {
        ongoingProcess.set('loadingTxInfo', false);
        showErrorAndBack(err.title, err.message);
        return;
      }
      // Sometimes API does not return this element;
      invoice['buyerPaidBtcMinerFee'] = invoice.buyerPaidBtcMinerFee || 0;
      var invoiceFeeSat = (invoice.buyerPaidBtcMinerFee * 100000000).toFixed();

      message = gettextCatalog.getString("{{amountStr}} for Mercado Livre Brazil Gift Card", {
        amountStr: $scope.amountUnitStr
      });

      createTx(wallet, invoice, message, function(err, ctxp) {
        ongoingProcess.set('loadingTxInfo', false);
        if (err) {
          _resetValues();
          showError(err.title, err.message);
          return;
        }

        // Save in memory
        createdTx = ctxp;
        invoiceId = invoice.id;

        createdTx['giftData'] = {
          currency: dataSrc.currency,
          amount: dataSrc.amount,
          uuid: dataSrc.uuid,
          accessKey: accessKey,
          invoiceId: invoice.id,
          invoiceUrl: invoice.url,
          invoiceTime: invoice.invoiceTime
        };
        $scope.totalAmountStr = txFormatService.formatAmountStr(coin, ctxp.amount);
        setTotalAmount(parsedAmount.amountSat, invoiceFeeSat, ctxp.fee);
      });
    });
  };

  $scope.$on("$ionicView.beforeLeave", function(event, data) {
    $ionicConfig.views.swipeBackEnabled(true);
  });

  $scope.$on("$ionicView.enter", function(event, data) {
    $ionicConfig.views.swipeBackEnabled(false);
  });

  $scope.$on("$ionicView.beforeEnter", function(event, data) {
    amount = data.stateParams.amount;
    currency = data.stateParams.currency;

    if (amount > 2000 || amount < 50) {
      showErrorAndBack(null, gettextCatalog.getString('Purchase amount must be a value between 50 and 2000'));
      return;
    }

    $scope.network = mercadoLibreService.getNetwork();
    $scope.wallets = profileService.getWallets({
      onlyComplete: true,
      network: $scope.network,
      coin: coin
    });
    if (lodash.isEmpty($scope.wallets)) {
      showErrorAndBack(null, gettextCatalog.getString('No wallets available'));
      return;
    }
    $scope.onWalletSelect($scope.wallets[0]); // Default first wallet
  });

  $scope.buyConfirm = function() {

    if (!createdTx) {
      showError(null, gettextCatalog.getString('Transaction has not been created'));
      return;
    }

    var title = gettextCatalog.getString('Confirm');
    var okText = gettextCatalog.getString('Ok');
    var cancelText = gettextCatalog.getString('Cancel');
    popupService.showConfirm(title, message, okText, cancelText, function(ok) {
      if (!ok) {
        $scope.sendStatus = '';
        return;
      }

      ongoingProcess.set('Comprando Vale-presente', true, statusChangeHandler);
      publishAndSign($scope.wallet, createdTx, function() {}, function(err, txSent) {
        if (err) {
          ongoingProcess.set('Comprando Vale-presente', false, statusChangeHandler);
          showError(gettextCatalog.getString('Could not send transaction'), err);
          return;
        }
        checkTransaction(1, createdTx.giftData);
      });
    });
  };

  $scope.showWalletSelector = function() {
    $scope.walletSelectorTitle = 'Buy from';
    $scope.showWallets = true;
  };

  $scope.onWalletSelect = function(wallet) {
    $scope.wallet = wallet;
    initialize(wallet);
  };

  $scope.goBackHome = function() {
    $scope.sendStatus = '';
    $ionicHistory.nextViewOptions({
      disableAnimate: true,
      historyRoot: true
    });
    $ionicHistory.clearHistory();
    $state.go('tabs.home').then(function() {
      $ionicHistory.nextViewOptions({
        disableAnimate: true
      });
      $state.transitionTo('tabs.giftcards.mercadoLibre').then(function() {
        $state.transitionTo('tabs.giftcards.mercadoLibre.cards', {
          invoiceId: invoiceId
        });
      });
    });
  };
});

'use strict';

angular.module('copayApp.controllers').controller('cashScanController',
  function($rootScope, $timeout, $scope, $state, $ionicHistory, gettextCatalog, lodash, ongoingProcess, profileService, walletService, $log, txFormatService, bwcError, pushNotificationsService, bwcService, externalLinkService) {
    var wallet;
    var errors = bwcService.getErrors();
    $scope.error = null;
    $scope.walletDisabled = '#667';

    $scope.$on("$ionicView.beforeEnter", function(event, data) {
      updateAllWallets();
    });

    $scope.openRecoveryToolLink = function() {
      var url = 'https://bitpay.github.io/copay-recovery/';
      var optIn = true;
      var title = null;
      var message = gettextCatalog.getString('Open the recovery tool.');
      var okText = gettextCatalog.getString('Open');
      var cancelText = gettextCatalog.getString('Go Back');
      externalLinkService.open(url, optIn, title, message, okText, cancelText);
    };

    var goHome = function() {
      $ionicHistory.nextViewOptions({
        disableAnimate: true,
        historyRoot: true
      });
      $ionicHistory.clearHistory();
      $state.go('tabs.settings').then(function() {
        $state.transitionTo('tabs.home');
      });
    }

    var updateAllWallets = function() {
      var walletsBTCZ = profileService.getWallets({
        coin: 'btcz',
        onlyComplete: true,
        network: 'livenet'
      });

      // Filter out already duplicated wallets
      var walletsBCH = profileService.getWallets({
        coin: 'bch',
        network: 'livenet'
      });
      var xPubKeyIndex = lodash.indexBy(walletsBCH, "credentials.xPubKey");

      walletsBTCZ = lodash.filter(walletsBTCZ, function(w) {
        return !xPubKeyIndex[w.credentials.xPubKey];
      });

      var availableWallets = [];
      var nonEligibleWallets = [];

      lodash.each(walletsBTCZ, function(w) {
        if (w.credentials.derivationStrategy != 'BIP44') {
          w.excludeReason = gettextCatalog.getString('Non BIP44 wallet');
          nonEligibleWallets.push(w);
        } else if (!w.canSign()) {
          w.excludeReason = gettextCatalog.getString('Read only wallet');
          nonEligibleWallets.push(w);
        } else if (w.needsBackup) {
          w.excludeReason = gettextCatalog.getString('Backup needed');
          nonEligibleWallets.push(w);
        } else {
          availableWallets.push(w);
        }
      });

      $scope.availableWallets = availableWallets;
      $scope.nonEligibleWallets = nonEligibleWallets;

      var i = availableWallets.length;
      var j = 0;
      lodash.each(availableWallets, function(wallet) {
        walletService.getBalance(wallet, {
          coin: 'bch'
        }, function(err, balance) {
          if (err) {
            wallet.error = (err === 'WALLET_NOT_REGISTERED') ? gettextCatalog.getString('Wallet not registered') : bwcError.msg(err);
            $log.error(err);
            return;
          }

          wallet.error = null;
          wallet.bchBalance = txFormatService.formatAmountStr('bch', balance.availableAmount);
          if (++j == i) {
            //Done
            $timeout(function() {
              $rootScope.$apply();
            }, 10);
          }
        });
      });
    };

    $scope.duplicate = function(wallet) {
      $scope.error = null;
      $log.debug('Duplicating wallet for BCH:' + wallet.id + ':' + wallet.name);

      var opts = {};
      opts.name = wallet.name + '[BCH]';
      opts.m = wallet.m;
      opts.n = wallet.n;
      opts.myName = wallet.credentials.copayerName;
      opts.networkName = wallet.network;
      opts.coin = 'bch';
      opts.walletPrivKey = wallet.credentials.walletPrivKey;
      opts.compliantDerivation = wallet.credentials.compliantDerivation;


      function setErr(err, cb) {

        if (!cb) cb = function() {};

        $scope.error = bwcError.cb(err, gettextCatalog.getString('Could not duplicate'), function() {
          return cb(err);
        });
        $timeout(function() {
          $rootScope.$apply();
        }, 10);
      }

      function importOrCreate(cb) {
        walletService.getStatus(wallet, {}, function(err, status) {
          if (err) return cb(err);

          opts.singleAddress = status.wallet.singleAddress;

          // first try to import
          profileService.importExtendedPrivateKey(opts.extendedPrivateKey, opts, function(err, newWallet) {
            if (err && !(err instanceof errors.NOT_AUTHORIZED)) {
              return setErr(err, cb);
            }
            if (err) {
              // create and store a wallet
              return profileService.createWallet(opts, function(err, newWallet) {
                if (err) return setErr(err, cb);
                return cb(null, newWallet, true);
              });
            }
            return cb(null, newWallet);
          });
        });
      };

      // Multisig wallets? add Copayers
      function addCopayers(newWallet, isNew, cb) {
        if (!isNew) return cb();
        if (wallet.n == 1) return cb();

        $log.info('Adding copayers for BCH wallet config:' + wallet.m + '-' + wallet.n);

        walletService.copyCopayers(wallet, newWallet, function(err) {
          if (err) return setErr(err, cb);

          return cb();
        });
      };

      walletService.getKeys(wallet, function(err, keys) {
        if (err) {
          $scope.error = err;
          return $timeout(function() {
            $rootScope.$apply();
          }, 10);
        }
        opts.extendedPrivateKey = keys.xPrivKey;
        ongoingProcess.set('duplicatingWallet', true);
        importOrCreate(function(err, newWallet, isNew) {
          if (err) {
            ongoingProcess.set('duplicatingWallet', false);
            return;
          }
          walletService.updateRemotePreferences(newWallet);
          pushNotificationsService.updateSubscription(newWallet);

          addCopayers(newWallet, isNew, function(err) {
            ongoingProcess.set('duplicatingWallet', false);
            if (err)
              return setErr(err);

            if (isNew)
              walletService.startScan(newWallet, function() {});

            goHome();
          });
        });
      });
    }
  });

'use strict';

angular.module('copayApp.controllers').controller('coinbaseController', function($scope, $timeout, $ionicModal, $ionicHistory, $log, coinbaseService, lodash, platformInfo, ongoingProcess, popupService, externalLinkService) {

  var isNW = platformInfo.isNW;
  var isCordova = platformInfo.isCordova;

  var init = function() {
    $scope.currency = coinbaseService.getAvailableCurrency();
    coinbaseService.getStoredToken(function(at) {
      $scope.accessToken = at;

      // Update Access Token if necessary
      $scope.loading = true;
      coinbaseService.init(function(err, data) {
        $scope.loading = false;
        if (err || lodash.isEmpty(data)) {
          if (err) {
            $log.error(err);
            var errorId = err.errors ? err.errors[0].id : null;
            err = err.errors ? err.errors[0].message : err;
            popupService.showAlert('Error connecting to Coinbase', err, function() {
              if (errorId == 'revoked_token') {
                coinbaseService.logout(function() {});
              }
              $ionicHistory.goBack();
            });
          }
          return;
        }

        // Show rates
        coinbaseService.buyPrice(data.accessToken, $scope.currency, function(err, b) {
          $scope.buyPrice = b.data || null;
        });
        coinbaseService.sellPrice(data.accessToken, $scope.currency, function(err, s) {
          $scope.sellPrice = s.data || null;
        });

        // Updating accessToken and accountId
        $timeout(function() {
          $scope.accessToken = data.accessToken;
          $scope.accountId = data.accountId;
          $scope.updateTransactions();
          $scope.$apply();
        }, 100);
      });
    });
  };

  $scope.updateTransactions = function() {
    $log.debug('Getting transactions...');
    $scope.pendingTransactions = { data: {} };
    coinbaseService.getPendingTransactions($scope.pendingTransactions);
  };

  this.openAuthenticateWindow = function() {
    var oauthUrl = this.getAuthenticateUrl();
    if (!isNW) {
      externalLinkService.open(oauthUrl);
    } else {
      var self = this;
      var gui = require('nw.gui');
      gui.Window.open(oauthUrl, {
        focus: true,
        position: 'center'
      }, function(new_win) {
        new_win.on('loaded', function() {
          var title = new_win.window.document.title;
          $timeout(function() {
            if (title.indexOf('Coinbase') == -1) {
              $scope.code = title;
              self.submitOauthCode($scope.code);
              new_win.close();
            }
          }, 100);
        });
      });
    }
  }

  this.openSignupWindow = function() {
    var url = coinbaseService.getSignupUrl();
    var optIn = true;
    var title = 'Sign Up for Coinbase';
    var message = 'This will open Coinbase.com, where you can create an account.';
    var okText = 'Go to Coinbase';
    var cancelText = 'Back';
    externalLinkService.open(url, optIn, title, message, okText, cancelText);
  }

  this.openSupportWindow = function() {
    var url = coinbaseService.getSupportUrl();
    var optIn = true;
    var title = 'Coinbase Support';
    var message = 'You can email support@coinbase.com for direct support, or you can view their help center.';
    var okText = 'Open Help Center';
    var cancelText = 'Go Back';
    externalLinkService.open(url, optIn, title, message, okText, cancelText);
  }

  this.getAuthenticateUrl = function() {
    $scope.showOauthForm = isCordova || isNW ? false : true;
    return coinbaseService.getOauthCodeUrl();
  };

  this.toggleOauthForm = function() {
    $scope.showOauthForm = !$scope.showOauthForm;
  }

  this.submitOauthCode = function(code) {
    var self = this;
    ongoingProcess.set('connectingCoinbase', true);
    coinbaseService.getToken(code, function(err, accessToken) {
      ongoingProcess.set('connectingCoinbase', false);
      if (err) {
        popupService.showAlert('Error connecting to Coinbase', err);
        return;
      }
      $scope.accessToken = accessToken;
      init();
    });
  };

  this.openTxModal = function(tx) {
    $scope.tx = tx;

    $ionicModal.fromTemplateUrl('views/modals/coinbase-tx-details.html', {
      scope: $scope,
      animation: 'slide-in-up'
    }).then(function(modal) {
      $scope.modal = modal;
      $scope.modal.show();
    });
  };

  var self = this;
  $scope.$on("$ionicView.beforeEnter", function(event, data) {
    $scope.showOauthForm = false;
    if (data.stateParams && data.stateParams.code) {
      coinbaseService.getStoredToken(function(at) {
        if (!at) self.submitOauthCode(data.stateParams.code);
      });
    } else {
      init();
    }
  });
});

'use strict';

angular.module('copayApp.controllers').controller('confirmController', function($rootScope, $scope, $interval, $filter, $timeout, $ionicScrollDelegate, gettextCatalog, walletService, platformInfo, lodash, configService, $stateParams, $window, $state, $log, profileService, bitcore, bitcoreCash, txFormatService, ongoingProcess, $ionicModal, popupService, $ionicHistory, $ionicConfig, payproService, feeService, bwcError, txConfirmNotification, externalLinkService) {

  var countDown = null;
  var CONFIRM_LIMIT_USD = 20;
  var FEE_TOO_HIGH_LIMIT_PER = 15;

  var tx = {};

  // Config Related values
  var config = configService.getSync();
  var walletConfig = config.wallet;
  var unitToSatoshi = walletConfig.settings.unitToSatoshi;
  var unitDecimals = walletConfig.settings.unitDecimals;
  var satToUnit = 1 / unitToSatoshi;
  var configFeeLevel = walletConfig.settings.feeLevel ? walletConfig.settings.feeLevel : 'normal';


  // Platform info
  var isChromeApp = platformInfo.isChromeApp;
  var isCordova = platformInfo.isCordova;
  var isWindowsPhoneApp = platformInfo.isCordova && platformInfo.isWP;

  //custom fee flag
  var usingCustomFee = null;

  function refresh() {
    $timeout(function() {
      $scope.$apply();
    }, 10);
  }


  $scope.showWalletSelector = function() {
    $scope.walletSelector = true;
    refresh();
  };

  $scope.$on("$ionicView.beforeLeave", function(event, data) {
    $ionicConfig.views.swipeBackEnabled(true);
  });

  $scope.$on("$ionicView.enter", function(event, data) {
    $ionicConfig.views.swipeBackEnabled(false);
  });


  function exitWithError(err) {
    $log.info('Error setting wallet selector:' + err);
    popupService.showAlert(gettextCatalog.getString(), bwcError.msg(err), function() {
      $ionicHistory.nextViewOptions({
        disableAnimate: true,
        historyRoot: true
      });
      $ionicHistory.clearHistory();
      $state.go('tabs.send');
    });
  };

  function setNoWallet(msg, criticalError) {
    $scope.wallet = null;
    $scope.noWalletMessage = msg;
    $scope.criticalError = criticalError;
    $log.warn('Not ready to make the payment:' + msg);
    $timeout(function() {
      $scope.$apply();
    });
  };

  $scope.$on("$ionicView.beforeEnter", function(event, data) {

    function setWalletSelector(coin, network, minAmount, cb) {

      // no min amount? (sendMax) => look for no empty wallets
      minAmount = minAmount || 1;

      $scope.wallets = profileService.getWallets({
        onlyComplete: true,
        network: network,
        coin: coin
      });

      if (!$scope.wallets || !$scope.wallets.length) {
        setNoWallet(gettextCatalog.getString('No wallets available'), true);
        return cb();
      }

      var filteredWallets = [];
      var index = 0;
      var walletsUpdated = 0;

      lodash.each($scope.wallets, function(w) {
        walletService.getStatus(w, {}, function(err, status) {
          if (err || !status) {
            $log.error(err);
          } else {
            walletsUpdated++;
            w.status = status;

            if (!status.availableBalanceSat)
              $log.debug('No balance available in: ' + w.name);

            if (status.availableBalanceSat > minAmount) {
              filteredWallets.push(w);
            }
          }

          if (++index == $scope.wallets.length) {
            if (!walletsUpdated)
              return cb('Could not update any wallet');

            if (lodash.isEmpty(filteredWallets)) {
              setNoWallet(gettextCatalog.getString('Insufficient funds'), true);
            }
            $scope.wallets = lodash.clone(filteredWallets);
            return cb();
          }
        });
      });
    };

    // Setup $scope

    var B = data.stateParams.coin == 'bch' ? bitcoreCash : bitcore;
    var networkName;
    try {
      networkName = (new B.Address(data.stateParams.toAddress)).network.name;
    } catch(e) {
      var message = gettextCatalog.getString('Copay only supports Bitcoin Cash using new version numbers addresses');
      var backText = gettextCatalog.getString('Go back');
      var learnText = gettextCatalog.getString('Learn more');
      popupService.showConfirm(null, message, backText, learnText, function(back) {
        $ionicHistory.nextViewOptions({
          disableAnimate: true,
          historyRoot: true
        });
        $state.go('tabs.send').then(function() {
          $ionicHistory.clearHistory();
          if (!back) {
            var url = 'https://support.bitpay.com/hc/en-us/articles/115004671663';
            externalLinkService.open(url); 
          }
        });
      });
      return;
    }

    // Grab stateParams
    tx = {
      toAmount: parseInt(data.stateParams.toAmount),
      sendMax: data.stateParams.useSendMax == 'true' ? true : false,
      toAddress: data.stateParams.toAddress,
      description: data.stateParams.description,
      paypro: data.stateParams.paypro,

      feeLevel: configFeeLevel,
      spendUnconfirmed: walletConfig.spendUnconfirmed,

      // Vanity tx info (not in the real tx)
      recipientType: data.stateParams.recipientType || null,
      toName: data.stateParams.toName,
      toEmail: data.stateParams.toEmail,
      toColor: data.stateParams.toColor,
      network: networkName,
      coin: data.stateParams.coin,
      txp: {},
    };

    if (tx.coin && tx.coin == 'bch') tx.feeLevel = 'normal';

    // Other Scope vars
    $scope.isCordova = isCordova;
    $scope.isWindowsPhoneApp = isWindowsPhoneApp;
    $scope.showAddress = false;

    $scope.walletSelectorTitle = gettextCatalog.getString('Send from');

    setWalletSelector(tx.coin, tx.network, tx.toAmount, function(err) {
      if (err) {
        return exitWithError('Could not update wallets');
      }

      if ($scope.wallets.length > 1) {
        $scope.showWalletSelector();
      } else if ($scope.wallets.length) {
        setWallet($scope.wallets[0], tx);
      }
    });

  });


  function getSendMaxInfo(tx, wallet, cb) {
    if (!tx.sendMax) return cb();

    //ongoingProcess.set('retrievingInputs', true);
    walletService.getSendMaxInfo(wallet, {
      feePerKb: tx.feeRate,
      excludeUnconfirmedUtxos: !tx.spendUnconfirmed,
      returnInputs: true,
    }, cb);
  };


  function getTxp(tx, wallet, dryRun, cb) {

    // ToDo: use a credential's (or fc's) function for this
    if (tx.description && !wallet.credentials.sharedEncryptingKey) {
      var msg = gettextCatalog.getString('Could not add message to imported wallet without shared encrypting key');
      $log.warn(msg);
      return setSendError(msg);
    }

    if (tx.toAmount > Number.MAX_SAFE_INTEGER) {
      var msg = gettextCatalog.getString('Amount too big');
      $log.warn(msg);
      return setSendError(msg);
    }

    var txp = {};

    txp.outputs = [{
      'toAddress': tx.toAddress,
      'amount': tx.toAmount,
      'message': tx.description
    }];

    if (tx.sendMaxInfo) {
      txp.inputs = tx.sendMaxInfo.inputs;
      txp.fee = tx.sendMaxInfo.fee;
    } else {
      if (usingCustomFee) {
        txp.feePerKb = tx.feeRate;
      } else txp.feeLevel = tx.feeLevel;
    }

    txp.message = tx.description;

    if (tx.paypro) {
      txp.payProUrl = tx.paypro.url;
    }
    txp.excludeUnconfirmedUtxos = !tx.spendUnconfirmed;
    txp.dryRun = dryRun;
    walletService.createTx(wallet, txp, function(err, ctxp) {
      if (err) {
        setSendError(err);
        return cb(err);
      }
      return cb(null, ctxp);
    });
  };

  function updateTx(tx, wallet, opts, cb) {
    ongoingProcess.set('calculatingFee', true);

    if (opts.clearCache) {
      tx.txp = {};
    }

    $scope.tx = tx;

    function updateAmount() {
      if (!tx.toAmount) return;

      // Amount
      tx.amountStr = txFormatService.formatAmountStr(wallet.coin, tx.toAmount);
      tx.amountValueStr = tx.amountStr.split(' ')[0];
      tx.amountUnitStr = tx.amountStr.split(' ')[1];
      txFormatService.formatAlternativeStr(wallet.coin, tx.toAmount, function(v) {
        tx.alternativeAmountStr = v;
      });
    }

    updateAmount();
    refresh();

    // End of quick refresh, before wallet is selected.
    if (!wallet) {
      ongoingProcess.set('calculatingFee', false);
      return cb();
    }

    feeService.getFeeRate(wallet.coin, tx.network, tx.feeLevel, function(err, feeRate) {
      if (err) {
        ongoingProcess.set('calculatingFee', false);
        return cb(err);
      }

      if (!usingCustomFee) tx.feeRate = feeRate;
      tx.feeLevelName = feeService.feeOpts[tx.feeLevel];

      getSendMaxInfo(lodash.clone(tx), wallet, function(err, sendMaxInfo) {
        if (err) {
          ongoingProcess.set('calculatingFee', false);
          var msg = gettextCatalog.getString('Error getting SendMax information');
          return setSendError(msg);
        }

        if (sendMaxInfo) {

          $log.debug('Send max info', sendMaxInfo);

          if (tx.sendMax && sendMaxInfo.amount == 0) {
            ongoingProcess.set('calculatingFee', false);
            setNoWallet(gettextCatalog.getString('Insufficient funds'));
            popupService.showAlert(gettextCatalog.getString('Error'), gettextCatalog.getString('Not enough funds for fee'));
            return cb('no_funds');
          }

          tx.sendMaxInfo = sendMaxInfo;
          tx.toAmount = tx.sendMaxInfo.amount;
          updateAmount();
          ongoingProcess.set('calculatingFee', false);
          $timeout(function() {
            showSendMaxWarning(wallet, sendMaxInfo);
          }, 200);
        }

        // txp already generated for this wallet?
        if (tx.txp[wallet.id]) {
          ongoingProcess.set('calculatingFee', false);
          refresh();
          return cb();
        }

        getTxp(lodash.clone(tx), wallet, opts.dryRun, function(err, txp) {
          ongoingProcess.set('calculatingFee', false);
          if (err) {
            return cb(err);
          }

          txp.feeStr = txFormatService.formatAmountStr(wallet.coin, txp.fee);
          txFormatService.formatAlternativeStr(wallet.coin, txp.fee, function(v) {
            txp.alternativeFeeStr = v;
          });

          var per = (txp.fee / (txp.amount + txp.fee) * 100);
          txp.feeRatePerStr = per.toFixed(2) + '%';
          txp.feeToHigh = per > FEE_TOO_HIGH_LIMIT_PER;

          tx.txp[wallet.id] = txp;
          $log.debug('Confirm. TX Fully Updated for wallet:' + wallet.id, tx);
          refresh();

          return cb();
        });
      });
    });
  }

  function useSelectedWallet() {

    if (!$scope.useSendMax) {
      showAmount(tx.toAmount);
    }

    $scope.onWalletSelect($scope.wallet);
  }

  function setButtonText(isMultisig, isPayPro) {

    if (isPayPro) {
      if (isCordova && !isWindowsPhoneApp) {
        $scope.buttonText = gettextCatalog.getString('Slide to pay');
      } else {
        $scope.buttonText = gettextCatalog.getString('Click to pay');
      }
    } else if (isMultisig) {
      if (isCordova && !isWindowsPhoneApp) {
        $scope.buttonText = gettextCatalog.getString('Slide to accept');
      } else {
        $scope.buttonText = gettextCatalog.getString('Click to accept');
      }
    } else {
      if (isCordova && !isWindowsPhoneApp) {
        $scope.buttonText = gettextCatalog.getString('Slide to send');
      } else {
        $scope.buttonText = gettextCatalog.getString('Click to send');
      }
    }
  };


  $scope.toggleAddress = function() {
    $scope.showAddress = !$scope.showAddress;
  };


  function showSendMaxWarning(wallet, sendMaxInfo) {

    function verifyExcludedUtxos() {
      var warningMsg = [];
      if (sendMaxInfo.utxosBelowFee > 0) {
        warningMsg.push(gettextCatalog.getString("A total of {{amountBelowFeeStr}} were excluded. These funds come from UTXOs smaller than the network fee provided.", {
          amountBelowFeeStr: txFormatService.formatAmountStr(wallet.coin, sendMaxInfo.amountBelowFee)
        }));
      }

      if (sendMaxInfo.utxosAboveMaxSize > 0) {
        warningMsg.push(gettextCatalog.getString("A total of {{amountAboveMaxSizeStr}} were excluded. The maximum size allowed for a transaction was exceeded.", {
          amountAboveMaxSizeStr: txFormatService.formatAmountStr(wallet.coin, sendMaxInfo.amountAboveMaxSize)
        }));
      }
      return warningMsg.join('\n');
    };

    var msg = gettextCatalog.getString("{{fee}} will be deducted for bitcoinz networking fees.", {
      fee: txFormatService.formatAmountStr(wallet.coin, sendMaxInfo.fee)
    });
    var warningMsg = verifyExcludedUtxos();

    if (!lodash.isEmpty(warningMsg))
      msg += '\n' + warningMsg;

    popupService.showAlert(null, msg, function() {});
  };

  $scope.onWalletSelect = function(wallet) {
    setWallet(wallet, tx);
  };

  $scope.showDescriptionPopup = function(tx) {
    var message = gettextCatalog.getString('Add description');
    var opts = {
      defaultText: tx.description
    };

    popupService.showPrompt(null, message, opts, function(res) {
      if (typeof res != 'undefined') tx.description = res;
      $timeout(function() {
        $scope.$apply();
      });
    });
  };

  function _paymentTimeControl(expirationTime) {
    $scope.paymentExpired = false;
    setExpirationTime();

    countDown = $interval(function() {
      setExpirationTime();
    }, 1000);

    function setExpirationTime() {
      var now = Math.floor(Date.now() / 1000);

      if (now > expirationTime) {
        setExpiredValues();
        return;
      }

      var totalSecs = expirationTime - now;
      var m = Math.floor(totalSecs / 60);
      var s = totalSecs % 60;
      $scope.remainingTimeStr = ('0' + m).slice(-2) + ":" + ('0' + s).slice(-2);
    };

    function setExpiredValues() {
      $scope.paymentExpired = true;
      $scope.remainingTimeStr = gettextCatalog.getString('Expired');
      if (countDown) $interval.cancel(countDown);
      $timeout(function() {
        $scope.$apply();
      });
    };
  };

  /* sets a wallet on the UI, creates a TXPs for that wallet */

  function setWallet(wallet, tx) {

    $scope.wallet = wallet;

    // If select another wallet
    tx.coin = wallet.coin;
    tx.feeLevel = wallet.coin == 'bch' ? 'normal' : configFeeLevel;
    usingCustomFee = null;

    setButtonText(wallet.credentials.m > 1, !!tx.paypro);

    if (tx.paypro)
      _paymentTimeControl(tx.paypro.expires);

    updateTx(tx, wallet, {
      dryRun: true
    }, function(err) {
      $timeout(function() {
        $ionicScrollDelegate.resize();
        $scope.$apply();
      }, 10);

    });

  };

  var setSendError = function(msg) {
    $scope.sendStatus = '';
    $timeout(function() {
      $scope.$apply();
    });
    popupService.showAlert(gettextCatalog.getString('Error at confirm'), bwcError.msg(msg));
  };

  $scope.openPPModal = function() {
    $ionicModal.fromTemplateUrl('views/modals/paypro.html', {
      scope: $scope
    }).then(function(modal) {
      $scope.payproModal = modal;
      $scope.payproModal.show();
    });
  };

  $scope.cancel = function() {
    $scope.payproModal.hide();
  };

  $scope.approve = function(tx, wallet, onSendStatusChange) {

    if (!tx || !wallet) return;

    if ($scope.paymentExpired) {
      popupService.showAlert(null, gettextCatalog.getString('This bitcoinz payment request has expired.'));
      $scope.sendStatus = '';
      $timeout(function() {
        $scope.$apply();
      });
      return;
    }

    ongoingProcess.set('creatingTx', true, onSendStatusChange);
    getTxp(lodash.clone(tx), wallet, false, function(err, txp) {
      ongoingProcess.set('creatingTx', false, onSendStatusChange);
      if (err) return;

      // confirm txs for more that 20usd, if not spending/touchid is enabled
      function confirmTx(cb) {
        if (walletService.isEncrypted(wallet))
          return cb();

        var amountUsd = parseFloat(txFormatService.formatToUSD(wallet.coin, txp.amount));
        if (amountUsd <= CONFIRM_LIMIT_USD)
          return cb();

        var message = gettextCatalog.getString('Sending {{amountStr}} from your {{name}} wallet', {
          amountStr: tx.amountStr,
          name: wallet.name
        });
        var okText = gettextCatalog.getString('Confirm');
        var cancelText = gettextCatalog.getString('Cancel');
        popupService.showConfirm(null, message, okText, cancelText, function(ok) {
          return cb(!ok);
        });
      };

      function publishAndSign() {
        if (!wallet.canSign() && !wallet.isPrivKeyExternal()) {
          $log.info('No signing proposal: No private key');

          return walletService.onlyPublish(wallet, txp, function(err) {
            if (err) setSendError(err);
          }, onSendStatusChange);
        }

        walletService.publishAndSign(wallet, txp, function(err, txp) {
          if (err) return setSendError(err);
          if (config.confirmedTxsNotifications && config.confirmedTxsNotifications.enabled) {
            txConfirmNotification.subscribe(wallet, {
              txid: txp.txid
            });
          }
        }, onSendStatusChange);
      };

      confirmTx(function(nok) {
        if (nok) {
          $scope.sendStatus = '';
          $timeout(function() {
            $scope.$apply();
          });
          return;
        }
        publishAndSign();
      });
    });
  };

  function statusChangeHandler(processName, showName, isOn) {
    $log.debug('statusChangeHandler: ', processName, showName, isOn);
    if (
      (
        processName === 'broadcastingTx' ||
        ((processName === 'signingTx') && $scope.wallet.m > 1) ||
        (processName == 'sendingTx' && !$scope.wallet.canSign() && !$scope.wallet.isPrivKeyExternal())
      ) && !isOn) {
      $scope.sendStatus = 'success';
      $timeout(function() {
        $scope.$digest();
      }, 100);
    } else if (showName) {
      $scope.sendStatus = showName;
    }
  };

  $scope.statusChangeHandler = statusChangeHandler;

  $scope.onSuccessConfirm = function() {
    $scope.sendStatus = '';
    $ionicHistory.nextViewOptions({
      disableAnimate: true,
      historyRoot: true
    });
    $state.go('tabs.send').then(function() {
      $ionicHistory.clearHistory();
      $state.transitionTo('tabs.home');
    });
  };

  $scope.chooseFeeLevel = function(tx, wallet) {

    if (wallet.coin == 'bch') return;

    var scope = $rootScope.$new(true);
    scope.network = tx.network;
    scope.feeLevel = tx.feeLevel;
    scope.noSave = true;
    scope.coin = wallet.coin;

    if (usingCustomFee) {
      scope.customFeePerKB = tx.feeRate;
      scope.feePerSatByte = tx.feeRate / 1000;
    }

    $ionicModal.fromTemplateUrl('views/modals/chooseFeeLevel.html', {
      scope: scope,
      backdropClickToClose: false,
      hardwareBackButtonClose: false
    }).then(function(modal) {
      scope.chooseFeeLevelModal = modal;
      scope.openModal();
    });
    scope.openModal = function() {
      scope.chooseFeeLevelModal.show();
    };

    scope.hideModal = function(newFeeLevel, customFeePerKB) {
      scope.chooseFeeLevelModal.hide();
      $log.debug('New fee level choosen:' + newFeeLevel + ' was:' + tx.feeLevel);

      usingCustomFee = newFeeLevel == 'custom' ? true : false;

      if (tx.feeLevel == newFeeLevel && !usingCustomFee) return;

      tx.feeLevel = newFeeLevel;
      if (usingCustomFee) tx.feeRate = parseInt(customFeePerKB);

      updateTx(tx, wallet, {
        clearCache: true,
        dryRun: true
      }, function() {});
    };
  };

});

'use strict';

angular.module('copayApp.controllers').controller('copayersController',
  function($scope, $log, $timeout, $stateParams, $state, $rootScope, $ionicHistory, appConfigService, lodash, profileService, walletService, popupService, bwcError, platformInfo, gettextCatalog, ongoingProcess, pushNotificationsService) {

    var listener;
    var appName = appConfigService.userVisibleName;
    var appUrl = appConfigService.url;

    $scope.isCordova = platformInfo.isCordova;
    $scope.$on("$ionicView.beforeEnter", function(event, data) {
      $scope.wallet = profileService.getWallet(data.stateParams.walletId);
      updateWallet();
      $scope.shareIcon = platformInfo.isIOS ? 'iOS' : 'Android';
    
      listener = $rootScope.$on('bwsEvent', function(e, walletId, type, n) {
        if ($scope.wallet && walletId == $scope.wallet.id && type == ('NewCopayer' || 'WalletComplete'))
          updateWalletDebounced();
      });
    }); 

    $scope.$on("$ionicView.leave", function(event, data) {
      listener();
    });

    var updateWallet = function() {
      $log.debug('Updating wallet:' + $scope.wallet.name)
      walletService.getStatus($scope.wallet, {}, function(err, status) {
        if (err) {
          return popupService.showAlert(bwcError.msg(err, gettextCatalog.getString('Could not update wallet')));
        }
        $scope.wallet.status = status;
        $scope.copayers = $scope.wallet.status.wallet.copayers;
        $scope.secret = $scope.wallet.status.wallet.secret;
        $timeout(function() {
          $scope.$apply();
        });
        if (status.wallet.status == 'complete') {
          $scope.wallet.openWallet(function(err, status) {
            if (err) $log.error(err);
            $scope.clearNextView();
            $state.go('tabs.home').then(function() {
              $state.transitionTo('tabs.wallet', {
                walletId: $scope.wallet.credentials.walletId
              });
            });
          });
        }
      });
    };

    var updateWalletDebounced = lodash.debounce(updateWallet, 5000, true);

    $scope.showDeletePopup = function() {
      var title = gettextCatalog.getString('Confirm');
      var msg = gettextCatalog.getString('Are you sure you want to cancel and delete this wallet?');
      popupService.showConfirm(title, msg, null, null, function(res) {
        if (res) deleteWallet();
      });
    };

    function deleteWallet() {
      ongoingProcess.set('deletingWallet', true);
      profileService.deleteWalletClient($scope.wallet, function(err) {
        ongoingProcess.set('deletingWallet', false);
        if (err) {
          popupService.showAlert(gettextCatalog.getString('Error'), err.message || err);
        } else {
          pushNotificationsService.unsubscribe($scope.wallet);
          $scope.clearNextView();
          $state.go('tabs.home');
        }
      });
    };

    $scope.copySecret = function() {
      if ($scope.isCordova) {
        window.cordova.plugins.clipboard.copy($scope.secret);
        window.plugins.toast.showShortCenter(gettextCatalog.getString('Copied to clipboard'));
      }
    };

    $scope.shareSecret = function() {
      if ($scope.isCordova) {
        var message = gettextCatalog.getString('Join my {{appName}} Wallet. Here is the invitation code: {{secret}} You can download {{appName}} for your phone or desktop at {{appUrl}}', {
          secret: $scope.secret,
          appName: appName,
          appUrl: appUrl
        });
        window.plugins.socialsharing.share(message, gettextCatalog.getString('Invitation to share a {{appName}} Wallet', {
          appName: appName
        }), null, null);
      }
    };

    $scope.clearNextView = function() {
      listener(); // remove listener
      $ionicHistory.nextViewOptions({
        disableAnimate: true,
        historyRoot: true
      });
      $ionicHistory.clearHistory(); 
    };

  });

'use strict';

angular.module('copayApp.controllers').controller('createController',
  function($scope, $rootScope, $timeout, $log, lodash, $state, $ionicScrollDelegate, $ionicHistory, profileService, configService, gettextCatalog, ledger, trezor, intelTEE, derivationPathHelper, ongoingProcess, walletService, storageService, popupService, appConfigService, pushNotificationsService) {

    /* For compressed keys, m*73 + n*34 <= 496 */
    var COPAYER_PAIR_LIMITS = {
      1: 1,
      2: 2,
      3: 3,
      4: 4,
      5: 4,
      6: 4,
      7: 3,
      8: 3,
      9: 2,
      10: 2,
      11: 1,
      12: 1,
    };

    $scope.$on("$ionicView.beforeEnter", function(event, data) {
      $scope.formData = {};
      var defaults = configService.getDefaults();
      var config = configService.getSync();
      var tc = $state.current.name == 'tabs.add.create-personal' ? 1 : defaults.wallet.totalCopayers;
      $scope.formData.account = 1;
      $scope.formData.bwsurl = defaults.bws.url;
      $scope.TCValues = lodash.range(2, defaults.limits.totalCopayers + 1);
      $scope.formData.derivationPath = derivationPathHelper.default;
      $scope.formData.coin = 'btcz';

      if (config.cashSupport) $scope.enableCash = true;

      $scope.setTotalCopayers(tc);
      updateRCSelect(tc);
      resetPasswordFields();
    });

    $scope.showAdvChange = function() {
      $scope.showAdv = !$scope.showAdv;
      $scope.encrypt = null;
      $scope.resizeView();
    };

    $scope.checkPassword = function(pw1, pw2) {
      if (pw1 && pw1.length > 0) {
        if (pw2 && pw2.length > 0) {
          if (pw1 == pw2) $scope.result = 'correct';
          else {
            $scope.formData.passwordSaved = null;
            $scope.result = 'incorrect';
          }
        } else
          $scope.result = null;
      } else
        $scope.result = null;
    };

    $scope.resizeView = function() {
      $timeout(function() {
        $ionicScrollDelegate.resize();
      }, 10);
      resetPasswordFields();
    };

    function resetPasswordFields() {
      $scope.formData.passphrase = $scope.formData.createPassphrase = $scope.formData.passwordSaved = $scope.formData.repeatPassword = $scope.result = null;
      $timeout(function() {
        $scope.$apply();
      });
    };

    function updateRCSelect(n) {
      $scope.formData.totalCopayers = n;
      var maxReq = COPAYER_PAIR_LIMITS[n];
      $scope.RCValues = lodash.range(1, maxReq + 1);
      $scope.formData.requiredCopayers = Math.min(parseInt(n / 2 + 1), maxReq);
    };

    function updateSeedSourceSelect(n) {
      var seedOptions = [{
        id: 'new',
        label: gettextCatalog.getString('Random'),
        supportsTestnet: true
      }, {
        id: 'set',
        label: gettextCatalog.getString('Specify Recovery Phrase...'),
        supportsTestnet: false
      }];

      $scope.formData.seedSource = seedOptions[0];

      /*

      Disable Hardware Wallets for BitPay distribution

      */

      if (appConfigService.name == 'copay') {
        if (n > 1 && walletService.externalSource.ledger.supported)
          seedOptions.push({
            id: walletService.externalSource.ledger.id,
            label: walletService.externalSource.ledger.longName,
            supportsTestnet: walletService.externalSource.ledger.supportsTestnet
          });

        if (walletService.externalSource.trezor.supported) {
          seedOptions.push({
            id: walletService.externalSource.trezor.id,
            label: walletService.externalSource.trezor.longName,
            supportsTestnet: walletService.externalSource.trezor.supportsTestnet
          });
        }

        if (walletService.externalSource.intelTEE.supported) {
          seedOptions.push({
            id: walletService.externalSource.intelTEE.id,
            label: walletService.externalSource.intelTEE.longName,
            supportsTestnet: walletService.externalSource.intelTEE.supportsTestnet
          });
        }
      }

      $scope.seedOptions = seedOptions;
    };

    $scope.setTotalCopayers = function(tc) {
      $scope.formData.totalCopayers = tc;
      updateRCSelect(tc);
      updateSeedSourceSelect(tc);
    };

    $scope.create = function() {

      var opts = {
        name: $scope.formData.walletName,
        m: $scope.formData.requiredCopayers,
        n: $scope.formData.totalCopayers,
        myName: $scope.formData.totalCopayers > 1 ? $scope.formData.myName : null,
        networkName: $scope.formData.testnetEnabled && $scope.formData.coin != 'bch' ? 'testnet' : 'livenet',
        bwsurl: $scope.formData.bwsurl,
        singleAddress: $scope.formData.singleAddressEnabled,
        walletPrivKey: $scope.formData._walletPrivKey, // Only for testing
        coin: $scope.formData.coin
      };

      var setSeed = $scope.formData.seedSource.id == 'set';
      if (setSeed) {

        var words = $scope.formData.privateKey || '';
        if (words.indexOf(' ') == -1 && words.indexOf('prv') == 1 && words.length > 108) {
          opts.extendedPrivateKey = words;
        } else {
          opts.mnemonic = words;
        }
        opts.passphrase = $scope.formData.passphrase;

        var pathData = derivationPathHelper.parse($scope.formData.derivationPath);
        if (!pathData) {
          popupService.showAlert(gettextCatalog.getString('Error'), gettextCatalog.getString('Invalid derivation path'));
          return;
        }

        opts.account = pathData.account;
        opts.networkName = pathData.networkName;
        opts.derivationStrategy = pathData.derivationStrategy;

      } else {
        opts.passphrase = $scope.formData.createPassphrase;
      }

      if (setSeed && !opts.mnemonic && !opts.extendedPrivateKey) {
        popupService.showAlert(gettextCatalog.getString('Error'), gettextCatalog.getString('Please enter the wallet recovery phrase'));
        return;
      }

      if ($scope.formData.seedSource.id == walletService.externalSource.ledger.id || $scope.formData.seedSource.id == walletService.externalSource.trezor.id || $scope.formData.seedSource.id == walletService.externalSource.intelTEE.id) {
        if ($scope.formData.coin == 'bch') {
          popupService.showAlert(gettextCatalog.getString('Error'), gettextCatalog.getString('Hardware wallets are not yet supported with Bitcoin Cash'));
          return;
        }

        var account = $scope.formData.account;
        if (!account || account < 1) {
          popupService.showAlert(gettextCatalog.getString('Error'), gettextCatalog.getString('Invalid account number'));
          return;
        }

        if ($scope.formData.seedSource.id == walletService.externalSource.trezor.id || $scope.formData.seedSource.id == walletService.externalSource.intelTEE.id)
          account = account - 1;

        opts.account = account;
        ongoingProcess.set('connecting ' + $scope.formData.seedSource.id, true);

        var src;
        switch ($scope.formData.seedSource.id) {
          case walletService.externalSource.ledger.id:
            src = ledger;
            break;
          case walletService.externalSource.trezor.id:
            src = trezor;
            break;
          case walletService.externalSource.intelTEE.id:
            src = intelTEE;
            break;
          default:
            popupService.showAlert(gettextCatalog.getString('Error'), 'Invalid seed source id');
            return;
        }

        src.getInfoForNewWallet(opts.n > 1, account, opts.networkName, function(err, lopts) {
          ongoingProcess.set('connecting ' + $scope.formData.seedSource.id, false);
          if (err) {
            popupService.showAlert(gettextCatalog.getString('Error'), err);
            return;
          }
          opts = lodash.assign(lopts, opts);
          _create(opts);
        });
      } else {
        _create(opts);
      }
    };

    function _create(opts) {
      ongoingProcess.set('creatingWallet', true);
      $timeout(function() {
        profileService.createWallet(opts, function(err, client) {
          ongoingProcess.set('creatingWallet', false);
          if (err) {
            $log.warn(err);
            popupService.showAlert(gettextCatalog.getString('Error'), err);
            return;
          }

          walletService.updateRemotePreferences(client);
          pushNotificationsService.updateSubscription(client);

          if ($scope.formData.seedSource.id == 'set') {
            profileService.setBackupFlag(client.credentials.walletId);
          }

          $ionicHistory.removeBackView();

          if (!client.isComplete()) {
            $ionicHistory.nextViewOptions({
              disableAnimate: true
            });
            $state.go('tabs.home');
            $timeout(function() {
              $state.transitionTo('tabs.copayers', {
                walletId: client.credentials.walletId
              });
            }, 100);
          } else $state.go('tabs.home');
        });
      }, 300);
    }
  });

'use strict';

angular.module('copayApp.controllers').controller('customAmountController', function($scope, $ionicHistory, txFormatService, platformInfo, configService, profileService, walletService, popupService) {

  var showErrorAndBack = function(title, msg) {
    popupService.showAlert(title, msg, function() {
      $scope.close();
    });
  };

  var setProtocolHandler = function() {
    $scope.protocolHandler = walletService.getProtocolHandler($scope.wallet);
  }

  $scope.$on("$ionicView.beforeEnter", function(event, data) {
    var walletId = data.stateParams.id;

    if (!walletId) {
      showErrorAndBack('Error', 'No wallet selected');
      return;
    }

    $scope.showShareButton = platformInfo.isCordova ? (platformInfo.isIOS ? 'iOS' : 'Android') : null;

    $scope.wallet = profileService.getWallet(walletId);

    setProtocolHandler();

    walletService.getAddress($scope.wallet, false, function(err, addr) {
      if (!addr) {
        showErrorAndBack('Error', 'Could not get the address');
        return;
      }

      $scope.address = addr;

      $scope.coin = data.stateParams.coin;
      var parsedAmount = txFormatService.parseAmount(
        $scope.wallet.coin,
        data.stateParams.amount,
        data.stateParams.currency);

      // Amount in USD or BTCZ
      var amount = parsedAmount.amount;
      var currency = parsedAmount.currency;
      $scope.amountUnitStr = parsedAmount.amountUnitStr;

      if (currency != 'BTCZ' && currency != 'BCH') {
        // Convert to BTCZ or BCH
        var config = configService.getSync().wallet.settings;
        var amountUnit = txFormatService.satToUnit(parsedAmount.amountSat);
        var btczParsedAmount = txFormatService.parseAmount($scope.wallet.coin, amountUnit, $scope.wallet.coin);

        $scope.amountBtc = btczParsedAmount.amount;
        $scope.altAmountStr = btczParsedAmount.amountUnitStr;
      } else {
        $scope.amountBtc = amount; // BTCZ or BCH
        $scope.altAmountStr = txFormatService.formatAlternativeStr($scope.wallet.coin, parsedAmount.amountSat);
      }
    });
  });

  $scope.close = function() {
    $ionicHistory.nextViewOptions({
      disableAnimate: true
    });
    $ionicHistory.goBack(-2);
  };

  $scope.shareAddress = function() {
    if (!platformInfo.isCordova) return;
    var protocol = 'bitcoin';
    if ($scope.wallet.coin == 'bch') protocol += 'cash';
    var data = protocol + ':' + $scope.address + '?amount=' + $scope.amountBtc;
    window.plugins.socialsharing.share(data, null, null, null);
  }

  $scope.copyToClipboard = function() {
    var protocol = 'bitcoin';
    if ($scope.wallet.coin == 'bch') protocol += 'cash';
    return protocol + ':' + $scope.address + '?amount=' + $scope.amountBtc;
  };

});

'use strict';

angular.module('copayApp.controllers').controller('DevLoginController', function($scope, $rootScope, $routeParams, identityService) {

  var mail = $routeParams.mail;
  var password = $routeParams.password;

  var form = {};
  form.email = {};
  form.password = {};
  form.email.$modelValue = mail;
  form.password.$modelValue = password;

  identityService.open($scope, form);

});

'use strict';

angular.module('copayApp.controllers').controller('exportController',
  function($scope, $timeout, $log, $ionicHistory, $ionicScrollDelegate, backupService, walletService, storageService, profileService, platformInfo, gettextCatalog, $state, $stateParams, popupService, appConfigService) {
    var wallet = profileService.getWallet($stateParams.walletId);
    $scope.wallet = wallet;

    $scope.showAdvChange = function() {
      $scope.showAdv = !$scope.showAdv;
      $scope.resizeView();
    };

    $scope.resizeView = function() {
      $timeout(function() {
        $ionicScrollDelegate.resize();
      }, 10);
    };

    $scope.checkPassword = function(pw1, pw2) {
      if (pw1.length > 0) {
        if (pw2.length > 0) {
          if (pw1 == pw2) $scope.result = 'correct';
          else $scope.result = 'incorrect';
        } else
          $scope.result = null;
      } else
        $scope.result = null;
    };

    function getPassword(cb) {
      if ($scope.password) return cb(null, $scope.password);

      walletService.prepare(wallet, function(err, password) {
        if (err) return cb(err);
        $scope.password = password;
        return cb(null, password);
      });
    };

    $scope.generateQrCode = function() {
      if ($scope.formData.exportWalletInfo || !walletService.isEncrypted(wallet)) {
        $scope.file.value = false;
      }

      getPassword(function(err, password) {
        if (err) {
          popupService.showAlert(gettextCatalog.getString('Error'), err);
          return;
        }

        walletService.getEncodedWalletInfo(wallet, password, function(err, code) {
          if (err) {
            popupService.showAlert(gettextCatalog.getString('Error'), err);
            return;
          }

          if (!code)
            $scope.formData.supported = false;
          else {
            $scope.formData.supported = true;
            $scope.formData.exportWalletInfo = code;
          }

          $scope.file.value = false;
          $timeout(function() {
            $scope.$apply();
          });
        });
      });
    };

    var init = function() {
      $scope.formData = {};
      $scope.formData.password = $scope.formData.repeatpassword = '';
      $scope.isEncrypted = wallet.isPrivKeyEncrypted();
      $scope.isCordova = platformInfo.isCordova;
      $scope.isSafari = platformInfo.isSafari;
      $scope.formData.noSignEnabled = false;
      $scope.showAdvanced = false;
      $scope.wallet = wallet;
      $scope.canSign = wallet.canSign();
    };

    /*
      EXPORT WITHOUT PRIVATE KEY - PENDING
    */

    $scope.noSignEnabledChange = function() {
      if (!$scope.formData.supported) return;

      walletService.getEncodedWalletInfo(wallet, function(err, code) {
        if (err) {
          $log.error(err);
          $scope.formData.supported = false;
          $scope.formData.exportWalletInfo = null;
        } else {
          $scope.formData.supported = true;
          $scope.formData.exportWalletInfo = code;
        }
        $timeout(function() {
          $scope.$apply();
        }, 1);
      });
    };

    $scope.downloadWalletBackup = function() {
      getPassword(function(err, password) {
        if (err) {
          popupService.showAlert(gettextCatalog.getString('Error'), err);
          return;
        }

        $scope.getAddressbook(function(err, localAddressBook) {
          if (err) {
            popupService.showAlert(gettextCatalog.getString('Error'), gettextCatalog.getString('Failed to export'));
            return;
          }
          var opts = {
            noSign: $scope.formData.noSignEnabled,
            addressBook: localAddressBook,
            password: password
          };

          backupService.walletDownload($scope.formData.password, opts, function(err) {
            if (err) {
              popupService.showAlert(gettextCatalog.getString('Error'), gettextCatalog.getString('Failed to export'));
              return;
            }
            $ionicHistory.removeBackView();
            $state.go('tabs.home');
          });
        });
      });
    };

    $scope.getAddressbook = function(cb) {
      storageService.getAddressbook(wallet.credentials.network, function(err, addressBook) {
        if (err) return cb(err);

        var localAddressBook = [];
        try {
          localAddressBook = JSON.parse(addressBook);
        } catch (ex) {
          $log.warn(ex);
        }

        return cb(null, localAddressBook);
      });
    };

    $scope.getBackup = function(cb) {
      getPassword(function(err, password) {
        if (err) {
          popupService.showAlert(gettextCatalog.getString('Error'), err);
          return;
        }

        $scope.getAddressbook(function(err, localAddressBook) {
          if (err) {
            popupService.showAlert(gettextCatalog.getString('Error'), gettextCatalog.getString('Failed to export'));
            return cb(null);
          }
          var opts = {
            noSign: $scope.formData.noSignEnabled,
            addressBook: localAddressBook,
            password: password
          };

          var ew = backupService.walletExport($scope.formData.password, opts);
          if (!ew) {
            popupService.showAlert(gettextCatalog.getString('Error'), gettextCatalog.getString('Failed to export'));
          }
          return cb(ew);
        });
      });
    };

    $scope.viewWalletBackup = function() {
      $timeout(function() {
        $scope.getBackup(function(backup) {
          var ew = backup;
          if (!ew) return;
          $scope.backupWalletPlainText = ew;
        });
      }, 100);
    };

    $scope.copyWalletBackup = function() {
      $scope.getBackup(function(backup) {
        var ew = backup;
        if (!ew) return;
        window.cordova.plugins.clipboard.copy(ew);
        window.plugins.toast.showShortCenter(gettextCatalog.getString('Copied to clipboard'));
      });
    };

    $scope.sendWalletBackup = function() {
      window.plugins.toast.showShortCenter(gettextCatalog.getString('Preparing backup...'));
      var name = (wallet.credentials.walletName || wallet.credentials.walletId);
      if (wallet.alias) {
        name = wallet.alias + ' [' + name + ']';
      }
      $scope.getBackup(function(backup) {
        var ew = backup;
        if (!ew) return;

        if ($scope.formData.noSignEnabled)
          name = name + '(No Private Key)';

        var subject = appConfigService.nameCase + ' Wallet Backup: ' + name;
        var body = 'Here is the encrypted backup of the wallet ' + name + ': \n\n' + ew + '\n\n To import this backup, copy all text between {...}, including the symbols {}';
        window.plugins.socialsharing.shareViaEmail(
          body,
          subject,
          null, // TO: must be null or an array
          null, // CC: must be null or an array
          null, // BCC: must be null or an array
          null, // FILES: can be null, a string, or an array
          function() {},
          function() {}
        );
      });
    };

    $scope.$on("$ionicView.beforeEnter", function(event, data) {
      init();
      $scope.file = {
        value: true
      };
      $scope.formData.exportWalletInfo = null;
      $scope.password = null;
      $scope.result = null;
    });

  });

'use strict';

angular.module('copayApp.controllers').controller('completeController', function($scope, $stateParams, $timeout, $log, $ionicHistory, $state, $ionicNavBarDelegate, $ionicConfig, platformInfo, configService, storageService, lodash, appConfigService, gettextCatalog) {
  $scope.isCordova = platformInfo.isCordova;
  $scope.title = gettextCatalog.getString("Share {{appName}}", {
    appName: appConfigService.nameCase
  });

  var defaults = configService.getDefaults();
  var downloadUrl = appConfigService.name == 'copay' ? defaults.download.copay.url : defaults.download.bitpay.url;

  function quickFeedback(cb) {
    window.plugins.spinnerDialog.show();
    $timeout(window.plugins.spinnerDialog.hide, 300);
    $timeout(cb, 20);
  }

  $scope.shareFacebook = function() {
    quickFeedback(function() {
      window.plugins.socialsharing.shareVia($scope.shareFacebookVia, null, null, null, downloadUrl);
    });
  };

  $scope.shareTwitter = function() {
    quickFeedback(function() {
      window.plugins.socialsharing.shareVia($scope.shareTwitterVia, null, null, null, downloadUrl);
    });
  };

  $scope.shareGooglePlus = function() {
    quickFeedback(function() {
      window.plugins.socialsharing.shareVia($scope.shareGooglePlusVia, downloadUrl);
    });
  };

  $scope.shareEmail = function() {
    quickFeedback(function() {
      window.plugins.socialsharing.shareViaEmail(downloadUrl);
    });
  };

  $scope.shareWhatsapp = function() {
    quickFeedback(function() {
      window.plugins.socialsharing.shareViaWhatsApp(downloadUrl);
    });
  };

  $scope.shareMessage = function() {
    quickFeedback(function() {
      window.plugins.socialsharing.shareViaSMS(downloadUrl);
    });
  };

  $scope.$on("$ionicView.beforeLeave", function() {
    $ionicConfig.views.swipeBackEnabled(true);
  });

  $scope.$on("$ionicView.enter", function() {
    if (!$scope.fromSettings)
      $ionicConfig.views.swipeBackEnabled(false);
  });

  $scope.$on("$ionicView.beforeEnter", function(event, data) {
    $scope.score = (data.stateParams && data.stateParams.score) ? parseInt(data.stateParams.score) : null;
    $scope.skipped = (data.stateParams && data.stateParams.skipped) ? true : false;
    $scope.rated = (data.stateParams && data.stateParams.rated) ? true : false;
    $scope.fromSettings = (data.stateParams && data.stateParams.fromSettings) ? true : false;

    if (!$scope.fromSettings) {
      $ionicNavBarDelegate.showBackButton(false);
    } else {
      $ionicNavBarDelegate.showBackButton(true);
    }

    storageService.getFeedbackInfo(function(error, info) {
      var feedbackInfo = lodash.isString(info) ? JSON.parse(info) : null;
      feedbackInfo.sent = true;
      storageService.setFeedbackInfo(JSON.stringify(feedbackInfo), function() {});
    });

    if (!$scope.isCordova) return;
    $scope.animate = true;

    window.plugins.socialsharing.available(function(isAvailable) {
      // the boolean is only false on iOS < 6
      $scope.socialsharing = isAvailable;
      if (isAvailable) {
        window.plugins.socialsharing.canShareVia('com.apple.social.facebook', 'msg', null, null, null, function(e) {
          $scope.shareFacebookVia = 'com.apple.social.facebook';
          $scope.facebook = true;
        }, function(e) {
          window.plugins.socialsharing.canShareVia('com.facebook.katana', 'msg', null, null, null, function(e) {
            $scope.shareFacebookVia = 'com.facebook.katana';
            $scope.facebook = true;
          }, function(e) {
            $log.debug('facebook error: ' + e);
            $scope.facebook = false;
          });
        });
        window.plugins.socialsharing.canShareVia('com.apple.social.twitter', 'msg', null, null, null, function(e) {
          $scope.shareTwitterVia = 'com.apple.social.twitter';
          $scope.twitter = true;
        }, function(e) {
          window.plugins.socialsharing.canShareVia('com.twitter.android', 'msg', null, null, null, function(e) {
            $scope.shareTwitterVia = 'com.twitter.android';
            $scope.twitter = true;
          }, function(e) {
            $log.debug('twitter error: ' + e);
            $scope.twitter = false;
          });
        });
        window.plugins.socialsharing.canShareVia('com.google.android.apps.plus', 'msg', null, null, null, function(e) {
          $scope.shareGooglePlusVia = 'com.google.android.apps.plus';
          $scope.googleplus = true;
        }, function(e) {
          $log.debug('googlePlus error: ' + e);
          $scope.googleplus = false;
        });
        window.plugins.socialsharing.canShareViaEmail(function(e) {
          $scope.email = true;
        }, function(e) {
          $log.debug('email error: ' + e);
          $scope.email = false;
        });
        window.plugins.socialsharing.canShareVia('whatsapp', 'msg', null, null, null, function(e) {
          $scope.whatsapp = true;
        }, function(e) {
          $log.debug('whatsapp error: ' + e);
          $scope.whatsapp = false;
        });
      }
    }, 100);
  });

  $scope.close = function() {
    $ionicHistory.nextViewOptions({
      disableAnimate: false,
      historyRoot: true
    });
    if ($scope.score == 5) $ionicHistory.goBack(-3);
    else $ionicHistory.goBack(-2);
  };
});

'use strict';

angular.module('copayApp.controllers').controller('rateAppController', function($scope, $state, $stateParams, $window, lodash, externalLinkService, configService, platformInfo, feedbackService, ongoingProcess, popupService, appConfigService) {
  $scope.score = parseInt($stateParams.score);
  $scope.appName = appConfigService.nameCase;
  var isAndroid = platformInfo.isAndroid;
  var isIOS = platformInfo.isIOS;

  var config = configService.getSync();

  $scope.skip = function() {
    var dataSrc = {
      "Email": lodash.values(config.emailFor)[0] || ' ',
      "Feedback": ' ',
      "Score": $stateParams.score,
      "AppVersion": $window.version,
      "Platform": ionic.Platform.platform(),
      "DeviceVersion": ionic.Platform.version()
    };
    feedbackService.send(dataSrc, function(err) {
      if (err) {
        // try to send, but not essential, since the user didn't add a message
        $log.warn('Could not send feedback.');
      }
    });
    $state.go('tabs.rate.complete', {
      score: $stateParams.score,
      skipped: true
    });
  };

  $scope.sendFeedback = function() {
    $state.go('tabs.rate.send', {
      score: $scope.score
    });
  };

  $scope.goAppStore = function() {
    var defaults = configService.getDefaults();
    var url;
    if (isAndroid)
      url = $scope.appName == 'MyBitcoinZ' ? defaults.rateApp.copay.android : defaults.rateApp.btczcom.android;
    if (isIOS)
      url = $scope.appName == 'MyBitcoinZ' ? defaults.rateApp.copay.ios : defaults.rateApp.btczcom.ios;

    externalLinkService.open(url);
    $state.go('tabs.rate.complete', {
      score: $stateParams.score,
      skipped: true,
      rated: true
    });
  };
});

'use strict';

angular.module('copayApp.controllers').controller('rateCardController', function($scope, $state, $timeout, $log, gettextCatalog, platformInfo, storageService, appConfigService) {

  $scope.isCordova = platformInfo.isCordova;
  $scope.score = 0;
  $scope.appName = appConfigService.nameCase;

  $scope.goFeedbackFlow = function() {
    $scope.hideCard();
    if ($scope.isCordova && $scope.score == 5) {
      $state.go('tabs.rate.rateApp', {
        score: $scope.score
      });
    } else {
      $state.go('tabs.rate.send', {
        score: $scope.score
      });
    }
  };

  $scope.setScore = function(score) {
    $scope.score = score;
    switch ($scope.score) {
      case 1:
        $scope.button_title = gettextCatalog.getString("I think this app is terrible.");
        break;
      case 2:
        $scope.button_title = gettextCatalog.getString("I don't like it");
        break;
      case 3:
        $scope.button_title = gettextCatalog.getString("Meh - it's alright");
        break;
      case 4:
        $scope.button_title = gettextCatalog.getString("I like the app");
        break;
      case 5:
        $scope.button_title = gettextCatalog.getString("This app is fantastic!");
        break;
    }
    $timeout(function() {
      $scope.$apply();
    });
  };

  $scope.hideCard = function() {
    $log.debug('Feedback card dismissed.')
    storageService.getFeedbackInfo(function(error, info) {
      var feedbackInfo = JSON.parse(info);
      feedbackInfo.sent = true;
      storageService.setFeedbackInfo(JSON.stringify(feedbackInfo), function() {
        $scope.showRateCard.value = false;
        $timeout(function() {
          $scope.$apply();
        }, 100);
      });
    });
  }

});

'use strict';

angular.module('copayApp.controllers').controller('sendController', function($scope, $state, $log, $timeout, $stateParams, $ionicNavBarDelegate, $ionicHistory, $ionicConfig, $window, gettextCatalog, popupService, configService, lodash, feedbackService, ongoingProcess, platformInfo, appConfigService) {

  $scope.sendFeedback = function(feedback, goHome) {

    var config = configService.getSync();

    var dataSrc = {
      "Email": lodash.values(config.emailFor)[0] || ' ',
      "Feedback": goHome ? ' ' : feedback,
      "Score": $stateParams.score || ' ',
      "AppVersion": $window.version,
      "Platform": ionic.Platform.platform(),
      "DeviceVersion": ionic.Platform.version()
    };

    if (!goHome) ongoingProcess.set('sendingFeedback', true);
    feedbackService.send(dataSrc, function(err) {
      if (goHome) return;
      ongoingProcess.set('sendingFeedback', false);
      if (err) {
        popupService.showAlert(gettextCatalog.getString('Error'), gettextCatalog.getString('Feedback could not be submitted. Please try again later.'));
        return;
      }
      if (!$stateParams.score) {
        popupService.showAlert(gettextCatalog.getString('Thank you!'), gettextCatalog.getString('A member of the team will review your feedback as soon as possible.'), function() {
          $scope.feedback.value = '';
          $ionicHistory.nextViewOptions({
            disableAnimate: false,
            historyRoot: true
          });
          $ionicHistory.goBack();
        }, gettextCatalog.getString('Finish'));
        return;
      }
      $state.go('tabs.rate.complete', {
        score: $stateParams.score
      });
    });
    if (goHome) $state.go('tabs.home');
  };

  $scope.$on("$ionicView.beforeLeave", function(event, data) {
    $ionicConfig.views.swipeBackEnabled(true);
  });

  $scope.$on("$ionicView.enter", function(event, data) {
    if ($scope.score)
      $ionicConfig.views.swipeBackEnabled(false);
  });

  $scope.$on("$ionicView.beforeEnter", function(event, data) {
    $scope.isCordova = platformInfo.isCordova;
    $scope.score = (data.stateParams && data.stateParams.score) ? parseInt(data.stateParams.score) : null;
    $scope.feedback = {};

    switch ($scope.score) {
      case 1:
        $scope.reaction = "Ouch!";
        $scope.comment = gettextCatalog.getString("There's obviously something we're doing wrong.") + ' ' + gettextCatalog.getString("How could we improve your experience?");
        break;
      case 2:
        $scope.reaction = gettextCatalog.getString("Oh no!");
        $scope.comment = gettextCatalog.getString("There's obviously something we're doing wrong.") + ' ' + gettextCatalog.getString("How could we improve your experience?");
        break;
      case 3:
        $scope.reaction = "Hmm...";
        $scope.comment = gettextCatalog.getString("We'd love to do better.") + ' ' + gettextCatalog.getString("How could we improve your experience?");
        break;
      case 4:
        $scope.reaction = gettextCatalog.getString("Thanks!");
        $scope.comment = gettextCatalog.getString("That's exciting to hear. We'd love to earn that fifth star from you  how could we improve your experience?");
        break;
      case 5:
        $scope.reaction = gettextCatalog.getString("Thank you!");
        $scope.comment = gettextCatalog.getString("We're always looking for ways to improve {{appName}}.", {
          appName: appConfigService.nameCase
        }) + ' ' + gettextCatalog.getString("Is there anything we could do better?");
        break;
      default:
        $scope.justFeedback = true;
        $scope.comment = gettextCatalog.getString("We're always looking for ways to improve {{appName}}. How could we improve your experience?", {
          appName: appConfigService.nameCase
        });
        break;
    }
  });

  $scope.$on("$ionicView.afterEnter", function() {
    $scope.showForm = true;
  });

  $scope.goBack = function() {
    $ionicHistory.nextViewOptions({
      disableAnimate: false,
      historyRoot: true
    });
    $ionicHistory.goBack();
  };

});

'use strict';

angular.module('copayApp.controllers').controller('glideraController',
  function($scope, $timeout, $ionicModal, $log, storageService, glideraService, ongoingProcess, platformInfo, externalLinkService, popupService, lodash) {

    $scope.openExternalLink = function(url) {
      externalLinkService.open(url);
    };

    var init = function() {
      ongoingProcess.set('connectingGlidera', true);
      glideraService.init(function(err, data) {
        ongoingProcess.set('connectingGlidera', false);
        if (err) {
          popupService.showAlert('Error connecting Glidera', err + '. Please re-connect to Glidera');
          return;
        }
        if (!data || (data && !data.token)) return;

        $scope.account['token'] = data.token;
        $scope.account['status'] = data.status;
        $scope.account['txs'] = data.txs; 

        $timeout(function() {
          $scope.$digest();
          $scope.update();
        });
      });
    };

    $scope.update = function(opts) {
      $log.debug('Updating Glidera...');
      glideraService.updateStatus($scope.account);
    };

    $scope.getAuthenticateUrl = function() {
      return glideraService.getOauthCodeUrl();
    };

    $scope.submitOauthCode = function(code) {
      ongoingProcess.set('connectingGlidera', true);
      glideraService.authorize(code, function(err, data) {
        ongoingProcess.set('connectingGlidera', false);
        if (err) {
          popupService.showAlert('Authorisation error', err);
          return;
        }
        $scope.account['token'] = data.token;
        $scope.account['status'] = data.status;
        init();
      });
    };

    $scope.openTxModal = function(tx) {
      $scope.tx = tx;

      glideraService.getTransaction($scope.account.token, tx.transactionUuid, function(err, tx) {
        if (err) {
          popupService.showAlert('Error getting transaction', 'Could not get transactions');
          return;
        }
        $scope.tx = tx;
      });

      $ionicModal.fromTemplateUrl('views/modals/glidera-tx-details.html', {
        scope: $scope,
        backdropClickToClose: false,
        hardwareBackButtonClose: false,
        animation: 'slide-in-up'
      }).then(function(modal) {
        $scope.glideraTxDetailsModal = modal;
        $scope.glideraTxDetailsModal.show();
      });
    };

    $scope.openAuthenticateWindow = function() {
      $scope.openExternalLink($scope.getAuthenticateUrl());
      $scope.showOauthForm = true
    }

    $scope.openLoginWindow = function() {
      var glideraUrl = ($scope.network === 'testnet') ? 'https://sandbox.glidera.io/login' : 'https://glidera.io/login';
      $scope.openExternalLink(glideraUrl);
    }

    $scope.openSupportWindow = function() {
      var url = glideraService.getSupportUrl();
      var optIn = true;
      var title = 'Glidera Support';
      var message = 'You can email glidera at support@glidera.io for direct support, or you can contact Glidera on Twitter.';
      var okText = 'Tweet @GlideraInc';
      var cancelText = 'Go Back';
      externalLinkService.open(url, optIn, title, message, okText, cancelText);
    }

    $scope.toggleOauthForm = function() {
      $scope.showOauthForm = !$scope.showOauthForm;
    }

    $scope.$on("$ionicView.afterEnter", function(event, data) {
      $scope.network = glideraService.getNetwork();
      $scope.currency = glideraService.getCurrency();
      $scope.showOauthForm = false;
      $scope.account = {};
      if (data.stateParams && data.stateParams.code) {
        $scope.submitOauthCode(data.stateParams.code);
      } else {
        init();
      }
    });

  });

'use strict';

angular.module('copayApp.controllers').controller('headController', function($scope, appConfigService, $log) {
  $scope.appConfig = appConfigService;
  $log.info('Running head controller:' + appConfigService.nameCase)
});

'use strict';

angular.module('copayApp.controllers').controller('homeIntegrationsController', function($scope, homeIntegrationsService, $ionicScrollDelegate, $timeout) {

  $scope.hide = false;
  $scope.services = homeIntegrationsService.get();

  $scope.toggle = function() {
    $scope.hide = !$scope.hide;
    $timeout(function() {
      $ionicScrollDelegate.resize();
      $scope.$apply();
    }, 10);
  };

});

'use strict';

angular.module('copayApp.controllers').controller('importController',
  function($scope, $timeout, $log, $state, $stateParams, $ionicHistory, $ionicScrollDelegate, profileService, configService, sjcl, ledger, trezor, derivationPathHelper, platformInfo, bwcService, ongoingProcess, walletService, popupService, gettextCatalog, appConfigService, hwWallet) {

    var reader = new FileReader();
    var defaults = configService.getDefaults();
    var config = configService.getSync();
    var errors = bwcService.getErrors();

    $scope.init = function() {
      $scope.supportsLedger = platformInfo.supportsLedger;
      $scope.supportsTrezor = platformInfo.supportsTrezor;
      $scope.isCordova = platformInfo.isCordova;
      $scope.formData = {};
      $scope.formData.bwsurl = defaults.bws.url;
      $scope.formData.derivationPath = derivationPathHelper.default;
      $scope.formData.account = 1;
      $scope.formData.coin = 'btcz';
      $scope.importErr = false;
      $scope.isCopay = appConfigService.name == 'bitcoinz';
      $scope.fromHardwareWallet = {
        value: false
      };

      if (config.cashSupport) $scope.enableCash = true;

      if ($stateParams.code)
        $scope.processWalletInfo($stateParams.code);

      $scope.seedOptions = [];

      if ($scope.supportsLedger) {
        $scope.seedOptions.push({
          id: walletService.externalSource.ledger.id,
          label: walletService.externalSource.ledger.longName,
        });
      }

      if ($scope.supportsTrezor) {
        $scope.seedOptions.push({
          id: walletService.externalSource.trezor.id,
          label: walletService.externalSource.trezor.longName,
        });
        $scope.formData.seedSource = $scope.seedOptions[0];
      }


      $scope.seedOptionsAll = [];

      $scope.seedOptionsAll.push({
        id: walletService.externalSource.ledger.id,
        label: walletService.externalSource.ledger.longName,
      });

      $scope.seedOptionsAll.push({
        id: walletService.externalSource.trezor.id,
        label: walletService.externalSource.trezor.longName,
      });
      $scope.formData.seedSourceAll = $scope.seedOptionsAll[0];


      $timeout(function() {
        $scope.$apply();
      });
    };

    $scope.switchTestnetOff = function() {
      $scope.formData.testnetEnabled = false;
      $scope.setDerivationPath();
      $scope.resizeView();
      $timeout(function() {
        $scope.$apply();
      });
    };

    $scope.processWalletInfo = function(code) {
      if (!code) return;

      $scope.importErr = false;
      var parsedCode = code.split('|');

      if (parsedCode.length != 5) {
        /// Trying to import a malformed wallet export QR code
        popupService.showAlert(gettextCatalog.getString('Error'), gettextCatalog.getString('Incorrect code format'));
        return;
      }

      var info = {
        type: parsedCode[0],
        data: parsedCode[1],
        network: parsedCode[2],
        derivationPath: parsedCode[3],
        hasPassphrase: parsedCode[4] == 'true' ? true : false
      };

      if (info.type == 1 && info.hasPassphrase)
        popupService.showAlert(gettextCatalog.getString('Error'), gettextCatalog.getString('Password required. Make sure to enter your password in advanced options'));

      $scope.formData.derivationPath = info.derivationPath;
      $scope.formData.testnetEnabled = info.network == 'testnet' ? true : false;

      $timeout(function() {
        $scope.formData.words = info.data;
        $scope.$apply();
      }, 1);
    };

    var _importBlob = function(str, opts) {
      var str2, err;
      try {
        str2 = sjcl.decrypt($scope.formData.password, str);
      } catch (e) {
        err = gettextCatalog.getString('Could not decrypt file, check your password');
        $log.warn(e);
      };

      if (err) {
        popupService.showAlert(gettextCatalog.getString('Error'), err);
        return;
      }

      ongoingProcess.set('importingWallet', true);
      opts.compressed = null;
      opts.password = null;

      $timeout(function() {
        profileService.importWallet(str2, opts, function(err, client) {
          ongoingProcess.set('importingWallet', false);
          if (err) {
            popupService.showAlert(gettextCatalog.getString('Error'), err);
            return;

          }
          finish(client);
        });
      }, 100);
    };

    var _importExtendedPrivateKey = function(xPrivKey, opts) {
      ongoingProcess.set('importingWallet', true);
      $timeout(function() {
        profileService.importExtendedPrivateKey(xPrivKey, opts, function(err, client) {
          ongoingProcess.set('importingWallet', false);
          if (err) {
            if (err instanceof errors.NOT_AUTHORIZED) {
              $scope.importErr = true;
            } else {
              popupService.showAlert(gettextCatalog.getString('Error'), err);
            }
            return $timeout(function() {
              $scope.$apply();
            });
          }
          finish(client);
        });
      }, 100);
    };

    /*
      IMPORT FROM PUBLIC KEY - PENDING

    var _importExtendedPublicKey = function(xPubKey, opts) {
      ongoingProcess.set('importingWallet', true);
      $timeout(function() {
        profileService.importExtendedPublicKey(opts, function(err, walletId) {
          ongoingProcess.set('importingWallet', false);
          if (err) {
            $scope.error = err;
            return $timeout(function() {
              $scope.$apply();
            });
          }

          profileService.setBackupFlag(walletId);
           if ($stateParams.fromOnboarding) {
             profileService.setDisclaimerAccepted(function(err) {
               if (err) $log.error(err);
             });
           }

          $state.go('tabs.home');
        });
      }, 100);
    };
    */

    var _importMnemonic = function(words, opts) {
      ongoingProcess.set('importingWallet', true);

      $timeout(function() {
        profileService.importMnemonic(words, opts, function(err, client) {

          ongoingProcess.set('importingWallet', false);

          if (err) {
            if (err instanceof errors.NOT_AUTHORIZED) {
              $scope.importErr = true;
            } else {
              popupService.showAlert(gettextCatalog.getString('Error'), err);
            }
            return $timeout(function() {
              $scope.$apply();
            });
          }
          finish(client);
        });
      }, 100);
    };

    $scope.setDerivationPath = function() {
      $scope.formData.derivationPath = $scope.formData.testnetEnabled ? derivationPathHelper.defaultTestnet : derivationPathHelper.default;
    };

    $scope.getFile = function() {
      // If we use onloadend, we need to check the readyState.
      reader.onloadend = function(evt) {
        if (evt.target.readyState == FileReader.DONE) { // DONE == 2
          var opts = {};
          opts.bwsurl = $scope.formData.bwsurl;
          opts.coin = $scope.formData.coin;
          _importBlob(evt.target.result, opts);
        }
      }
    };

    $scope.importBlob = function(form) {
      if (form.$invalid) {
        popupService.showAlert(gettextCatalog.getString('Error'), gettextCatalog.getString('There is an error in the form'));
        return;
      }

      var backupFile = $scope.formData.file;
      var backupText = $scope.formData.backupText;
      var password = $scope.formData.password;

      if (!backupFile && !backupText) {
        popupService.showAlert(gettextCatalog.getString('Error'), gettextCatalog.getString('Please, select your backup file'));
        return;
      }

      if (backupFile) {
        reader.readAsBinaryString(backupFile);
      } else {
        var opts = {};
        opts.bwsurl = $scope.formData.bwsurl;
        opts.coin = $scope.formData.coin;
        _importBlob(backupText, opts);
      }
    };

    $scope.importMnemonic = function(form) {
      if (form.$invalid) {
        popupService.showAlert(gettextCatalog.getString('Error'), gettextCatalog.getString('There is an error in the form'));
        return;
      }

      var opts = {};

      if ($scope.formData.bwsurl)
        opts.bwsurl = $scope.formData.bwsurl;

      var pathData = derivationPathHelper.parse($scope.formData.derivationPath);

      if (!pathData) {
        popupService.showAlert(gettextCatalog.getString('Error'), gettextCatalog.getString('Invalid derivation path'));
        return;
      }

      opts.account = pathData.account;
      opts.networkName = pathData.networkName;
      opts.derivationStrategy = pathData.derivationStrategy;
      opts.coin = $scope.formData.coin;

      var words = $scope.formData.words || null;

      if (!words) {
        popupService.showAlert(gettextCatalog.getString('Error'), gettextCatalog.getString('Please enter the recovery phrase'));
        return;
      } else if (words.indexOf('xprv') == 0 || words.indexOf('tprv') == 0) {
        return _importExtendedPrivateKey(words, opts);
      } else if (words.indexOf('xpub') == 0 || words.indexOf('tpuv') == 0) {
        return _importExtendedPublicKey(words, opts);
      } else {
        var wordList = words.split(/[\u3000\s]+/);

        if ((wordList.length % 3) != 0) {
          popupService.showAlert(gettextCatalog.getString('Error'), gettextCatalog.getString('Wrong number of recovery words: ') + wordList.length);
          return;
        }
      }

      opts.passphrase = $scope.formData.passphrase || null;

      if ($scope.fromHardwareWallet.value) {
        $log.debug('Importing seed from hardware wallet');
        $log.warn('This wont work for Intel TEE wallets');

        var id = $scope.formData.seedSourceAll.id;
        var isMultisig = opts.derivationStrategy == 'BIP48';
        var account = opts.account;
        opts.entropySourcePath = 'm/' + hwWallet.getEntropyPath(id, isMultisig, account);
      }

      _importMnemonic(words, opts);
    };

    $scope.importTrezor = function(account, isMultisig) {
      trezor.getInfoForNewWallet(isMultisig, account, 'livenet', function(err, lopts) {
        ongoingProcess.clear();
        if (err) {
          popupService.showAlert(gettextCatalog.getString('Error'), err);
          return;
        }

        lopts.externalSource = walletService.externalSource.trezor.id;
        lopts.bwsurl = $scope.formData.bwsurl;
        lopts.account = account;
        ongoingProcess.set('importingWallet', true);
        $log.debug('Import opts', lopts);

        profileService.importExtendedPublicKey(lopts, function(err, wallet) {
          ongoingProcess.set('importingWallet', false);
          if (err) {
            popupService.showAlert(gettextCatalog.getString('Error'), err);
            return;
          }
          finish(wallet);
        });
      }, 100);
    };

    $scope.importHW = function(form) {
      if (form.$invalid || $scope.formData.account < 0) {
        popupService.showAlert(gettextCatalog.getString('Error'), gettextCatalog.getString('There is an error in the form'));
        return;
      }

      $scope.importErr = false;

      var account = $scope.formData.account;

      if ($scope.formData.seedSource.id == walletService.externalSource.trezor.id) {
        if (account < 1) {
          popupService.showAlert(gettextCatalog.getString('Error'), gettextCatalog.getString('Invalid account number'));
          return;
        }
        account = account - 1;
      }

      switch ($scope.formData.seedSource.id) {
        case (walletService.externalSource.ledger.id):
          ongoingProcess.set('connectingledger', true);
          $scope.importLedger(account);
          break;
        case (walletService.externalSource.trezor.id):
          ongoingProcess.set('connectingtrezor', true);
          $scope.importTrezor(account, $scope.formData.isMultisig);
          break;
        default:
          throw ('Error: bad source id');
      };
    };

    $scope.importLedger = function(account) {
      ledger.getInfoForNewWallet(true, account, 'livenet', function(err, lopts) {
        ongoingProcess.clear();
        if (err) {
          popupService.showAlert(gettextCatalog.getString('Error'), err);
          return;
        }

        lopts.externalSource = lopts.externalSource = walletService.externalSource.ledger.id;
        lopts.bwsurl = $scope.formData.bwsurl;
        lopts.account = account;
        ongoingProcess.set('importingWallet', true);
        $log.debug('Import opts', lopts);

        profileService.importExtendedPublicKey(lopts, function(err, wallet) {
          ongoingProcess.set('importingWallet', false);
          if (err) {
            popupService.showAlert(gettextCatalog.getString('Error'), err);
            return;
          }
          finish(wallet);
        });
      }, 100);
    };

    var finish = function(wallet) {
      walletService.updateRemotePreferences(wallet);

      profileService.setBackupFlag(wallet.credentials.walletId);
      if ($stateParams.fromOnboarding) {
        profileService.setDisclaimerAccepted(function(err) {
          if (err) $log.error(err);
        });
      }
      $ionicHistory.removeBackView();
      $state.go('tabs.home', {
        fromOnboarding: $stateParams.fromOnboarding
      });
    };

    $scope.showAdvChange = function() {
      $scope.showAdv = !$scope.showAdv;
      $timeout(function() {
        $scope.resizeView();
      }, 100);
    };

    $scope.resizeView = function() {
      $timeout(function() {
        $ionicScrollDelegate.resize();
      }, 10);
    };

    $scope.$on("$ionicView.afterEnter", function(event, data) {
      $scope.showAdv = false;
      $scope.init();
    });

  });

'use strict';

angular.module('copayApp.controllers').controller('joinController',
  function($scope, $rootScope, $timeout, $state, $ionicHistory, $ionicScrollDelegate, profileService, configService, storageService, applicationService, gettextCatalog, lodash, ledger, trezor, intelTEE, derivationPathHelper, ongoingProcess, walletService, $log, $stateParams, popupService, appConfigService) {

    $scope.$on("$ionicView.beforeEnter", function(event, data) {
      var defaults = configService.getDefaults();
      var config = configService.getSync();
      $scope.formData = {};
      $scope.formData.bwsurl = defaults.bws.url;
      $scope.formData.derivationPath = derivationPathHelper.default;
      $scope.formData.account = 1;
      $scope.formData.secret = null;
      $scope.formData.coin = 'btcz';
      if (config.cashSupport) $scope.enableCash = true;
      resetPasswordFields();
      updateSeedSourceSelect();
    });

    $scope.showAdvChange = function() {
      $scope.showAdv = !$scope.showAdv;
      $scope.encrypt = null;
      $scope.resizeView();
    };

    $scope.checkPassword = function(pw1, pw2) {
      if (pw1 && pw1.length > 0) {
        if (pw2 && pw2.length > 0) {
          if (pw1 == pw2) $scope.result = 'correct';
          else {
            $scope.formData.passwordSaved = null;
            $scope.result = 'incorrect';
          }
        } else
          $scope.result = null;
      } else
        $scope.result = null;
    };

    $scope.resizeView = function() {
      $timeout(function() {
        $ionicScrollDelegate.resize();
      }, 10);
      resetPasswordFields();
    };

    function resetPasswordFields() {
      $scope.formData.passphrase = $scope.formData.createPassphrase = $scope.formData.passwordSaved = $scope.formData.repeatPassword = $scope.result = null;
      $timeout(function() {
        $scope.$apply();
      });
    };

    $scope.onQrCodeScannedJoin = function(data) {
      $scope.formData.secret = data;
      $scope.$apply();
    };

    if ($stateParams.url) {
      var data = $stateParams.url;
      data = data.replace('copay:', '');
      $scope.onQrCodeScannedJoin(data);
    }

    function updateSeedSourceSelect() {
      $scope.seedOptions = [{
        id: 'new',
        label: gettextCatalog.getString('Random'),
      }, {
        id: 'set',
        label: gettextCatalog.getString('Specify Recovery Phrase...'),
      }];
      $scope.formData.seedSource = $scope.seedOptions[0];
      /*

      Disable Hardware Wallets

      */

      if (appConfigService.name == 'copay') {
        if (walletService.externalSource.ledger.supported) {
          $scope.seedOptions.push({
            id: walletService.externalSource.ledger.id,
            label: walletService.externalSource.ledger.longName
          });
        }

        if (walletService.externalSource.trezor.supported) {
          $scope.seedOptions.push({
            id: walletService.externalSource.trezor.id,
            label: walletService.externalSource.trezor.longName
          });
        }

        if (walletService.externalSource.intelTEE.supported) {
          $scope.seedOptions.push({
            id: walletService.externalSource.intelTEE.id,
            label: walletService.externalSource.intelTEE.longName
          });
        }
      }
    };

    $scope.join = function() {

      var opts = {
        secret: $scope.formData.secret,
        myName: $scope.formData.myName,
        bwsurl: $scope.formData.bwsurl,
        coin: $scope.formData.coin
      }

      var setSeed = $scope.formData.seedSource.id == 'set';
      if (setSeed) {
        var words = $scope.formData.privateKey;
        if (words.indexOf(' ') == -1 && words.indexOf('prv') == 1 && words.length > 108) {
          opts.extendedPrivateKey = words;
        } else {
          opts.mnemonic = words;
        }
        opts.passphrase = $scope.formData.passphrase;

        var pathData = derivationPathHelper.parse($scope.formData.derivationPath);
        if (!pathData) {
          popupService.showAlert(gettextCatalog.getString('Error'), gettextCatalog.getString('Invalid derivation path'));
          return;
        }
        opts.account = pathData.account;
        opts.networkName = pathData.networkName;
        opts.derivationStrategy = pathData.derivationStrategy;
      } else {
        opts.passphrase = $scope.formData.createPassphrase;
      }

      opts.walletPrivKey = $scope._walletPrivKey; // Only for testing


      if (setSeed && !opts.mnemonic && !opts.extendedPrivateKey) {
        popupService.showAlert(gettextCatalog.getString('Error'), gettextCatalog.getString('Please enter the wallet recovery phrase'));
        return;
      }

      if ($scope.formData.seedSource.id == walletService.externalSource.ledger.id || $scope.formData.seedSource.id == walletService.externalSource.trezor.id || $scope.formData.seedSource.id == walletService.externalSource.intelTEE.id) {
        if ($scope.formData.coin == 'bch') {
          popupService.showAlert(gettextCatalog.getString('Error'), gettextCatalog.getString('Hardware wallets are not yet supported with Bitcoin Cash'));
          return;
        }

        var account = $scope.formData.account;
        if (!account || account < 1) {
          popupService.showAlert(gettextCatalog.getString('Error'), gettextCatalog.getString('Invalid account number'));
          return;
        }

        if ($scope.formData.seedSource.id == walletService.externalSource.trezor.id || $scope.formData.seedSource.id == walletService.externalSource.intelTEE.id)
          account = account - 1;

        opts.account = account;
        opts.isMultisig = true;
        ongoingProcess.set('connecting' + $scope.formData.seedSource.id, true);

        var src;
        switch ($scope.formData.seedSource.id) {
          case walletService.externalSource.ledger.id:
            src = ledger;
            break;
          case walletService.externalSource.trezor.id:
            src = trezor;
            break;
          case walletService.externalSource.intelTEE.id:
            src = intelTEE;
            break;
          default:
            popupService.showAlert(gettextCatalog.getString('Error'), 'Invalid seed source id');
            return;
        }

        // TODO: cannot currently join an intelTEE testnet wallet (need to detect from the secret)
        src.getInfoForNewWallet(true, account, 'livenet', function(err, lopts) {
          ongoingProcess.set('connecting' + $scope.formData.seedSource.id, false);
          if (err) {
            popupService.showAlert(gettextCatalog.getString('Error'), err);
            return;
          }
          opts = lodash.assign(lopts, opts);
          _join(opts);
        });
      } else {

        _join(opts);
      }
    };

    function _join(opts) {
      ongoingProcess.set('joiningWallet', true);
      $timeout(function() {
        profileService.joinWallet(opts, function(err, client) {
          ongoingProcess.set('joiningWallet', false);
          if (err) {
            popupService.showAlert(gettextCatalog.getString('Error'), err);
            return;
          }

          walletService.updateRemotePreferences(client);
          $ionicHistory.removeBackView();

          if (!client.isComplete()) {
            $ionicHistory.nextViewOptions({
              disableAnimate: true
            });
            $state.go('tabs.home');
            $timeout(function() {
              $state.transitionTo('tabs.copayers', {
                walletId: client.credentials.walletId
              });
            });
          } else $state.go('tabs.home');
        });
      });
    };
  });

'use strict';

angular.module('copayApp.controllers').controller('lockSetupController', function($state, $rootScope, $scope, $timeout, $log, configService, gettextCatalog, fingerprintService, profileService, lodash, applicationService) {

  function init() {
    $scope.options = [
      {
        method: 'none',
        label: gettextCatalog.getString('Disabled'),
        disabled: false,
      },
      {
        method: 'pin',
        label: gettextCatalog.getString('Lock by PIN'),
        needsBackup: false,
        disabled: false,
      },
    ];

    if (fingerprintService.isAvailable()) {
      $scope.options.push({
        method: 'fingerprint',
        label: gettextCatalog.getString('Lock by Fingerprint'),
        needsBackup: false,
        disabled: false,
      });
    }

    initMethodSelector();
    processWallets();
  };

  $scope.$on("$ionicView.beforeEnter", function(event) {
    init();
  });

  function getSavedMethod() {
    var config = configService.getSync();
    if (config.lock && config.lock.method) return config.lock.method;
    return 'none';
  };

  function initMethodSelector() {
    function disable(method) {
      lodash.find($scope.options, {
        method: method
      }).disabled = true;
    };

    var savedMethod = getSavedMethod();

    lodash.each($scope.options, function(o) {
      o.disabled = false;
    });

    // HACK: Disable until we allow to change between methods directly
    if (fingerprintService.isAvailable()) {
      switch (savedMethod) {
        case 'pin':
          disable('fingerprint');
          break;
        case 'fingerprint':
          disable('pin');
          break;
      }
    }

    $scope.currentOption = lodash.find($scope.options, {
      method: savedMethod
    });
    $timeout(function() {
      $scope.$apply();
    });
  };

  function processWallets() {
    var wallets = profileService.getWallets();
    var singleLivenetWallet = wallets.length == 1 && wallets[0].network == 'livenet' && wallets[0].needsBackup;
    var atLeastOneLivenetWallet = lodash.any(wallets, function(w) {
      return w.network == 'livenet' && w.needsBackup;
    });

    if (singleLivenetWallet) {
      $scope.errorMsg = gettextCatalog.getString('Backup your wallet before using this function');
      disableOptsUntilBackup();
    } else if (atLeastOneLivenetWallet) {
      $scope.errorMsg = gettextCatalog.getString('Backup all livenet wallets before using this function');
      disableOptsUntilBackup();
    } else {
      enableOptsAfterBackup();
      $scope.errorMsg = null;
    }

    function enableOptsAfterBackup() {
      $scope.options[1].needsBackup = false;
      if ($scope.options[2]) $scope.options[2].needsBackup = false;
    };

    function disableOptsUntilBackup() {
      $scope.options[1].needsBackup = true;
      if ($scope.options[2]) $scope.options[2].needsBackup = true;
    };

    $timeout(function() {
      $scope.$apply();
    });
  };

  $scope.select = function(selectedMethod) {
    var savedMethod = getSavedMethod();
    if (savedMethod == selectedMethod) return;

    if (selectedMethod == 'none') {
      disableMethod(savedMethod);
    } else {
      enableMethod(selectedMethod);
    }
  };

  function disableMethod(method) {
    switch (method) {
      case 'pin':
        applicationService.pinModal('disable');
        break;
      case 'fingerprint':
        fingerprintService.check('unlockingApp', function(err) {
          if (err) init();
          else saveConfig('none');
        });
        break;
    }
  };

  function enableMethod(method) {
    switch (method) {
      case 'pin':
        applicationService.pinModal('setup');
        break;
      case 'fingerprint':
        saveConfig('fingerprint');
        break;
    }
  };

  function saveConfig(method) {
    var opts = {
      lock: {
        method: method,
        value: null,
      }
    };

    configService.set(opts, function(err) {
      if (err) $log.debug(err);
      initMethodSelector();
    });
  };

  $rootScope.$on('pinModalClosed', function() {
    init()
  });

});

'use strict';

angular.module('copayApp.controllers').controller('mercadoLibreController',
  function($scope, $timeout, $log, mercadoLibreService, externalLinkService, popupService) {

    $scope.openExternalLink = function(url) {
      externalLinkService.open(url);
    };

    var init = function() {
      mercadoLibreService.getPendingGiftCards(function(err, gcds) {
        if (err) $log.error(err);
        $scope.giftCards = gcds;
        $timeout(function() {
          $scope.$digest();
        });
      });
    };

    $scope.$on("$ionicView.beforeEnter", function(event, data) {
      $scope.network = mercadoLibreService.getNetwork();
      init();
    });
  });

'use strict';

angular.module('copayApp.controllers').controller('mercadoLibreCardsController',
  function($scope, $timeout, $ionicModal, $log, $ionicScrollDelegate, lodash, mercadoLibreService, platformInfo, externalLinkService, popupService, ongoingProcess) {

    $scope.openExternalLink = function(url) {
      externalLinkService.open(url);
    };

    var updateGiftCards = function(cb) {
      mercadoLibreService.getPendingGiftCards(function(err, gcds) {
        if (err) {
          popupService.showAlert('Could not get gift cards', err);
          if (cb) return cb();
          else return;
        }
        $scope.giftCards = gcds;
        $timeout(function() {
          $scope.$digest();
          $ionicScrollDelegate.resize();
          if (cb) return cb();
        }, 100);
      });
    };

    $scope.updatePendingGiftCards = lodash.debounce(function() {
      updateGiftCards(function() {
        var index = 0;
        var gcds = $scope.giftCards;
        lodash.forEach(gcds, function(dataFromStorage) {
          if (dataFromStorage.status == 'PENDING') {
            $log.debug("Creating / Updating gift card");

            mercadoLibreService.createGiftCard(dataFromStorage, function(err, giftCard) {

              if (err) {
                popupService.showAlert('Error creating gift card', err);
                return;
              }

              if (giftCard.status != 'PENDING') {
                var newData = {};

                if (!giftCard.status) dataFromStorage.status = null; // Fix error from server

                var cardStatus = giftCard.cardStatus;
                if (cardStatus && (cardStatus != 'active' && cardStatus != 'inactive' && cardStatus != 'expired'))
                  giftCard.status = 'FAILURE';

                lodash.merge(newData, dataFromStorage, giftCard);

                mercadoLibreService.savePendingGiftCard(newData, null, function(err) {
                  $log.debug("Saving new gift card");
                  updateGiftCards();
                });
              }
            });
          }
        });
      });

    }, 1000, {
      'leading': true
    });

    $scope.openCardModal = function(card) {
      $scope.card = card;

      $ionicModal.fromTemplateUrl('views/modals/mercadolibre-card-details.html', {
        scope: $scope
      }).then(function(modal) {
        $scope.mercadoLibreCardDetailsModal = modal;
        $scope.mercadoLibreCardDetailsModal.show();
      });

      $scope.$on('modal.hidden', function() {
        $scope.updatePendingGiftCards();
      });
    };

    $scope.$on("$ionicView.beforeEnter", function(event, data) {
      $scope.invoiceId = data.stateParams.invoiceId;
      updateGiftCards(function() {
        if ($scope.invoiceId) {
          var card = lodash.find($scope.giftCards, {
            invoiceId: $scope.invoiceId
          });
          if (lodash.isEmpty(card)) {
            popupService.showAlert(null, 'Card not found');
            return;
          }
          $scope.openCardModal(card);
        }
      });
    });

    $scope.$on("$ionicView.afterEnter", function(event, data) {
      $scope.updatePendingGiftCards();
    });
  });

'use strict';

angular.module('copayApp.controllers').controller('amazonCardDetailsController', function($scope, $log, $timeout, $ionicScrollDelegate, bwcError, amazonService, lodash, ongoingProcess, popupService, externalLinkService) {

  $scope.cancelGiftCard = function() {
    ongoingProcess.set('cancelingGiftCard', true);
    amazonService.cancelGiftCard($scope.card, function(err, data) {
      ongoingProcess.set('cancelingGiftCard', false);
      if (err) {
        popupService.showAlert('Error canceling gift card', bwcError.msg(err));
        return;
      }
      $scope.card.cardStatus = data.cardStatus;
      $timeout(function() {
        $ionicScrollDelegate.resize();
        $ionicScrollDelegate.scrollTop();
      }, 10);
      amazonService.savePendingGiftCard($scope.card, null, function(err) {
        $scope.refreshGiftCard();
      });
    });
  };

  $scope.remove = function() {
    amazonService.savePendingGiftCard($scope.card, {
      remove: true
    }, function(err) {
      $scope.cancel();
    });
  };

  $scope.refreshGiftCard = function() {
    ongoingProcess.set('updatingGiftCard', true);
    amazonService.getPendingGiftCards(function(err, gcds) {
      if (lodash.isEmpty(gcds)) {
        $timeout(function() {
          ongoingProcess.set('updatingGiftCard', false);
        }, 1000);
      }
      if (err) {
        popupService.showAlert('Error', err);
        return;
      }
      var index = 0;
      lodash.forEach(gcds, function(dataFromStorage) {
        if (++index == Object.keys(gcds).length) {
          $timeout(function() {
            ongoingProcess.set('updatingGiftCard', false);
          }, 1000);
        }
        if (dataFromStorage.status == 'PENDING' && dataFromStorage.invoiceId == $scope.card.invoiceId) {
          $log.debug("creating gift card");
          amazonService.createGiftCard(dataFromStorage, function(err, giftCard) {
            if (err) {
              popupService.showAlert('Error', bwcError.msg(err));
              return;
            }
            if (!lodash.isEmpty(giftCard)) {
              var newData = {};
              lodash.merge(newData, dataFromStorage, giftCard);
              amazonService.savePendingGiftCard(newData, null, function(err) {
                $log.debug("Saving new gift card");
                $scope.card = newData;
                $timeout(function() {
                  $scope.$digest();
                });
              });
            } else $log.debug("pending gift card not available yet");
          });
        }
      });
    });
  };

  $scope.cancel = function() {
    $scope.amazonCardDetailsModal.hide();
  };

  $scope.openExternalLink = function(url) {
    externalLinkService.open(url);
  };

});

'use strict';

angular.module('copayApp.controllers').controller('bitpayCardConfirmationController', function($scope, $timeout, $state, bitpayCardService) {

  $scope.ok = function() {
    bitpayCardService.logout(function() {
      $state.go('bitpayCard.main');
    });
    $scope.cancel();
  };

  $scope.cancel = function() {
    $scope.bitpayCardConfirmationModal.hide();
  };

});

'use strict';

angular.module('copayApp.controllers').controller('coinbaseTxDetailsController', function($scope, coinbaseService, popupService) {

  $scope.remove = function() {
    coinbaseService.setCredentials();
    $scope.updateRequired = false;
    var message = 'Are you sure you want to remove this transaction?';
    popupService.showConfirm(null, message, null, null, function(ok) {
      if (!ok) {
        return;
      }
      coinbaseService.savePendingTransaction($scope.tx, {
        remove: true
      }, function(err) {
        $scope.updateRequired = true;
        $scope.close();
      });
    });
  };

  $scope.close = function() {
    $scope.modal.hide().then(function() {
      if ($scope.updateRequired) $scope.updateTransactions();
    });
  };

});

'use strict';

angular.module('copayApp.controllers').controller('confirmationController', function($scope) {

  $scope.ok = function() {
    $scope.loading = true;
    $scope.okAction();
    $scope.confirmationModal.hide();
  };

  $scope.cancel = function() {
    $scope.confirmationModal.hide();
  };

});

'use strict';

angular.module('copayApp.controllers').controller('feeLevelsController', function($scope, $timeout, $log, lodash, gettextCatalog, configService, feeService, ongoingProcess, popupService) {

  var FEE_MULTIPLIER = 10;
  var FEE_MIN = 0;

  var showErrorAndClose = function(title, msg) {
    title = title || gettextCatalog.getString('Error');
    $log.error(msg);
    popupService.showAlert(title, msg, function() {
      $scope.chooseFeeLevelModal.hide();
    });

  };

  var getMinRecommended = function() {
    var value = lodash.find($scope.feeLevels[$scope.network], {
      level: 'superEconomy'
    });
    return parseInt((value.feePerKb / 1000).toFixed());
  };

  var getMaxRecommended = function() {
    var value = lodash.find($scope.feeLevels[$scope.network], {
      level: 'urgent'
    });
    return parseInt((value.feePerKb / 1000).toFixed());
  };

  $scope.ok = function() {
    $scope.customFeePerKB = $scope.customFeePerKB ? ($scope.customSatPerByte.value * 1000).toFixed() : null;
    $scope.hideModal($scope.feeLevel, $scope.customFeePerKB);
  };

  $scope.setFeesRecommended = function() {
    $scope.maxFeeRecommended = getMaxRecommended();
    $scope.minFeeRecommended = getMinRecommended();
    $scope.minFeeAllowed = FEE_MIN;
    $scope.maxFeeAllowed = $scope.maxFeeRecommended * FEE_MULTIPLIER;
  };

  $scope.checkFees = function(feePerSatByte) {
    var fee = Number(feePerSatByte);

    if (fee <= $scope.minFeeAllowed) $scope.showError = true;
    else $scope.showError = false;

    if (fee > $scope.minFeeAllowed && fee < $scope.minFeeRecommended) $scope.showMinWarning = true;
    else $scope.showMinWarning = false;

    if (fee < $scope.maxFeeAllowed && fee > $scope.maxFeeRecommended) $scope.showMaxWarning = true;
    else $scope.showMaxWarning = false;
  };

  $scope.updateFeeRate = function() {
    var value = lodash.find($scope.feeLevels[$scope.network], {
      level: $scope.feeLevel
    });

    // If no custom fee
    if (value) {
      $scope.customFeePerKB = null;
      $scope.feePerSatByte = (value.feePerKb / 1000).toFixed();
      $scope.avgConfirmationTime = value.nbBlocks * 10;
    } else {
      $scope.avgConfirmationTime = null;
      $scope.customSatPerByte = { value: Number($scope.feePerSatByte) };
      $scope.customFeePerKB = ($scope.feePerSatByte * 1000).toFixed();
    }

    // Warnings
    $scope.setFeesRecommended();
    $scope.checkFees($scope.feePerSatByte);

    $timeout(function() {
      $scope.$apply();
    });
  };

  $scope.$watch(
    "selectedFee.value",
    function ( newValue, oldValue ) {
      if (newValue != oldValue) {
        $log.debug('New fee level: ' + newValue);
        $scope.feeLevel = $scope.selectedFee.value;
        $scope.updateFeeRate();
      }
    }
  );

  // From parent controller
  // $scope.network
  // $scope.feeLevel
  //
  // IF usingCustomFee
  // $scope.customFeePerKB
  // $scope.feePerSatByte

  if (lodash.isEmpty($scope.feeLevel)) showErrorAndClose(null, gettextCatalog.getString('Fee level is not defined') );
  $scope.selectedFee = { value: $scope.feeLevel };

  $scope.feeOpts = feeService.feeOpts;
  $scope.loadingFee = true;
  feeService.getFeeLevels($scope.coin, function(err, levels) {
    $scope.loadingFee = false;
    if (err || lodash.isEmpty(levels)) {
      showErrorAndClose(null, err);
      return;
    }
    if (lodash.isEmpty(levels)) {
      showErrorAndClose(null, gettextCatalog.getString('Could not get fee levels'));
      return;
    }
    $scope.feeLevels = levels;
    $scope.updateFeeRate();
  });

});

'use strict';

angular.module('copayApp.controllers').controller('glideraTxDetailsController', function($scope) {

  $scope.cancel = function() {
    $scope.glideraTxDetailsModal.hide();
  };

});

'use strict';

angular.module('copayApp.controllers').controller('mercadoLibreCardDetailsController', function($scope, mercadoLibreService, externalLinkService) {

  $scope.remove = function() {
    mercadoLibreService.savePendingGiftCard($scope.card, {
      remove: true
    }, function(err) {
      $scope.close();
    });
  };

  $scope.close = function() {
    $scope.mercadoLibreCardDetailsModal.hide();
  };

  $scope.openExternalLink = function(url) {
    externalLinkService.open(url);
  };

});

'use strict';

angular.module('copayApp.controllers').controller('pinController', function($state, $interval, $stateParams, $ionicHistory, $timeout, $scope, $log, configService, appConfigService, applicationService) {
  var ATTEMPT_LIMIT = 3;
  var ATTEMPT_LOCK_OUT_TIME = 5 * 60;
  var currentPin;
  currentPin = $scope.confirmPin = '';

  $scope.match = $scope.error = $scope.disableButtons = false;
  $scope.currentAttempts = 0;
  $scope.appName = appConfigService.name;

  configService.whenAvailable(function(config) {
    if (!config.lock) return;
    $scope.bannedUntil = config.lock.bannedUntil || null;
    if ($scope.bannedUntil) {
      var now = Math.floor(Date.now() / 1000);
      if (now < $scope.bannedUntil) {
        $scope.error = $scope.disableButtons = true;
        lockTimeControl($scope.bannedUntil);
      }
    }
  });

  function getSavedMethod() {
    var config = configService.getSync();
    if (config.lock) return config.lock.method;
    return 'none';
  };

  function checkAttempts() {
    $scope.currentAttempts += 1;
    $log.debug('Attempts to unlock:', $scope.currentAttempts);
    if ($scope.currentAttempts === ATTEMPT_LIMIT) {
      $scope.currentAttempts = 0;
      var bannedUntil = Math.floor(Date.now() / 1000) + ATTEMPT_LOCK_OUT_TIME;
      saveFailedAttempt(bannedUntil);
    }
  };

  function lockTimeControl(bannedUntil) {
    setExpirationTime();

    var countDown = $interval(function() {
      setExpirationTime();
    }, 1000);

    function setExpirationTime() {
      var now = Math.floor(Date.now() / 1000);
      if (now > bannedUntil) {
        if (countDown) reset();
      } else {
        $scope.disableButtons = true;
        var totalSecs = bannedUntil - now;
        var m = Math.floor(totalSecs / 60);
        var s = totalSecs % 60;
        $scope.expires = ('0' + m).slice(-2) + ":" + ('0' + s).slice(-2);
      }
    };

    function reset() {
      $scope.expires = $scope.error = $scope.disableButtons = null;
      currentPin = $scope.confirmPin = '';
      $interval.cancel(countDown);
      $timeout(function() {
        $scope.$apply();
      });
      return;
    };
  };

  $scope.getFilledClass = function(limit) {
    return currentPin.length >= limit ? 'filled-' + $scope.appName : null;
  };

  $scope.delete = function() {
    if ($scope.disableButtons) return;
    if (currentPin.length > 0) {
      currentPin = currentPin.substring(0, currentPin.length - 1);
      $scope.error = false;
      $scope.updatePin();
    }
  };

  $scope.isComplete = function() {
    if (currentPin.length < 4) return false;
    else return true;
  };

  $scope.updatePin = function(value) {
    if ($scope.disableButtons) return;
    $scope.error = false;
    if (value && !$scope.isComplete()) {
      currentPin = currentPin + value;
      $timeout(function() {
        $scope.$apply();
      });
    }
    $scope.save();
  };

  function isMatch(pin) {
    var config = configService.getSync();
    return config.lock.value == pin;
  };

  $scope.save = function() {
    if (!$scope.isComplete()) return;
    var savedMethod = getSavedMethod();

    switch ($scope.action) {
      case 'setup':
        applyAndCheckPin();
        break;
      case 'disable':
        if (isMatch(currentPin)) {
          deletePin();
        } else {
          showError();
          checkAttempts();
        }
        break;
      case 'check':
        if (isMatch(currentPin)) {
          $scope.hideModal();
          return;
        }
        showError();
        checkAttempts();
        break;
    }
  };

  function showError() {
    $timeout(function() {
      $scope.confirmPin = currentPin = '';
      $scope.error = true;
    }, 200);

    $timeout(function() {
      $scope.$apply();
    });
  };

  function applyAndCheckPin() {
    if (!$scope.confirmPin) {
      $timeout(function() {
        $scope.confirmPin = currentPin;
        currentPin = '';
      }, 200);
    } else {
      if ($scope.confirmPin == currentPin)
        savePin($scope.confirmPin);
      else {
        $scope.confirmPin = currentPin = '';
        $scope.error = true;
      }
    }
    $timeout(function() {
      $scope.$apply();
    });
  };

  function deletePin() {
    var opts = {
      lock: {
        method: 'none',
        value: null,
        bannedUntil: null,
      }
    };

    configService.set(opts, function(err) {
      if (err) $log.debug(err);
      $scope.hideModal();
    });
  };

  function savePin(value) {
    var opts = {
      lock: {
        method: 'pin',
        value: value,
        bannedUntil: null,
      }
    };

    configService.set(opts, function(err) {
      if (err) $log.debug(err);
      $scope.hideModal();
    });
  };

  function saveFailedAttempt(bannedUntil) {
    var opts = {
      lock: {
        bannedUntil: bannedUntil,
      }
    };

    configService.set(opts, function(err) {
      if (err) $log.debug(err);
      lockTimeControl(bannedUntil);
    });
  };

});

'use strict';

angular.module('copayApp.controllers').controller('searchController', function($scope, $interval, $timeout, $filter, $log, $ionicModal, $ionicPopover, $state, $stateParams, $ionicScrollDelegate, bwcError, profileService, lodash, configService, gettext, gettextCatalog, platformInfo, walletService) {

  var HISTORY_SHOW_LIMIT = 10;
  var currentTxHistoryPage = 0;
  var wallet;
  var isCordova = platformInfo.isCordova;

  $scope.updateSearchInput = function(search) {
    if (isCordova)
      window.plugins.toast.hide();
    currentTxHistoryPage = 0;
    throttleSearch(search);
    $timeout(function() {
      $ionicScrollDelegate.resize();
    }, 10);
  }

  var throttleSearch = lodash.throttle(function(search) {

    function filter(search) {
      $scope.filteredTxHistory = [];

      function computeSearchableString(tx) {
        var addrbook = '';
        if (tx.addressTo && $scope.addressbook && $scope.addressbook[tx.addressTo]) addrbook = $scope.addressbook[tx.addressTo].name || $scope.addressbook[tx.addressTo] || '';
        var searchableDate = computeSearchableDate(new Date(tx.time * 1000));
        var message = tx.message ? tx.message : '';
        var comment = tx.note ? tx.note.body : '';
        var addressTo = tx.addressTo ? tx.addressTo : '';
        var txid = tx.txid ? tx.txid : '';
        return ((tx.amountStr + message + addressTo + addrbook + searchableDate + comment + txid).toString()).toLowerCase();
      }

      function computeSearchableDate(date) {
        var day = ('0' + date.getDate()).slice(-2).toString();
        var month = ('0' + (date.getMonth() + 1)).slice(-2).toString();
        var year = date.getFullYear();
        return [month, day, year].join('/');
      };

      if (lodash.isEmpty(search)) {
        $scope.txHistoryShowMore = false;
        return [];
      }

      $scope.filteredTxHistory = lodash.filter($scope.completeTxHistory, function(tx) {
        if (!tx.searcheableString) tx.searcheableString = computeSearchableString(tx);
        return lodash.includes(tx.searcheableString, search.toLowerCase());
      });

      if ($scope.filteredTxHistory.length > HISTORY_SHOW_LIMIT) $scope.txHistoryShowMore = true;
      else $scope.txHistoryShowMore = false;
      return $scope.filteredTxHistory;
    };

    $scope.txHistorySearchResults = filter(search).slice(0, HISTORY_SHOW_LIMIT);

    if (isCordova)
      window.plugins.toast.showShortBottom(gettextCatalog.getString('Matches: ' + $scope.filteredTxHistory.length));

    $timeout(function() {
      $scope.$apply();
    });

  }, 1000);

  $scope.moreSearchResults = function() {
    currentTxHistoryPage++;
    $scope.showHistory();
    $scope.$broadcast('scroll.infiniteScrollComplete');
  };

  $scope.showHistory = function() {
    $scope.txHistorySearchResults = $scope.filteredTxHistory ? $scope.filteredTxHistory.slice(0, (currentTxHistoryPage + 1) * HISTORY_SHOW_LIMIT) : [];
    $scope.txHistoryShowMore = $scope.filteredTxHistory.length > $scope.txHistorySearchResults.length;
  };

});

'use strict';

angular.module('copayApp.controllers').controller('txpDetailsController', function($scope, $rootScope, $timeout, $interval, $log, ongoingProcess, platformInfo, $ionicScrollDelegate, txFormatService, bwcError, gettextCatalog, lodash, walletService, popupService, $ionicHistory, feeService) {
  var isGlidera = $scope.isGlidera;
  var GLIDERA_LOCK_TIME = 6 * 60 * 60;
  var now = Math.floor(Date.now() / 1000);
  var countDown;

  $scope.init = function() {
    $scope.loading = null;
    $scope.isCordova = platformInfo.isCordova;
    $scope.isWindowsPhoneApp = platformInfo.isCordova && platformInfo.isWP;
    $scope.copayers = $scope.wallet.status.wallet.copayers;
    $scope.copayerId = $scope.wallet.credentials.copayerId;
    $scope.isShared = $scope.wallet.credentials.n > 1;
    $scope.canSign = $scope.wallet.canSign() || $scope.wallet.isPrivKeyExternal();
    $scope.color = $scope.wallet.color;
    $scope.data = {};
    displayFeeValues();
    initActionList();
    checkPaypro();
    applyButtonText();
  };

  function displayFeeValues() {
    txFormatService.formatAlternativeStr($scope.wallet.coin, $scope.tx.fee, function(v) {
      $scope.tx.feeFiatStr = v;
    });
    $scope.tx.feeRateStr = ($scope.tx.fee / ($scope.tx.amount + $scope.tx.fee) * 100).toFixed(2) + '%';
    $scope.tx.feeLevelStr = feeService.feeOpts[$scope.tx.feeLevel];
  };

  function applyButtonText() {
    var lastSigner = lodash.filter($scope.tx.actions, {
      type: 'accept'
    }).length == $scope.tx.requiredSignatures - 1;

    if (lastSigner) {
      if ($scope.isCordova && !$scope.isWindowsPhoneApp) {
        $scope.buttonText = gettextCatalog.getString('Slide to send');
      } else {
        $scope.buttonText = gettextCatalog.getString('Click to send');
      }
      $scope.successText = gettextCatalog.getString('Payment Sent');
    } else {
      if ($scope.isCordova && !$scope.isWindowsPhoneApp) {
        $scope.buttonText = gettextCatalog.getString('Slide to accept');
      } else {
        $scope.buttonText = gettextCatalog.getString('Click to accept');
      }
      $scope.successText = gettextCatalog.getString('Payment Accepted');
    }
  };

  function initActionList() {
    $scope.actionList = [];

    if (!$scope.isShared) return;

    var actionDescriptions = {
      created: gettextCatalog.getString('Proposal Created'),
      accept: gettextCatalog.getString('Accepted'),
      reject: gettextCatalog.getString('Rejected'),
      broadcasted: gettextCatalog.getString('Broadcasted'),
    };

    $scope.actionList.push({
      type: 'created',
      time: $scope.tx.createdOn,
      description: actionDescriptions['created'],
      by: $scope.tx.creatorName
    });

    lodash.each($scope.tx.actions, function(action) {
      $scope.actionList.push({
        type: action.type,
        time: action.createdOn,
        description: actionDescriptions[action.type],
        by: action.copayerName
      });
    });

    $timeout(function() {
      $scope.actionList.reverse();
    }, 10);
  };

  function checkPaypro() {
    if ($scope.tx.payProUrl && !platformInfo.isChromeApp) {
      $scope.wallet.fetchPayPro({
        payProUrl: $scope.tx.payProUrl,
      }, function(err, paypro) {
        if (err) return;
        $scope.tx.paypro = paypro;
        paymentTimeControl($scope.tx.paypro.expires);
        $timeout(function() {
          $ionicScrollDelegate.resize();
        }, 10);
      });
    }
  };

  function paymentTimeControl(expirationTime) {
    $scope.paymentExpired = false;
    setExpirationTime();

    countDown = $interval(function() {
      setExpirationTime();
    }, 1000);

    function setExpirationTime() {
      var now = Math.floor(Date.now() / 1000);
      if (now > expirationTime) {
        $scope.paymentExpired = true;
        if (countDown) $interval.cancel(countDown);
        return;
      }
      var totalSecs = expirationTime - now;
      var m = Math.floor(totalSecs / 60);
      var s = totalSecs % 60;
      $scope.expires = ('0' + m).slice(-2) + ":" + ('0' + s).slice(-2);
    };
  };

  $scope.$on('accepted', function(event) {
    $scope.sign();
  });

  // ToDo: use tx.customData instead of tx.message
  if ($scope.tx.message === 'Glidera transaction' && isGlidera) {
    $scope.tx.isGlidera = true;
    if ($scope.tx.canBeRemoved) {
      $scope.tx.canBeRemoved = (Date.now() / 1000 - ($scope.tx.ts || $scope.tx.createdOn)) > GLIDERA_LOCK_TIME;
    }
  }

  var setError = function(err, prefix) {
    $scope.sendStatus = '';
    $scope.loading = false;
    popupService.showAlert(gettextCatalog.getString('Error'), bwcError.msg(err, prefix));
  };

  $scope.sign = function(onSendStatusChange) {
    $scope.loading = true;
    walletService.publishAndSign($scope.wallet, $scope.tx, function(err, txp) {
      $scope.$emit('UpdateTx');
      if (err) return setError(err, gettextCatalog.getString('Could not send payment'));
      success();
    }, onSendStatusChange);
  };

  $scope.reject = function(txp) {
    var title = gettextCatalog.getString('Warning!');
    var msg = gettextCatalog.getString('Are you sure you want to reject this transaction?');
    popupService.showConfirm(title, msg, null, null, function(res) {
      if (res) {
        $scope.loading = true;

        walletService.reject($scope.wallet, $scope.tx, function(err, txpr) {
          if (err)
            return setError(err, gettextCatalog.getString('Could not reject payment'));

          $scope.close();
        });
      }
    });
  };

  $scope.remove = function() {
    var title = gettextCatalog.getString('Warning!');
    var msg = gettextCatalog.getString('Are you sure you want to remove this transaction?');
    popupService.showConfirm(title, msg, null, null, function(res) {
      if (res) {
        ongoingProcess.set('removeTx', true);
        walletService.removeTx($scope.wallet, $scope.tx, function(err) {
          ongoingProcess.set('removeTx', false);

          // Hacky: request tries to parse an empty response
          if (err && !(err.message && err.message.match(/Unexpected/))) {
            $scope.$emit('UpdateTx');
            return setError(err, gettextCatalog.getString('Could not delete payment proposal'));
          }

          $scope.close();
        });
      }
    });
  };

  $scope.broadcast = function(txp) {
    $scope.loading = true;

    $timeout(function() {
      ongoingProcess.set('broadcastingTx', true);
      walletService.broadcastTx($scope.wallet, $scope.tx, function(err, txpb) {
        ongoingProcess.set('broadcastingTx', false);

        if (err) {
          return setError(err, gettextCatalog.getString('Could not broadcast payment'));
        }

        $scope.close();
      });
    }, 10);
  };

  $scope.getShortNetworkName = function() {
    return $scope.wallet.credentials.networkName.substring(0, 4);
  };

  var updateTxInfo = function(eventName) {
    $scope.wallet.getTx($scope.tx.id, function(err, tx) {
      if (err) {
        if (err.message && err.message == 'Transaction proposal not found' &&
          (eventName == 'transactionProposalRemoved' || eventName == 'TxProposalRemoved')) {
          $scope.tx.removed = true;
          $scope.tx.canBeRemoved = false;
          $scope.tx.pendingForUs = false;
          $scope.$apply();
        }
        return;
      }

      var action = lodash.find(tx.actions, {
        copayerId: $scope.wallet.credentials.copayerId
      });

      $scope.tx = txFormatService.processTx($scope.wallet.coin, tx);

      if (!action && tx.status == 'pending')
        $scope.tx.pendingForUs = true;

      $scope.updateCopayerList();
      initActionList();
      $scope.$apply();
    });
  };

  var bwsEvent = $rootScope.$on('bwsEvent', function(e, walletId, type, n) {
    lodash.each([
        'TxProposalRejectedBy',
        'TxProposalAcceptedBy',
        'transactionProposalRemoved',
        'TxProposalRemoved',
        'NewOutgoingTx',
        'UpdateTx'
    ], function(eventName) {
      if (walletId == $scope.wallet.id && type == eventName) {
        updateTxInfo(eventName);
      }
    });
  });

  $scope.updateCopayerList = function() {
    lodash.map($scope.copayers, function(cp) {
      lodash.each($scope.tx.actions, function(ac) {
        if (cp.id == ac.copayerId) {
          cp.action = ac.type;
        }
      });
    });
  };

  function statusChangeHandler(processName, showName, isOn) {
    $log.debug('statusChangeHandler: ', processName, showName, isOn);
    if (showName) {
      $scope.sendStatus = showName;
    }
  }

  function success() {
    $scope.sendStatus = 'success';
    $scope.$digest();
  }

  $scope.statusChangeHandler = statusChangeHandler;

  $scope.onConfirm = function() {
    $scope.sign(statusChangeHandler);
  };

  $scope.onSuccessConfirm = function() {
    $ionicHistory.nextViewOptions({
      disableAnimate: true
    });
    $scope.close();
  };

  $scope.close = function() {
    bwsEvent();
    $scope.loading = null;
    $scope.txpDetailsModal.hide();
  };
});

'use strict';

angular.module('copayApp.controllers').controller('txStatusController', function($scope, $timeout) {

  if ($scope.cb) $timeout($scope.cb, 100);

  $scope.cancel = function() {
    $scope.txStatusModal.hide();
  };

});

'use strict';

angular.module('copayApp.controllers').controller('walletsController', function($scope, $timeout, bwcError, profileService) {

  $scope.selectWallet = function(walletId) {

    var client = profileService.getClient(walletId);
    $scope.errorSelectedWallet = {};

    profileService.isReady(client, function(err) {
      if (err) {
        $scope.errorSelectedWallet[walletId] = bwcError.msg(err);
        $timeout(function() {
          $scope.$apply();
        });
        return;
      }

      $scope.$emit('walletSelected', walletId);
    });
  };

  $scope.cancel = function() {
    $scope.walletsModal.hide();
  };

});

'use strict';

angular.module('copayApp.controllers').controller('nextStepsController', function($scope, nextStepsService, $ionicScrollDelegate, $timeout) {

  $scope.hide = false;
  $scope.services = nextStepsService.get();

  $scope.toggle = function() {
    $scope.hide = !$scope.hide;
    $timeout(function() {
      $ionicScrollDelegate.resize();
      $scope.$apply();
    }, 10);
  };

});

'use strict';

angular.module('copayApp.controllers').controller('backupRequestController', function($scope, $state, $stateParams, $ionicConfig, popupService, gettextCatalog) {

  $scope.walletId = $stateParams.walletId;

  $scope.$on("$ionicView.enter", function() {
    $ionicConfig.views.swipeBackEnabled(false);
  });

  $scope.$on("$ionicView.beforeLeave", function() {
    $ionicConfig.views.swipeBackEnabled(true);
  });

  $scope.openPopup = function() {

    var title = gettextCatalog.getString('Watch out!');
    var message = gettextCatalog.getString('If this device is replaced or this app is deleted, no one can recover your funds without a backup.');
    var okText = gettextCatalog.getString('I understand');
    var cancelText = gettextCatalog.getString('Go back');
    popupService.showConfirm(title, message, okText, cancelText, function(val) {
      if (val) {
        var title = gettextCatalog.getString('Are you sure you want to skip it?');
        var message = gettextCatalog.getString('You can create a backup later from your wallet settings.');
        var okText = gettextCatalog.getString('Yes, skip');
        var cancelText = gettextCatalog.getString('Go back');
        popupService.showConfirm(title, message, okText, cancelText, function(val) {
          if (val) {
            $state.go('onboarding.disclaimer', {
              walletId: $scope.walletId,
              backedUp: false
            });
          }
        });
      }
    });
  }

});

'use strict';

angular.module('copayApp.controllers').controller('backupWarningController', function($scope, $state, $timeout, $stateParams, $ionicModal) {

  $scope.walletId = $stateParams.walletId;
  $scope.fromState = $stateParams.from == 'onboarding' ? $stateParams.from + '.backupRequest' : $stateParams.from;
  $scope.toState = $stateParams.from + '.backup';

  $scope.openPopup = function() {
    $ionicModal.fromTemplateUrl('views/includes/screenshotWarningModal.html', {
      scope: $scope,
      backdropClickToClose: true,
      hardwareBackButtonClose: true
    }).then(function(modal) {
      $scope.warningModal = modal;
      $scope.warningModal.show();
    });

    $scope.close = function() {
      $scope.warningModal.remove();
      $timeout(function() {
        $state.go($scope.toState, {
          walletId: $scope.walletId
        });
      }, 200);
    };
  }

  $scope.goBack = function() {
    $state.go($scope.fromState, {
      walletId: $scope.walletId
    });
  };

});

'use strict';

angular.module('copayApp.controllers').controller('collectEmailController', function($scope, $state, $log, $timeout, $http, $httpParamSerializer, $ionicConfig, profileService, configService, walletService, appConfigService, emailService) {

  var wallet, walletId;
  $scope.data = {};
  // Get more info: https://mashe.hawksey.info/2014/07/google-sheets-as-a-database-insert-with-apps-script-using-postget-methods-with-ajax-example/
  var URL = "https://script.google.com/macros/s/AKfycbwQXvUw6-Ix0cRLMi7hBB8dlgNTCTgwfNIQRds6RypPV7dO8evW/exec";

  var _post = function(dataSrc) {
    return {
      method: 'POST',
      url: URL,
      headers: {
        'content-type': 'application/x-www-form-urlencoded; charset=UTF-8'
      },
      data: $httpParamSerializer(dataSrc)
    };
  };

  $scope.$on("$ionicView.beforeLeave", function() {
    $ionicConfig.views.swipeBackEnabled(true);
  });

  $scope.$on("$ionicView.enter", function() {
    $ionicConfig.views.swipeBackEnabled(false);
  });

  $scope.$on("$ionicView.beforeEnter", function(event, data) {
    walletId = data.stateParams.walletId;
    wallet = profileService.getWallet(walletId);
    $scope.data.accept = true;
  });

  var collectEmail = function() {
    var dataSrc = {
      "App": appConfigService.nameCase,
      "Email": $scope.data.email,
      "Platform": ionic.Platform.platform(),
      "DeviceVersion": ionic.Platform.version()
    };

    $http(_post(dataSrc)).then(function() {
      $log.info("SUCCESS: Email collected");
    }, function(err) {
      $log.error("ERROR: Could not collect email");
    });
  };

  $scope.save = function() {
    $scope.disableButton = true;
    $timeout(function() {
      var enabled = true; // Set enabled email: true

      emailService.updateEmail({
        enabled: enabled,
        email: enabled ? $scope.data.email : null
      });
          
      if ($scope.data.accept) collectEmail();

      $timeout(function() {
        $scope.goNextView();
      }, 200);
    }, 200);
  };

  $scope.goNextView = function() {
    $state.go('onboarding.backupRequest', {
      walletId: walletId
    });
  };

  $scope.confirm = function(emailForm) {
    if (emailForm.$invalid) return;
    $scope.confirmation = true;
  };

  $scope.cancel = function() {
    $scope.confirmation = false;
    $timeout(function() {
      $scope.$digest();
    }, 1);
  };

});

'use strict';

angular.module('copayApp.controllers').controller('disclaimerController', function($scope, $timeout, $state, $log, $ionicModal, $ionicConfig, profileService, uxLanguage, externalLinkService, storageService, $stateParams, startupService, $rootScope) {

  $scope.$on("$ionicView.afterEnter", function() {
    startupService.ready();
  });

  $scope.$on("$ionicView.beforeEnter", function() {
    $scope.lang = uxLanguage.currentLanguage;
    $scope.terms = {};
    $scope.accepted = {};
    $scope.accepted.first = $scope.accepted.second = $scope.accepted.third = false;
    $scope.backedUp = $stateParams.backedUp == 'false' ? false : true;
    $scope.resume = $stateParams.resume || false;
    $scope.shrinkView = false;
  });

  $scope.$on("$ionicView.enter", function() {
    if ($scope.backedUp || $scope.resume) $ionicConfig.views.swipeBackEnabled(false);
  });

  $scope.$on("$ionicView.beforeLeave", function() {
    $ionicConfig.views.swipeBackEnabled(true);
  });

  $scope.confirm = function() {
    profileService.setDisclaimerAccepted(function(err) {
      if (err) $log.error(err);
      else {
        $state.go('tabs.home', {
          fromOnboarding: true
        });
      }
    });
  };

  $scope.openExternalLink = function(url, target) {
    externalLinkService.open(url, target);
  };

  $scope.openTerms = function() {
    $scope.shrinkView = !$scope.shrinkView;
  }

  $scope.goBack = function() {
    $state.go('onboarding.backupRequest', {
      walletId: $stateParams.walletId
    });
  }


});

'use strict';

angular.module('copayApp.controllers').controller('termsController', function($scope, $log, $state, appConfigService, uxLanguage, profileService, externalLinkService, gettextCatalog) {
  $scope.lang = uxLanguage.currentLanguage;

  $scope.confirm = function() {
    profileService.setDisclaimerAccepted(function(err) {
      if (err) $log.error(err);
      else {
        $state.go('tabs.home', {
          fromOnboarding: true
        });
      }
    });
  };

  $scope.openExternalLink = function() {
    var url = appConfigService.disclaimerUrl;
    var optIn = true;
    var title = gettextCatalog.getString('View Terms of Service');
    var message = gettextCatalog.getString('The official English Terms of Service are available on the BitPay website.');
    var okText = gettextCatalog.getString('Open Website');
    var cancelText = gettextCatalog.getString('Go Back');
    externalLinkService.open(url, optIn, title, message, okText, cancelText);
  };

});

'use strict';
angular.module('copayApp.controllers').controller('tourController',
  function($scope, $state, $log, $timeout, $filter, ongoingProcess, profileService, rateService, popupService, gettextCatalog) {

    $scope.data = {
      index: 0
    };

    $scope.options = {
      loop: false,
      effect: 'flip',
      speed: 500,
      spaceBetween: 100
    }

    $scope.$on("$ionicSlides.sliderInitialized", function(event, data) {
      $scope.slider = data.slider;
    });

    $scope.$on("$ionicSlides.slideChangeStart", function(event, data) {
      $scope.data.index = data.slider.activeIndex;
    });

    $scope.$on("$ionicSlides.slideChangeEnd", function(event, data) {});

    $scope.$on("$ionicView.enter", function(event, data) {
      rateService.whenAvailable(function() {
        var localCurrency = 'USD';
        var btczAmount = 1;
        var rate = rateService.toFiat(btczAmount * 1e8, localCurrency, 'btcz');
        $scope.localCurrencySymbol = '$';
        $scope.localCurrencyPerBtc = $filter('formatFiatAmount')(parseFloat(rate.toFixed(2), 10));
        $timeout(function() {
          $scope.$apply();
        })
      });
    });

    var retryCount = 0;
    $scope.createDefaultWallet = function() {
      ongoingProcess.set('creatingWallet', true);
      $timeout(function() {
        profileService.createDefaultWallet(function(err, walletClient) {
          if (err) {
            $log.warn(err);

            return $timeout(function() {
              $log.warn('Retrying to create default wallet.....:' + ++retryCount);
              if (retryCount > 3) {
                ongoingProcess.set('creatingWallet', false);
                popupService.showAlert(
                  gettextCatalog.getString('Cannot Create Wallet'), err,
                  function() {
                    retryCount = 0;
                    return $scope.createDefaultWallet();
                  }, gettextCatalog.getString('Retry'));
              } else {
                return $scope.createDefaultWallet();
              }
            }, 2000);
          };
          ongoingProcess.set('creatingWallet', false);
          var wallet = walletClient;
          var walletId = wallet.credentials.walletId;

          $state.go('onboarding.collectEmail', {
            walletId: walletId
          });

            /*
          $state.go('onboarding.backupRequest', {
            walletId: walletId
          });
            */
        });
      }, 300);
    };

    $scope.goBack = function() {
      if ($scope.data.index != 0) $scope.slider.slidePrev();
      else $state.go('onboarding.welcome');
    }

    $scope.slideNext = function() {
      if ($scope.data.index != 2) $scope.slider.slideNext();
      else $state.go('onboarding.welcome');
    }
  });

'use strict';

angular.module('copayApp.controllers').controller('welcomeController', function($scope, $state, $timeout, $ionicConfig, $log, profileService, startupService, storageService) {

  $scope.$on("$ionicView.afterEnter", function() {
    startupService.ready();
  });

  $scope.$on("$ionicView.enter", function() {
    $ionicConfig.views.swipeBackEnabled(false);
  });

  $scope.$on("$ionicView.beforeLeave", function() {
    $ionicConfig.views.swipeBackEnabled(true);
  });

  $scope.createProfile = function() {
    $log.debug('Creating profile');
    profileService.createProfile(function(err) {
      if (err) $log.warn(err);
    });
  };

});

angular.module('copayApp.controllers').controller('paperWalletController',
  function($scope, $timeout, $log, $ionicModal, $ionicHistory, feeService, popupService, gettextCatalog, platformInfo, configService, profileService, $state, bitcore, ongoingProcess, txFormatService, $stateParams, walletService) {

    function _scanFunds(cb) {
      function getPrivateKey(scannedKey, isPkEncrypted, passphrase, cb) {
        if (!isPkEncrypted) return cb(null, scannedKey);
        $scope.wallet.decryptBIP38PrivateKey(scannedKey, passphrase, null, cb);
      };

      function getBalance(privateKey, cb) {
        $scope.wallet.getBalanceFromPrivateKey(privateKey, cb);
      };

      function checkPrivateKey(privateKey) {
        try {
          new bitcore.PrivateKey(privateKey, 'livenet');
        } catch (err) {
          return false;
        }
        return true;
      };

      getPrivateKey($scope.scannedKey, $scope.isPkEncrypted, $scope.passphrase, function(err, privateKey) {
        if (err) return cb(err);
        if (!checkPrivateKey(privateKey)) return cb(new Error('Invalid private key'));

        getBalance(privateKey, function(err, balance) {
          if (err) return cb(err);
          return cb(null, privateKey, balance);
        });
      });
    };

    $scope.scanFunds = function() {
      ongoingProcess.set('scanning', true);
      $timeout(function() {
        _scanFunds(function(err, privateKey, balance) {
          ongoingProcess.set('scanning', false);
          if (err) {
            $log.error(err);
            popupService.showAlert(gettextCatalog.getString('Error scanning funds:'), err || err.toString());
            $state.go('tabs.home');
          } else {
            $scope.privateKey = privateKey;
            $scope.balanceSat = balance;
            if ($scope.balanceSat <= 0)
              popupService.showAlert(gettextCatalog.getString('Error'), gettextCatalog.getString('Not funds found'));
            $scope.balance = txFormatService.formatAmountStr($scope.wallet.coin, balance);
          }
          $scope.$apply();
        });
      }, 100);
    };

    function _sweepWallet(cb) {
      walletService.getAddress($scope.wallet, true, function(err, destinationAddress) {
        if (err) return cb(err);

        $scope.wallet.buildTxFromPrivateKey($scope.privateKey, destinationAddress, null, function(err, testTx) {
          if (err) return cb(err);
          var rawTxLength = testTx.serialize().length;
          feeService.getCurrentFeeRate('btcz', 'livenet', function(err, feePerKb) {
            var opts = {};
            opts.fee = Math.round((feePerKb * rawTxLength) / 2000);
            $scope.wallet.buildTxFromPrivateKey($scope.privateKey, destinationAddress, opts, function(err, tx) {
              if (err) return cb(err);
              $scope.wallet.broadcastRawTx({
                rawTx: tx.serialize(),
                network: 'livenet'
              }, function(err, txid) {
                if (err) return cb(err);
                return cb(null, destinationAddress, txid);
              });
            });
          });
        });
      });
    };

    $scope.sweepWallet = function() {
      ongoingProcess.set('sweepingWallet', true);
      $scope.sending = true;

      $timeout(function() {
        _sweepWallet(function(err, destinationAddress, txid) {
          ongoingProcess.set('sweepingWallet', false);
          $scope.sending = false;
          if (err) {
            $log.error(err);
            popupService.showAlert(gettextCatalog.getString('Error sweeping wallet:'), err || err.toString());
          } else {
            $scope.sendStatus = 'success';
          }
          $scope.$apply();
        });
      }, 100);
    };

    $scope.onSuccessConfirm = function() {
      $state.go('tabs.home');
    };

    $scope.onWalletSelect = function(wallet) {
      $scope.wallet = wallet;
    };

    $scope.showWalletSelector = function() {
      if ($scope.singleWallet) return;
      $scope.walletSelectorTitle = gettextCatalog.getString('Transfer to');
      $scope.showWallets = true;
    };

    $scope.$on("$ionicView.beforeEnter", function(event, data) {
      $scope.scannedKey = (data.stateParams && data.stateParams.privateKey) ? data.stateParams.privateKey : null;
      $scope.isPkEncrypted = $scope.scannedKey ? ($scope.scannedKey.substring(0, 2) == '6P') : null;
      $scope.sendStatus = null;
      $scope.error = false;

      $scope.wallets = profileService.getWallets({
        onlyComplete: true,
        network: 'livenet',
      });
      $scope.singleWallet = $scope.wallets.length == 1;

      if (!$scope.wallets || !$scope.wallets.length) {
        $scope.noMatchingWallet = true;
        return;
      }
    });

    $scope.$on("$ionicView.enter", function(event, data) {
      $scope.wallet = $scope.wallets[0];
      if (!$scope.wallet) return;
      if (!$scope.isPkEncrypted) $scope.scanFunds();
      else {
        var message = gettextCatalog.getString('Private key encrypted. Enter password');
        popupService.showPrompt(null, message, null, function(res) {
          $scope.passphrase = res;
          $scope.scanFunds();
        });
      }
    });

  });

'use strict';
angular.module('copayApp.controllers').controller('paymentUriController',
  function($rootScope, $scope, $stateParams, $location, $timeout, $ionicHistory, profileService, configService, lodash, bitcore, $state) {
    function strip(number) {
      return (parseFloat(number.toPrecision(12)));
    };

    // Build bitcoinURI with querystring
    this.init = function() {
      var query = [];
      this.bitcoinURI = $stateParams.url;

      var URI = bitcore.URI;
      var isUriValid = URI.isValid(this.bitcoinURI);
      if (!URI.isValid(this.bitcoinURI)) {
        this.error = true;
        return;
      }
      var uri = new URI(this.bitcoinURI);

      if (uri && uri.address) {
        var config = configService.getSync().wallet.settings;
        var unitToSatoshi = config.unitToSatoshi;
        var satToUnit = 1 / unitToSatoshi;
        var unitName = config.unitName;

        if (uri.amount) {
          uri.amount = strip(uri.amount * satToUnit) + ' ' + unitName;
        }
        uri.network = uri.address.network.name;
        this.uri = uri;
      }
    };

    this.getWallets = function(network) {

      $scope.wallets = [];
      lodash.forEach(profileService.getWallets(network), function(w) {
        var client = profileService.getClient(w.id);
        profileService.isReady(client, function(err) {
          if (err) return;
          $scope.wallets.push(w);
        })
      });
    };

    this.selectWallet = function(wid) {
      var self = this;
      profileService.setAndStoreFocus(wid, function() {});
      $ionicHistory.removeBackView();
      $state.go('tabs.home');
      $timeout(function() {
        $rootScope.$emit('paymentUri', self.bitcoinURI);
      }, 1000);
    };
  });

'use strict';

angular.module('copayApp.controllers').controller('preferencesController',
  function($scope, $rootScope, $timeout, $log, $ionicHistory, configService, profileService, fingerprintService, walletService, platformInfo, externalLinkService, gettextCatalog) {
    var wallet;
    var walletId;

    $scope.hiddenBalanceChange = function() {
      var opts = {
        balance: {
          enabled: $scope.hiddenBalance.value
        }
      };
      profileService.toggleHideBalanceFlag(walletId, function(err) {
        if (err) $log.error(err);
      });
    };

    $scope.encryptChange = function() {
      if (!wallet) return;
      var val = $scope.encryptEnabled.value;

      if (val && !walletService.isEncrypted(wallet)) {
        $log.debug('Encrypting private key for', wallet.name);
        walletService.encrypt(wallet, function(err) {
          if (err) {
            $log.warn(err);

            // ToDo show error?
            $scope.encryptEnabled.value = false;
            $timeout(function() {
              $scope.$apply();
            });
            return;
          }
          profileService.updateCredentials(JSON.parse(wallet.export()), function() {
            $log.debug('Wallet encrypted');
            return;
          });
        })
      } else if (!val && walletService.isEncrypted(wallet)) {
        walletService.decrypt(wallet, function(err) {
          if (err) {
            $log.warn(err);

            // ToDo show error?
            $scope.encryptEnabled.value = true;
            $timeout(function() {
              $scope.$apply();
            });
            return;
          }
          profileService.updateCredentials(JSON.parse(wallet.export()), function() {
            $log.debug('Wallet decrypted');
            return;
          });
        })
      }
    };

    $scope.openWikiSpendingPassword = function() {
      var url = 'https://github.com/bitpay/copay/wiki/COPAY---FAQ#what-the-spending-password-does';
      var optIn = true;
      var title = null;
      var message = gettextCatalog.getString('Read more in our Wiki');
      var okText = gettextCatalog.getString('Open');
      var cancelText = gettextCatalog.getString('Go Back');
      externalLinkService.open(url, optIn, title, message, okText, cancelText);
    };

    $scope.touchIdChange = function() {
      var newStatus = $scope.touchIdEnabled.value;
      walletService.setTouchId(wallet, !!newStatus, function(err) {
        if (err) {
          $scope.touchIdEnabled.value = !newStatus;
          $timeout(function() {
            $scope.$apply();
          }, 1);
          return;
        }
        $log.debug('Touch Id status changed: ' + newStatus);
      });
    };

    $scope.$on("$ionicView.beforeEnter", function(event, data) {
      wallet = profileService.getWallet(data.stateParams.walletId);
      walletId = wallet.credentials.walletId;
      $scope.wallet = wallet;
      $scope.isWindowsPhoneApp = platformInfo.isCordova && platformInfo.isWP;
      $scope.externalSource = null;

      if (!wallet)
        return $ionicHistory.goBack();

      var config = configService.getSync();

      $scope.hiddenBalance = {
        value: $scope.wallet.balanceHidden
      };

      $scope.encryptEnabled = {
        value: walletService.isEncrypted(wallet)
      };

      $scope.touchIdAvailable = fingerprintService.isAvailable();
      $scope.touchIdEnabled = {
        value: config.touchIdFor ? config.touchIdFor[walletId] : null
      };

      $scope.deleted = false;
      if (wallet.credentials && !wallet.credentials.mnemonicEncrypted && !wallet.credentials.mnemonic) {
        $scope.deleted = true;
      }
    });
  });

'use strict';

angular.module('copayApp.controllers').controller('preferencesAbout',
  function($scope, $window, appConfigService, gettextCatalog, externalLinkService) {

    $scope.title = gettextCatalog.getString('About') + ' ' + appConfigService.nameCase;
    $scope.version = $window.version;
    $scope.commitHash = $window.commitHash;

    $scope.openExternalLink = function() {
      var url = 'https://github.com/bitpay/' + appConfigService.gitHubRepoName + '/tree/' + $window.commitHash + '';
      var optIn = true;
      var title = gettextCatalog.getString('Open GitHub Project');
      var message = gettextCatalog.getString('You can see the latest developments and contribute to this open source app by visiting our project on GitHub.');
      var okText = gettextCatalog.getString('Open GitHub');
      var cancelText = gettextCatalog.getString('Go Back');
      externalLinkService.open(url, optIn, title, message, okText, cancelText);
    };
  });

'use strict';

angular.module('copayApp.controllers').controller('preferencesAdvancedController', function($scope, $timeout, $state, $stateParams, profileService) {
  var wallet = profileService.getWallet($stateParams.walletId);
  $scope.network = wallet.network;
  $scope.wallet = wallet;

  $scope.goToAddresses = function() {
    $state.go('tabs.settings.addresses', {
      walletId: $stateParams.walletId,
    });
  };

  $timeout(function() {
    $scope.$apply();
  }, 1);
});

'use strict';

angular.module('copayApp.controllers').controller('preferencesAliasController',
  function($scope, $timeout, $stateParams, $ionicHistory, configService, profileService, walletService) {
    var wallet = profileService.getWallet($stateParams.walletId);
    var walletId = wallet.credentials.walletId;
    var config = configService.getSync();

    $scope.walletName = wallet.credentials.walletName;
    $scope.walletAlias = config.aliasFor && config.aliasFor[walletId] ? config.aliasFor[walletId] : wallet.credentials.walletName;
    $scope.alias = {
      value: $scope.walletAlias
    };

    $scope.save = function() {
      var opts = {
        aliasFor: {}
      };

      opts.aliasFor[walletId] = $scope.alias.value;

      configService.set(opts, function(err) {
        if (err) $log.warn(err);
        $ionicHistory.goBack();
      });
    };
  });

'use strict';

angular.module('copayApp.controllers').controller('preferencesAltCurrencyController',
  function($scope, $log, $timeout, $ionicHistory, configService, rateService, lodash, profileService, walletService, storageService) {

    var next = 10;
    var completeAlternativeList = [];

    function init() {
      var unusedCurrencyList = [{
        isoCode: 'LTL'
      }, {
        isoCode: 'BTCZ'
      }];
      rateService.whenAvailable(function() {

        $scope.listComplete = false;

        var idx = lodash.indexBy(unusedCurrencyList, 'isoCode');
        var idx2 = lodash.indexBy($scope.lastUsedAltCurrencyList, 'isoCode');

        completeAlternativeList = lodash.reject(rateService.listAlternatives(true), function(c) {
          return idx[c.isoCode] || idx2[c.isoCode];
        });

        $scope.altCurrencyList = completeAlternativeList.slice(0, 10);

        $timeout(function() {
          $scope.$apply();
        });
      });
    }

    $scope.loadMore = function() {
      $timeout(function() {
        $scope.altCurrencyList = completeAlternativeList.slice(0, next);
        next += 10;
        $scope.listComplete = $scope.altCurrencyList.length >= completeAlternativeList.length;
        $scope.$broadcast('scroll.infiniteScrollComplete');
      }, 100);
    };

    $scope.findCurrency = function(search) {
      if (!search) init();
      $scope.altCurrencyList = lodash.filter(completeAlternativeList, function(item) {
        var val = item.name
        var val2 = item.isoCode;
        return lodash.includes(val.toLowerCase(), search.toLowerCase()) || lodash.includes(val2.toLowerCase(), search.toLowerCase());
      });
      $timeout(function() {
        $scope.$apply();
      });
    };

    $scope.save = function(newAltCurrency) {
      var opts = {
        wallet: {
          settings: {
            alternativeName: newAltCurrency.name,
            alternativeIsoCode: newAltCurrency.isoCode,
          }
        }
      };

      configService.set(opts, function(err) {
        if (err) $log.warn(err);

        $ionicHistory.goBack();
        saveLastUsed(newAltCurrency);
        walletService.updateRemotePreferences(profileService.getWallets());
      });
    };

    function saveLastUsed(newAltCurrency) {
      $scope.lastUsedAltCurrencyList.unshift(newAltCurrency);
      $scope.lastUsedAltCurrencyList = lodash.uniq($scope.lastUsedAltCurrencyList, 'isoCode');
      $scope.lastUsedAltCurrencyList = $scope.lastUsedAltCurrencyList.slice(0, 3);
      storageService.setLastCurrencyUsed(JSON.stringify($scope.lastUsedAltCurrencyList), function() {});
    };

    $scope.$on("$ionicView.beforeEnter", function(event, data) {
      var config = configService.getSync();
      $scope.currentCurrency = config.wallet.settings.alternativeIsoCode;

      storageService.getLastCurrencyUsed(function(err, lastUsedAltCurrency) {
        $scope.lastUsedAltCurrencyList = lastUsedAltCurrency ? JSON.parse(lastUsedAltCurrency) : [];
        init();
      });
    });
  });

'use strict';

angular.module('copayApp.controllers').controller('preferencesBitpayCardController',
  function($scope, $state, $timeout, $ionicHistory, bitpayCardService, popupService, gettextCatalog, $log) {

    $scope.remove = function(card) {
      var msg = gettextCatalog.getString('Are you sure you would like to remove your BitPay Card ({{lastFourDigits}}) from this device?', {
        lastFourDigits: card.lastFourDigits
      });
      popupService.showConfirm(null, msg, null, null, function(res) {
        $log.info('Removing bitpay card:' + card.eid)
        if (res) 
          remove(card.eid);
      });
    };

    var remove = function(cardEid) {
      bitpayCardService.remove(cardEid, function(err) {
        if (err) {
          return popupService.showAlert(gettextCatalog.getString('Error'), gettextCatalog.getString('Could not remove card'));
        }
        $ionicHistory.clearHistory();
        $timeout(function() {
          $state.go('tabs.home');
        }, 100);
      });
    };

    $scope.$on("$ionicView.beforeEnter", function(event, data) {
      bitpayCardService.getCards(function(err, data) {
        if (err) return;

        $scope.bitpayCards = data;
      });
    });

  });

'use strict';

angular.module('copayApp.controllers').controller('preferencesBitpayServicesController',
  function($rootScope, $scope, $state, $timeout, $ionicHistory, bitpayAccountService, bitpayCardService, popupService, gettextCatalog) {

    $scope.removeAccount = function(account) {
      var title = gettextCatalog.getString('Remove BitPay Account?');
      var msg = gettextCatalog.getString('Removing your BitPay account will remove all associated BitPay account data from this device. Are you sure you would like to remove your BitPay Account ({{email}}) from this device?', {
        email: account.email
      });
      popupService.showConfirm(title, msg, null, null, function(res) {
        if (res) {
          removeAccount(account);
        }
      });
    };

    $scope.removeCard = function(card) {
      var title = gettextCatalog.getString('Remove BitPay Card?');
      var msg = gettextCatalog.getString('Are you sure you would like to remove your BitPay Card ({{lastFourDigits}}) from this device?', {
        lastFourDigits: card.lastFourDigits
      });
      popupService.showConfirm(title, msg, null, null, function(res) {
        if (res) {
          removeCard(card);
        }
      });
    };

    var removeAccount = function(account) {
      bitpayAccountService.removeAccount(account, function(err) {
        if (err) {
          return popupService.showAlert(gettextCatalog.getString('Error'), gettextCatalog.getString('Could not remove account'));
        }
        setScope(function() {
          // If there are no paired accounts then change views.
          if ($scope.bitpayAccounts.length == 0) {
            $state.go('tabs.settings').then(function() {
              $ionicHistory.clearHistory();
              $state.go('tabs.home');
            });
          }
        });
      });
    };

    var removeCard = function(card) {
      bitpayCardService.remove(card.id, function(err) {
        if (err) {
          return popupService.showAlert(gettextCatalog.getString('Error'), gettextCatalog.getString('Could not remove card'));
        }
        setScope();
      });
    };

    var setScope = function(cb) {
      bitpayAccountService.getAccounts(function(err, accounts) {
        if (err) return;
        $scope.bitpayAccounts = accounts;

        bitpayCardService.getCards(function(err, cards) {
          if (err) return;
          $scope.bitpayCards = cards;
          if (cb) {
            cb();
          }
          $timeout(function(){
            $rootScope.$apply();
          }, 10);
        });
      });
    };

    $scope.$on("$ionicView.beforeEnter", function(event, data) {
      setScope();
    });

  });

'use strict';

angular.module('copayApp.controllers').controller('preferencesBwsUrlController',
  function($scope, $log, $stateParams, configService, applicationService, profileService, storageService, appConfigService) {
    $scope.success = null;

    var wallet = profileService.getWallet($stateParams.walletId);
    $scope.wallet = wallet;

    var walletId = wallet.credentials.walletId;
    var defaults = configService.getDefaults();
    var config = configService.getSync();
    $scope.appName = appConfigService.nameCase;
    $scope.bwsurl = {
      value: (config.bwsFor && config.bwsFor[walletId]) || defaults.bws.url
    };

    $scope.resetDefaultUrl = function() {
      $scope.bwsurl.value = defaults.bws.url;
    };

    $scope.save = function() {

      var bws;
      switch ($scope.bwsurl.value) {
        case 'prod':
        case 'production':
          bws = 'https://bws.bitcoinz.ph/bws/api'
          break;
        case 'sta':
        case 'staging':
          bws = 'https://bws.bitcoinz.ph/bws/api'
          break;
        case 'loc':
        case 'local':
          bws = 'http://localhost:3232/bws/api'
          break;
      };
      if (bws) {
        $log.info('Using BWS URL Alias to ' + bws);
        $scope.bwsurl.value = bws;
      }

      var opts = {
        bwsFor: {}
      };
      opts.bwsFor[walletId] = $scope.bwsurl.value;

      configService.set(opts, function(err) {
        if (err) $log.debug(err);
        storageService.setCleanAndScanAddresses(walletId, function() {
          applicationService.restart();
        });
      });
    };
  });

'use strict';

angular.module('copayApp.controllers').controller('preferencesCashController', function($scope, $log, $timeout, appConfigService, configService, gettextCatalog, externalLinkService) {
  var updateConfig = function() {

    var config = configService.getSync();
    $scope.appName = appConfigService.nameCase;

    $scope.cashSupport = {
      value: config.cashSupport
    };

    $timeout(function() {
      $scope.$apply();
    });
  };

  $scope.cashSupportChange = function() {
    var opts = {
      cashSupport: $scope.cashSupport.value
    };
    configService.set(opts, function(err) {
      if (err) $log.debug(err);
    });
  };


  $scope.openBitcoinCashWeb = function() {
    var url = 'https://www.bitcoincash.org/';
    var optIn = true;
    var title = null;
    var message = gettextCatalog.getString('Open bitcoincash.org?');
    var okText = gettextCatalog.getString('Open');
    var cancelText = gettextCatalog.getString('Go Back');
    externalLinkService.open(url, optIn, title, message, okText, cancelText);
  };


  $scope.$on("$ionicView.beforeEnter", function(event, data) {
    updateConfig();
  });
});

'use strict';

angular.module('copayApp.controllers').controller('preferencesCoinbaseController', function($scope, $timeout, $log, $state, $ionicHistory, lodash, ongoingProcess, popupService, coinbaseService) {

  $scope.revokeToken = function() {
    popupService.showConfirm('Coinbase', 'Are you sure you would like to log out of your Coinbase account?', null, null, function(res) {
      if (res) {
        coinbaseService.logout(function() {
          $ionicHistory.clearHistory();
          $timeout(function() {
            $state.go('tabs.home');
          }, 100);
        });
      }
    });
  };

  $scope.$on("$ionicView.enter", function(event, data){
    ongoingProcess.set('connectingCoinbase', true);
    coinbaseService.init(function(err, data) {
      if (err || lodash.isEmpty(data)) {
        ongoingProcess.set('connectingCoinbase', false);
        if (err) {
          $log.error(err);
          var errorId = err.errors ? err.errors[0].id : null;
          err = err.errors ? err.errors[0].message : err;
          popupService.showAlert('Error connecting to Coinbase', err, function() {
            if (errorId == 'revoked_token') {
              coinbaseService.logout(function() {});
              $ionicHistory.goBack();
            }
          });
        }
        return;
      }
      var accessToken = data.accessToken;
      var accountId = data.accountId;
      coinbaseService.getAccount(accessToken, accountId, function(err, account) {
        ongoingProcess.set('connectingCoinbase', false);
        $scope.coinbaseAccount = account.data;
      });
      coinbaseService.getCurrentUser(accessToken, function(err, user) {
        $scope.coinbaseUser = user.data;
      });
    });
  });

});

'use strict';

angular.module('copayApp.controllers').controller('preferencesColorController', function($scope, $timeout, $log, $stateParams, $ionicHistory, configService, profileService) {
  var wallet = profileService.getWallet($stateParams.walletId);
  $scope.wallet = wallet;
  var walletId = wallet.credentials.walletId;
  var config = configService.getSync();
  config.colorFor = config.colorFor || {};

  var retries = 3;
  $scope.colorCount = getColorCount();
  setCurrentColorIndex();

  $scope.save = function(i) {
    var color = indexToColor(i);
    if (!color) return;

    var opts = {
      colorFor: {}
    };
    opts.colorFor[walletId] = color;

    configService.set(opts, function(err) {
      if (err) $log.warn(err);
      $ionicHistory.goBack();
    });
  };

  function getColorDefault() {
    return rgb2hex(window.getComputedStyle(document.getElementsByClassName('wallet-color-default')[0]).color);
  };

  function getColorCount() {
    var count = window.getComputedStyle(document.getElementsByClassName('wallet-color-count')[0]).content;
    return parseInt(count.replace(/[^0-9]/g, ''));
  };

  function setCurrentColorIndex() {
    try {
      $scope.currentColorIndex = colorToIndex(config.colorFor[walletId] || getColorDefault());
    } catch(e) {
      // Wait for DOM to render and try again.
      $timeout(function() {
        if (retries > 0) {
          retries -= 1;
          setCurrentColorIndex();
        }
      }, 100);
    }
  };

  function colorToIndex(color) {
    for (var i = 0; i < $scope.colorCount; i++) {
      if (indexToColor(i) == color.toLowerCase()) {
        return i;
      }
    }
    return undefined;
  };

  function indexToColor(i) {
    // Expect an exception to be thrown if can't getComputedStyle().
    return rgb2hex(window.getComputedStyle(document.getElementsByClassName('wallet-color-' + i)[0]).backgroundColor);
  };

  function rgb2hex(rgb) {
    rgb = rgb.match(/^rgba?[\s+]?\([\s+]?(\d+)[\s+]?,[\s+]?(\d+)[\s+]?,[\s+]?(\d+)[\s+]?/i);
    return (rgb && rgb.length === 4) ? "#" +
      ("0" + parseInt(rgb[1],10).toString(16)).slice(-2) +
      ("0" + parseInt(rgb[2],10).toString(16)).slice(-2) +
      ("0" + parseInt(rgb[3],10).toString(16)).slice(-2) : '';
  };

});

'use strict';

angular.module('copayApp.controllers').controller('preferencesDeleteWalletController',
  function($scope, $ionicHistory, gettextCatalog, lodash, profileService, $state, ongoingProcess, popupService, pushNotificationsService) {

    $scope.$on("$ionicView.beforeEnter", function(event, data) {
      if (!data.stateParams || !data.stateParams.walletId) {
        popupService.showAlert(null, gettextCatalog.getString('No wallet selected'), function() {
          $ionicHistory.goBack();
        });
        return;
      }
      $scope.wallet = profileService.getWallet(data.stateParams.walletId);
      if (!$scope.wallet) {
        popupService.showAlert(null, gettextCatalog.getString('No wallet found'), function() {
          $ionicHistory.goBack();
        });
        return;
      }
      $scope.walletName = $scope.wallet.name;
    });

    $scope.showDeletePopup = function() {
      var title = gettextCatalog.getString('Warning!');
      var message = gettextCatalog.getString('Are you sure you want to delete this wallet?');
      popupService.showConfirm(title, message, null, null, function(res) {
        if (res) deleteWallet();
      });
    };

    function deleteWallet() {
      ongoingProcess.set('deletingWallet', true);
      profileService.deleteWalletClient($scope.wallet, function(err) {
        ongoingProcess.set('deletingWallet', false);
        if (err) {
          popupService.showAlert(gettextCatalog.getString('Error'), err.message || err);
        } else {
          pushNotificationsService.unsubscribe($scope.wallet);
          $ionicHistory.nextViewOptions({
            disableAnimate: true,
            historyRoot: true
          });
          $ionicHistory.clearHistory();
          $state.go('tabs.settings').then(function() {
            $state.transitionTo('tabs.home');
          });
        }
      });
    };
  });

'use strict';

angular.module('copayApp.controllers').controller('preferencesExternalController', function($scope, $stateParams, lodash, gettextCatalog, popupService, profileService, walletService) {
  var wallet = profileService.getWallet($stateParams.walletId);

  $scope.externalSource = lodash.find(walletService.externalSource, function(source) {
    return source.id == wallet.getPrivKeyExternalSourceName();
  });

  if ($scope.externalSource.isEmbeddedHardware) {
    $scope.hardwareConnected = $scope.externalSource.version.length > 0;

    $scope.showMneumonicFromHardwarePopup = function() {
      var title = gettextCatalog.getString('Warning!');
      var message = gettextCatalog.getString('Are you being watched? Anyone with your recovery phrase can access or spend your bitcoin.');
      popupService.showConfirm(title, message, null, null, function(res) {
        if (res) {
          walletService.showMneumonicFromHardware(wallet, function(err) {
            if (err) {
              popupService.showAlert(gettextCatalog.getString('Error'), err.message || err);
            }
          });
        }
      });
    };    
  }

});
'use strict';

angular.module('copayApp.controllers').controller('preferencesFeeController', function($scope, $timeout, $ionicHistory, lodash, gettextCatalog, configService, feeService, ongoingProcess, popupService) {

  $scope.save = function(newFee) {

    $scope.currentFeeLevel = newFee;

    if ($scope.currentFeeLevel != 'custom') updateCurrentValues();
    else showCustomFeePrompt();

    if ($scope.noSave) return;

    var opts = {
      wallet: {
        settings: {
          feeLevel: newFee
        }
      }
    };

    configService.set(opts, function(err) {
      if (err) $log.debug(err);
      $timeout(function() {
        $scope.$apply();
      });
    });
  };

  $scope.$on("$ionicView.beforeEnter", function(event, data) {
    $scope.init();
  });

  $scope.init = function() {
    var coin = 'btcz'; // TODO: only BTCZ in preferences
    $scope.network = $scope.network || 'livenet';
    $scope.feeOpts = feeService.feeOpts;
    $scope.currentFeeLevel = $scope.feeLevel || feeService.getCurrentFeeLevel();
    $scope.loadingFee = true;
    feeService.getFeeLevels(coin, function(err, levels) {
      $scope.loadingFee = false;
      if (err) {
        //Error is already formatted
        popupService.showAlert(err);
        return;
      }
      $scope.feeLevels = levels;
      updateCurrentValues();
      $timeout(function() {
        $scope.$apply();
      });
    });
  };

  var updateCurrentValues = function() {
    if (lodash.isEmpty($scope.feeLevels) || lodash.isEmpty($scope.currentFeeLevel)) return;

    var value = lodash.find($scope.feeLevels[$scope.network], {
      level: $scope.currentFeeLevel
    });

    if (lodash.isEmpty(value)) {
      $scope.feePerSatByte = $scope.currentFeeLevel == 'custom' ? $scope.feePerSatByte : null;
      $scope.avgConfirmationTime = null;
      setMinWarning();
      setMaxWarning();
      return;
    }

    $scope.feePerSatByte = (value.feePerKb / 1000).toFixed();
    $scope.avgConfirmationTime = value.nbBlocks * 10;
    $scope.invalidCustomFeeEntered = false;
    setMinWarning();
    setMaxWarning();
  };

  $scope.chooseNewFee = function() {
    $scope.hideModal($scope.currentFeeLevel, $scope.customFeePerKB);
  };

  var showCustomFeePrompt = function() {
    $scope.invalidCustomFeeEntered = true;
    $scope.showMaxWarning = false;
    $scope.showMinWarning = false;
    popupService.showPrompt(gettextCatalog.getString('Custom Fee'), gettextCatalog.getString('Set your own fee in satoshis/byte'), null, function(text) {
      if (!text || !parseInt(text) || parseInt(text) <= 0) return;
      $scope.feePerSatByte = parseInt(text);
      $scope.customFeePerKB = ($scope.feePerSatByte * 1000).toFixed();
      setMaxWarning();
      setMinWarning();
      $timeout(function() {
        $scope.$apply();
      });
    });
  };

  $scope.getMinimumRecommeded = function() {
    var value = lodash.find($scope.feeLevels[$scope.network], {
      level: 'superEconomy'
    });
    return parseInt((value.feePerKb / 1000).toFixed());
  };

  var setMinWarning = function() {
    if (parseInt($scope.feePerSatByte) < $scope.getMinimumRecommeded()) $scope.showMinWarning = true;
    else $scope.showMinWarning = false;
  };

  var setMaxWarning = function() {
    if (parseInt($scope.feePerSatByte) > 1000) {
      $scope.showMaxWarning = true;
      $scope.invalidCustomFeeEntered = true;
    } else {
      $scope.showMaxWarning = false;
      $scope.invalidCustomFeeEntered = false;
    }
  };

});

'use strict';

angular.module('copayApp.controllers').controller('preferencesGlideraController',
  function($scope, $timeout, $state, $ionicHistory, glideraService, popupService) {

    $scope.revokeToken = function() {
      popupService.showConfirm('Glidera', 'Are you sure you would like to log out of your Glidera account?', null, null, function(res) {
        if (res) {
          glideraService.remove(function() {
            $ionicHistory.clearHistory();
            $timeout(function() {
              $state.go('tabs.home');
            }, 100);
          });
        }
      });
    };

    $scope.$on("$ionicView.afterEnter", function(event, data){
      glideraService.updateStatus($scope.account);
    });

    $scope.$on("$ionicView.beforeEnter", function(event, data){
      $scope.account = {};
      glideraService.init(function(err, glidera) {
        if (err || !glidera) {
          if (err) popupService.showAlert('Error connecting Glidera', err);
          return;
        }
        $scope.account['token'] = glidera.token;
        $scope.account['permissions'] = glidera.permissions;
        $scope.account['status'] = glidera.status;
      });
    });

  });

'use strict';

angular.module('copayApp.controllers').controller('preferencesHistory',
  function($scope, $log, $stateParams, $timeout, $state, $ionicHistory, storageService, platformInfo, profileService, lodash, appConfigService, walletService) {
    $scope.wallet = profileService.getWallet($stateParams.walletId);
    $scope.csvReady = false;
    $scope.isCordova = platformInfo.isCordova;
    $scope.appName = appConfigService.nameCase;


    // TODO : move this to walletService.
    $scope.csvHistory = function(cb) {
      var allTxs = [];

      function getHistory(cb) {
        storageService.getTxHistory($scope.wallet.id, function(err, txs) {
          if (err) return cb(err);

          var txsFromLocal = [];
          try {
            txsFromLocal = JSON.parse(txs);
          } catch (ex) {
            $log.warn(ex);
          }

          allTxs.push(txsFromLocal);
          return cb(null, lodash.compact(lodash.flatten(allTxs)));
        });
      };

      $log.debug('Generating CSV from History');
      getHistory(function(err, txs) {
        if (err || lodash.isEmpty(txs)) {
          if (err) {
            $log.warn('Failed to generate CSV:', err);
            $scope.err = err;
          } else {
            $log.warn('Failed to generate CSV: no transactions');
            $scope.err = 'no transactions';
          }
          if (cb) return cb(err);
          return;
        }
        $log.debug('Wallet Transaction History Length:', txs.length);

        $scope.satToUnit = 1 / $scope.unitToSatoshi;
        var data = txs;
        var satToBtc = 1 / 100000000;
        $scope.csvContent = [];
        $scope.csvFilename = $scope.appName + '-' + $scope.wallet.name + '.csv';
        $scope.csvHeader = ['Date', 'Destination', 'Description', 'Amount', 'Currency', 'Txid', 'Creator', 'Copayers', 'Comment'];

        var _amount, _note, _copayers, _creator, _comment;
        data.forEach(function(it, index) {
          var amount = it.amount;

          if (it.action == 'moved')
            amount = 0;

          _copayers = '';
          _creator = '';

          if (it.actions && it.actions.length > 1) {
            for (var i = 0; i < it.actions.length; i++) {
              _copayers += it.actions[i].copayerName + ':' + it.actions[i].type + ' - ';
            }
            _creator = (it.creatorName && it.creatorName != 'undefined') ? it.creatorName : '';
          }
          _amount = (it.action == 'sent' ? '-' : '') + (amount * satToBtc).toFixed(8);
          _note = it.message || '';
          _comment = it.note ? it.note.body : '';

          if (it.action == 'moved')
            _note += ' Moved:' + (it.amount * satToBtc).toFixed(8)

          $scope.csvContent.push({
            'Date': formatDate(it.time * 1000),
            'Destination': it.addressTo || '',
            'Description': _note,
            'Amount': _amount,
            'Currency': 'BTCZ',
            'Txid': it.txid,
            'Creator': _creator,
            'Copayers': _copayers,
            'Comment': _comment
          });

          if (it.fees && (it.action == 'moved' || it.action == 'sent')) {
            var _fee = (it.fees * satToBtc).toFixed(8)
            $scope.csvContent.push({
              'Date': formatDate(it.time * 1000),
              'Destination': 'Bitcoin Network Fees',
              'Description': '',
              'Amount': '-' + _fee,
              'Currency': 'BTCZ',
              'Txid': '',
              'Creator': '',
              'Copayers': ''
            });
          }
        });

        $scope.csvReady = true;
        $timeout(function() {
          $scope.$apply();
        }, 100);

        if (cb)
          return cb();
        return;
      });

      function formatDate(date) {
        var dateObj = new Date(date);
        if (!dateObj) {
          $log.debug('Error formating a date');
          return 'DateError'
        }
        if (!dateObj.toJSON()) {
          return '';
        }

        return dateObj.toJSON();
      };
    };

    $scope.clearTransactionHistory = function() {
      $log.info('Removing Transaction history ' + $scope.wallet.id);

      walletService.clearTxHistory($scope.wallet, function(err) {

        if (err) {
          $log.error(err);
          return;
        }

        $log.info('Transaction history cleared for :' + $scope.wallet.id);

        $ionicHistory.removeBackView();
        $state.go('tabs.home');
        $timeout(function() {
          $state.transitionTo('tabs.wallet', {
            walletId: $scope.wallet.id
          });
        }, 100);
      });
    };

    $scope.$on("$ionicView.enter", function(event, data) {
      $scope.csvHistory();
    });
  });

'use strict';

angular.module('copayApp.controllers').controller('preferencesInformation',
  function($scope, $log, $ionicHistory, platformInfo, lodash, profileService, configService, $stateParams, $state, walletService) {
    var wallet = profileService.getWallet($stateParams.walletId);
    $scope.wallet = wallet;

    var walletId = wallet.id;
    var config = configService.getSync();
    var colorCounter = 1;
    var BLACK_WALLET_COLOR = '#202020';
    $scope.isCordova = platformInfo.isCordova;
    config.colorFor = config.colorFor || {};

    $scope.saveBlack = function() {
      function save(color) {
        var opts = {
          colorFor: {}
        };
        opts.colorFor[walletId] = color;

        configService.set(opts, function(err) {
          $ionicHistory.removeBackView();
          $state.go('tabs.home');
          if (err) $log.warn(err);
        });
      };

      if (colorCounter != 5) return colorCounter++;
      save(BLACK_WALLET_COLOR);
    };

    $scope.$on("$ionicView.enter", function(event, data) {
      var c = wallet.credentials;
      var basePath = c.getBaseAddressDerivationPath();

      $scope.wallet = wallet;
      $scope.walletName = c.walletName;
      $scope.walletId = c.walletId;
      $scope.network = c.network;
      $scope.addressType = c.addressType || 'P2SH';
      $scope.derivationStrategy = c.derivationStrategy || 'BIP45';
      $scope.basePath = basePath;
      $scope.M = c.m;
      $scope.N = c.n;
      $scope.pubKeys = lodash.pluck(c.publicKeyRing, 'xPubKey');
      $scope.externalSource = null;

      if (wallet.isPrivKeyExternal()) {
        $scope.externalSource = lodash.find(walletService.externalSource, function(source) {
          return source.id == wallet.getPrivKeyExternalSourceName();
        }).name;
      }
    });

  });

'use strict';

angular.module('copayApp.controllers').controller('preferencesLanguageController',
  function($scope, $log, $ionicHistory, configService, profileService, uxLanguage, walletService, externalLinkService, gettextCatalog) {

    $scope.availableLanguages = uxLanguage.getLanguages();

    $scope.openExternalLink = function() {
      var url = 'https://crowdin.com/project/copay';
      var optIn = true;
      var title = gettextCatalog.getString('Open Translation Community');
      var message = gettextCatalog.getString('You can make contributions by signing up on our Crowdin community translation website. Were looking forward to hearing from you!');
      var okText = gettextCatalog.getString('Open Crowdin');
      var cancelText = gettextCatalog.getString('Go Back');
      externalLinkService.open(url, optIn, title, message, okText, cancelText);
    };

    $scope.save = function(newLang) {
      var opts = {
        wallet: {
          settings: {
            defaultLanguage: newLang
          }
        }
      };

      uxLanguage._set(newLang);
      configService.set(opts, function(err) {
        if (err) $log.warn(err);
        walletService.updateRemotePreferences(profileService.getWallets());
      });

      $ionicHistory.goBack();
    };

    $scope.$on("$ionicView.beforeEnter", function(event, data) {
      $scope.currentLanguage = uxLanguage.getCurrentLanguage();
    });
  });

'use strict';

angular.module('copayApp.controllers').controller('preferencesLogs',
  function($scope, historicLog, lodash, configService, gettextCatalog) {

    var config = configService.getSync();
    var logLevels = historicLog.getLevels();
    var selectedLevel;

    $scope.logOptions = lodash.indexBy(logLevels, 'level');

    var filterLogs = function(weight) {
      $scope.filteredLogs = historicLog.get(weight);
    };

    $scope.setOptionSelected = function(level) {
      var weight = $scope.logOptions[level].weight;
      $scope.fillClass = 'fill-bar-' + level;
      filterLogs(weight);
      lodash.each($scope.logOptions, function(opt) {
        opt.selected = opt.weight <= weight ? true : false;
        opt.head = opt.weight == weight;
      });

      // Save the setting.
      var opts = {
        log: {
          filter: level
        }
      };
      configService.set(opts, function(err) {
        if (err) $log.debug(err);
      });
    };

    $scope.prepareLogs = function() {
      var log = 'Copay Session Logs\n Be careful, this could contain sensitive private data\n\n';
      log += '\n\n';
      log += historicLog.get().map(function(v) {
        return '[' + v.timestamp + '][' + v.level + ']' + v.msg;
      }).join('\n');

      return log;
    };

    $scope.sendLogs = function() {
      var body = $scope.prepareLogs();

      window.plugins.socialsharing.shareViaEmail(
        body,
        'Copay Logs',
        null, // TO: must be null or an array
        null, // CC: must be null or an array
        null, // BCC: must be null or an array
        null, // FILES: can be null, a string, or an array
        function() {},
        function() {}
      );
    };

    $scope.showOptionsMenu = function() {
      $scope.showOptions = true;
    };

    $scope.$on("$ionicView.beforeEnter", function(event, data) {
      selectedLevel = lodash.has(config, 'log.filter') ? historicLog.getLevel(config.log.filter) : historicLog.getDefaultLevel();
      $scope.setOptionSelected(selectedLevel.level);
    });

    $scope.$on("$ionicView.enter", function(event, data) {
      filterLogs(selectedLevel.weight);
    });
  });

'use strict';

angular.module('copayApp.controllers').controller('preferencesNotificationsController', function($scope, $log, $timeout, appConfigService, lodash, configService, platformInfo, pushNotificationsService, emailService) {
  var updateConfig = function() {
    var config = configService.getSync();
    $scope.appName = appConfigService.nameCase;
    $scope.PNEnabledByUser = true;
    $scope.usePushNotifications = platformInfo.isCordova && !platformInfo.isWP;
    $scope.isIOSApp = platformInfo.isIOS && platformInfo.isCordova;

    $scope.pushNotifications = {
      value: config.pushNotificationsEnabled
    };

    var isConfirmedTxsNotificationsEnabled = config.confirmedTxsNotifications ? config.confirmedTxsNotifications.enabled : false;
    $scope.confirmedTxsNotifications = {
      value: isConfirmedTxsNotificationsEnabled
    };

    $scope.latestEmail = {
      value: emailService.getEmailIfEnabled()
    };

    $scope.newEmail = lodash.clone($scope.latestEmail);
    var isEmailEnabled = config.emailNotifications ? config.emailNotifications.enabled : false;

    $scope.emailNotifications = {
      value: isEmailEnabled && $scope.newEmail.value ? true : false
    };

    $timeout(function() {
      $scope.$apply();
    });
  };

  $scope.pushNotificationsChange = function() {
    if (!$scope.pushNotifications) return;
    var opts = {
      pushNotificationsEnabled: $scope.pushNotifications.value
    };
    configService.set(opts, function(err) {
      if (err) $log.debug(err);
      if (opts.pushNotificationsEnabled)
        pushNotificationsService.init();
      else
        pushNotificationsService.disable();
    });
  };

  $scope.confirmedTxsNotificationsChange = function() {
    if (!$scope.pushNotifications) return;
    var opts = {
      confirmedTxsNotifications: {
        enabled: $scope.confirmedTxsNotifications.value
      }
    };
    configService.set(opts, function(err) {
      if (err) $log.debug(err);
    });
  };

  $scope.emailNotificationsChange = function() {
    var opts = {
      enabled: $scope.emailNotifications.value,
      email: $scope.newEmail.value
    };

    $scope.latestEmail = {
      value: emailService.getEmailIfEnabled()
    };

    emailService.updateEmail(opts);
  };

  $scope.save = function() {
    emailService.updateEmail({
      enabled: $scope.emailNotifications.value,
      email: $scope.newEmail.value
    });

    $scope.latestEmail = {
      value: $scope.newEmail.value
    };

    $timeout(function() {
      $scope.$apply();
    });
  };

  $scope.$on("$ionicView.enter", function(event, data) {
    updateConfig();
  });
});

'use strict';

angular.module('copayApp.controllers').controller('proposalsController',
  function($timeout, $scope, profileService, $log, txpModalService, addressbookService, timeService) {

    $scope.fetchingProposals = true;

    $scope.$on("$ionicView.enter", function(event, data) {
      addressbookService.list(function(err, ab) {
        if (err) $log.error(err);
        $scope.addressbook = ab || {};

        profileService.getTxps(50, function(err, txps) {
          $scope.fetchingProposals = false;
          if (err) {
            $log.error(err);
            return;
          }
          $scope.txps = txps;
          $timeout(function() {
            $scope.$apply();
          });
        });
      });
    });

    $scope.openTxpModal = txpModalService.open;

    $scope.createdWithinPastDay = function(time) {
      return timeService.withinPastDay(time);
    };
  });

'use strict';

angular.module('copayApp.controllers').controller('sellCoinbaseController', function($scope, $log, $state, $timeout, $ionicHistory, $ionicScrollDelegate, $ionicConfig, lodash, coinbaseService, popupService, profileService, ongoingProcess, walletService, appConfigService, configService, txFormatService) {

  var coin = 'btcz';
  var amount;
  var currency;

  var showErrorAndBack = function(err) {
    $scope.sendStatus = '';
    $log.error(err);
    err = err.errors ? err.errors[0].message : err;
    popupService.showAlert('Error', err, function() {
      $ionicHistory.goBack();
    });
  };

  var showError = function(err) {
    $scope.sendStatus = '';
    $log.error(err);
    err = err.errors ? err.errors[0].message : err;
    popupService.showAlert('Error', err);
  };

  var publishAndSign = function (wallet, txp, onSendStatusChange, cb) {
    if (!wallet.canSign() && !wallet.isPrivKeyExternal()) {
      var err = 'No signing proposal: No private key';
      $log.info(err);
      return cb(err);
    }

    walletService.publishAndSign(wallet, txp, function(err, txp) {
      if (err) return cb(err);
      return cb(null, txp);
    }, onSendStatusChange);
  };

  var processPaymentInfo = function() {
    ongoingProcess.set('connectingCoinbase', true);
    coinbaseService.init(function(err, res) {
      if (err) {
        ongoingProcess.set('connectingCoinbase', false);
        showErrorAndBack(err);
        return;
      }
      var accessToken = res.accessToken;

      coinbaseService.sellPrice(accessToken, coinbaseService.getAvailableCurrency(), function(err, s) {
        $scope.sellPrice = s.data || null;
      });

      $scope.paymentMethods = [];
      $scope.selectedPaymentMethodId = { value : null };
      coinbaseService.getPaymentMethods(accessToken, function(err, p) {
        if (err) {
          ongoingProcess.set('connectingCoinbase', false);
          showErrorAndBack(err);
          return;
        }
        var hasPrimary;
        var pm;
        for(var i = 0; i < p.data.length; i++) {
          pm = p.data[i];
          if (pm.allow_sell) {
            $scope.paymentMethods.push(pm);
          }
          if (pm.allow_sell && pm.primary_sell) {
            hasPrimary = true;
            $scope.selectedPaymentMethodId.value = pm.id;
          }
        }
        if (lodash.isEmpty($scope.paymentMethods)) {
          ongoingProcess.set('connectingCoinbase', false);
          showErrorAndBack('No payment method available to sell');
          return;
        }
        if (!hasPrimary) $scope.selectedPaymentMethodId.value = $scope.paymentMethods[0].id;
        $scope.sellRequest();
      });
    });
  };

  var checkTransaction = lodash.throttle(function(count, txp) {
    $log.warn('Check if transaction has been received by Coinbase. Try ' + count + '/5');
    // TX amount in BTCZ
    var satToBtc = 1 / 100000000;
    var amountBTCZ = (txp.amount * satToBtc).toFixed(8);
    coinbaseService.init(function(err, res) {
      if (err) {
        $log.error(err);
        checkTransaction(count, txp);
        return;
      }
      var accessToken = res.accessToken;
      var accountId = res.accountId;
      var sellPrice = null;

      coinbaseService.sellPrice(accessToken, coinbaseService.getAvailableCurrency(), function(err, sell) {
        if (err) {
          $log.debug(err);
          checkTransaction(count, txp);
          return;
        }
        sellPrice = sell.data;

        coinbaseService.getTransactions(accessToken, accountId, function(err, ctxs) {
          if (err) {
            $log.debug(err);
            checkTransaction(count, txp);
            return;
          }

          var coinbaseTransactions = ctxs.data;
          var txFound = false;
          var ctx;
          for(var i = 0; i < coinbaseTransactions.length; i++) {
            ctx = coinbaseTransactions[i];
            if (ctx.type == 'send' && ctx.from && ctx.amount.amount == amountBTCZ ) {
              $log.warn('Transaction found!', ctx);
              txFound = true;
              $log.debug('Saving transaction to process later...');
              ctx['payment_method'] = $scope.selectedPaymentMethodId.value;
              ctx['status'] = 'pending'; // Forcing "pending" status to process later
              ctx['price_sensitivity'] = $scope.selectedPriceSensitivity.data;
              ctx['sell_price_amount'] = sellPrice ? sellPrice.amount : '';
              ctx['sell_price_currency'] = sellPrice ? sellPrice.currency : 'USD';
              ctx['description'] = appConfigService.nameCase + ' Wallet: ' + $scope.wallet.name;
              coinbaseService.savePendingTransaction(ctx, null, function(err) {
                ongoingProcess.set('sellingBitcoin', false, statusChangeHandler);
                if (err) $log.debug(err);
              });
              return;
            }
          }
          if (!txFound) {
            // Transaction sent, but could not be verified by Coinbase.com
            $log.warn('Transaction not found in Coinbase.');
            if (count < 5) {
              checkTransaction(count + 1, txp);
            } else {
              ongoingProcess.set('sellingBitcoin', false, statusChangeHandler);
              showError('No transaction found');
              return;
            }
          }
        });
      });
    });
  }, 8000, {
    'leading': true
  });

  var statusChangeHandler = function (processName, showName, isOn) {
    $log.debug('statusChangeHandler: ', processName, showName, isOn);
    if ( processName == 'sellingBitcoin' && !isOn) {
      $scope.sendStatus = 'success';
      $timeout(function() {
        $scope.$digest();
      }, 100);
    } else if (showName) {
      $scope.sendStatus = showName;
    }
  };

  $scope.$on("$ionicView.beforeLeave", function(event, data) {
    $ionicConfig.views.swipeBackEnabled(true);
  });

  $scope.$on("$ionicView.enter", function(event, data) {
    $ionicConfig.views.swipeBackEnabled(false);
  });

  $scope.$on("$ionicView.beforeEnter", function(event, data) {
    $scope.isFiat = data.stateParams.currency != 'BTCZ' ? true : false;
    amount = data.stateParams.amount;
    currency = data.stateParams.currency;

    $scope.priceSensitivity = coinbaseService.priceSensitivity;
    $scope.selectedPriceSensitivity = { data: coinbaseService.selectedPriceSensitivity };

    $scope.network = coinbaseService.getNetwork();
    $scope.wallets = profileService.getWallets({
      m: 1, // Only 1-signature wallet
      onlyComplete: true,
      network: $scope.network,
      hasFunds: true,
      coin: coin
    });

    if (lodash.isEmpty($scope.wallets)) {
      showErrorAndBack('Insufficient funds');
      return;
    }
    $scope.onWalletSelect($scope.wallets[0]); // Default first wallet
  });

  $scope.sellRequest = function() {
    ongoingProcess.set('connectingCoinbase', true);
    coinbaseService.init(function(err, res) {
      if (err) {
        ongoingProcess.set('connectingCoinbase', false);
        showErrorAndBack(err);
        return;
      }
      var accessToken = res.accessToken;
      var accountId = res.accountId;
      var dataSrc = {
        amount: amount,
        currency: currency,
        payment_method: $scope.selectedPaymentMethodId.value,
        quote: true
      };
      coinbaseService.sellRequest(accessToken, accountId, dataSrc, function(err, data) {
        ongoingProcess.set('connectingCoinbase', false);
        if (err) {
          showErrorAndBack(err);
          return;
        }
        $scope.sellRequestInfo = data.data;
        $timeout(function() {
          $scope.$apply();
        }, 100);
      });
    });
  };

  $scope.sellConfirm = function() {
    var config = configService.getSync();
    var configWallet = config.wallet;
    var walletSettings = configWallet.settings;

    var message = 'Selling bitcoin for ' + amount + ' ' + currency;
    var okText = 'Confirm';
    var cancelText = 'Cancel';
    popupService.showConfirm(null, message, okText, cancelText, function(ok) {
      if (!ok) return;

      ongoingProcess.set('sellingBitcoin', true, statusChangeHandler);
      coinbaseService.init(function(err, res) {
        if (err) {
          ongoingProcess.set('sellingBitcoin', false, statusChangeHandler);
          showError(err);
          return;
        }
        var accessToken = res.accessToken;
        var accountId = res.accountId;

        var dataSrc = {
          name: 'Received from ' + appConfigService.nameCase
        };
        coinbaseService.createAddress(accessToken, accountId, dataSrc, function(err, data) {
          if (err) {
            ongoingProcess.set('sellingBitcoin', false, statusChangeHandler);
            showError(err);
            return;
          }
          var outputs = [];
          var toAddress = data.data.address;
          var amountSat = parseInt(($scope.sellRequestInfo.amount.amount * 100000000).toFixed(0));
          var comment = 'Sell bitcoin (Coinbase)';

          outputs.push({
            'toAddress': toAddress,
            'amount': amountSat,
            'message': comment
          });

          var txp = {
            toAddress: toAddress,
            amount: amountSat,
            outputs: outputs,
            message: comment,
            payProUrl: null,
            excludeUnconfirmedUtxos: configWallet.spendUnconfirmed ? false : true,
            feeLevel: walletSettings.feeLevel || 'normal'
          };

          walletService.createTx($scope.wallet, txp, function(err, ctxp) {
            if (err) {
              ongoingProcess.set('sellingBitcoin', false, statusChangeHandler);
              showError(err);
              return;
            }
            $log.debug('Transaction created.');
            publishAndSign($scope.wallet, ctxp, function() {}, function(err, txSent) {
              if (err) {
                ongoingProcess.set('sellingBitcoin', false, statusChangeHandler);
                showError(err);
                return;
              }
              $log.debug('Transaction broadcasted. Wait for Coinbase confirmation...');
              checkTransaction(1, txSent);
            });
          });
        });
      });
    });
  };

  $scope.showWalletSelector = function() {
    $scope.walletSelectorTitle = 'Sell From';
    $scope.showWallets = true;
  };

  $scope.onWalletSelect = function(wallet) {
    $scope.wallet = wallet;
    var parsedAmount = txFormatService.parseAmount(
      coin,
      amount,
      currency);

    amount = parsedAmount.amount;
    currency = parsedAmount.currency;
    $scope.amountUnitStr = parsedAmount.amountUnitStr;
    processPaymentInfo();
  };

  $scope.goBackHome = function() {
    $scope.sendStatus = '';
    $ionicHistory.nextViewOptions({
      disableAnimate: true,
      historyRoot: true
    });
    $ionicHistory.clearHistory();
    $state.go('tabs.home').then(function() {
      $state.transitionTo('tabs.buyandsell.coinbase');
    });
  };

});

'use strict';

angular.module('copayApp.controllers').controller('sellGlideraController', function($scope, $log, $state, $timeout, $ionicHistory, $ionicConfig, lodash, glideraService, popupService, profileService, ongoingProcess, walletService, configService, platformInfo, txFormatService) {

  var coin = 'btcz';
  var amount;
  var currency;

  $scope.isCordova = platformInfo.isCordova;

  var showErrorAndBack = function(err) {
    $scope.sendStatus = '';
    $log.error(err);
    err = err.errors ? err.errors[0].message : err;
    popupService.showAlert('Error', err, function() {
      $ionicHistory.goBack();
    });
  };

  var showError = function(err) {
    $scope.sendStatus = '';
    $log.error(err);
    err = err.errors ? err.errors[0].message : err;
    popupService.showAlert('Error', err);
  };

  var statusChangeHandler = function (processName, showName, isOn) {
    $log.debug('statusChangeHandler: ', processName, showName, isOn);
    if ( processName == 'sellingBitcoin' && !isOn) {
      $scope.sendStatus = 'success';
      $timeout(function() {
        $scope.$digest();
      }, 100);
    } else if (showName) {
      $scope.sendStatus = showName;
    }
  };

  var processPaymentInfo = function() {
    ongoingProcess.set('connectingGlidera', true);
    glideraService.init(function(err, data) {
      if (err) {
        ongoingProcess.set('connectingGlidera', false);
        showErrorAndBack(err);
        return;
      }
      $scope.token = data.token;
      var price = {};
      if ($scope.isFiat) {
        price['fiat'] = amount;
      } else {
        price['qty'] = amount;
      }
      glideraService.sellPrice($scope.token, price, function(err, sell) {
        ongoingProcess.set('connectingGlidera', false);
        if (err) {
          showErrorAndBack(err);
          return;
        }
        $scope.sellInfo = sell;
      });
    });
  };

  $scope.$on("$ionicView.beforeLeave", function(event, data) {
    $ionicConfig.views.swipeBackEnabled(true);
  });

  $scope.$on("$ionicView.enter", function(event, data) {
    $ionicConfig.views.swipeBackEnabled(false);
  });

  $scope.$on("$ionicView.beforeEnter", function(event, data) {
    $scope.isFiat = data.stateParams.currency != 'BTCZ' ? true : false;
    amount = data.stateParams.amount;
    currency = data.stateParams.currency;

    $scope.network = glideraService.getNetwork();
    $scope.wallets = profileService.getWallets({
      m: 1, // Only 1-signature wallet
      onlyComplete: true,
      network: $scope.network,
      hasFunds: true,
      coin: coin
    });

    if (lodash.isEmpty($scope.wallets)) {
      showErrorAndBack('Insufficient funds');
      return;
    }
    $scope.onWalletSelect($scope.wallets[0]); // Default first wallet
  });

  var ask2FaCode = function(mode, cb) {
    if (mode != 'NONE') {
      // SHOW PROMPT
      var title = 'Please, enter the code below';
      var message;
      if (mode == 'PIN') {
        message = 'You have enabled PIN based two-factor authentication.';
      } else if (mode == 'AUTHENTICATOR') {
        message = 'Use an authenticator app (Authy or Google Authenticator).';
      } else {
        message = 'A SMS containing a confirmation code was sent to your phone.';
      }
      popupService.showPrompt(title, message, null, function(twoFaCode) {
        if (typeof twoFaCode == 'undefined') return cb();
        return cb(twoFaCode);
      });
    } else {
      return cb();
    }
  };

  $scope.sellConfirm = function() {
    var message = 'Sell bitcoin for ' + amount + ' ' + currency;
    var okText = 'Confirm';
    var cancelText = 'Cancel';
    popupService.showConfirm(null, message, okText, cancelText, function(ok) {
      if (!ok) return;
      ongoingProcess.set('sellingBitcoin', true, statusChangeHandler);
      glideraService.get2faCode($scope.token, function(err, tfa) {
        if (err) {
          ongoingProcess.set('sellingBitcoin', false, statusChangeHandler);
          showError(err);
          return;
        }
        ask2FaCode(tfa.mode, function(twoFaCode) {
          if (tfa.mode != 'NONE' && lodash.isEmpty(twoFaCode)) {
            ongoingProcess.set('sellingBitcoin', false, statusChangeHandler);
            showError('No code entered');
            return;
          }

          var outputs = [];
          var config = configService.getSync();
          var configWallet = config.wallet;
          var walletSettings = configWallet.settings;

          walletService.getAddress($scope.wallet, null, function(err, refundAddress) {
            if (!refundAddress) {
              ongoingProcess.set('sellingBitcoin', false, statusChangeHandler);
              showError('Could not create address');
              return;
            }
            glideraService.getSellAddress($scope.token, function(err, sellAddress) {
              if (!sellAddress || err) {
                ongoingProcess.set('sellingBitcoin', false, statusChangeHandler);
                showError(err);
                return;
              }
              var amount = parseInt(($scope.sellInfo.qty * 100000000).toFixed(0));
              var comment = 'Glidera transaction';

              outputs.push({
                'toAddress': sellAddress,
                'amount': amount,
                'message': comment
              });

              var txp = {
                toAddress: sellAddress,
                amount: amount,
                outputs: outputs,
                message: comment,
                payProUrl: null,
                excludeUnconfirmedUtxos: configWallet.spendUnconfirmed ? false : true,
                feeLevel: walletSettings.feeLevel || 'normal',
                customData: {
                  'glideraToken': $scope.token
                }
              };

              walletService.createTx($scope.wallet, txp, function(err, createdTxp) {
                if (err) {
                  ongoingProcess.set('sellingBitcoin', false, statusChangeHandler);
                  showError(err);
                  return;
                }
                walletService.prepare($scope.wallet, function(err, password) {
                  if (err) {
                    ongoingProcess.set('sellingBitcoin', false, statusChangeHandler);
                    showError(err);
                    return;
                  }
                  walletService.publishTx($scope.wallet, createdTxp, function(err, publishedTxp) {
                    if (err) {
                      ongoingProcess.set('sellingBitcoin', false, statusChangeHandler);
                      showError(err);
                      return;
                    }
                    walletService.signTx($scope.wallet, publishedTxp, password, function(err, signedTxp) {
                      if (err) {
                        ongoingProcess.set('sellingBitcoin', false, statusChangeHandler);
                        showError(err);
                        walletService.removeTx($scope.wallet, signedTxp, function(err) {
                          if (err) $log.debug(err);
                        });
                        return;
                      }
                      var rawTx = signedTxp.raw;
                      var data = {
                        refundAddress: refundAddress,
                        signedTransaction: rawTx,
                        priceUuid: $scope.sellInfo.priceUuid,
                        useCurrentPrice: $scope.sellInfo.priceUuid ? false : true,
                        ip: null
                      };
                      glideraService.sell($scope.token, twoFaCode, data, function(err, data) {
                        ongoingProcess.set('sellingBitcoin', false, statusChangeHandler);
                        if (err) return showError(err);
                        $log.info(data);
                      });
                    });
                  });
                });
              });
            });
          });
        });
      });
    });
  };

  $scope.showWalletSelector = function() {
    $scope.walletSelectorTitle = 'Sell From';
    $scope.showWallets = true;
  };

  $scope.onWalletSelect = function(wallet) {
    $scope.wallet = wallet;
    var parsedAmount = txFormatService.parseAmount(
      coin,
      amount,
      currency);

    amount = parsedAmount.amount;
    currency = parsedAmount.currency;
    $scope.amountUnitStr = parsedAmount.amountUnitStr;
    processPaymentInfo();
  };

  $scope.goBackHome = function() {
    $scope.sendStatus = '';
    $ionicHistory.nextViewOptions({
      disableAnimate: true,
      historyRoot: true
    });
    $ionicHistory.clearHistory();
    $state.go('tabs.home').then(function() {
      $state.transitionTo('tabs.buyandsell.glidera');
    });
  };

});

'use strict';

angular.module('copayApp.controllers').controller('tabHomeController',
  function($rootScope, $timeout, $scope, $state, $stateParams, $ionicModal, $ionicScrollDelegate, $window, gettextCatalog, lodash, popupService, ongoingProcess, externalLinkService, latestReleaseService, profileService, walletService, configService, $log, platformInfo, storageService, txpModalService, appConfigService, startupService, addressbookService, feedbackService, bwcError, nextStepsService, buyAndSellService, homeIntegrationsService, bitpayCardService, pushNotificationsService, timeService) {
    var wallet;
    var listeners = [];
    var notifications = [];
    $scope.externalServices = {};
    $scope.openTxpModal = txpModalService.open;
    $scope.version = $window.version;
    $scope.name = appConfigService.nameCase;
    $scope.homeTip = $stateParams.fromOnboarding;
    $scope.isCordova = platformInfo.isCordova;
    $scope.isAndroid = platformInfo.isAndroid;
    $scope.isWindowsPhoneApp = platformInfo.isCordova && platformInfo.isWP;
    $scope.isNW = platformInfo.isNW;
    $scope.showRateCard = {};

    $scope.$on("$ionicView.afterEnter", function() {
      startupService.ready();
    });

    $scope.$on("$ionicView.beforeEnter", function(event, data) {
      if (!$scope.homeTip) {
        storageService.getHomeTipAccepted(function(error, value) {
          $scope.homeTip = (value == 'accepted') ? false : true;
        });
      }

      if ($scope.isNW) {
        latestReleaseService.checkLatestRelease(function(err, newRelease) {
          if (err) {
            $log.warn(err);
            return;
          }
          if (newRelease) {
            $scope.newRelease = true;
            $scope.updateText = gettextCatalog.getString('There is a new version of {{appName}} available', {
              appName: $scope.name
            });
          }
        });
      }

      storageService.getFeedbackInfo(function(error, info) {

        if ($scope.isWindowsPhoneApp) {
          $scope.showRateCard.value = false;
          return;
        }
        if (!info) {
          initFeedBackInfo();
        } else {
          var feedbackInfo = JSON.parse(info);
          //Check if current version is greater than saved version
          var currentVersion = $scope.version;
          var savedVersion = feedbackInfo.version;
          var isVersionUpdated = feedbackService.isVersionUpdated(currentVersion, savedVersion);
          if (!isVersionUpdated) {
            initFeedBackInfo();
            return;
          }
          var now = moment().unix();
          var timeExceeded = (now - feedbackInfo.time) >= 24 * 7 * 60 * 60;
          $scope.showRateCard.value = timeExceeded && !feedbackInfo.sent;
          $timeout(function() {
            $scope.$apply();
          });
        }
      });

      function initFeedBackInfo() {
        var feedbackInfo = {};
        feedbackInfo.time = moment().unix();
        feedbackInfo.version = $scope.version;
        feedbackInfo.sent = false;
        storageService.setFeedbackInfo(JSON.stringify(feedbackInfo), function() {
          $scope.showRateCard.value = false;
        });
      };
    });

    $scope.$on("$ionicView.enter", function(event, data) {
      updateAllWallets();

      addressbookService.list(function(err, ab) {
        if (err) $log.error(err);
        $scope.addressbook = ab || {};
      });

      listeners = [
        $rootScope.$on('bwsEvent', function(e, walletId, type, n) {
          var wallet = profileService.getWallet(walletId);
          updateWallet(wallet);
          if ($scope.recentTransactionsEnabled) getNotifications();

        }),
        $rootScope.$on('Local/TxAction', function(e, walletId) {
          $log.debug('Got action for wallet ' + walletId);
          var wallet = profileService.getWallet(walletId);
          updateWallet(wallet);
          if ($scope.recentTransactionsEnabled) getNotifications();
        })
      ];


      $scope.buyAndSellItems = buyAndSellService.getLinked();
      $scope.homeIntegrations = homeIntegrationsService.get();

      bitpayCardService.get({}, function(err, cards) {
        $scope.bitpayCardItems = cards;
      });

      configService.whenAvailable(function(config) {
        $scope.recentTransactionsEnabled = config.recentTransactions.enabled;
        if ($scope.recentTransactionsEnabled) getNotifications();

        if (config.hideNextSteps.enabled) {
          $scope.nextStepsItems = null;
        } else {
          $scope.nextStepsItems = nextStepsService.get();
        }

        pushNotificationsService.init();

        $timeout(function() {
          $ionicScrollDelegate.resize();
          $scope.$apply();
        }, 10);
      });
    });

    $scope.$on("$ionicView.leave", function(event, data) {
      lodash.each(listeners, function(x) {
        x();
      });
    });

    $scope.createdWithinPastDay = function(time) {
      return timeService.withinPastDay(time);
    };

    $scope.openExternalLink = function() {
      var url = 'https://github.com/bitpay/copay/releases/latest';
      var optIn = true;
      var title = gettextCatalog.getString('Update Available');
      var message = gettextCatalog.getString('An update to this app is available. For your security, please update to the latest version.');
      var okText = gettextCatalog.getString('View Update');
      var cancelText = gettextCatalog.getString('Go Back');
      externalLinkService.open(url, optIn, title, message, okText, cancelText);
    };

    $scope.openNotificationModal = function(n) {
      wallet = profileService.getWallet(n.walletId);

      if (n.txid) {
        $state.transitionTo('tabs.wallet.tx-details', {
          txid: n.txid,
          walletId: n.walletId
        });
      } else {
        var txp = lodash.find($scope.txps, {
          id: n.txpId
        });
        if (txp) {
          txpModalService.open(txp);
        } else {
          ongoingProcess.set('loadingTxInfo', true);
          walletService.getTxp(wallet, n.txpId, function(err, txp) {
            var _txp = txp;
            ongoingProcess.set('loadingTxInfo', false);
            if (err) {
              $log.warn('No txp found');
              return popupService.showAlert(gettextCatalog.getString('Error'), gettextCatalog.getString('Transaction not found'));
            }
            txpModalService.open(_txp);
          });
        }
      }
    };

    $scope.openWallet = function(wallet) {
      if (!wallet.isComplete()) {
        return $state.go('tabs.copayers', {
          walletId: wallet.credentials.walletId
        });
      }

      $state.go('tabs.wallet', {
        walletId: wallet.credentials.walletId
      });
    };

    var updateTxps = function() {
      profileService.getTxps({
        limit: 3
      }, function(err, txps, n) {
        if (err) $log.error(err);
        $scope.txps = txps;
        $scope.txpsN = n;
        $timeout(function() {
          $ionicScrollDelegate.resize();
          $scope.$apply();
        }, 10);
      })
    };

    var updateAllWallets = function() {
      $scope.wallets = profileService.getWallets();
      if (lodash.isEmpty($scope.wallets)) return;

      var i = $scope.wallets.length;
      var j = 0;
      var timeSpan = 60 * 60 * 24 * 7;

      lodash.each($scope.wallets, function(wallet) {
        walletService.getStatus(wallet, {}, function(err, status) {
          if (err) {

            wallet.error = (err === 'WALLET_NOT_REGISTERED') ? gettextCatalog.getString('Wallet not registered') : bwcError.msg(err);

            $log.error(err);
          } else {
            wallet.error = null;
            wallet.status = status;

            // TODO service refactor? not in profile service
            profileService.setLastKnownBalance(wallet.id, wallet.status.totalBalanceStr, function() {});
          }
          if (++j == i) {
            updateTxps();
          }
        });
      });
    };

    var updateWallet = function(wallet) {
      $log.debug('Updating wallet:' + wallet.name)
      walletService.getStatus(wallet, {}, function(err, status) {
        if (err) {
          $log.error(err);
          return;
        }
        wallet.status = status;
        updateTxps();
      });
    };

    var getNotifications = function() {
      profileService.getNotifications({
        limit: 3
      }, function(err, notifications, total) {
        if (err) {
          $log.error(err);
          return;
        }
        $scope.notifications = notifications;
        $scope.notificationsN = total;
        $timeout(function() {
          $ionicScrollDelegate.resize();
          $scope.$apply();
        }, 10);
      });
    };

    $scope.hideHomeTip = function() {
      storageService.setHomeTipAccepted('accepted', function() {
        $scope.homeTip = false;
        $timeout(function() {
          $scope.$apply();
        })
      });
    };


    $scope.onRefresh = function() {
      $timeout(function() {
        $scope.$broadcast('scroll.refreshComplete');
      }, 300);
      updateAllWallets();
    };
  });

'use strict';

angular.module('copayApp.controllers').controller('tabReceiveController', function($rootScope, $scope, $timeout, $log, $ionicModal, $state, $ionicHistory, $ionicPopover, storageService, platformInfo, walletService, profileService, configService, lodash, gettextCatalog, popupService, bwcError) {

  var listeners = [];
  $scope.isCordova = platformInfo.isCordova;
  $scope.isNW = platformInfo.isNW;

  $scope.requestSpecificAmount = function() {
    $state.go('tabs.paymentRequest.amount', {
      id: $scope.wallet.credentials.walletId,
      coin: $scope.wallet.coin
    });
  };

  $scope.setAddress = function(newAddr) {
    $scope.addr = null;
    if (!$scope.wallet || $scope.generatingAddress || !$scope.wallet.isComplete()) return;
    $scope.generatingAddress = true;
    walletService.getAddress($scope.wallet, newAddr, function(err, addr) {
      $scope.generatingAddress = false;

      if (err) {
        //Error is already formated
        popupService.showAlert(err);
      }

      $scope.addr = addr;
      $timeout(function() {
        $scope.$apply();
      }, 10);
    });
  };

  $scope.goCopayers = function() {
    $ionicHistory.removeBackView();
    $ionicHistory.nextViewOptions({
      disableAnimate: true
    });
    $state.go('tabs.home');
    $timeout(function() {
      $state.transitionTo('tabs.copayers', {
        walletId: $scope.wallet.credentials.walletId
      });
    }, 100);
  };

  $scope.openBackupNeededModal = function() {
    $ionicModal.fromTemplateUrl('views/includes/backupNeededPopup.html', {
      scope: $scope,
      backdropClickToClose: false,
      hardwareBackButtonClose: false
    }).then(function(modal) {
      $scope.BackupNeededModal = modal;
      $scope.BackupNeededModal.show();
    });
  };

  $scope.close = function() {
    $scope.BackupNeededModal.hide();
    $scope.BackupNeededModal.remove();
  };

  $scope.doBackup = function() {
    $scope.close();
    $scope.goToBackupFlow();
  };

  $scope.goToBackupFlow = function() {
    $state.go('tabs.receive.backupWarning', {
      from: 'tabs.receive',
      walletId: $scope.wallet.credentials.walletId
    });
  };

  $scope.shouldShowReceiveAddressFromHardware = function() {
    var wallet = $scope.wallet;
    if (wallet.isPrivKeyExternal() && wallet.credentials.hwInfo) {
      return (wallet.credentials.hwInfo.name == walletService.externalSource.intelTEE.id);
    } else {
      return false;
    }
  };

  $scope.showReceiveAddressFromHardware = function() {
    var wallet = $scope.wallet;
    if (wallet.isPrivKeyExternal() && wallet.credentials.hwInfo) {
      walletService.showReceiveAddressFromHardware(wallet, $scope.addr, function() {});
    }
  };

  $scope.$on("$ionicView.beforeEnter", function(event, data) {
    $scope.wallets = profileService.getWallets();
    $scope.singleWallet = $scope.wallets.length == 1;

    if (!$scope.wallets[0]) return;

    // select first wallet if no wallet selected previously
    var selectedWallet = checkSelectedWallet($scope.wallet, $scope.wallets);
    $scope.onWalletSelect(selectedWallet);

    $scope.showShareButton = platformInfo.isCordova ? (platformInfo.isIOS ? 'iOS' : 'Android') : null;

    listeners = [
      $rootScope.$on('bwsEvent', function(e, walletId, type, n) {
        // Update current address
        if ($scope.wallet && walletId == $scope.wallet.id && type == 'NewIncomingTx') $scope.setAddress(true);
      })
    ];
  });

  $scope.$on("$ionicView.leave", function(event, data) {
    lodash.each(listeners, function(x) {
      x();
    });
  });

  var checkSelectedWallet = function(wallet, wallets) {
    if (!wallet) return wallets[0];
    var w = lodash.find(wallets, function(w) {
      return w.id == wallet.id;
    });
    if (!w) return wallets[0];
    return wallet;
  }

  var setProtocolHandler = function() {
    $scope.protocolHandler = walletService.getProtocolHandler($scope.wallet);
  }

  $scope.onWalletSelect = function(wallet) {
    $scope.wallet = wallet;
    setProtocolHandler();
    $scope.setAddress();
  };

  $scope.showWalletSelector = function() {
    if ($scope.singleWallet) return;
    $scope.walletSelectorTitle = gettextCatalog.getString('Select a wallet');
    $scope.showWallets = true;
  };

  $scope.shareAddress = function() {
    if (!$scope.isCordova) return;
    var protocol = 'bitcoin';
    if ($scope.wallet.coin == 'bch') protocol += 'cash';
    window.plugins.socialsharing.share(protocol + ':' + $scope.addr, null, null, null);
  }
});

'use strict';

angular.module('copayApp.controllers').controller('tabScanController', function($scope, $log, $timeout, scannerService, incomingData, $state, $ionicHistory, $rootScope) {

  var scannerStates = {
    unauthorized: 'unauthorized',
    denied: 'denied',
    unavailable: 'unavailable',
    loading: 'loading',
    visible: 'visible'
  };
  $scope.scannerStates = scannerStates;

  function _updateCapabilities(){
    var capabilities = scannerService.getCapabilities();
    $scope.scannerIsAvailable = capabilities.isAvailable;
    $scope.scannerHasPermission = capabilities.hasPermission;
    $scope.scannerIsDenied = capabilities.isDenied;
    $scope.scannerIsRestricted = capabilities.isRestricted;
    $scope.canEnableLight = capabilities.canEnableLight;
    $scope.canChangeCamera = capabilities.canChangeCamera;
    $scope.canOpenSettings = capabilities.canOpenSettings;
  }

  function _handleCapabilities(){
    // always update the view
    $timeout(function(){
      if(!scannerService.isInitialized()){
        $scope.currentState = scannerStates.loading;
      } else if(!$scope.scannerIsAvailable){
        $scope.currentState = scannerStates.unavailable;
      } else if($scope.scannerIsDenied){
        $scope.currentState = scannerStates.denied;
      } else if($scope.scannerIsRestricted){
        $scope.currentState = scannerStates.denied;
      } else if(!$scope.scannerHasPermission){
        $scope.currentState = scannerStates.unauthorized;
      }
      $log.debug('Scan view state set to: ' + $scope.currentState);
    });
  }

  function _refreshScanView(){
    _updateCapabilities();
    _handleCapabilities();
    if($scope.scannerHasPermission){
      activate();
    }
  }

  // This could be much cleaner with a Promise API
  // (needs a polyfill for some platforms)
  $rootScope.$on('scannerServiceInitialized', function(){
    $log.debug('Scanner initialization finished, reinitializing scan view...');
    _refreshScanView();
  });

  $scope.$on("$ionicView.afterEnter", function() {
    // try initializing and refreshing status any time the view is entered
    if(!scannerService.isInitialized()){
      scannerService.gentleInitialize();
    }
    activate();
  });

  function activate(){
    scannerService.activate(function(){
      _updateCapabilities();
      _handleCapabilities();
      $log.debug('Scanner activated, setting to visible...');
      $scope.currentState = scannerStates.visible;
        // pause to update the view
        $timeout(function(){
          scannerService.scan(function(err, contents){
          if(err){
            $log.debug('Scan canceled.');
          } else if ($state.params.passthroughMode) {
            $rootScope.scanResult = contents;
            goBack();
          } else {
            handleSuccessfulScan(contents);
          }
          });
          // resume preview if paused
          scannerService.resumePreview();
        });
    });
  }
  $scope.activate = activate;

  $scope.authorize = function(){
    scannerService.initialize(function(){
      _refreshScanView();
    });
  };

  $scope.$on("$ionicView.afterLeave", function() {
    scannerService.deactivate();
  });

  function handleSuccessfulScan(contents){
    $log.debug('Scan returned: "' + contents + '"');
    scannerService.pausePreview();
    incomingData.redir(contents);
  }

  $rootScope.$on('incomingDataMenu.menuHidden', function() {
    activate();
  });

  $scope.openSettings = function(){
    scannerService.openSettings();
  };

  $scope.attemptToReactivate = function(){
    scannerService.reinitialize();
  };

  $scope.toggleLight = function(){
    scannerService.toggleLight(function(lightEnabled){
      $scope.lightActive = lightEnabled;
      $scope.$apply();
    });
  };

  $scope.toggleCamera = function(){
    $scope.cameraToggleActive = true;
    scannerService.toggleCamera(function(status){
    // (a short delay for the user to see the visual feedback)
      $timeout(function(){
        $scope.cameraToggleActive = false;
        $log.debug('Camera toggle control deactivated.');
      }, 200);
    });
  };

  $scope.canGoBack = function(){
    return $state.params.passthroughMode;
  };
  function goBack(){
    $ionicHistory.nextViewOptions({
      disableAnimate: true
    });
    $ionicHistory.backView().go();
  }
  $scope.goBack = goBack;
});

'use strict';

angular.module('copayApp.controllers').controller('tabSendController', function($scope, $rootScope, $log, $timeout, $ionicScrollDelegate, addressbookService, profileService, lodash, $state, walletService, incomingData, popupService, platformInfo, bwcError, gettextCatalog, scannerService, bitcoreCash) {

  var originalList;
  var CONTACTS_SHOW_LIMIT;
  var currentContactsPage;
  $scope.isChromeApp = platformInfo.isChromeApp;


  var hasWallets = function() {
    $scope.wallets = profileService.getWallets({
      onlyComplete: true
    });
    $scope.hasWallets = lodash.isEmpty($scope.wallets) ? false : true;
  };

  // THIS is ONLY to show the 'buy bitcoins' message
  // does not has any other function.

  var updateHasFunds = function() {

    if ($rootScope.everHasFunds) {
      $scope.hasFunds = true;
      return;
    }

    $scope.hasFunds = false;
    var index = 0;
    lodash.each($scope.wallets, function(w) {
      walletService.getStatus(w, {}, function(err, status) {

        ++index;
        if (err && !status) {
          $log.error(err);
          // error updating the wallet. Probably a network error, do not show
          // the 'buy bitcoins' message.

          $scope.hasFunds = true;
        } else if (status.availableBalanceSat > 0) {
          $scope.hasFunds = true;
          $rootScope.everHasFunds = true;
        }

        if (index == $scope.wallets.length) {
          $scope.checkingBalance = false;
          $timeout(function() {
            $scope.$apply();
          });
        }
      });
    });
  };

  var updateWalletsList = function() {

    var networkResult = lodash.countBy($scope.wallets, 'network');

    $scope.showTransferCard = $scope.hasWallets && (networkResult.livenet > 1 || networkResult.testnet > 1);

    if ($scope.showTransferCard) {
      var walletsToTransfer = $scope.wallets;
      if (!(networkResult.livenet > 1)) {
        walletsToTransfer = lodash.filter(walletsToTransfer, function(item) {
          return item.network == 'testnet';
        });
      }
      if (!(networkResult.testnet > 1)) {
        walletsToTransfer = lodash.filter(walletsToTransfer, function(item) {
          return item.network == 'livenet';
        });
      }
      var walletList = [];
      lodash.each(walletsToTransfer, function(v) {
        walletList.push({
          color: v.color,
          name: v.name,
          recipientType: 'wallet',
          coin: v.coin,
          network: v.network,
          getAddress: function(cb) {
            walletService.getAddress(v, false, cb);
          },
        });
      });
      originalList = originalList.concat(walletList);
    }
  }

  var getCoin = function(address) {
    var cashAddress = bitcoreCash.Address.isValid(address, 'livenet');
    if (cashAddress) {
      return 'bch';
    }
    return 'btcz';
  };

  var updateContactsList = function(cb) {
    addressbookService.list(function(err, ab) {
      if (err) $log.error(err);

      $scope.hasContacts = lodash.isEmpty(ab) ? false : true;
      if (!$scope.hasContacts) return cb();

      var completeContacts = [];
      lodash.each(ab, function(v, k) {
        completeContacts.push({
          name: lodash.isObject(v) ? v.name : v,
          address: k,
          email: lodash.isObject(v) ? v.email : null,
          recipientType: 'contact',
          coin: getCoin(k),
          getAddress: function(cb) {
            return cb(null, k);
          },
        });
      });
      var contacts = completeContacts.slice(0, (currentContactsPage + 1) * CONTACTS_SHOW_LIMIT);
      $scope.contactsShowMore = completeContacts.length > contacts.length;
      originalList = originalList.concat(contacts);
      return cb();
    });
  };

  var updateList = function() {
    $scope.list = lodash.clone(originalList);
    $timeout(function() {
      $ionicScrollDelegate.resize();
      $scope.$apply();
    }, 10);
  };

  $scope.openScanner = function() {
    var isWindowsPhoneApp = platformInfo.isCordova && platformInfo.isWP;

    if (!isWindowsPhoneApp) {
      $state.go('tabs.scan');
      return;
    }

    scannerService.useOldScanner(function(err, contents) {
      if (err) {
        popupService.showAlert(gettextCatalog.getString('Error'), err);
        return;
      }
      incomingData.redir(contents);
    });
  };

  $scope.showMore = function() {
    currentContactsPage++;
    updateWalletsList();
  };

  $scope.searchInFocus = function() {
    $scope.searchFocus = true;
  };

  $scope.searchBlurred = function() {
    if ($scope.formData.search == null || $scope.formData.search.length == 0) {
      $scope.searchFocus = false;
    }
  };

  $scope.findContact = function(search) {

    if (incomingData.redir(search)) {
      return;
    }

    if (!search || search.length < 2) {
      $scope.list = originalList;
      $timeout(function() {
        $scope.$apply();
      });
      return;
    }

    var result = lodash.filter(originalList, function(item) {
      var val = item.name;
      return lodash.includes(val.toLowerCase(), search.toLowerCase());
    });

    $scope.list = result;
  };

  $scope.goToAmount = function(item) {
    $timeout(function() {
      item.getAddress(function(err, addr) {
        if (err || !addr) {
          //Error is already formated
          return popupService.showAlert(err);
        }
        $log.debug('Got toAddress:' + addr + ' | ' + item.name);
        return $state.transitionTo('tabs.send.amount', {
          recipientType: item.recipientType,
          toAddress: addr,
          toName: item.name,
          toEmail: item.email,
          toColor: item.color,
          coin: item.coin
        })
      });
    });
  };

  // This could probably be enhanced refactoring the routes abstract states
  $scope.createWallet = function() {
    $state.go('tabs.home').then(function() {
      $state.go('tabs.add.create-personal');
    });
  };

  $scope.buyBitcoin = function() {
    $state.go('tabs.home').then(function() {
      $state.go('tabs.buyandsell');
    });
  };

  $scope.$on("$ionicView.beforeEnter", function(event, data) {
    $scope.checkingBalance = true;
    $scope.formData = {
      search: null
    };
    originalList = [];
    CONTACTS_SHOW_LIMIT = 10;
    currentContactsPage = 0;
    hasWallets();
  });

  $scope.$on("$ionicView.enter", function(event, data) {
    if (!$scope.hasWallets) {
      $scope.checkingBalance = false;
      return;
    }
    updateHasFunds();
    updateWalletsList();
    updateContactsList(function() {
      updateList();
    });
  });
});

'use strict';

angular.module('copayApp.controllers').controller('tabSettingsController', function($rootScope, $timeout, $scope, appConfigService, $ionicModal, $log, lodash, uxLanguage, platformInfo, profileService, feeService, configService, externalLinkService, bitpayAccountService, bitpayCardService, storageService, glideraService, gettextCatalog, buyAndSellService) {

  var updateConfig = function() {
    $scope.currentLanguageName = uxLanguage.getCurrentLanguageName();
    $scope.feeOpts = feeService.feeOpts;
    $scope.currentFeeLevel = feeService.getCurrentFeeLevel();
    $scope.wallets = profileService.getWallets();
    $scope.buyAndSellServices = buyAndSellService.getLinked();

    configService.whenAvailable(function(config) {
      $scope.selectedAlternative = {
        name: config.wallet.settings.alternativeName,
        isoCode: config.wallet.settings.alternativeIsoCode
      };

      // TODO move this to a generic service
      bitpayAccountService.getAccounts(function(err, data) {
        if (err) $log.error(err);
        $scope.bitpayAccounts = !lodash.isEmpty(data);

        $timeout(function() {
          $rootScope.$apply();
        }, 10);
      });

      $scope.cashSupport = {
        value: config.cashSupport
      };


      // TODO move this to a generic service
      bitpayCardService.getCards(function(err, cards) {
        if (err) $log.error(err);
        $scope.bitpayCards = cards && cards.length > 0;

        $timeout(function() {
          $rootScope.$apply();
        }, 10);
      });
    });
  };

  $scope.openExternalLink = function() {
    var appName = appConfigService.name;
    var url = appName == 'copay' ? 'https://github.com/bitpay/copay/issues' : 'https://help.bitpay.com/bitpay-app';
    var optIn = true;
    var title = null;
    var message = gettextCatalog.getString('Help and support information is available at the website.');
    var okText = gettextCatalog.getString('Open');
    var cancelText = gettextCatalog.getString('Go Back');
    externalLinkService.open(url, optIn, title, message, okText, cancelText);
  };

  $scope.$on("$ionicView.beforeEnter", function(event, data) {
    $scope.isCordova = platformInfo.isCordova;
    $scope.isWindowsPhoneApp = platformInfo.isCordova && platformInfo.isWP;
    $scope.isDevel = platformInfo.isDevel;
    $scope.appName = appConfigService.nameCase;
    configService.whenAvailable(function(config) {
      $scope.locked = config.lock && config.lock.method;
      if (!$scope.locked || $scope.locked == 'none')
        $scope.method = gettextCatalog.getString('Disabled');
      else
        $scope.method = $scope.locked.charAt(0).toUpperCase() + config.lock.method.slice(1);
    });
  });



  $scope.$on("$ionicView.enter", function(event, data) {
    updateConfig();
  });

});

'use strict';

angular.module('copayApp.controllers').controller('tabsController', function($rootScope, $log, $scope, $state, $stateParams, $timeout, platformInfo, incomingData, lodash, popupService, gettextCatalog, scannerService) {

  $scope.onScan = function(data) {
    if (!incomingData.redir(data)) {
      popupService.showAlert(gettextCatalog.getString('Error'), gettextCatalog.getString('Invalid data'));
    }
  };

  $scope.setScanFn = function(scanFn) {
    $scope.scan = function() {
      $log.debug('Scanning...');
      scanFn();
    };
  };

  $scope.importInit = function() {
    $scope.fromOnboarding = $stateParams.fromOnboarding;
    $timeout(function() {
      $scope.$apply();
    }, 1);
  };

  $scope.chooseScanner = function() {

    var isWindowsPhoneApp = platformInfo.isCordova && platformInfo.isWP;

    if (!isWindowsPhoneApp) {
      $state.go('tabs.scan');
      return;
    }

    scannerService.useOldScanner(function(err, contents) {
      if (err) {
        popupService.showAlert(gettextCatalog.getString('Error'), err);
        return;
      }
      incomingData.redir(contents);
    });

  };

});

'use strict';

angular.module('copayApp.controllers').controller('topUpController', function($scope, $log, $state, $timeout, $ionicHistory, $ionicConfig, lodash, popupService, profileService, ongoingProcess, walletService, configService, platformInfo, bitpayService, bitpayCardService, payproService, bwcError, txFormatService, sendMaxService, gettextCatalog) {

  $scope.isCordova = platformInfo.isCordova;
  var coin = 'btcz';
  var cardId;
  var useSendMax;
  var amount;
  var currency;
  var createdTx;
  var message;
  var configWallet = configService.getSync().wallet;

  var _resetValues = function() {
    $scope.totalAmountStr = $scope.amount = $scope.invoiceFee = $scope.networkFee = $scope.totalAmount = $scope.wallet = null;
    createdTx = message = null;
  };

  var showErrorAndBack = function(title, msg) {
    title = title || gettextCatalog.getString('Error');
    $scope.sendStatus = '';
    $log.error(msg);
    msg = msg.errors ? msg.errors[0].message : msg;
    popupService.showAlert(title, msg, function() {
      $ionicHistory.goBack();
    });
  };

  var showError = function(title, msg, cb) {
    cb = cb || function() {};
    title = title || gettextCatalog.getString('Error');
    $scope.sendStatus = '';
    $log.error(msg);
    msg = msg.errors ? msg.errors[0].message : msg;
    popupService.showAlert(title, msg, cb);
  };

  var satToFiat = function(sat, cb) {
    txFormatService.toFiat(coin, sat, $scope.currencyIsoCode, function(value) {
      return cb(value);
    });
  };

  var publishAndSign = function (wallet, txp, onSendStatusChange, cb) {
    if (!wallet.canSign() && !wallet.isPrivKeyExternal()) {
      var err = gettextCatalog.getString('No signing proposal: No private key');
      $log.info(err);
      return cb(err);
    }

    walletService.publishAndSign(wallet, txp, function(err, txp) {
      if (err) return cb(err);
      return cb(null, txp);
    }, onSendStatusChange);
  };

  var statusChangeHandler = function (processName, showName, isOn) {
    $log.debug('statusChangeHandler: ', processName, showName, isOn);
    if (processName == 'topup' && !isOn) {
      $scope.sendStatus = 'success';
      $timeout(function() {
        $scope.$digest();
      }, 100);
    } else if (showName) {
      $scope.sendStatus = showName;
    }
  };

  var setTotalAmount = function(amountSat, invoiceFeeSat, networkFeeSat) {
    satToFiat(amountSat, function(a) {
      $scope.amount = Number(a);

      satToFiat(invoiceFeeSat, function(i) {
        $scope.invoiceFee = Number(i);

        satToFiat(networkFeeSat, function(n) {
          $scope.networkFee = Number(n);
          $scope.totalAmount = $scope.amount + $scope.invoiceFee + $scope.networkFee;
          $timeout(function() {
            $scope.$digest();
          });
        });
      });
    });
  };

  var createInvoice = function(data, cb) {
    bitpayCardService.topUp(cardId, data, function(err, invoiceId) {
      if (err) {
        return cb({
          title: gettextCatalog.getString('Could not create the invoice'),
          message: err
        });
      }

      bitpayCardService.getInvoice(invoiceId, function(err, inv) {
        if (err) {
          return cb({
            title: gettextCatalog.getString('Could not get the invoice'),
            message: err
          });
        }
        return cb(null, inv);
      });
    });
  };

  var createTx = function(wallet, invoice, message, cb) {
    var payProUrl = (invoice && invoice.paymentUrls) ? invoice.paymentUrls.BIP73 : null;

    if (!payProUrl) {
      return cb({
        title: gettextCatalog.getString('Error in Payment Protocol'),
        message: gettextCatalog.getString('Invalid URL')
      });
    }

    var outputs = [];
    var toAddress = invoice.bitcoinAddress;
    var amountSat = parseInt((invoice.btczDue * 100000000).toFixed(0)); // BTCZ to Satoshi

    outputs.push({
      'toAddress': toAddress,
      'amount': amountSat,
      'message': message
    });

    var txp = {
      toAddress: toAddress,
      amount: amountSat,
      outputs: outputs,
      message: message,
      payProUrl: payProUrl,
      excludeUnconfirmedUtxos: configWallet.spendUnconfirmed ? false : true,
      feeLevel: configWallet.settings.feeLevel || 'normal'
    };

    walletService.createTx(wallet, txp, function(err, ctxp) {
      if (err) {
        return cb({
          title: gettextCatalog.getString('Could not create transaction'),
          message: bwcError.msg(err)
        });
      }
      return cb(null, ctxp);
    });
  };

  var calculateAmount = function(wallet, cb) {
    // Global variables defined beforeEnter
    var a = amount;
    var c = currency;

    if (useSendMax) {
      sendMaxService.getInfo(wallet, function(err, maxValues) {
        if (err) {
          return cb({
            title: null,
            message: err
          })
        }

        if (maxValues.amount == 0) {
          return cb({message: gettextCatalog.getString('Insufficient funds for fee')});
        }

        var maxAmountBtc = Number((maxValues.amount / 100000000).toFixed(8));

        createInvoice({amount: maxAmountBtc, currency: 'BTCZ'}, function(err, inv) {
          if (err) return cb(err);

          var invoiceFeeSat = parseInt((inv.buyerPaidBtcMinerFee * 100000000).toFixed());
          var newAmountSat = maxValues.amount - invoiceFeeSat;

          if (newAmountSat <= 0) {
            return cb({message: gettextCatalog.getString('Insufficient funds for fee')});
          }

          return cb(null, newAmountSat, 'sat');
        });
      });
    } else {
      return cb(null, a, c);
    }
  };

  var initializeTopUp = function(wallet, parsedAmount) {
    $scope.amountUnitStr = parsedAmount.amountUnitStr;
    var dataSrc = {
      amount: parsedAmount.amount,
      currency: parsedAmount.currency
    };
    ongoingProcess.set('loadingTxInfo', true);
    createInvoice(dataSrc, function(err, invoice) {
      if (err) {
        ongoingProcess.set('loadingTxInfo', false);
        showErrorAndBack(err.title, err.message);
        return;
      }

      // Sometimes API does not return this element;
      invoice['buyerPaidBtcMinerFee'] = invoice.buyerPaidBtcMinerFee || 0;
      var invoiceFeeSat = (invoice.buyerPaidBtcMinerFee * 100000000).toFixed();

      message = gettextCatalog.getString("Top up {{amountStr}} to debit card ({{cardLastNumber}})", {
        amountStr: $scope.amountUnitStr,
        cardLastNumber: $scope.lastFourDigits
      });

      createTx(wallet, invoice, message, function(err, ctxp) {
        ongoingProcess.set('loadingTxInfo', false);
        if (err) {
          _resetValues();
          showError(err.title, err.message);
          return;
        }

        // Save TX in memory
        createdTx = ctxp;

        $scope.totalAmountStr = txFormatService.formatAmountStr(coin, ctxp.amount);

        setTotalAmount(parsedAmount.amountSat, invoiceFeeSat, ctxp.fee);

      });

    });

  };

  $scope.$on("$ionicView.beforeLeave", function(event, data) {
    $ionicConfig.views.swipeBackEnabled(true);
  });

  $scope.$on("$ionicView.enter", function(event, data) {
    $ionicConfig.views.swipeBackEnabled(false);
  });

  $scope.$on("$ionicView.beforeEnter", function(event, data) {

    cardId = data.stateParams.id;
    useSendMax = data.stateParams.useSendMax;
    amount = data.stateParams.amount;
    currency = data.stateParams.currency;

    bitpayCardService.get({ cardId: cardId, noRefresh: true }, function(err, card) {
      if (err) {
        showErrorAndBack(null, err);
        return;
      }
      bitpayCardService.setCurrencySymbol(card[0]);
      $scope.lastFourDigits = card[0].lastFourDigits;
      $scope.currencySymbol = card[0].currencySymbol;
      $scope.currencyIsoCode = card[0].currency;

      $scope.wallets = profileService.getWallets({
        onlyComplete: true,
        network: bitpayService.getEnvironment().network,
        hasFunds: true,
        coin: coin
      });

      if (lodash.isEmpty($scope.wallets)) {
        showErrorAndBack(null, gettextCatalog.getString('No wallets available'));
        return;
      }

      bitpayCardService.getRates($scope.currencyIsoCode, function(err, r) {
        if (err) $log.error(err);
        $scope.rate = r.rate;
      });

      $scope.onWalletSelect($scope.wallets[0]); // Default first wallet
    });
  });

  $scope.topUpConfirm = function() {

    if (!createdTx) {
      showError(null, gettextCatalog.getString('Transaction has not been created'));
      return;
    }

    var title = gettextCatalog.getString('Confirm');
    var okText = gettextCatalog.getString('OK');
    var cancelText = gettextCatalog.getString('Cancel');
    popupService.showConfirm(title, message, okText, cancelText, function(ok) {
      if (!ok) {
        $scope.sendStatus = '';
        return;
      }

      ongoingProcess.set('topup', true, statusChangeHandler);
      publishAndSign($scope.wallet, createdTx, function() {}, function(err, txSent) {
        if (err) {
          _resetValues();
          ongoingProcess.set('topup', false, statusChangeHandler);
          showError(gettextCatalog.getString('Could not send transaction'), err);
          return;
        }
        ongoingProcess.set('topup', false, statusChangeHandler);
      });
    });
  };

  $scope.showWalletSelector = function() {
    $scope.walletSelectorTitle = gettextCatalog.getString('From');
    $scope.showWallets = true;
  };

  $scope.onWalletSelect = function(wallet) {
    $scope.wallet = wallet;
    ongoingProcess.set('retrievingInputs', true);
    calculateAmount(wallet, function(err, a, c) {
      ongoingProcess.set('retrievingInputs', false);
      if (err) {
        _resetValues();
        showError(err.title, err.message, function() {
          $scope.showWalletSelector();
        });
        return;
      }
      var parsedAmount = txFormatService.parseAmount(coin, a, c);
      initializeTopUp(wallet, parsedAmount);
    });
  };

  $scope.goBackHome = function() {
    $scope.sendStatus = '';
    $ionicHistory.nextViewOptions({
      disableAnimate: true,
      historyRoot: true
    });
    $ionicHistory.clearHistory();
    $state.go('tabs.home').then(function() {
      $state.transitionTo('tabs.bitpayCard', {id: cardId});
    });
  };

});

'use strict';

angular.module('copayApp.controllers').controller('txDetailsController', function($rootScope, $log, $ionicHistory, $scope, $timeout, walletService, lodash, gettextCatalog, profileService, externalLinkService, popupService, ongoingProcess, txFormatService, txConfirmNotification, feeService, configService) {

  var txId;
  var listeners = [];
  var config = configService.getSync();
  var blockexplorerUrl;

  $scope.$on("$ionicView.beforeEnter", function(event, data) {
    txId = data.stateParams.txid;
    $scope.title = gettextCatalog.getString('Transaction');
    $scope.wallet = profileService.getWallet(data.stateParams.walletId);
    $scope.color = $scope.wallet.color;
    $scope.copayerId = $scope.wallet.credentials.copayerId;
    $scope.isShared = $scope.wallet.credentials.n > 1;
    $scope.txsUnsubscribedForNotifications = config.confirmedTxsNotifications ? !config.confirmedTxsNotifications.enabled : true;

    if ($scope.wallet.coin == 'bch') {
      blockexplorerUrl = 'bch-insight.bitpay.com';
    } else {
      blockexplorerUrl = 'bitcoinz.ph';
    }

    txConfirmNotification.checkIfEnabled(txId, function(res) {
      $scope.txNotification = {
        value: res
      };
    });

    updateTx();

    listeners = [
      $rootScope.$on('bwsEvent', function(e, walletId, type, n) {
        if (type == 'NewBlock' && n && n.data && n.data.network == 'livenet') {
          updateTxDebounced({
            hideLoading: true
          });
        }
      })
    ];
  });

  $scope.$on("$ionicView.leave", function(event, data) {
    lodash.each(listeners, function(x) {
      x();
    });
  });

  $scope.readMore = function() {
    var url = 'https://github.com/bitpay/copay/wiki/COPAY---FAQ#amount-too-low-to-spend';
    var optIn = true;
    var title = null;
    var message = gettextCatalog.getString('Read more in our Wiki');
    var okText = gettextCatalog.getString('Open');
    var cancelText = gettextCatalog.getString('Go Back');
    externalLinkService.open(url, optIn, title, message, okText, cancelText);
  };

  function updateMemo() {
    walletService.getTxNote($scope.wallet, $scope.btx.txid, function(err, note) {
      if (err) {
        $log.warn('Could not fetch transaction note: ' + err);
        return;
      }
      if (!note) return;

      $scope.btx.note = note;
      $scope.$apply();
    });
  }

  function initActionList() {
    $scope.actionList = [];
    if ($scope.btx.action != 'sent' || !$scope.isShared) return;

    var actionDescriptions = {
      created: gettextCatalog.getString('Proposal Created'),
      accept: gettextCatalog.getString('Accepted'),
      reject: gettextCatalog.getString('Rejected'),
      broadcasted: gettextCatalog.getString('Broadcasted'),
    };

    $scope.actionList.push({
      type: 'created',
      time: $scope.btx.createdOn,
      description: actionDescriptions['created'],
      by: $scope.btx.creatorName
    });

    lodash.each($scope.btx.actions, function(action) {
      $scope.actionList.push({
        type: action.type,
        time: action.createdOn,
        description: actionDescriptions[action.type],
        by: action.copayerName
      });
    });

    $scope.actionList.push({
      type: 'broadcasted',
      time: $scope.btx.time,
      description: actionDescriptions['broadcasted'],
    });

    $timeout(function() {
      $scope.actionList.reverse();
    }, 10);
  }

  var updateTx = function(opts) {
    opts = opts || {};
    if (!opts.hideLoading) ongoingProcess.set('loadingTxInfo', true);
    walletService.getTx($scope.wallet, txId, function(err, tx) {
      if (!opts.hideLoading) ongoingProcess.set('loadingTxInfo', false);
      if (err) {
        $log.warn('Error getting transaction: ' + err);
        $ionicHistory.goBack();
        return popupService.showAlert(gettextCatalog.getString('Error'), gettextCatalog.getString('Transaction not available at this time'));
      }

      $scope.btx = txFormatService.processTx($scope.wallet.coin, tx);
      txFormatService.formatAlternativeStr($scope.wallet.coin, tx.fees, function(v) {
        $scope.btx.feeFiatStr = v;
        $scope.btx.feeRateStr = ($scope.btx.fees / ($scope.btx.amount + $scope.btx.fees) * 100).toFixed(2) + '%';
      });

      if ($scope.btx.action != 'invalid') {
        if ($scope.btx.action == 'sent') $scope.title = gettextCatalog.getString('Sent Funds');
        if ($scope.btx.action == 'received') $scope.title = gettextCatalog.getString('Received Funds');
        if ($scope.btx.action == 'moved') $scope.title = gettextCatalog.getString('Moved Funds');
      }

      updateMemo();
      initActionList();
      getFiatRate();
      $timeout(function() {
        $scope.$digest();
      });

      feeService.getFeeLevels($scope.wallet.coin, function(err, levels) {
        if (err) return;
        walletService.getLowAmount($scope.wallet, levels, function(err, amount) {
          if (err) return;
          $scope.btx.lowAmount = tx.amount < amount;

          $timeout(function() {
            $scope.$apply();
          });

        });
      });
    });
  };

  var updateTxDebounced = lodash.debounce(updateTx, 5000);

  $scope.showCommentPopup = function() {
    var opts = {};
    if ($scope.btx.message) {
      opts.defaultText = $scope.btx.message;
    }
    if ($scope.btx.note && $scope.btx.note.body) opts.defaultText = $scope.btx.note.body;

    popupService.showPrompt($scope.wallet.name, gettextCatalog.getString('Memo'), opts, function(text) {
      if (typeof text == "undefined") return;

      $scope.btx.note = {
        body: text
      };
      $log.debug('Saving memo');

      var args = {
        txid: $scope.btx.txid,
        body: text
      };

      walletService.editTxNote($scope.wallet, args, function(err, res) {
        if (err) {
          $log.debug('Could not save tx comment ' + err);
        }
      });
    });
  };

  $scope.viewOnBlockchain = function() {
    var btx = $scope.btx;
    var url = 'https://' + ($scope.getShortNetworkName() == 'test' ? 'test-' : '') + blockexplorerUrl + '/tx/' + btx.txid;
    var optIn = true;
    var title = null;
    var message = gettextCatalog.getString('View Transaction on Insight');
    var okText = gettextCatalog.getString('Open Insight');
    var cancelText = gettextCatalog.getString('Go Back');
    externalLinkService.open(url, optIn, title, message, okText, cancelText);
  };

  $scope.getShortNetworkName = function() {
    var n = $scope.wallet.credentials.network;
    return n.substring(0, 4);
  };

  var getFiatRate = function() {
    $scope.alternativeIsoCode = $scope.wallet.status.alternativeIsoCode;
    $scope.wallet.getFiatRate({
      code: $scope.alternativeIsoCode,
      ts: $scope.btx.time * 1000
    }, function(err, res) {
      if (err) {
        $log.debug('Could not get historic rate');
        return;
      }
      if (res && res.rate) {
        $scope.rateDate = res.fetchedOn;
        $scope.rate = res.rate;
      }
    });
  };

  $scope.txConfirmNotificationChange = function() {
    if ($scope.txNotification.value) {
      txConfirmNotification.subscribe($scope.wallet, {
        txid: txId
      });
    } else {
      txConfirmNotification.unsubscribe($scope.wallet, txId);
    }
  };

});

'use strict';

angular.module('copayApp.controllers').controller('versionController', function() {
  this.version = window.version;
  this.commitHash = window.commitHash;
});

'use strict';

angular.module('copayApp.controllers').controller('walletDetailsController', function($scope, $rootScope, $interval, $timeout, $filter, $log, $ionicModal, $ionicPopover, $state, $stateParams, $ionicHistory, profileService, lodash, configService, platformInfo, walletService, txpModalService, externalLinkService, popupService, addressbookService, storageService, $ionicScrollDelegate, $window, bwcError, gettextCatalog, timeService, feeService, appConfigService) {

  var HISTORY_SHOW_LIMIT = 10;
  var currentTxHistoryPage = 0;
  var listeners = [];
  $scope.txps = [];
  $scope.completeTxHistory = [];
  $scope.openTxpModal = txpModalService.open;
  $scope.isCordova = platformInfo.isCordova;
  $scope.isAndroid = platformInfo.isAndroid;
  $scope.isIOS = platformInfo.isIOS;

  $scope.amountIsCollapsible = !$scope.isAndroid;

  $scope.openExternalLink = function(url, target) {
    externalLinkService.open(url, target);
  };

  var setPendingTxps = function(txps) {

    /* Uncomment to test multiple outputs */

    // var txp = {
    //   message: 'test multi-output',
    //   fee: 1000,
    //   createdOn: new Date() / 1000,
    //   outputs: [],
    //   wallet: $scope.wallet
    // };
    //
    // function addOutput(n) {
    //   txp.outputs.push({
    //     amount: 600,
    //     toAddress: '2N8bhEwbKtMvR2jqMRcTCQqzHP6zXGToXcK',
    //     message: 'output #' + (Number(n) + 1)
    //   });
    // };
    // lodash.times(15, addOutput);
    // txps.push(txp);

    if (!txps) {
      $scope.txps = [];
      return;
    }
    $scope.txps = lodash.sortBy(txps, 'createdOn').reverse();
  };

  var analyzeUtxosDone;

  var analyzeUtxos = function() {
    if (analyzeUtxosDone) return;

    feeService.getFeeLevels($scope.wallet.coin, function(err, levels) {
      if (err) return;
      walletService.getLowUtxos($scope.wallet, levels, function(err, resp) {
        if (err || !resp) return;
        analyzeUtxosDone = true;
        $scope.lowUtxosWarning = resp.warning;
      });
    });
  };

  var updateStatus = function(force) {
    $scope.updatingStatus = true;
    $scope.updateStatusError = null;
    $scope.walletNotRegistered = false;

    walletService.getStatus($scope.wallet, {
      force: !!force,
    }, function(err, status) {
      $scope.updatingStatus = false;
      if (err) {
        if (err === 'WALLET_NOT_REGISTERED') {
          $scope.walletNotRegistered = true;
        } else {
          $scope.updateStatusError = bwcError.msg(err, gettextCatalog.getString('Could not update wallet'));
        }
        $scope.status = null;
      } else {
        setPendingTxps(status.pendingTxps);
        $scope.status = status;
      }
      refreshAmountSection();
      $timeout(function() {
        $scope.$apply();
      });

      analyzeUtxos();

    });
  };

  $scope.openSearchModal = function() {
    $scope.color = $scope.wallet.color;
    $scope.isSearching = true;
    $scope.txHistorySearchResults = [];
    $scope.filteredTxHistory = [];

    $ionicModal.fromTemplateUrl('views/modals/search.html', {
      scope: $scope,
      focusFirstInput: true
    }).then(function(modal) {
      $scope.searchModal = modal;
      $scope.searchModal.show();
    });

    $scope.close = function() {
      $scope.isSearching = false;
      $scope.searchModal.hide();
    };

    $scope.openTx = function(tx) {
      $ionicHistory.nextViewOptions({
        disableAnimate: true
      });
      $scope.close();
      $scope.openTxModal(tx);
    };
  };

  $scope.openTxModal = function(btx) {
    $scope.btx = lodash.cloneDeep(btx);
    $scope.walletId = $scope.wallet.id;
    $state.transitionTo('tabs.wallet.tx-details', {
      txid: $scope.btx.txid,
      walletId: $scope.walletId
    });
  };

  $scope.openBalanceModal = function() {
    $ionicModal.fromTemplateUrl('views/modals/wallet-balance.html', {
      scope: $scope
    }).then(function(modal) {
      $scope.walletBalanceModal = modal;
      $scope.walletBalanceModal.show();
    });

    $scope.close = function() {
      $scope.walletBalanceModal.hide();
    };
  };

  $scope.recreate = function() {
    walletService.recreate($scope.wallet, function(err) {
      if (err) return;
      $timeout(function() {
        walletService.startScan($scope.wallet, function() {
          $scope.updateAll();
          $scope.$apply();
        });
      });
    });
  };

  var updateTxHistory = function(cb) {
    if (!cb) cb = function() {};

    $scope.updateTxHistoryError = false;
    $scope.updatingTxHistoryProgress = 0;

    var progressFn = function(txs, newTxs) {
      $scope.updatingTxHistoryProgress = newTxs;
      $scope.completeTxHistory = txs;
      $scope.showHistory();
      $timeout(function() {
        $scope.$apply();
      });
    };

    feeService.getFeeLevels($scope.wallet.coin, function(err, levels) {
      walletService.getTxHistory($scope.wallet, {
        progressFn: progressFn,
        feeLevels: levels,
      }, function(err, txHistory) {
        $scope.updatingTxHistory = false;
        if (err) {
          $scope.txHistory = null;
          $scope.updateTxHistoryError = true;
          return;
        }
        $scope.completeTxHistory = txHistory;
        $scope.showHistory();
        $timeout(function() {
          $scope.$apply();
        });
        return cb();
      });
    });
  };

  $scope.showHistory = function() {
    if ($scope.completeTxHistory) {
      $scope.txHistory = $scope.completeTxHistory.slice(0, (currentTxHistoryPage + 1) * HISTORY_SHOW_LIMIT);
      $scope.txHistoryShowMore = $scope.completeTxHistory.length > $scope.txHistory.length;
    }
  };

  $scope.getDate = function(txCreated) {
    var date = new Date(txCreated * 1000);
    return date;
  };

  $scope.isFirstInGroup = function(index) {
    if (index === 0) {
      return true;
    }
    var curTx = $scope.txHistory[index];
    var prevTx = $scope.txHistory[index - 1];
    return !$scope.createdDuringSameMonth(curTx, prevTx);
  };

  $scope.isLastInGroup = function(index) {
    if (index === $scope.txHistory.length - 1) {
      return true;
    }
    return $scope.isFirstInGroup(index + 1);
  };

  $scope.createdDuringSameMonth = function(curTx, prevTx) {
    return timeService.withinSameMonth(curTx.time * 1000, prevTx.time * 1000);
  };

  $scope.createdWithinPastDay = function(time) {
    return timeService.withinPastDay(time);
  };

  $scope.isDateInCurrentMonth = function(date) {
    return timeService.isDateInCurrentMonth(date);
  };

  $scope.isUnconfirmed = function(tx) {
    return !tx.confirmations || tx.confirmations === 0;
  };

  $scope.showMore = function() {
    $timeout(function() {
      currentTxHistoryPage++;
      $scope.showHistory();
      $scope.$broadcast('scroll.infiniteScrollComplete');
    }, 100);
  };

  $scope.onRefresh = function() {
    $timeout(function() {
      $scope.$broadcast('scroll.refreshComplete');
    }, 300);
    $scope.updateAll(true);
  };

  $scope.updateAll = function(force, cb) {
    updateStatus(force);
    updateTxHistory(cb);
  };

  $scope.hideToggle = function() {
    profileService.toggleHideBalanceFlag($scope.wallet.credentials.walletId, function(err) {
      if (err) $log.error(err);
    });
  };

  var prevPos;

  function getScrollPosition() {
    var scrollPosition = $ionicScrollDelegate.getScrollPosition();
    if (!scrollPosition) {
      $window.requestAnimationFrame(function() {
        getScrollPosition();
      });
      return;
    }
    var pos = scrollPosition.top;
    if (pos === prevPos) {
      $window.requestAnimationFrame(function() {
        getScrollPosition();
      });
      return;
    }
    prevPos = pos;
    refreshAmountSection(pos);
  };

  function refreshAmountSection(scrollPos) {
    $scope.showBalanceButton = false;
    if ($scope.status) {
      $scope.showBalanceButton = ($scope.status.totalBalanceSat != $scope.status.spendableAmount);
    }
    if (!$scope.amountIsCollapsible) {
      var t = ($scope.showBalanceButton ? 15 : 45);
      $scope.amountScale = 'translateY(' + t + 'px)';
      return;
    }

    scrollPos = scrollPos || 0;
    var amountHeight = 210 - scrollPos;
    if (amountHeight < 80) {
      amountHeight = 80;
    }
    var contentMargin = amountHeight;
    if (contentMargin > 210) {
      contentMargin = 210;
    }

    var amountScale = (amountHeight / 210);
    if (amountScale < 0.5) {
      amountScale = 0.5;
    }
    if (amountScale > 1.1) {
      amountScale = 1.1;
    }

    var s = amountScale;

    // Make space for the balance button when it needs to display.
    var TOP_NO_BALANCE_BUTTON = 115;
    var TOP_BALANCE_BUTTON = 30;
    var top = TOP_NO_BALANCE_BUTTON;
    if ($scope.showBalanceButton) {
      top = TOP_BALANCE_BUTTON;
    }

    var amountTop = ((amountScale - 0.7) / 0.7) * top;
    if (amountTop < -10) {
      amountTop = -10;
    }
    if (amountTop > top) {
      amountTop = top;
    }

    var t = amountTop;

    $scope.altAmountOpacity = (amountHeight - 100) / 80;
    $window.requestAnimationFrame(function() {
      $scope.amountHeight = amountHeight + 'px';
      $scope.contentMargin = contentMargin + 'px';
      $scope.amountScale = 'scale3d(' + s + ',' + s + ',' + s + ') translateY(' + t + 'px)';
      $scope.$digest();
      getScrollPosition();
    });
  }

  var scrollWatcherInitialized;

  $scope.$on("$ionicView.enter", function(event, data) {
    if ($scope.isCordova && $scope.isAndroid) setAndroidStatusBarColor();
    if (scrollWatcherInitialized || !$scope.amountIsCollapsible) {
      return;
    }
    scrollWatcherInitialized = true;
  });

  $scope.$on("$ionicView.beforeEnter", function(event, data) {
    $scope.walletId = data.stateParams.walletId;
    $scope.wallet = profileService.getWallet($scope.walletId);
    if (!$scope.wallet) return;
    $scope.requiresMultipleSignatures = $scope.wallet.credentials.m > 1;

    $scope.updatingTxHistory = true;

    addressbookService.list(function(err, ab) {
      if (err) $log.error(err);
      $scope.addressbook = ab || {};
    });

    listeners = [
      $rootScope.$on('bwsEvent', function(e, walletId) {
        if (walletId == $scope.wallet.id && e.type != 'NewAddress')
          $scope.updateAll();
      }),
      $rootScope.$on('Local/TxAction', function(e, walletId) {
        if (walletId == $scope.wallet.id)
          $scope.updateAll();
      }),
    ];
  });

  $scope.$on("$ionicView.afterEnter", function(event, data) {
    $scope.updateAll();
    refreshAmountSection();
  });

  $scope.$on("$ionicView.afterLeave", function(event, data) {

    if ($window.StatusBar) {
      var statusBarColor = appConfigService.name == 'copay' ? '#192c3a' : '#1e3186';
      $window.StatusBar.backgroundColorByHexString(statusBarColor);
    }
  });

  $scope.$on("$ionicView.leave", function(event, data) {
    lodash.each(listeners, function(x) {
      x();
    });
  });

  function setAndroidStatusBarColor() {
    var SUBTRACT_AMOUNT = 15;
    var walletColor;
    if (!$scope.wallet.color) walletColor = appConfigService.name == 'copay' ? '#019477' : '#4a90e2';
    else walletColor = $scope.wallet.color;
    var rgb = hexToRgb(walletColor);
    var keys = Object.keys(rgb);
    keys.forEach(function(k) {
      if (rgb[k] - SUBTRACT_AMOUNT < 0) {
        rgb[k] = 0;
      } else {
        rgb[k] -= SUBTRACT_AMOUNT;
      }
    });
    var statusBarColorHexString = rgbToHex(rgb.r, rgb.g, rgb.b);
    if ($window.StatusBar)
      $window.StatusBar.backgroundColorByHexString(statusBarColorHexString);
  }

  function hexToRgb(hex) {
    // Expand shorthand form (e.g. "03F") to full form (e.g. "0033FF")
    var shorthandRegex = /^#?([a-f\d])([a-f\d])([a-f\d])$/i;
    hex = hex.replace(shorthandRegex, function(m, r, g, b) {
      return r + r + g + g + b + b;
    });

    var result = /^#?([a-f\d]{2})([a-f\d]{2})([a-f\d]{2})$/i.exec(hex);
    return result ? {
      r: parseInt(result[1], 16),
      g: parseInt(result[2], 16),
      b: parseInt(result[3], 16)
    } : null;
  }

  function componentToHex(c) {
    var hex = c.toString(16);
    return hex.length == 1 ? "0" + hex : hex;
  }

  function rgbToHex(r, g, b) {
    return "#" + componentToHex(r) + componentToHex(g) + componentToHex(b);
  }
});

angular.module('copayApp').run(['gettextCatalog', function (gettextCatalog) {
/* jshint -W100 */
    gettextCatalog.setStrings('de', {"(Trusted)":"(Vertraut)","(possible double spend)":"(mgliche Doppelausgabe)","* A payment proposal can be deleted if 1) you are the creator, and no other copayer has signed, or 2) 24 hours have passed since the proposal was created.":"* Ein Zahlungsvorschlag kann gelscht werden, wenn 1) Du diesen erzeugt hast und noch kein anderer Copayer unterschrieben hat, oder 2) 24 Stunden vergangen sind, seit der Vorschlag erstellt wurde.","- {{btx.feeRateStr}} of the transaction":"- {{btx.feeRateStr}}","5-star ratings help us get {{appName}} into more hands, and more users means more resources can be committed to the app!":"Eine 5-Sterne Bewertung hilft uns, {{appName}} unter die Leute zu bringen. Und mehr Nutzer bedeuten, dass uns mehr Ressourcen fr die App-Entwicklung zur Verfgung stehen!","A member of the team will review your feedback as soon as possible.":"Ein Mitarbeiter wird Ihr Feedback so bald wie mglich berprfen.","A total of {{amountAboveMaxSizeStr}} were excluded. The maximum size allowed for a transaction was exceeded.":"Insgesamt wurden {{amountAboveMaxSizeStr}} ausgeschlossen. Die maximale Gre fr eine Transaktion wurde berschritten.","A total of {{amountBelowFeeStr}} were excluded. These funds come from UTXOs smaller than the network fee provided.":"Insgesamt wurden {{amountBelowFeeStr}} ausgeschlossen. Diese Gelder stammen aus UTXOs, die kleiner sind als die Netzwerkgebhr.","About":"ber","Accepted":"Akzeptiert","Account":"Benutzerkonto","Account Number":"Kontonummer","Accounts":"Konten","Activity":"Aktivitt","Add Account":"Konto hinzufgen","Add BitPay Account?":"BitPay-Konto hinzufgen?","Add Contact":"Kontakt hinzufgen","Add Funds":"Guthaben aufladen","Add Memo":"Notiz hinzufgen","Add a password":"Passwort festlegen","Add account":"Konto hinzufgen","Add an optional password to secure the recovery phrase":"Ein optionales Passwort zur Sicherung der Wiederherstellungsphrase hinzufgen","Add description":"Beschreibung hinzufgen","Add wallet":"Wallet hinzufgen","Address":"Adresse","Address Book":"Addressbuch","Address Type":"Adresstyp","Addresses With Balance":"Adressen mit Guthaben","Advanced":"Erweitert","Advanced Settings":"Erweiterte Einstellungen","All":"Alle","All Addresses":"Alle Adressen","All of your bitcoin wallet balance may not be available for immediate spending.":"Mglicherweise kann nicht ihr gesamtes Bitcoin Guthaben sofort ausgegeben werden.","All signing devices must be added to this multisig wallet before bitcoin addresses can be created.":"Alle unterzeichnenden Gerte mssen zu dieser Multi-Signatur Wallet hinzugefgt werden, bevor Bitcoin-Adressen erstellt werden knnen.","Allow Camera Access":"Kamerazugriff erlauben","Allow notifications":"Benachrichtigungen erlauben","Almost done! Let's review.":"Fast fertig! Fassen wir zusammen.","Alternative Currency":"Alternative Whrung","Amount":"Betrag","Amount below minimum allowed":"Betrag unter zulssigem Minimum","Amount too big":"Betrag zu hoch","An update to this app is available. For your security, please update to the latest version.":"Ein Aktualisierung fr diese App ist verfgbar. Zu Ihrer Sicherheit bitte auf die neueste Version aktualisieren.","Anyone with your backup phrase can access or spend your bitcoin.":"Jeder mit Ihrer Wiederherstellungsphrase hat Zugriff auf ihre Bitcoins und kann diese ausgeben.","Are you being watched?":"Werden Sie beobachtet?","Are you being watched? Anyone with your recovery phrase can access or spend your bitcoin.":"Werden Sie beobachtet? Jeder der Ihre Wiederherstellungsphrase kennt, kann auf Ihre Bitcoin zugreifen und diese ausgeben.","Are you sure you want to cancel and delete this wallet?":"Wollen Sie wirklich abbrechen und dieses Wallet lschen?","Are you sure you want to delete this wallet?":"Soll das Wallet wirklich gelscht werden?","Are you sure you want to reject this transaction?":"Wollen Sie wirklich diese Transaktion ablehnen?","Are you sure you want to remove this transaction?":"Wollen Sie wirklich diese Transaktion lschen?","Are you sure you want to skip it?":"Sind Sie sicher dass Sie es berspringen mchten?","Are you sure you would like to remove your BitPay Card ({{lastFourDigits}}) from this device?":"Sind Sie sicher, dass Sie Ihre BitPay-Karte ({{lastFourDigits}}) von diesem Gert entfernen mchten?","Auditable":"Prffhig","Available":"Verfgbar","Available Balance":"Verfgbarer Gesamtbetrag","Average confirmation time":"Durchschnittliche Besttigungzeit","BIP32 path for address derivation":"BIP32 Pfad fr die Adressen-Ableitung","Backup":"Sicherung","Backup Needed":"Backup wird bentigt","Backup all livenet wallets before using this function":"Sichern Sie alle Livenet Wallets, bevor Sie diese Funktion nutzen","Backup needed":"Backup bentigt","Backup now":"Jetzt sichern","Backup wallet":"Sicherung der Wallet","Backup your wallet before using this function":"Sichern Sie ihr Wallet, bevor Sie diese Funktion nutzen","Bad wallet invitation":"Ungltige Einladung","Balance By Address":"Guthaben nach Adresse","Be sure to store your recovery phrase in a secure place. If this app is deleted, your money cannot be recovered without it.":"Achten Sie darauf Ihre Wiederherstellungsphrase an einem sicheren Ort abzulegen. Ihr Geld kann nicht ohne dieser Phrase wiederhergestellt werden falls die App deinstalliert wird.","BitPay Visa Cards":"BitPay Visa&reg; Karten","Bitcoin Address":"Bitcoin-Adresse","Bitcoin Network Fee Policy":"Bitcoin-Netzwerk Gebhrenbersicht","Bitcoin is a currency.":"Bitcoin ist eine Whrung.","Bitcoin is different  it cannot be safely held with a bank or web service.":"Bitcoins sind anders &ndash; sie knnen nicht sicher in einer Bank oder einem Onlinedienst aufbewahrt werden.","Bitcoin is secure,<br>digital money.":"Bitcoin ist sicheres,<br>digitales Geld.","Bitcoin transactions include a fee collected by miners on the network.":"Bitcoin Transaktionen enthalten eine Gebhr fr die \"Miners\" im Netzwerk.","Broadcast Payment":"Zahlung bermitteln","Broadcasted":"Gesendet","Broadcasting transaction":"bermittlung der Transaktion","Browser unsupported":"Browser wird nicht untersttzt","Buy &amp; Sell Bitcoin":"Kaufe &amp; Verkaufe Bitcoins","Buy Bitcoin":"Kaufe Bitcoins","Buying Bitcoin...":"Kaufe Bitcoins...","Calculating fee":"Mining-Fee Berechnung","Cancel":"Abbruch","Cannot Create Wallet":"Wallet kann nicht erstellt werden","Cannot join the same wallet more that once":"An einem Wallet kann nicht mehrfach teilgenommen werden","Cards":"Karten","Certified by":"Zertifiziert von","Check installation and retry.":"Installation berprfen und wiederholen.","Choose a backup file from your computer":"Bitte eine Sicherungsdatei vom Computer whlen","Choose your destination wallet":"Whlen Sie Ihre Ziel-Wallet","Choose your source wallet":"Whlen Sie Ihre Quell-Wallet","Clear":"Leeren","Clear cache":"Cache leeren","Close":"Schlieen","Color":"Farbe","Commit hash":"Hash bertragen","Complete the backup process to use this option":"Beenden Sie den Backupvorgang um diese Option zu nutzen","Confirm":"Besttigen","Confirm &amp; Finish":"Besttigen &amp; Beenden","Confirm your PIN":"PIN besttigen","Confirm your new spending password":"Besttigen Sie Ihr neues Passwort","Confirmations":"Besttigungen","Confirming":"Besttigen","Connect my BitPay Card":"Verbinde meine BitPay-Karte","Connecting to Coinbase...":"Verbinde mit Coinbase...","Connecting to Glidera...":"Verbinde mit Glidera...","Connection reset by peer":"Verbindung von Peer zurckgesetzt","Contacts":"Kontakte","Continue":"Weiter","Contribute Translations":"bersetzungen beitragen","Copayer already in this wallet":"Copayer nimmt bereits teil","Copayer already voted on this spend proposal":"Copayer hat schon fr diesen Zahlungsvorschlag angestimmt","Copayer data mismatch":"Copayer Datenkonflikt","Copayer joined":"Copayer beigetreten","Copayer {{$index}}":"Copayer {{$index}}","Copied to clipboard":"In die Zwischenablage kopiert","Copy this text as it is to a safe place (notepad or email)":"Diesen Text an einem sichern Ort einfgen (Notepad oder E-Mail)","Copy to clipboard":"In die Zwischenablage kopieren","Could not access the wallet at the server. Please check:":"Kein Zugriff auf Wallet des Servers. berprfen Sie bitte:","Could not access wallet":"Auf Wallet konnte nicht zugegriffen werden","Could not add message to imported wallet without shared encrypting key":"Nachricht kann nicht an die importierte Wallet hinzugefgt werden ohne einem gemeinsamen Verschlsselungsschlssel","Could not broadcast payment":"Zahlung konnte nicht gesendet werden","Could not build transaction":"Transaktion konnte nicht erstellt werden","Could not create address":"Adresse konnte nicht erstellt werden","Could not create using the specified extended private key":"Erzeugung mit erweiterten privaten Schlssel nicht mglich","Could not create using the specified extended public key":"Erzeugung mit dem angegebenen erweiterten ffentlichen Schlssel nicht mglich","Could not create: Invalid wallet recovery phrase":"Wallet-Wiederherstellungsphrase nicht gltig","Could not decrypt file, check your password":"Datei konnte nicht entschlsselt werden, bitte das Passwort berprfen","Could not delete payment proposal":"Zahlungsvorschlag konnte nicht gelscht werden","Could not get dynamic fee":"Dynamische Gebhr konnten nicht abgerufen werden","Could not get dynamic fee for level: {{feeLevel}}":"Dynamische Gebhr fr den Level konnte nicht abgerufen werden: {{feeLevel}}","Could not get transactions":"Transaktionen konnten nicht gefunden werden","Could not import":"Import nicht mglich","Could not import. Check input file and spending password":"Import nicht mglich. Bitte Datei und Berechtigungscode berprfen","Could not join wallet":"Beteiligung am Wallet nicht mglich","Could not reject payment":"Zahlung konnte nicht abgelehnt werden","Could not remove account":"Konto konnte nicht entfernt werden","Could not remove card":"Karte konnte nicht gelscht werden","Could not save preferences on the server":"Die Einstellungen konnten nicht am Server gespeichert werden","Could not send payment":"Zahlung kann nicht gesendet werden","Could not update transaction history":"Die Transaktionshistorie konnte nicht aktualisiert werden","Could not update wallet":"Wallet konnte nicht aktualisiert werden","Create Personal Wallet":"Erstelle eine persnliche Wallet","Create Shared Wallet":"Erstelle eine gemeinsame Wallet","Create bitcoin wallet":"Erstelle Bitcoin-Wallet","Create new wallet":"Neues Wallet erzeugen","Create shared wallet":"Erstelle gemeinsame Wallet","Create {{formData.requiredCopayers}}-of-{{formData.totalCopayers}} wallet":"Ein {{formData.requiredCopayers}}-von-{{formData.totalCopayers}} Wallet erzeugen","Created by":"Erstellt von","Creating Wallet...":"Wallet erstellen...","Creating transaction":"Transaktion erstellen","Current fee rate for this policy":"Aktuelle Gebhr fr dieses Verfahren","Custom Amount":"Benutzerdefinierter Betrag","Date":"Datum","Delete":"Lschen","Delete Payment Proposal":"Zahlungsvorschlag lschen","Delete Wallet":"Wallet lschen","Delete it and create a new one":"Lschen und neues Wallet erzeugen","Deleting Wallet...":"Wallet wird gelscht...","Deleting payment proposal":"Lsche Zahlungsvorschlag","Derivation Path":"Ableitungsstruktur","Derivation Strategy":"Ableitungstrategie","Disabled":"Deaktiviert","Do it later":"Spter erledigen","Do not include private key":"Den privaten Schlssel nicht einbeziehen","Don't see your language on Crowdin? Contact the Owner on Crowdin! We'd love to support your language.":"Wird deine Sprache auf Crowdin nicht angezeigt? Kontaktiere den Support von Crowdin, denn wir wrden deine Sprache gerne hinzufgen.","Download":"Herunterladen","Each bitcoin wallet can generate billions of addresses from your 12-word backup. A new address is automatically generated and shown each time you receive a payment.":"Jede Bitcoin-Wallet kann Milliarden von Adressen aus Ihrem 12-Wort Backup erzeugen. Jedesmal wenn Sie eine Zahlung erhalten wird neue Adresse automatisch generiert und dargestellten.","Economy":"Wirtschaftlich","Email":"E-Mail","Email Address":"E-Mail Adresse","Empty addresses limit reached. New addresses cannot be generated.":"Obergrenze fr leere Adressen erreicht. Neue Adressen knnen nicht generiert werden.","Enable camera access in your device settings to get started.":"Aktiviere den Kamerazugriff in Ihren Gerteeinstellungen.","Enable email notifications":"Aktiviere E-Mail Benachrichtigung","Enable push notifications":"Pushbenachrichtigungen aktivieren","Enable the camera to get started.":"Aktivieren Sie die Kamera um loszulegen.","Enter Spending Password":"Berechtigungscode eingeben","Enter Two Factor for your BitPay account":"Eingabe des Zwei-Faktor-Authentifizierungs-Codes fr das BitPay Konto","Enter new spending password":"Neuen Berechtigungscode eingeben","Enter the recovery phrase (BIP39)":"Wiederherstellungsphrase eingeben (BIP39)","Enter your password":"Passwort eingeben","Error":"Fehler","Error at confirm":"Fehler beim besttigen","Error creating wallet":"Fehler beim Erstellen des Wallets","Error scanning funds:":"Fehler beim Ermitteln des Guthaben:","Error sweeping wallet:":"Fehler beim Leeren der Wallet:","Error updating Debit Cards":"Fehler beim Aktualisieren der Debitkarten","Exceeded daily limit of $500 per user":"Tageslimit von $500 pro Benutzer berschritten","Expired":"Abgelaufen","Expires":"Gltig bis","Export Wallet":"Wallet exportieren","Export to file":"In eine Datei exportieren","Export wallet":"Wallet exportieren","Exporting via QR not supported for this wallet":"Fr diese Wallet ist Export per QR nicht untersttzt","Extended Public Keys":"Erweiterte ffentliche Schlssel","Failed to export":"Fehler beim Exportieren","Family vacation funds":"Familienurlaub","Fee":"Gebhr","Feedback could not be submitted. Please try again later.":"Feedback konnte nicht abgeschickt werden. Bitte versuchen Sie es spter erneut.","Fetching BitPay Account...":"BitPay Konto abrufen...","File/Text":"Datei/Text","Finger Scan Failed":"Abtasten des Fingerabdrucks gescheitert","Finish":"Beenden","For audit purposes":"Zur Kontrolle","From":"Von","From BitPay account":"Von BitPay Konto","From the destination device, go to Add wallet &gt; Import wallet and scan this QR code":"Gehen Sie auf Wallet Hinzufgen &gt; Wallet Importieren von dem Zielgert und scannen Sie diesen QR-Code","Funds are locked by pending spend proposals":"Betrge sind durch ausstehende Zahlungsvorschlge gesperrt","Funds found:":"Betrag gefunden:","Funds transferred":"Betrag bermittelt","Funds will be transferred to":"Betrge werden berwiesen an","Generating .csv file...":"CSV-Datei erzeugen...","Generating new address...":"Neue Adresse erzeugen...","Get local cash anywhere you go, from any Visa<sup></sup> compatible ATM. ATM bank fees may apply.":"Erhalten Sie Bargeld berall von einem Visa<sup>&reg;</sup> kompatiblen Bankomaten. Es fallen eventuell Bankomatgebhren an.","Get news and updates from BitPay":"Erhalten Sie Neuigkeiten und Aktualisierungen von BitPay","Get started":"Los gehts","Get started by adding your first one.":"Starten Sie indem Sie ihr erstes hinzufgen.","Getting fee levels...":"Entgelt-Level werden abgerufen...","Go Back":"Zurck","Go back":"Zurck","Got it":"Habe verstanden","Hardware Wallet":"Hardware-Wallet","Hardware not connected.":"Hardware nicht verbunden.","Hardware wallet":"Hardware-Wallet","Help & Support":"Hilfe & Support","Help and support information is available at the website.":"Hilfe und Support-Informationen gibt es auf der Website.","Hide":"Verstecken","Hide Balance":"Guthaben Verstecken","Hide Next Steps Card":"Nchste Schritte der Karte ausblenden","Hide advanced options":"Erweiterte Optionen ausblenden","Home":"Start","How could we improve your experience?":"Wie knnen wir Ihre Zufriedenheit verbessern?","How do you like {{appName}}?":"Wie gefllt Ihnen {{appName}}?","I don't like it":"Das gefllt mir nicht","I have read, understood, and agree to the <a ng-click=\"openTerms()\" translate=\"\">Terms of Use</a>.":"Ich habe die <a ng-click=\"openTerms()\" translate=\"\">Nutzungsbedingungen</a> gelesen, verstanden und stimme ihnen zu.","I have read, understood, and agree with the Terms of use.":"Ich habe die Nutzungsbedingungen gelesen und stimme ihnen zu.","I have written it down":"Ich habe es aufgeschrieben","I like the app":"Mir gefllt die App","I think this app is terrible.":"Diese App ist furchtbar.","I understand":"Ich verstehe","I understand that if this app is moved to another device or deleted, my bitcoin can only be recovered with the backup phrase.":"Ich verstehe, dass wenn diese App auf ein anderes Gert verschoben oder gelscht wird, meine Bitcoins nur mit der Wiederherstellungsphrase wiederhergestellt werden knnen.","I understand that my funds are held securely on this device, not by a company.":"Ich verstehe, dass mein Geld auf diesem Gert und nicht von einem Unternehmen gesichert wird.","I've written it down":"Ich habe es aufgeschrieben","If enabled, all sensitive information (private key and recovery phrase) and actions (spending and exporting) associated with this wallet will be protected.":"Wenn aktiviert, werden alle vertraulichen Informationen (private Schlssel und Wiederherstellungs Satz) und die zugeordneten Aktionen (Ausgaben und Exporte) des Wallets geschtzt.","If enabled, the Recent Transactions card - a list of transactions occuring across all wallets - will appear in the Home tab.":"Wenn aktiviert wird die \"Krzlich Ausgefhrte Transaktionen\" Karte - eine Liste von Transaktionen aller Wallets - in der Registerkarte \"Start\" erscheinen.","If enabled, wallets will also try to spend unconfirmed funds. This option may cause transaction delays.":"Wenn aktiviert werden Wallets auch versuchen unbesttigtes Vermgen auszugeben. Diese Option kann zu Transaktionsverzgerungen fhren.","If this device is replaced or this app is deleted, neither you nor BitPay can recover your funds without a backup.":"Wenn dieses Gert ersetzt oder diese App gelscht wird, so knnen weder Sie noch BitPay Ihr Geld ohne eine Sicherung wiederherstellen.","If you have additional feedback, please let us know by tapping the \"Send feedback\" option in the Settings tab.":"Wenn Sie zustzliches Feedback haben, so lassen Sie uns es wissen indem Sie auf die Option \"Feedback senden\" in der Registerkarte \"Einstellungen\" drcken.","If you take a screenshot, your backup may be viewed by other apps. You can make a safe backup with physical paper and a pen.":"Wenn Sie einen Screenshot erstellen, kann die Sicherung von anderen Apps angesehen werden. Sie knnen ein sicheres Backup mit Papier und Stift erstellen.","Import":"Import","Import Wallet":"Wallet importieren","Import backup":"Importiere Sicherung","Import wallet":"Wallet importieren","Importing Wallet...":"Wallet wird importiert...","In order to verify your wallet backup, please type your password.":"Um die Sicherung der Wallet zu berprfen, geben Sie bitte Ihr Passwort ein.","Incomplete":"Unvollstndig","Incomplete wallet":"Unvollstndige Wallet","Incorrect PIN, try again.":"Falscher PIN, bitte erneut versuchen.","Incorrect code format":"QR code hat falsches Format","Insufficient funds":"Nicht ausreichendes Guthaben","Insufficient funds for fee":"Nicht ausreichendes Guthaben fr die Gebhr","Invalid":"Ungltig","Invalid account number":"Ungltige Kontonummer","Invalid address":"Ungltige Adresse","Invalid data":"Ungltige Daten","Invalid derivation path":"Ungltige Ableitungsstruktur","Invitation to share a {{appName}} Wallet":"Einladung um eine {{appName}} Wallet zu teilen","Is there anything we could do better?":"Gibt es etwas, das wir besser machen knnen?","Is this correct?":"Ist das richtig?","Is this email address correct?":"Ist diese E-Mail Adresse korrekt?","It's a good idea to avoid reusing addresses - this both protects your privacy and keeps your bitcoins secure against hypothetical attacks by quantum computers.":"Es ist eine gute Idee Adressen nicht wiederzuverwenden - dies schtzt Ihre Privatsphre und hlt Ihre Bitcoins vor hypothetischen Angriffen durch Quanten-Computern sicher.","It's important that you write your backup phrase down correctly. If something happens to your wallet, you'll need this backup to recover your money. Please review your backup and try again.":"Es ist wichtig dass Sie Ihre Wiederherstellungsphrase korrekt aufschreiben. Wenn etwas mit Ihrer Wallet passiert bentigen Sie diese Sicherung um Ihr Geld wiederherstellen zu knnen. Bitte berprfen Sie Ihre Sicherung und versuchen Sie es erneut.","Join":"Teilnehmen","Join my {{appName}} Wallet. Here is the invitation code: {{secret}} You can download {{appName}} for your phone or desktop at {{appUrl}}":"Meiner {{appName}} Wallet beitreten. Hier ist der Einladungs-Code: {{secret}} Sie knnen {{appName}} fr Ihr Telefon oder Desktop auf {{appUrl}} herunterladen","Join shared wallet":"Gemeinschaftliches Wallet","Joining Wallet...":"Teilnahme am Wallet einrichten...","Just scan the code to pay.":"Scannen Sie einfach den Code um zu zahlen.","Key already associated with an existing wallet":"Schlssel ist bereits mit einem existierenden Wallet verbunden","Language":"Sprache","Last Month":"Letzter Monat","Let's verify your backup phrase.":"berprfen Sie Ihre Wiederherstellungsphrase.","Loading addresses...":"Lade Adressen...","Loading transaction info...":"Transaktionen werden geladen...","Lock App":"App sperren","Lock by Fingerprint":"Mit Fingerabdruck sperren","Lock by PIN":"Mit PIN sperren","Locked":"Gesperrt","Locktime in effect. Please wait to create a new spend proposal":"Zeitsperre aktiv. Bitte mit neuem Zahlungsvorschlag warten","Locktime in effect. Please wait to remove this spend proposal":"Zeitsperre aktiv. Bitte auf die Entfernung des Zahlungsvorschlags warten","Low fees":"Niedrige Gebhren","Makes sense":"Macht Sinn","Matches:":"bereinstimmungen:","Me":"Ich","Meh - it's alright":"Meh - ist in Ordnung","Memo":"Notiz","Merchant Message":"Hndlernachricht","Missing parameter":"Angabe fehlt","Missing private keys to sign":"Zum Signieren fehlen die privaten Schlssel","More Options":"Weitere Optionen","Moved":"Verschoben","Moved Funds":"Guthaben verschoben","Multiple recipients":"Mehrere Empfnger","NOTE: To import a wallet from a 3rd party software, please go to Add Wallet &gt; Create Wallet, and specify the Recovery Phrase there.":"Hinweis: Um eine Brieftasche aus einer 3rd-Party-Software zu importieren, gehen Sie bitte auf Wallet Hinzufgen &gt; Wallet Importieren, und geben Sie die Wiederhestellungsphrase ein.","Name":"Name","Network error":"Netzwerkfehler","New Proposal":"Neuer Vorschlag","New address could not be generated. Please try again.":"Neue Adresse konnte nicht erstellt werden. Bitte versuche es erneut.","New personal wallet":"Neue persnliche Wallet","Next steps":"Nchste Schritte","No Wallet":"Keine Wallet","No backup, no bitcoin.":"Keine Sicherung, keine Bitcoins.","No contacts yet":"Noch keine Kontakte","No hardware information available.":"Keine Hardwareinformationen verfgbar.","No hardware wallets supported on this device":"Hardware-Wallets werden auf diesem Gert nicht untersttzt","No pending proposals":"Keine ausstehenden Vorschlge","No recent transactions":"Keine aktuellen Transaktionen","No transactions yet":"Noch keine Transaktionen","No wallet found":"Kein Wallet gefunden","No wallet selected":"Kein Wallet ausgewhlt","No wallets available to receive funds":"Keine Wallet verfgbar um Guthaben zu erhalten","Normal":"Normal","Not authorized":"Nicht berechtigt","Not enough funds for fee":"Das Guthaben reicht nicht fr die Gebhr","Not even BitPay can access it.":"Nicht einmal BitPay kann darauf zugreifen.","Not funds found":"Kein Guthaben gefunden","Not now":"Nicht jetzt","Note":"Notiz","Notice: only 1-1 (single signature) wallets can be used for sell bitcoin":"Hinweis: nur 1-1 (Einzelunterschrift) Wallets knnen verwendet werden um Bitcoins zu verkaufen","Notifications":"Benachrichtigungen","Now is a good time to backup your wallet. If this device is lost, it is impossible to access your funds without a backup.":"Jetzt ist ein guter Zeitpunkt um Ihre Wallet zu sichern. Wenn das Gert verloren geht ist es unmglich ohne eine Sicherung auf Ihr Geld zuzugreifen.","Now is a perfect time to assess your surroundings. Nearby windows? Hidden cameras? Shoulder-spies?":"Jetzt ist die perfekte Zeit um Ihre Umgebung zu berprfen. In der Nhe eines Fensters? Versteckte Kameras? Schulter-Spione?","OK":"OK","OKAY":"Okay","Official English Disclaimer":"Offizieller englischer Haftungsausschluss","Oh no!":"Oh nein!","On this screen you can see all your wallets, accounts, and assets.":"Auf diesem Bildschirm sehen Sie alle Ihre Wallets, Konten und Guthaben.","Open":"ffnen","Open Crowdin":"ffne Crowdin","Open GitHub":"ffne GitHub","Open GitHub Project":"ffne GitHub Projekt","Open Insight":"ffne Insight","Open Settings":"ffne Einstellungen","Open Translation Community":"ffne bersetzungs-Community","Open Website":"ffne Website","Open wallet":"ffne Wallet","Order the BitPay Card":"BitPay-Karte bestellen","Password":"Passwort","Password required. Make sure to enter your password in advanced options":"Passwort erforderlich. Geben Sie Ihr Passwort in den erweiterten Optionen ein","Paste invitation here":"Einladung hier einfgen","Paste the backup plain text code":"Den Klartext der Sicherung einfgen","Pay 0% fees to turn bitcoin into dollars.":"Zahle 0 % Gebhren um Bitcoins in Dollar zu wechseln.","Pay To":"Zahle an","Payment Accepted":"Zahlung angenommen","Payment Expires:":"Zahlung luft ab:","Payment Proposal":"Zahlungsvorschlag","Payment Proposal Created":"Zahlungsvorschlag erstellt","Payment Proposals":"Zahlungsvorschlge","Payment Protocol Invalid":"Ungltiges Zahlungsprotokoll","Payment Protocol not supported on Chrome App":"Zahlungsprotokoll wird nicht von der Chrome App untersttzt","Payment Received":"Zahlung erhalten","Payment Rejected":"Zahlung abgelehnt","Payment Sent":"Zahlung gesendet","Payment accepted, but not yet broadcasted":"Zahlung akzeptiert, aber noch nicht bermittelt","Payment accepted. It will be broadcasted by Glidera. In case there is a problem, it can be deleted 6 hours after it was created.":"Zahlung akzeptiert. Sie wird durch Glidera bermittelt. Falls ein Problem auftritt, kann sie nach einer Wartezeit von 6 Stunden gelscht werden.","Payment details":"Zahlungsdetails","Payment request":"Zahlungsanforderung","Pending Proposals":"Anstehende Vorschlge","Permanently delete this wallet.":"Wallet dauerhaft lschen.","Personal Wallet":"Persnliches Wallet","Please carefully write down this phrase.":"Notieren Sie bitte sorgfltig diese Phrase.","Please connect a camera to get started.":"Bitte verbinden Sie eine Kamera um loszulegen.","Please enter the recovery phrase":"Bitte geben Sie die Wiederherstellungsphrase ein","Please enter the wallet recovery phrase":"Bitte geben Sie die Wallet-Wiederherstellungsphrase ein","Please enter your PIN":"Bitte geben Sie Ihre PIN ein","Please tap each word in the correct order.":"Bitte tippen Sie jedes Wort in der richtigen Reihenfolge.","Please upgrade Copay to perform this action":"Bitte Copay aktualisieren, um diese Aktion auszufhren","Please, select your backup file":"Bitte die Sicherungsdatei whlen","Preferences":"Einstellungen","Preparing addresses...":"Adressen werden vorbereitet...","Preparing backup...":"Sicherung wird vorbereitet...","Press again to exit":"Zum Beenden erneut drcken","Priority":"hchste Prioritt","Private key encrypted. Enter password":"Privater Schlssel verschlsselt. Passwort eingeben","Private key is encrypted, cannot sign":"Der private Schlssel ist verschlsselt, signieren ist nicht mglich","Proposal Accepted":"Vorschlag angenommen","Proposal Created":"Vorschlag erstellt","Proposal Deleted":"Vorschlag gelscht","Proposal Rejected":"Vorschlag abgelehnt","Proposals":"Vorschlge","Push Notifications":"Push-Benachrichtigungen","Push notifications for {{appName}} are currently disabled. Enable them in the Settings app.":"Push-Benachrichtigungen fr {{appName}} sind derzeit deaktiviert. Aktivieren Sie diese in den Einstellungen.","QR Code":"QR-Code","Quick review!":"Schnelle berprfung!","Random":"Per Zufall","Rate on the app store":"Im App Store bewerten","Read less":"Weniger anzeigen","Read more":"Mehr anzeigen","Receive":"Empfangen","Received":"Empfangen","Received Funds":"Erhaltener Betrag","Receiving":"Eingehend","Recent":"Krzlich","Recent Transaction Card":"Krzlich Ausgefhrte Transaktionen Karte","Recent Transactions":"Krzliche Transaktionen","Recipient":"Empfnger","Recipients":"Empfnger","Recovery phrase":"Wiederherstellungsphrase","Recreating Wallet...":"Wallet wiederherstellen...","Rejected":"Abgelehnt","Rejecting payment proposal":"Ablehnung des Zahlungsvorschlags","Release information":"Release-Informationen","Remove BitPay Account?":"BitPay-Konto entfernen?","Remove BitPay Card?":"BitPay Karte entfernen?","Removing your BitPay account will remove all associated BitPay account data from this device. Are you sure you would like to remove your BitPay Account ({{email}}) from this device?":"Das Entfernen des BitPay-Kontos lscht alle zugehrigen Daten von diesem Gert. Soll wirklich das BityPay-Konto ({{email}}) von diesem Gert entfernt werden?","Repeat password":"Passwort wiederholen","Repeat the password":"Passwort wiederholen","Request Fingerprint":"Fingerabdruck anfordern","Request Specific amount":"Einen bestimmten Betrag anfordern","Request Spending Password":"Berechtigungscode abfragen","Required number of signatures":"Erforderliche Anzahl von Signaturen","Restore from backup":"Von Sicherung wiederherstellen","Retrieving inputs information":"Eingnge werden abgerufen","Retry":"Nochmals versuchen","Retry Camera":"Kamera nochmals versuchen","Save":"Speichern","Scan":"Scannen","Scan QR Codes":"QR-Code scannen","Scan addresses for funds":"Adresse auf neue Betrge berprfen","Scan your fingerprint please":"Scannen Sie bitte Ihren Fingerabdruck","Scanning Wallet funds...":"Prfe Wallet auf neue Betrge...","Screenshots are not secure":"Screenshots sind nicht sicher","Search Transactions":"Transaktionen durchsuchen","Search or enter bitcoin address":"Bitcoin-Adresse suchen oder eingeben","Search transactions":"Transaktionen durchsuchen","Search your currency":"Suchen Sie Ihre Whrung","Security":"Sicherheit","Select a backup file":"Eine Sicherungsdatei auswhlen","Select a wallet":"Wallet whlen","Self-signed Certificate":"Selbstsigniertes Zertifikat","Selling Bitcoin...":"Verkauf von Bitcoins...","Send":"Senden","Send Feedback":"Feedback senden","Send Money":"Geld senden","Send addresses by email":"Adressen per e-Mail versenden","Send by email":"Per E-Mail versenden","Send from":"Senden von","Send max amount":"Sende max. Betrag","Send us feedback instead":"Senden Sie uns Feedback stattdessen","Sending":"Senden","Sending 2FA code...":"2FA Code senden...","Sending feedback...":"Feedback wird gesendet...","Sending maximum amount":"Sende maximalen Betrag","Sending transaction":"Sende Transaktion","Sending {{amountStr}} from your {{name}} wallet":"Sende {{amountStr}} aus Ihrer Wallet {{name}}","Sent":"Gesendet","Sent Funds":"Guthaben senden","Server response could not be verified":"Antwort des Servers konnte nicht verifiziert werden","Services":"Services","Session Log":"Sitzungsprotokoll","Session log":"Sitzungsprotokoll","Set up a password":"Passwort einrichten","Settings":"Einstellungen","Share the love by inviting your friends.":"Teilen Sie die Liebe indem Sie Ihre Freunde einladen.","Share this invitation with your copayers":"Einladung mit Copayern teilen","Share {{appName}}":"{{appName}} weiterleiten","Shared Wallet":"Wallet teilen","Show Recovery Phrase":"Wiederherstellungsphrase anzeigen","Show address":"Adresse anzeigen","Show advanced options":"Erweiterte Optionen anzeigen","Show bitcoin address":"Bitcoin-Adresse anzeigen","Show more":"Mehr anzeigen","Signatures rejected by server":"Signaturen wurden vom Server abgelehnt","Signing transaction":"Unterschreibe Transaktion","Since only you control your money, youll need to save your backup phrase in case this app is deleted.":"Da nur Sie Ihr Geld kontrollieren mssen Sie Ihre Wiederherstellungsphrase gut sichern, fr den Fall dass die App gelscht wird.","Single Address Wallet":"Wallet mit einer einzigen Adresse","Skip":"berspringen","Specify Recovery Phrase...":"Wiederherstellungsphrase angeben...","Spend proposal is not accepted":"Zahlungsvorschlag wurde nicht akzeptiert","Spend proposal not found":"Zahlungsvorschlag wurde nicht gefunden","Spending Password needed":"Berechtigungscode erforderlich","Start sending bitcoin":"Starte mit dem Senden der Bitcoins","Startup Lock":"Sperre des Startups","Super Economy":"Niedrigste Prioritt","Sweep":"Leeren","Sweep paper wallet":"Paperwallet lschen","Sweeping Wallet...":"Leere Wallet...","THIS ACTION CANNOT BE REVERSED":"DIESE AKTION KANN NICHT RCKGNGIG GEMACHT WERDEN","Take control of your money,<br>get started with bitcoin.":"bernehmen Sie die Kontrolle ber Ihr Geld, <br>Legen Sie los mit Bitcoins.","Tap and hold to show":"Anzeigen durch tippen und halten","Tap to retry":"Zum Wiederholen antippen","Terms Of Use":"Nutzungsbedingungen","Terms of Use":"Nutzungsbedingungen","Testnet":"Testnet","Thank you!":"Vielen Dank!","Thanks!":"Danke!","That's exciting to hear. We'd love to earn that fifth star from you  how could we improve your experience?":"Wir sind gespannt es zu erfahren. Wir wrden uns freuen fnf Sterne von Ihnen zu erhalten - Wie knnen wir Ihre Erfahrung verbessern?","The Ledger Chrome application is not installed":"Die Chrome-Anwendung fr Ledger ist nicht installiert","The amount of bitcoin immediately spendable from this wallet.":"Den Betrag an Bitcoins sofort aus dieser Wallet zahlen.","The amount of bitcoin stored in this wallet that is allocated as inputs to your pending transaction proposals. The amount is determined using unspent transaction outputs associated with this wallet and may be more than the actual amounts associated with your pending transaction proposals.":"Der Betrag an Bitcoins gespeichert in dieser Wallet ist zugewiesen als Einsatz fr die ausstehende Transaktion. Dem Betrag wurde zugewiesen unverbrauchte Transaktions-Ausgnge zu verwenden, welche mit dieser Brieftasche verbunden sind, und entspricht mglicherweise mehr als die tatschlichen Betrge welche im Zusammenhang mit Ihren ausstehenden Transaktions-Betrag stehen.","The amount of bitcoin stored in this wallet with less than 1 blockchain confirmation.":"Die Menge an Bitcoins sind in dieser Geldbrse mit weniger als 1 Blockchain Besttigung gespeichert.","The derivation path":"Die Ableitungsstruktur","The exchange rate changes with the market.":"Der Wechselkurs ndert sich mit dem Markt.","The higher the fee, the greater the incentive a miner has to include that transaction in a block. Current fees are determined based on network load and the selected policy.":"Je hher die Gebhr, desto grer ist der Anreiz das ein \"Miner\" die Transaktion in einem \"Block\" inkludiert. Aktuelle Gebhren werden anhand der Netzauslastung und der ausgewhlten Richtlinie bestimmt.","The maximum number of consecutive unused addresses (20) has been reached. When one of your unused addresses receives a payment, a new address will be generated and shown in your Receive tab.":"Die maximale Anzahl aufeinander folgender ungenutzter Adressen (20) wurde erreicht. Wenn eine Ihrer ungenutzten Adressen eine Zahlung erhlt wird eine neue Adresse erzeugt und in der Registerkarte \"Empfangen\" gezeigt.","The official English Terms of Service are available on the BitPay website.":"Die offizielle englischen Nutzungsbedingungen sind auf der BitPay Website verfgbar.","The password of the recovery phrase (if set)":"Das Passwort der Wiederherstellungsphrase (wenn eingestellt)","The payment was created but could not be completed. Please try again from home screen":"Die Zahlung wurde erzeugt, kann aber nicht abgeschlossen werden. Bitte erneut ber die Startseite versuchen","The payment was removed by creator":"Die Zahlung wurde vom Ersteller entfernt","The recovery phrase could require a password to be imported":"Um die Wiederherstellungsphrase zu importieren knnte ein Passwort ntig sein","The request could not be understood by the server":"Die Anforderung konnte nicht vom Server interpretiert werden","The restore process will stop when 20 addresses are generated in a row which contain no funds. To safely generate more addresses, make a payment to one of the unused addresses which has already been generated.":"Der Wiederherstellungsvorgang wird beendet wenn 20 hintereinander generierte Adressen keinen Betrag erhalten. Um sicher mehr Adressen generieren zu knnen fhren Sie eine Zahlung zu einer der ungenutzten Adressen durch welche bereits erzeugt wurden.","The spend proposal is not pending":"Der Zahlungsvorschlag ist nicht ausstehend","The total amount of bitcoin stored in this wallet.":"Der Gesamtbetrag an Bitcoins vorrtig in dieser Wallet.","The transaction history and every new incoming transaction are cached in the app. This feature clean this up and synchronizes again from the server":"Die Transaktionshistorie und jede neue eingehende Transaktion werden in der App zwischengespeichert. Diese Funktion bereinigt dies und synchronisiert erneut vom Server","The wallet service URL":"Die URL des Wallet-Diensts","There is a new version of {{appName}} available":"Es steht eine neue Version von {{appName}} zur Verfgung","There is an error in the form":"Es ist ein Fehler im Formular aufgetreten","There's obviously something we're doing wrong.":"Hier ist offensichtlich etwas was wir falsch machen.","This app is fantastic!":"Diese App ist fantastisch!","This app stores your bitcoin with cutting-edge security.":"Diese App speichert Ihre Bitcoins mit modernster Sicherheit.","This bitcoin payment request has expired.":"Diese Bitcoin Zahlungsaufforderung ist abgelaufen.","This password cannot be recovered. If the password is lost, there is no way you could recover your funds.":"Dieses Passwort kann nicht wiederhergestellt werden. Wenn das Passwort verloren gegangen ist gibt es keine Mglichkeit mehr Ihr Geld zurck zu holen.","This recovery phrase was created with a password. To recover this wallet both the recovery phrase and password are needed.":"Diese Wiederherstellungsphrase entstand mit einem Passwort. Zur Wiederherstellung der Wallet sind die Wiederherstellungsphrase und das Passwort erforderlich.","This transaction could take a long time to confirm or could be dropped due to the low fees set by the sender":"Die Besttigung dieser Transaktion kann sehr lange dauern oder verworfen werden, da vom Absender nur geringe Gebhren eingestellt wurden","This wallet is not registered at the given Bitcore Wallet Service (BWS). You can recreate it from the local information.":"Dieses Wallet ist nicht beim angegebenen Bitcore Wallet Service (BWS) registriert. Bitte aus den lokalen Informationen wiederherstellen","Timeline":"Zeitachse","To":"An","To get started, buy bitcoin or share your address. You can receive bitcoin from any wallet or service.":"Um loszulegen kaufe Bitcoins oder teilen Sie ihre Adresse. Sie knnen Bitcoins von jeder beliebigen Wallet oder von einem Dienstleister/Broker empfangen.","To get started, you'll need to create a bitcoin wallet and get some bitcoin.":"Um loszulegen mssen Sie eine Bitcoin-Wallet erstellen und einige Bitcoins erhalten.","Total":"Gesamt","Total Locked Balance":"Ingesamt gesperrter Gesamtsaldo","Total number of copayers":"Gesamtanzahl der Copayer","Touch ID Failed":"Touch-ID gescheitert","Transaction":"Transaktion","Transaction History":"Transaktionsverlauf","Transaction already broadcasted":"Transaktion wurde bereits bermittelt","Transaction not available at this time":"Transaktion ist zu diesem Zeitpunkt nicht verfgbar","Transaction not found":"Transaktion konnte nicht gefunden werden","Transfer to Wallet":"bertragung zur Wallet","Try again in {{expires}}":"Versuchen Sie es erneut in {{expires}}","Turn bitcoin into dollars, swipe anywhere Visa<sup></sup> is accepted.":"Wechseln Sie Bitcoins in Dollar, wechseln Sie berall wo Visa<sup>&reg;</sup> akzeptiert wird.","Type the Recovery Phrase (usually 12 words)":"Wiederherstellungsphrase eingeben (in der Regel 12 Wrter)","Uh oh...":"Uh oh...","Unconfirmed":"Unbesttigt","Unsent transactions":"Nicht vesendete Transaktionen","Unused Addresses":"Nicht verwendete Adressen","Unused Addresses Limit":"Nicht genutzte Adressen Limit","Update Available":"Aktualisierung verfgbar","Updating pending proposals. Please stand by":"Aktualisiere anstehende Vorschlge. Bitte warten","Updating transaction history. Please stand by.":"Aktualisieren des Transaktionsverlaufs. Bitte warten.","Updating... Please stand by":"Aktualisiere... Bitte warten","Urgent":"Dringend","Use Unconfirmed Funds":"Unbesttigte Mittel einsetzen","Validating recovery phrase...":"berprfe Wiederherstellungsphrase...","Version":"Version","View":"Ansicht","View All Addresses":"Alle Adressen anzeigen","View Terms of Service":"Nutzungsbedingungen anzeigen","View Transaction on Insight":"Transaktionen auf Insight anzeigen","View Update":"Aktualisierungen anzeigen","View on blockchain":"Auf blockchain anzeigen","WARNING: Key derivation is not working on this device/wallet. Actions cannot be performed on this wallet.":"Warnung: Ableitung der Schlssel funktioniert nicht auf diesem Gert/Wallet. Aktionen knnen nicht mit dieser Wallet durchgefhrt werden.","WARNING: Not including the private key allows to check the wallet balance, transaction history, and create spend proposals from the export. However, does not allow to approve (sign) proposals, so <b>funds will not be accessible from the export</b>.":"WARNUNG: Ohne das Hinzufgen des privaten Schlssels, ist es mglich das Guthaben und die Transaktionshistorie einzusehen, sowie Zahlungsvorschlge zu erzeugen. Allerdings knnen Vorschlge nicht ausgefhrt (unterschrieben) werden und es ist <b>kein Zugriff auf Guthaben mglich</b>.","WARNING: The private key of this wallet is not available. The export allows to check the wallet balance, transaction history, and create spend proposals from the export. However, does not allow to approve (sign) proposals, so <b>funds will not be accessible from the export</b>.":"WARNUNG: Der private Schlssel ist nicht verfgbar. Dieser Export ermglicht das Guthaben und die Transaktionshistorie zu prfen, sowie Zahlungsvorschlge zu erzeugen. Allerdings knnen Vorschlge nicht ausgefhrt (unterschrieben) werden und so ist <b>kein Zugriff auf Guthaben mglich</b>.","WARNING: UNTRUSTED CERTIFICATE":"WARNUNG: NICHT VERTRAUENSWRDIGES ZERTIFIKAT","Waiting for Ledger...":"Warte auf Ledger...","Waiting for Trezor...":"Warte auf Trezor...","Waiting for copayers":"Warte auf copayer","Waiting...":"Warte...","Wallet Addresses":"Wallet-Adressen","Wallet Color":"Wallet-Farbe","Wallet Configuration (m-n)":"Wallet-Konfiguration (m-n)","Wallet Created":"Wallet erstellt","Wallet Id":"Wallet-Id","Wallet Information":"Wallet-Informationen","Wallet Invitation":"Wallet Einladung","Wallet Key":"Wallet-Schlssel","Wallet Name":"Wallet-Name","Wallet Name (at creation)":"Wallet-Name (bei der Erzeugung)","Wallet Network":"Wallet-Netzwerk","Wallet Recovery Phrase":"Wallet-Wiederherstellungsphrase","Wallet Recovery Phrase is invalid":"Wallet-Wiederherstellungsphrase ist ungltig","Wallet Service URL":"URL des Wallet-Diensts","Wallet Settings":"Wallet-Einstellungen","Wallet Type":"Wallet-Typ","Wallet already exists":"Wallet exstiert bereits","Wallet created":"Wallet erstellt","Wallet incomplete and broken":"Wallet unvollstndig oder defekt","Wallet is full":"Maximale Teilnehmerzahl erreicht","Wallet is locked":"Wallet ist gesperrt","Wallet is not complete":"Wallet ist unvollstndig","Wallet name":"Name des Wallets","Wallet needs backup":"Wallet braucht Sicherung","Wallet not backed up":"Wallet nicht gesichert","Wallet not found":"Wallet nicht gefunden","Wallet not registered":"Wallet nicht registriert","Wallet not registered at the wallet service. Recreate it from \"Create Wallet\" using \"Advanced Options\" to set your recovery phrase":"Wallet ist nicht beim Wallet-Service registiert. Neu erzeugen mit \"Neues Wallet erzeugen\" und \"Erweiterte Optionen\" um die Wiederherstellungsphrase anzugeben","Wallet recovery phrase not available.":"Wiederherstellungsphrase fr die Wallet nicht verfgbar.","Wallet service not found":"Wallet-Dienst nicht gefunden","Wallets":"Wallets","Wallets & Integrations":"Wallets & Integrationen","Warning!":"Warnung!","Warning: this transaction has unconfirmed inputs":"Warnung: Diese Transaktion hat unbesttigte Eingnge","Watch out!":"Aufgepasst!","We'd love to do better.":"Wir wrden es gerne besser machen.","We'll confirm on the next screen.":"Wir werden es auf der nchsten Seite besttigen.","We're always looking for ways to improve {{appName}}.":"Wir sind immer auf der Suche nach Mglichkeiten um {{appName}} zu verbessern.","We're always looking for ways to improve {{appName}}. How could we improve your experience?":"Wir sind immer auf der Suche nach Mglichkeiten um {{appName}} zu verbessern. Wie knnen wir Ihr Erlebnis verbessern?","Were always looking for translation contributions! You can make corrections or help to make this app available in your native language by joining our community on Crowdin.":"Wir sind immer auf der Suche nach bersetzungs-Beitrge! Sie knnen Korrekturen vornehmen oder helfen diese App in Ihrer Muttersprache zur Verfgung stellen, durch den Beitritt unserer Community bei Crowdin.","What do you call this wallet?":"Wie mchten Sie diese Wallet benennen?","When this wallet was created, it was called {{walletName}}. You can change the name displayed on this device below.":"Zu dem Zeitpunkt an dem diese Wallet erstellt wurde, wurde Sie &ldquo;{{walletName}}&rdquo; benannt. Sie knnen auf diesem Gert den unten angezeigten Namen ndern.","Where would you like to receive email notifications about payments?":"Wo mchten Sie E-Mail Benachrichtigungen ber Zahlungen erhalten?","Why?":"Warum?","Would you be willing to rate {{appName}} in the app store?":"Wren Sie bereit {{appName}} im App Store zu bewerten?","Would you like to receive push notifications about payments?":"Mchten Sie Push-Benachrichtigungen ber Zahlungen erhalten?","Wrong number of recovery words:":"Falsche Anzahl von Wiederherstellungswrtern:","Wrong spending password":"Falscher Berechtigungscode","Yes":"Ja","Yes, skip":"Ja, berspringen","You can create a backup later from your wallet settings.":"Sie knnen spter eine Sicherung ber Ihren Wallet-Einstellungen erstellen.","You can make contributions by signing up on our Crowdin community translation website. Were looking forward to hearing from you!":"Sie knnen Beitrge leisten indem Sie sich auf unserer Crowdin Community bersetzungs-Website registrieren. Wir freuen uns darauf von Ihnen zu hren!","You can scan bitcoin addresses, payment requests, paper wallets, and more.":"Sie knnen Bitcoin-Adressen, Zahlungsaufforderungen, Papier-Wallets und mehr scannen.","You can see the latest developments and contribute to this open source app by visiting our project on GitHub.":"Sie knnen auf GitHub die neuesten Entwicklungen ansehen und zu dieser Open-Source App beitragen.","You can spend bitcoin at millions of websites and stores worldwide.":"Sie knnen Bitcoins auf Millionen von Webseiten und Shops weltweit ausgeben.","You can still export it from Advanced &gt; Export.":"Sie knnen es auch exportieren aus dem Erweiterten &gt; Export.","You can trade it for other currencies like US Dollars, Euros, or Pounds.":"Sie knnen auch mit andere Whrungen wie US-Dollar, Euro oder Pfund handeln.","You control your bitcoin.":"Sie kontrollieren Ihre Bitcoins.","You'll receive email notifications about payments sent and received from your wallets.":"Sie erhalten E-Mail Benachrichtigungen ber gesendete und empfangen Zahlungen aus Ihren Wallets.","Your bitcoin wallet is backed up!":"Ihre Bitcoin-Wallet wurde gesichert!","Your bitcoin wallet is ready!":"Ihre Bitcoin-Wallet ist fertig!","Your ideas, feedback, or comments":"Ihre Ideen, Feedback oder Kommentare","Your name":"Ihr Name","Your nickname":"Name des Teilnehmers","Your password":"Passwort","Your wallet is never saved to cloud storage or standard device backups.":"Ihre Wallet wird nie auf einem Cloud-Speicher oder einer Standard-Gerte-Backup gespeichert.","Your wallet key will be encrypted. The Spending Password cannot be recovered. Be sure to write it down.":"Ihre Wallet wird verschlsselt. Der Berechtigungscode kann nicht wiederhergestellt werden. Achten Sie darauf ihn aufzuschreiben.","[Balance Hidden]":"[Guthaben versteckt]","add your BitPay Visa card(s)":"Ihre BitPay Visa Karte(n) hinzufgen","locked by pending payments":"durch ausstehende Zahlungen gesperrt","me":"Ich","name@example.com":"name@beispiel.com","preparing...":"in Arbeit...","{{appName}} depends on Bitcore Wallet Service (BWS) for blockchain information, networking and Copayer synchronization. The default configuration points to https://bws.bitpay.com (BitPay's public BWS instance).":"{{appName}} hngt von Bitcore Wallet Service (BWS) ab bezglich Blockchain Informationen, Vernetzung und Copayer Synchronisation. Die Standard Konfiguration verweist auf https://bws.bitpay.com (BitPays ffentlicher BWS Instanz).","{{fee}} will be deducted for bitcoin networking fees.":"{{fee}} wird fr Bitcoin-Netzwerkgebhren abgezogen werden.","{{updatingTxHistoryProgress}} transactions downloaded":"{{updatingTxHistoryProgress}} Transaktionen werden heruntergeladen","{{wallet.m}}-of-{{wallet.n}}":"{{wallet.m}}-von-{{wallet.n}}"});
    gettextCatalog.setStrings('es', {"(Trusted)":"(De confianza)","(possible double spend)":"(Posible doble gasto)","* A payment proposal can be deleted if 1) you are the creator, and no other copayer has signed, or 2) 24 hours have passed since the proposal was created.":"* Una propuesta de pago puede ser eliminada si 1) T eres el creador, y ningn otro copayer la haya firmado, o 2) hayan transcurrido 24 horas desde la creacin de la propuesta.","- {{btx.feeRateStr}} of the transaction":"- {{btx.feeRateStr}} de la transaccin","- {{tx.feeRateStr}} of the transaction":"- {{tx.feeRateStr}} de la transaccin","5-star ratings help us get {{appName}} into more hands, and more users means more resources can be committed to the app!":"Una calificacin de 5 estrellas nos ayuda a que {{appName}} sea ms utilizado, mientras ms usuarios ms son las razones para seguir comprometidos con esta aplicacin!","<b>Only</b> redeemable on Mercado Livre (Brazil)":"<b>Solo</b> canjeable en Mercado Livre (Brasil)","A member of the team will review your feedback as soon as possible.":"Un miembro del equipo revisar tus comentarios tan pronto como sea posible.","A total of {{amountAboveMaxSizeStr}} were excluded. The maximum size allowed for a transaction was exceeded.":"Se excluyeron un total de {{amountAboveMaxSizeStr}}. Fue excedido el tamao mximo permitido para una transaccin.","A total of {{amountBelowFeeStr}} were excluded. These funds come from UTXOs smaller than the network fee provided.":"Se excluyeron un total de {{amountBelowFeeStr}}. Estos fondos provienen del UTXOs ms pequeos que la comisin de red provista.","About":"Acerca de","Accepted":"Aceptado","Account":"Cuenta","Account Number":"Nmero de cuenta","Accounts":"Cuentas","Activity":"Actividad","Add Account":"Agregar Cuenta","Add BitPay Account?":"Agregar cuenta de BitPay?","Add Contact":"Agregar contacto","Add Funds":"Aadir fondos","Add Memo":"Aadir nota","Add a password":"Agregar una contrasea","Add account":"Agregar cuenta","Add an optional password to secure the recovery phrase":"Agregar una contrasea opcional para asegurar la frase de recuperacin","Add as a contact":"Agregar como Contacto","Add description":"Aadir descripcin","Add funds":"Agregar fondos","Add this BitPay account ({{email}})?":"Agregar esta cuenta BitPay ({{email}})?","Add wallet":"Agregar billetera","Address":"Direccin","Address Book":"Agenda de contactos","Address Type":"Tipo de direccin","Addresses With Balance":"Direcciones con fondos","Advanced":"Avanzado","Advanced Settings":"Preferencias Avanzadas","All":"Todos","All Addresses":"Todas las direcciones","All of your bitcoin wallet balance may not be available for immediate spending.":"Todo el balance de tu billetera puede que no est disponible para su uso inmediato.","All signing devices must be added to this multisig wallet before bitcoin addresses can be created.":"Todos los dispositivos de los firmantes deben ser agregados a esta billetera compartido antes de que se puedan crear direcciones bitcoin.","Allow Camera Access":"Permitir el acceso de la cmara","Allow notifications":"Permitir notificaciones","Almost done! Let's review.":"Casi listo! Vamos a revisar.","Alternative Currency":"Moneda Alternativa","Amazon.com is not available at this moment. Please try back later.":"Amazon.com no est disponible en este momento. Intntalo de nuevo ms tarde.","Amount":"Importe","Amount below minimum allowed":"Cantidad por debajo del mnimo permitido","Amount too big":"Monto demasiado grande","Amount too low to spend":"Monto insuficiente para enviar","An update to this app is available. For your security, please update to the latest version.":"Actualizacin disponible. Por seguridad, actualiza a la versin ms reciente.","Anyone with your backup phrase can access or spend your bitcoin.":"Cualquier persona con tu copia de seguridad puede gastar tus bitcoins.","Approximate Bitcoin network fee to transfer wallet's balance (with normal priority)":"Comisin aproximada de la red Bitcoin para transferir el saldo de esta billetera (con prioridad normal)","Are you being watched?":"Ests siendo observado?","Are you being watched? Anyone with your recovery phrase can access or spend your bitcoin.":"Ests siendo observado? Cualquier persona con tu copia de seguridad puede gastar tus bitcoins.","Are you sure you want to cancel and delete this wallet?":"Ests seguro de cancelar y borrar esta billetera?","Are you sure you want to delete this contact?":"Est seguro de que desea eliminar este contacto?","Are you sure you want to delete this wallet?":"Ests seguro de borrar esta billetera?","Are you sure you want to reject this transaction?":"Ests seguro de rechazar esta transaccin?","Are you sure you want to remove this transaction?":"Ests seguro de eliminar esta transaccin?","Are you sure you want to skip it?":"Ests seguro de omitirla?","Are you sure you would like to log out of your BitPay Card account?":"Est seguro que desea cerrar la sesin de su cuenta BitPay Card?","Are you sure you would like to remove your BitPay Card ({{lastFourDigits}}) from this device?":"Ests seguro de quitar tu BitPay Card ({{lastFourDigits}}) de este dispositivo?","Auditable":"Auditables","Available":"Disponible","Available Balance":"Balance disponible","Average confirmation time":"Tiempo promedio de confirmacin","BIP32 path for address derivation":"BIP32 para el camino de derivacin de direcciones","BTCZ Wallets":"Billeteras BTCZ","Backup":"Copia de seguridad","Backup Needed":"Se necesita copia de seguridad","Backup all livenet wallets before using this function":"Debes respaldar todas tus billeteras para utilizar esta funcin","Backup needed":"Necesita respaldar","Backup now":"Realizar copia de seguridad","Backup wallet":"Respaldar","Backup your wallet before using this function":"Respalda tu billetera para utilizar esta funcin","Bad wallet invitation":"Invitacin incorrecta a la billetera","Balance By Address":"Balance por Direccin","Be sure to store your recovery phrase in a secure place. If this app is deleted, your money cannot be recovered without it.":"Asegrate de guardar la frase de recuperacin en un lugar seguro. Si se elimina esta aplicacin, no se podr recuperar el dinero.","BitPay Visa Cards":"Tarjetas BitPay Visa&reg;","Bitcoin Address":"Direccin Bitcoin","Bitcoin Cash (BCH) Balances":"Saldos Bitcoin Cash (BCH)","Bitcoin Cash Support":"Soportar Bitcoin Cash","Bitcoin Network Fee Policy":"Poltica de Comisin de la Red Bitcoin","Bitcoin cash Payment":"Pago en Bitcoin cash","Bitcoin is a currency.":"Bitcoin es una moneda.","Bitcoin is different  it cannot be safely held with a bank or web service.":"Bitcoin es diferente &ndash; no se puede resguardar con ningn servicio web o banco.","Bitcoin is secure,<br>digital money.":"Bitcoin es seguro,<br> dinero digital.","Bitcoin transactions include a fee collected by miners on the network.":"Las transacciones de bitcoins incluyen una comisin recogida por los mineros de la red.","Bought {{amountUnitStr}}":"Compr {{amountUnitStr}}","Broadcast Payment":"Enviar Pago","Broadcasted":"Enviado","Broadcasting transaction":"Finalizando transaccin","Browser unsupported":"Navegador no soportado","Buy":"Comprar","Buy &amp; Sell Bitcoin":"Comprar &amp; Vender Bitcoin","Buy Bitcoin":"Comprar Bitcoin","Buy a Gift Card":"Comprar una Tarjeta de Regalo","Buy from":"Comprar desde","Buying Bitcoin...":"Comprando Bitcoins...","Calculating fee":"Calculando comisin","Cancel":"Cancelar","Cancel invitation":"Cancelar invitacin","Cannot Create Wallet":"No se pudo crear la billetera","Cannot join the same wallet more that once":"No puede unirse a la misma billetera ms de una vez","Cards":"Tarjetas","Certified by":"Certificado por","Check installation and retry.":"Comproba la instalacin y reintenta.","Choose a backup file from your computer":"Selecciona el archivo de copia de seguridad de tu computadora","Choose your destination wallet":"Elegir billetera destino","Choose your source wallet":"Elegir billetera de origen","Clear":"Anular","Clear cache":"Limpiar cache","Click to accept":"Click para aceptar","Click to pay":"Click para pagar","Click to send":"Click para enviar","Close":"Cerrar","Coin":"Moneda","Color":"Color","Commit hash":"Commit hash","Complete the backup process to use this option":"Completar el proceso de respaldo para usar esta opcin","Completed":"Terminadas","Confirm":"Confirmar","Confirm &amp; Finish":"Confirmar y terminar","Confirm purchase":"Confirmar compra","Confirm your PIN":"Confirma tu PIN","Confirm your new spending password":"Confirme su contrasea para enviar","Confirmations":"Confirmaciones","Confirming":"Confirmando","Connect my BitPay Card":"Conecte mi BitPay Card","Connecting to Coinbase...":"Conectando a Coinbase...","Connecting to Glidera...":"Conectando a Glidera...","Connection reset by peer":"Conexin re establecida","Contacts":"Contactos","Continue":"Continuar","Contribute Translations":"Contribuir","Copayer already in this wallet":"Ya se encuentra en esta billetera","Copayer already voted on this spend proposal":"Ya votaste en esta propuesta de gasto","Copayer data mismatch":"Discrepancia en los datos del Copayer","Copayer joined":"Copayer unido","Copayer {{$index}}":"Copayer {{$index}}","Copied to clipboard":"Copiado al portapapeles","Copy this text as it is to a safe place (notepad or email)":"Copiar el texto como est en un lugar seguro (bloc de notas o correo electrnico)","Copy to clipboard":"Copiar al portapapeles","Could not access Gift Card Service":"No se pudo acceder a Gift Card Service","Could not access the wallet at the server. Please check:":"No se pudo acceder a la billetera desde el servidor. Por favor verificar:","Could not access to Amazon.com":"No se pudo acceder a Amazon.com","Could not access wallet":"No se pudo acceder a la billetera","Could not add message to imported wallet without shared encrypting key":"No se puede agregar mensajes a una billetera importada sin la clave cifrada compartida","Could not broadcast payment":"No se pudo enviar el pago","Could not build transaction":"No se pudo construir la transaccin","Could not create address":"No se pudo crear la direccin","Could not create the invoice":"No se pudo crear la factura","Could not create transaction":"No se pudo crear la transaccin","Could not create using the specified extended private key":"No se pudo crear la billetera usando la clave privada ingresada","Could not create using the specified extended public key":"No se pudo crear con la clave pblica extendida especificada","Could not create: Invalid wallet recovery phrase":"No se pudo crear: frase de recuperacin invlida","Could not decrypt file, check your password":"No se pudo descifrar el archivo, verifique su contrasea","Could not delete payment proposal":"No se pudo eliminar la propuesta de pago","Could not duplicate":"No se pudo duplicar","Could not get dynamic fee":"No se pudo obtener comisin dinmica","Could not get dynamic fee for level: {{feeLevel}}":"No se pudo obtener comisin dinmica: {{feeLevel}}","Could not get fee levels":"No se pudieron obtener los niveles de comisin","Could not get the invoice":"No se pudo obtener la factura","Could not get transactions":"No se pudo obtener las transacciones","Could not import":"No se pudo importar","Could not import. Check input file and spending password":"No se pudo importar. Verifique el archivo y la contrasea para pagos","Could not join wallet":"No se pudo unir a la billetera","Could not reject payment":"No se pudo rechazar el pago","Could not remove account":"No se pudo eliminar la cuenta","Could not remove card":"No se pudo quitar tarjeta","Could not save preferences on the server":"No se pueden guardar las preferencias en el servidor","Could not send payment":"No se pudo enviar el pago","Could not send transaction":"No se pudo enviar la transaccin","Could not update transaction history":"No se pudo actualizar el historial de transacciones","Could not update wallet":"No se pudo actualizar la billetera","Create Personal Wallet":"Crear billetera Personal","Create Shared Wallet":"Crear billetera compartida","Create bitcoin wallet":"Crear billetera","Create new wallet":"Crear billetera nueva","Create shared wallet":"Crear billetera compartida","Create {{formData.requiredCopayers}}-of-{{formData.totalCopayers}} wallet":"Crear billetera {{formData.requiredCopayers}}-de-{{formData.totalCopayers}}","Created by":"Creado por","Creating Wallet...":"Creando billetera...","Creating transaction":"Creando transaccin","Current fee rate for this policy":"Tarifa actual de esta poltica","Custom":"Personalizado","Custom Amount":"Importe Especfico","Custom Fee":"Comisin personalizada","Date":"Fecha","Delete":"Eliminar","Delete Payment Proposal":"Eliminar Propuesta de Pago","Delete Wallet":"Eliminar billetera","Delete it and create a new one":"Borrar y crear uno nuevo","Deleting Wallet...":"Eliminando billetera...","Deleting payment proposal":"Eliminando la propuesta de pago","Derivation Path":"Camino de derivacin","Derivation Strategy":"Estrategia de derivacin","Details":"Detalles","Disabled":"Deshabilitado","Do it later":"Luego","Do not include private key":"No incluir la clave privada","Don't see your language on Crowdin? Contact the Owner on Crowdin! We'd love to support your language.":"No ves tu idioma en Crowdin? Contacta con el encargado del proyecto! Nos encantara soportar tu idioma.","Download":"Descargar","Duplicate for BCH":"Duplicar a BCH","Duplicating wallet...":"Duplicando billetera...","Each bitcoin wallet can generate billions of addresses from your 12-word backup. A new address is automatically generated and shown each time you receive a payment.":"Cada billetera puede generar billones de direcciones desde sus 12 palabras. Se genera una nueva direccin automticamente cada vez que se recibe un pago.","Economy":"Econmico","Edit":"Editar","Email":"Correo electrnico","Email Address":"Direccin de correo electrnico","Empty addresses limit reached. New addresses cannot be generated.":"Se ha alcanzado el lmite de direcciones vacas. No se pueden generar nuevas direcciones.","Enable Bitcoin Cash wallet creation and operation within the App.":"Habilita la creacin y operacin de billetera Bitcoin Cash dentro de la aplicacin.","Enable camera access in your device settings to get started.":"Habilitar el acceso de la cmara en su configuracin de dispositivo para empezar.","Enable email notifications":"Activar notificaciones de correo electrnico","Enable push notifications":"Activar notificaciones push","Enable the camera to get started.":"Activar la cmara empezar.","Enabled":"Habilitado","Enter Spending Password":"Ingrese contrasea para pagos","Enter Two Factor for your BitPay account":"Ingrese Autenticacin de Dos Pasos para su cuenta de BitPay","Enter amount":"Ingrese el monto","Enter custom fee":"Ingrese comisin","Enter new spending password":"Ingrese una nueva contrasea para pagos","Enter the recovery phrase (BIP39)":"Introduce la frase de recuperacin (BIP39)","Enter your email":"Ingresa tu correo electrnico","Enter your password":"Ingrese su contrasea","Error":"Error","Error at confirm":"Error al confirmar","Error creating gift card":"Error al crear tarjeta de regalo","Error creating the invoice":"Error al crear la factura","Error creating wallet":"Error al crear billetera","Error getting SendMax information":"Error al obtener informacin de SendMax","Error in Payment Protocol":"Error en el Protocolo de Pago","Error pairing BitPay Account":"Error de sincronizacin con la cuenta de BitPay","Error scanning funds:":"Error al escanear fondos:","Error sweeping wallet:":"Error al buscar fondos:","Error updating Debit Cards":"Error al actualizar las tarjetas de dbito","Exceeded daily limit of $500 per user":"Se excedi el limite de $500 por usuario","Expired":"Expirada","Expires":"Expira","Export Wallet":"Exportar billetera","Export to file":"Exportar a archivo","Export wallet":"Exportar billetera","Exporting via QR not supported for this wallet":"Exportar va cdigo QR no es compatible para esta billetera","Extended Public Keys":"Claves Pblicas Extendidas","Extracting Wallet information...":"Obteniendo Informacin de la billetera...","Failed to export":"Error al exportar","Family vacation funds":"Fondos para vacaciones en familia","Fee":"Comisin","Fee level":"Nivel de comisin","Fee level is not defined":"El nivel de comisin no esta definido","Fee:":"Comisin:","Feedback could not be submitted. Please try again later.":"No se pudo enviar el comentario. Por favor intente nuevamente.","Fetching BitPay Account...":"Buscando Cuenta de BitPay...","Fetching payment information":"Obteniendo informacin del pago","File/Text":"Archivo/Texto","Filter setting":"Ajuste de filtro","Finger Scan Failed":"Fallo en la verificacin de la huella","Finish":"Finalizar","For audit purposes":"Para propsitos de auditora","From":"Desde","From BitPay account":"De la cuenta de BitPay","From Hardware Wallet":"Billetera Fsica","From the destination device, go to Add wallet &gt; Import wallet and scan this QR code":"Desde el dispositivo de destino, ir a Agregar billetera &gt; Importar y escanear este cdigo QR","Funds are locked by pending spend proposals":"Los fondos estn bloqueados por propuestas de gastos pendientes","Funds found:":"Fondos encontrados:","Funds to be added":"Fondos a agregar","Funds transferred":"Fondos transferidos","Funds were added to debit card":"Los fondos se agregaron a la tarjeta de dbito","Funds will be transferred to":"Los fondos sern transferidos a","Generate new address":"Generar nueva direccin","Generating .csv file...":"Generando archivo .csv...","Generating new address...":"Generando una nueva direccin...","Get local cash anywhere you go, from any Visa<sup></sup> compatible ATM. ATM bank fees may apply.":"Consigue efectivo local dondequiera que vayas, desde cualquier ATM Visa<sup>&reg;</sup> compatible. Comisin de parte del ATM pueden ser aplicadas.","Get news and updates from BitPay":"Recibir noticias y actualizaciones de BitPay","Get started":{"button":"Comenzar","$$noContext":"Empezar"},"Get started by adding your first one.":"Comienza agregando el primero.","Getting fee levels...":"Obteniendo niveles de comisin...","Gift Card is not available to use anymore":"La Tarjeta de Regalo ya no esta disponible para usar","Gift card":"Tarjeta de regalo","Gift card expired":"La tarjeta de regalo expir","Gift card generated and ready to use.":"Tarjeta de regalo generada y lista para usar.","Go Back":"Volver","Go back":"Volver","Got it":"Entiendo","Hardware Wallet":"Billetera Fsica","Hardware not connected.":"Equipo no conectado.","Hardware wallet":"Billetera fsica","Hardware wallets are not yet supported with Bitcoin Cash":"Billeteras en hardware no son compatibles con Bitcoin Cash todava","Help & Support":"Ayuda & Soporte","Help and support information is available at the website.":"La ayuda est disponible en el sitio web.","Hide":"Ocultar","Hide Balance":"Balance Oculto","Hide Next Steps Card":"Ocultar Tarjeta de Prximo Pasos","Hide advanced options":"Ocultar opciones avanzadas","Home":"Inicio","How could we improve your experience?":"Cmo podramos mejorar tu experiencia?","How do you like {{appName}}?":"Te gusta {{appName}}?","I don't like it":"No me gusta","I have read, understood, and agree to the <a ng-click=\"openTerms()\" translate=\"\">Terms of Use</a>.":"He ledo, entendido y acepto los <a ng-click=\"openTerms()\" translate=\"\">Trminos de Uso</a>.","I have read, understood, and agree with the Terms of use.":"He ledo, entendido y acepto los Trminos de uso.","I have written it down":"Ya he anotado","I like the app":"Me gusta la aplicacin","I think this app is terrible.":"Creo que esta aplicacin es terrible.","I understand":"Entiendo","I understand that if this app is moved to another device or deleted, my bitcoin can only be recovered with the backup phrase.":"Entiendo que si esta aplicacin es borrada, mis fondos pueden recuperarse nicamente con la copia de seguridad.","I understand that my funds are held securely on this device, not by a company.":"Entiendo que mis fondos estn protegidos por el dispositivo y no por una empresa.","I've written it down":"Ya he anotado","If enabled, all sensitive information (private key and recovery phrase) and actions (spending and exporting) associated with this wallet will be protected.":"Si est habilitado, se proteger toda informacin sensible (clave privada y frase recuperacin) y acciones (gastar y exportar) asociadas con esta billetera.","If enabled, the Recent Transactions card - a list of transactions occuring across all wallets - will appear in the Home tab.":"Si se habilita, aparecer una lista de las transacciones recientes de las billeteras en el inicio.","If enabled, wallets will also try to spend unconfirmed funds. This option may cause transaction delays.":"Si se habilita, las billeteras podrn gastar los fondos sin confirmar. Esta opcin puede causar demoras en la transaccin.","If this device is replaced or this app is deleted, neither you nor BitPay can recover your funds without a backup.":"Si pierdes este dispositivo o esta aplicacin es eliminada, ni t ni BitPay podrn recuperar el dinero.","If you have additional feedback, please let us know by tapping the \"Send feedback\" option in the Settings tab.":"Si tienes comentarios adicionales, por favor envalos pulsando la opcin \"Enviar comentarios\" en la pestaa de preferencias.","If you take a screenshot, your backup may be viewed by other apps. You can make a safe backup with physical paper and a pen.":"Si tomas una captura de pantalla, otras aplicaciones podran ver tu copia de seguridad. La forma ms acertada es resguardarla con tinta y papel.","Import":"Importar","Import Wallet":"Importar billetera","Import backup":"Importar copia de seguridad","Import wallet":"Importar billetera","Importing Wallet...":"Importando billetera...","In order to verify your wallet backup, please type your password.":"Para verificar la copia de seguridad de la billetera, por favor escriba la contrasea.","Inactive":"Inactivo","Incomplete":"Incompleta","Incomplete wallet":"Billetera Incompleta","Incorrect PIN, try again.":"PIN Incorrecto. Intntelo de nuevo.","Incorrect code format":"Formato de cdigo incorrecto","Incorrect network address":"Direccin de red incorrecta","Insufficient funds":"Fondos insuficientes","Insufficient funds for fee":"Fondos insuficientes para el pago de la comisin","Invalid":"Invlido","Invalid URL":"URL incorrecta","Invalid account number":"Nmero de cuenta invlido","Invalid address":"Direccin invlida","Invalid data":"Datos no vlidos","Invalid derivation path":"Camino de derivacin no vlido","Invitation to share a {{appName}} Wallet":"Invitacin para unirse a la billetera {{appName}} compartida","Invoice expired":"Factura vencida","Is there anything we could do better?":"Hay algo que podramos mejorar?","Is this correct?":"Es correcto?","Is this email address correct?":"Es correcta esta direccin de correo electrnico?","It's a good idea to avoid reusing addresses - this both protects your privacy and keeps your bitcoins secure against hypothetical attacks by quantum computers.":"Es una buena idea evitar el reuso de las direcciones. Esto protege tu privacidad y mantiene tus fondos seguros contra hipotticos ataques de ordenadores cunticos.","It's important that you write your backup phrase down correctly. If something happens to your wallet, you'll need this backup to recover your money. Please review your backup and try again.":"Es importante que escribas correctamente la frase de seguridad. Si algo le pasa a tu billetera, necesitars de sta para recuperar el dinero. Revsala y vuelve a intentarlo.","Join":"Unirse","Join my {{appName}} Wallet. Here is the invitation code: {{secret}} You can download {{appName}} for your phone or desktop at {{appUrl}}":"nete a mi billetera {{appName}}. Aqu est el cdigo de invitacin: {{secret}} puede descargar {{appName}} para su telfono o escritorio en {{appUrl}}","Join shared wallet":"Unirse a una billetera compartida","Joining Wallet...":"Unindose a la billetera...","Just scan the code to pay.":"Slo escanea y paga.","Key already associated with an existing wallet":"La clave ya esta asociada a un monedero existente","Language":"Idioma","Last Month":"Mes pasado","Learn more":"Ms informacin","Let's verify your backup phrase.":"Verifiquemos la copia de seguridad.","Loading addresses...":"Cargando direcciones...","Loading transaction info...":"Cargando informacin de transaccin...","Lock App":"Bloquear la aplicacin","Lock by Fingerprint":"Bloquear por huella digital","Lock by PIN":"Bloquear por PIN","Locked":"Bloqueado","Locktime in effect. Please wait to create a new spend proposal":"Bloqueo temporal. Por favor espera para crear una nueva propuesta de gasto","Locktime in effect. Please wait to remove this spend proposal":"Bloqueo temporal. Por favor espera para eliminar esta propuesta de gasto","Log options":"Opciones de registro","Log out":"Cerrar Sesin","Low amount inputs":"Entradas de monto bajo","Low fees":"Comisin baja","Makes sense":"Entiendo","Matches:":"Coincidencias:","Me":"Yo","Meh - it's alright":"Buu - est bien","Memo":"Nota","Mercado Livre Brazil Gift Cards":"Tarjetas de Regalo Mercado Livre Brasil","Mercadolibre Gift Card Service is not available at this moment. Please try back later.":"Mercadolibre Gift Card Service no esta disponible en este momento. Por favor, intntelo ms tarde.","Merchant Message":"Mensaje del comerciante","Miner Fee":"Comisin de minado","Missing parameter":"Faltan parmetros","Missing private keys to sign":"Faltan las claves privadas para firmar","More Options":"Ms opciones","Moved":"Movido","Moved Funds":"Fondos movidos","Multiple recipients":"Varios destinatarios","NOTE: To import a wallet from a 3rd party software, please go to Add Wallet &gt; Create Wallet, and specify the Recovery Phrase there.":"Nota: Para importar una billetera de un software de tercero debes ir a Aadir billetera &gt; Crear billetera, y especificar la frase de recuperacin.","Name":"Nombre","Network Cost":"Costo de la red","Network error":"Error de red","New Proposal":"Nueva propuesta de pago","New address could not be generated. Please try again.":"No se pudo generar la nueva direccin. Por favor intntalo de nuevo.","New personal wallet":"Nueva billetera personal","Next steps":"Prximos pasos","No Wallet":"Sin billetera","No access key defined":"No se ha definido la llave de acceso","No backup, no bitcoin.":"Sin copia de seguridad, no hay bitcoins.","No contacts yet":"Aun no hay contactos","No entries for this log level":"No hay entradas para este nivel de registro","No hardware information available.":"No hay informacin disponible sobre el equipo.","No hardware wallets supported on this device":"No hay billeteras fsicas compatibles con este dispositivo","No pending proposals":"No propuestas de pago pendientes","No recent transactions":"No hay transacciones recientes","No signing proposal: No private key":"Propuesta sin firmar: No existe la clave privada","No transactions yet":"Aun no hay transacciones","No wallet found":"Se se encontr la billetera","No wallet selected":"No se seleccion una billetera","No wallets available":"No hay billeteras disponibles","No wallets available to receive funds":"No hay billeteras disponibles para recibir fondos","No wallets eligible for Bitcoin Cash support":"No hay billeteras elegibles para soporte a Bitcoin Cash","Non eligible BTCZ wallets":"Billeteras BTCZ no elegibles","Normal":"Normal","Not authorized":"No autorizado","Not enough funds for fee":"No hay suficientes fondos para la comisin","Not even BitPay can access it.":"Ni siquiera BitPay puede acceder a ellos.","Not funds found":"No se encontraron fondos","Not now":"Ahora no","Note":"Nota","Notice: only 1-1 (single signature) wallets can be used for sell bitcoin":"Aviso: solo billeteras 1-1 (nica firma) pueden ser utilizadas para vender bitcoin","Notifications":"Notificaciones","Notifications by email":"Notificaciones por correo electrnico","Notify me if confirmed":"Notificarme si se confirma","Notify me when transactions are confirmed":"Notificarme cuando se confirmen las transacciones","Now is a good time to backup your wallet. If this device is lost, it is impossible to access your funds without a backup.":"Es un buen momento para realizar una copia de seguridad de la billetera. Si este dispositivo se pierde, ser imposible acceder a los fondos.","Now is a perfect time to assess your surroundings. Nearby windows? Hidden cameras? Shoulder-spies?":"Es el momento perfecto para mirar a tu alrededor. ventanas? cmaras? gente curiosa?","OK":"OK","OKAY":"LISTO","Official English Disclaimer":"Renuncia oficial en ingls","Oh no!":"Oh no!","Ok":"Correcto","On this screen you can see all your wallets, accounts, and assets.":"En esta pantalla puedes ver tus billeteras, cuentas y activos.","Open":"Abrir","Open Crowdin":"Abrir Crowdin","Open GitHub":"Abrir GitHub","Open GitHub Project":"Abrir Proyecto en GitHub","Open Insight":"Abrir Insight","Open Settings":"Abrir Opciones","Open Translation Community":"Abrir Comunidad de Traducciones","Open Website":"Abrir Sitio Web","Open bitcoincash.org?":"Abrir bitcoincash.org?","Open wallet":"Abrir billetera","Open website":"Abrir pgina web","Order the BitPay Card":"Solicitar BitPay Card","Password":"Contrasea","Password required. Make sure to enter your password in advanced options":"Se requiere contrasea. Asegrate de introducirla en opciones avanzadas","Paste invitation here":"Pegar invitacin aqu","Paste the backup plain text code":"Pegar copia de seguridad en texto plano","Pay 0% fees to turn bitcoin into dollars.":"Paga 0% de comisin para transformar tus bitcoin en dlares.","Pay To":"Pagar A","Payment Accepted":"Pago Aceptado","Payment Expires:":"Pago expira:","Payment Proposal":"Propuesta de Pago","Payment Proposal Created":"Propuesta de Pago Creada","Payment Proposals":"Propuestas de Pago","Payment Protocol Invalid":"Protocolo de Pago Invlido","Payment Protocol not supported on Chrome App":"El protocolo de pago no est soportado en Chrome","Payment Received":"Pago recibido","Payment Rejected":"Pago Rechazado","Payment Sent":"Pago Enviado","Payment accepted, but not yet broadcasted":"Pago aceptado, pero an no fue enviado","Payment accepted. It will be broadcasted by Glidera. In case there is a problem, it can be deleted 6 hours after it was created.":"Pago aceptado. Se transmitir por Glidera. En caso de que haya un problema, puedes eliminar la transaccin 6 horas despus de fue creada.","Payment address was translated to new Bitcoin Cash address format:":"La direccin de pago fue traducida al nuevo formato de Bitcoin Cash:","Payment details":"Detalles del pago","Payment request":"Solicitud de pago","Pending":"Pendiente","Pending Proposals":"Propuestas de pago pendientes","Permanently delete this wallet.":"Eliminar esta billetera de forma permanente.","Personal Wallet":"Billetera Personal","Please carefully write down this phrase.":"Por favor, anota cuidadosamente esta frase.","Please connect a camera to get started.":"Por favor, conecta una cmara para empezar.","Please enter the recovery phrase":"Por favor ingresa la frase de recuperacin","Please enter the wallet recovery phrase":"Por favor ingresa la frase de recuperacin de la billetera","Please enter your PIN":"Ingres tu PIN","Please tap each word in the correct order.":"Escoje las palabras en el orden correcto.","Please upgrade Copay to perform this action":"Por favor actualiza Copay para realizar esta accin","Please wait":"Por favor espere","Please, select your backup file":"Por favor, selecciona el archivo de copia de seguridad","Pre-Auth Holds":"Pre-Auth Holds","Preferences":"Preferencias","Preparing addresses...":"Preparando direcciones...","Preparing backup...":"Preparando copia de seguridad...","Press again to exit":"Presione nuevamente para salir","Priority":"Prioritario","Private Key":"Clave privada","Private key encrypted. Enter password":"La clave privada est encriptada. Escriba la contrasea","Private key is encrypted, cannot sign":"La clave privada est encriptada, no puedes firmar","Proposal Accepted":"Propuesta Aceptada","Proposal Created":"Propuesta Creada","Proposal Deleted":"Propuesta Eliminada","Proposal Rejected":"Propuesta Rechazada","Proposals":"Propuestas","Purchase Amount is limited to {{limitPerDay}} {{currency}} per day":"El monto de la compra esta limitada a {{limitPerDay}} {{currency}} por da","Purchase amount must be a value between 50 and 2000":"El monto de la compra debe ser un valor entre 50 y 2000","Push Notifications":"Notificaciones Push","Push notifications for {{appName}} are currently disabled. Enable them in the Settings app.":"Notificaciones push para {{appName}} estn deshabilitadas. Habilitarla en la configuracin de la aplicacin.","QR Code":"Cdigo QR","Quick review!":"Revisin rpida!","Random":"Al azar","Rate on the app store":"Califica en la app store","Read less":"Mostrar menos","Read more":"Leer ms","Read more in our Wiki":"Lee ms en nuestra Wiki","Receive":"Recibir","Receive in":"Recibir en","Received":"Recibido","Received Funds":"Fondos recibidos","Receiving":"Recibiendo","Recent":"Recientes","Recent Transaction Card":"Tarjeta con transacciones recientes","Recent Transactions":"Transacciones Recientes","Recipient":"Destinatario","Recipients":"Destinatarios","Recovery phrase":"Frase de Recuperacin","Recreating Wallet...":"Recreando billetera...","Redeem now":"Canjear ahora","Rejected":"Rechazado","Rejecting payment proposal":"Rechazando propuesta de pago","Release information":"Informacin de la versin","Remove":"Remover","Remove BitPay Account?":"Eliminar Cuenta de BitPay?","Remove BitPay Card?":"Eliminar BitPay Card?","Removing your BitPay account will remove all associated BitPay account data from this device. Are you sure you would like to remove your BitPay Account ({{email}}) from this device?":"Al eliminar una cuenta de BitPay se eliminarn todos los datos asociados de este dispositivo. Desea realmente eliminar la cuenta de BitPay ({{email}}) del dispositivo?","Repeat password":"Escribe nuevamente la contrasea","Repeat the password":"Repetir la contrasea","Request Fingerprint":"Solicitar Huella Digital","Request Specific amount":"Solicitar importe Especifico","Request Spending Password":"Solicitar contrasea para pagos","Required number of signatures":"Nmero requerido de firmas","Restore from backup":"Restaurar desde copia de seguridad","Retrieving inputs information":"Recuperando informacin de las entradas","Retry":"Vuelva a intentarlo","Retry Camera":"Reintentar","Save":"Guardar","Scan":"Escanear","Scan QR Codes":"Escanear Cdigo QR","Scan addresses for funds":"Busca direcciones con fondos","Scan again":"Escanear de nuevo","Scan your fingerprint please":"Por favor ingrese su huella digital","Scan your wallets for Bitcoin Cash":"Explora tus billeteras para Bitcoin Cash","Scanning Wallet funds...":"Buscando fondos en la billetera...","Scanning funds...":"Buscando fondos...","Screenshots are not secure":"Las capturas de pantallas no son seguras","Search Transactions":"Buscar transacciones","Search or enter bitcoin address":"Buscar o introducir direccin bitcoin","Search transactions":"Buscar transacciones","Search your currency":"Busca tu moneda","Security":"Seguridad","See invoice":"Ver factura","Select a backup file":"Seleccionar el archivo de copia de seguridad","Select a wallet":"Seleccionar una billetera","Self-signed Certificate":"Certificado autofirmado","Selling Bitcoin...":"Vendiendo Bitcoins...","Send":"Enviar","Send Feedback":"Enviar Sugerencia","Send Money":"Enviar dinero","Send addresses by email":"Enviar las direcciones por email","Send by email":"Enviar por correo electrnico","Send from":"Enviar desde","Send max amount":"Enviar la mxima cantidad","Send payment to this address":"Enviar pago a esta direccin","Send us feedback instead":"En su lugar, enviar comentario","Sending":"Enviando","Sending 2FA code...":"Enviando cdigo 2FA...","Sending feedback...":"Enviando comentario...","Sending maximum amount":"Enviando cantidad mxima","Sending transaction":"Enviando transaccin","Sending {{amountStr}} from your {{name}} wallet":"Enviando {{amountStr}} desde tu billetera {{name}}","Sent":"Enviado","Sent Funds":"Fondos enviados","Server response could not be verified":"La respuesta del servidor no se ha podido verificar","Service not available":"Servicio no disponible","Services":"Servicios","Session Log":"Registro de sesin","Session log":"Registro de sesin","Set up a password":"Configurar una contrasea","Set your own fee in satoshis/byte":"Establecer su propia comisin en satoshis/byte","Settings":"Configuracin","Share the love by inviting your friends.":"Comparte la pasin invitando a tus amigos.","Share this invitation with your copayers":"Compartir esta invitacin con sus copayers","Share {{appName}}":"Compartir {{appName}}","Shared Wallet":"Billetera Compartida","Show Recovery Phrase":"Mostrar frase de recuperacin del monedero","Show address":"Mostrar direccin","Show advanced options":"Mostrar opciones avanzadas","Show bitcoin address":"Mostrar direccin bitcoin","Show more":"Ver ms","Signatures rejected by server":"Firmas rechazadas por el servidor","Signing transaction":"Firmando transaccin","Since only you control your money, youll need to save your backup phrase in case this app is deleted.":"Ya que slo tu controlas tu dinero, debers guardar la copia de seguridad en caso de que esta aplicacin sea eliminada.","Single Address Wallet":"Billetera de una sola direccin","Skip":"Omitir","Slide to accept":"Deslizar para aceptar","Slide to buy":"Deslizar para comprar","Slide to pay":"Deslizar para pagar","Slide to send":"Deslizar para enviar","Specify Recovery Phrase...":"Especificar la frase de recuperacin...","Spend proposal is not accepted":"La propuesta de gasto no se ha aceptado","Spend proposal not found":"La propuesta de gasto no se ha encontrado","Spending Password needed":"Se necesita la contrasea para pagos","Spending this balance will need significant Bitcoin network fees":"Gastar este balance requiere de significativas comisiones","Start sending bitcoin":"Empezar a enviar bitcoin","Startup Lock":"Bloqueo inicial","Still pending":"An pendiente","Success":"Listo","Super Economy":"Sper Econmico","Support Bitcoin Cash":"Soportar Bitcoin Cash","Sweep":"Importar","Sweep paper wallet":"Importar billetera en papel","Sweeping Wallet...":"Leyendo la Billetera...","THIS ACTION CANNOT BE REVERSED":"ESTA ACCIN NO SE PUEDE REVERTIR","Take control of your money,<br>get started with bitcoin.":"Toma control de tu dinero,<br>comienza a utilizar bitcoin.","Tap and hold to show":"Tocar y mantener para mostrar","Tap to recreate":"Toca para recrear","Tap to retry":"Toque para reintentar","Terms Of Use":"Trminos de uso","Terms of Use":"Trminos de Uso","Testnet":"Testnet","Text":"Texto","Thank you!":"Gracias!","Thanks!":"Gracias!","That's exciting to hear. We'd love to earn that fifth star from you  how could we improve your experience?":"Es emocionante escucharlo. Nos encantara ganar esa quinta estrella  cmo podemos mejorar tu experiencia?","The Ledger Chrome application is not installed":"La aplicacin Ledger de Chrome no esta instalada","The amount of bitcoin immediately spendable from this wallet.":"Total de bitcoins disponibles en esta billetera para su uso inmediato.","The amount of bitcoin stored in this wallet that is allocated as inputs to your pending transaction proposals. The amount is determined using unspent transaction outputs associated with this wallet and may be more than the actual amounts associated with your pending transaction proposals.":"La cantidad de bitcoins almacenados en esta billetera que se utilizan como \"inputs\" en la transaccin pendiente. Esa cantidad se determina en base a los \"unspent transaction outputs\" asociados con la billetera, estos pueden que sean mayor al monto enviado en la transaccin en cuestin.","The amount of bitcoin stored in this wallet with less than 1 blockchain confirmation.":"La cantidad de bitcoins almacenados en esta billetera que poseen menos de 1 confirmacin en \"Blockchain\".","The derivation path":"La ruta de derivacin","The exchange rate changes with the market.":"La cotizacin vara segn el mercado.","The higher the fee, the greater the incentive a miner has to include that transaction in a block. Current fees are determined based on network load and the selected policy.":"Mientras ms grande la comisin, mayor incentivo tiene el minero para agregar tu transaccin a un bloque. Las comisiones estn determinadas en base al trfico y poltica de la red elegida.","The maximum number of consecutive unused addresses (20) has been reached. When one of your unused addresses receives a payment, a new address will be generated and shown in your Receive tab.":"Se ha alcanzado el nmero mximo de direcciones consecutivas sin utilizar (20). Cuando una de sus direcciones reciba un pago, una nueva direccin se generar y se mostrar en la pestaa 'Recibir'.","The official English Terms of Service are available on the BitPay website.":"Los trminos y condiciones oficiales en ingls se encuentran disponibles en la web de BitPay.","The password of the recovery phrase (if set)":"La contrasea de la frase de recuperacin (si existe)","The payment was created but could not be completed. Please try again from home screen":"El pago fue creado pero no se pudo completar. Por favor intenta nuevamente desde la pantalla de inicio","The payment was removed by creator":"El pago fue eliminado por el creador","The recovery phrase could require a password to be imported":"La frase de recuperacin podra requerir una contrasea para ser importada","The request could not be understood by the server":"La solicitud no pudo ser comprendida por el servidor","The restore process will stop when 20 addresses are generated in a row which contain no funds. To safely generate more addresses, make a payment to one of the unused addresses which has already been generated.":"El proceso generacin de nuevas direcciones se detendr cuando se generen 20 direcciones de manera consecutiva. Luego debers recibir un pago en una de las direcciones sin uso para obtener una nueva.","The spend proposal is not pending":"La propuesta de gasto no esta pendiente","The total amount of bitcoin stored in this wallet.":"El total de bitcoins almacenados en esta billetera.","The transaction history and every new incoming transaction are cached in the app. This feature clean this up and synchronizes again from the server":"El historial de transacciones y cada nueva transaccin entrantes se almacenan en cach en la aplicacin. Esta caracterstica limpia y sincroniza otra vez desde el servidor","The wallet service URL":"URL de Wallet Service","There is a new version of {{appName}} available":"Hay una nueva versin de {{appName}} disponible","There is an error in the form":"Hay un error en el formulario","There's obviously something we're doing wrong.":"Obviamente hay algo que estamos haciendo mal.","This app is fantastic!":"Esta aplicacin es fantstica!","This app stores your bitcoin with cutting-edge security.":"Esta aplicacin almacena tus bitcoins con seguridad avanzada.","This bitcoin payment request has expired.":"Esta solicitud de pago ha caducado.","This password cannot be recovered. If the password is lost, there is no way you could recover your funds.":"Esta contrasea no se puede recuperar. Si la pierdes, no hay manera de que puedas recuperar los fondos.","This recovery phrase was created with a password. To recover this wallet both the recovery phrase and password are needed.":"Esta frase de recuperacin fue creada con una contrasea. Para recuperar esta billetera, la frase de recuperacin y la contrasea son necesarios.","This transaction amount is too small compared to current Bitcoin network fees. Spending these funds will need a Bitcoin network fee cost comparable to the funds itself.":"Este monto en la transaccin es demasiado bajo comparado con las comisiones de la red Bitcoin. Para gastar estos fondos se requiere disponer de un monto superior a la comisin requerida por la red Bitcoin.","This transaction could take a long time to confirm or could be dropped due to the low fees set by the sender":"Esta transaccin podra tardar mucho tiempo en confirmar o podra caer debido a la baja comisin establecida por el remitente","This wallet is not registered at the given Bitcore Wallet Service (BWS). You can recreate it from the local information.":"Esta billetera no est registrada en el servidor de Bitcore Wallet Service (BWS). Debes re-crearla con la informacin local disponible.","Timeline":"Lnea de tiempo","To":"Para","To get started, buy bitcoin or share your address. You can receive bitcoin from any wallet or service.":"Para empezar, compra bitcoin o comparte tu direccin. Puedes recibir bitcoin desde cualquier billetera o servicio.","To get started, you'll need to create a bitcoin wallet and get some bitcoin.":"Para empezar, necesitars crear una billetera y obtener bitcoins.","To {{reason}} you must first add your BitPay account - {{email}}":"Para {{reason}} primero debes agregar tu cuenta de BitPay - {{email}}","Top up in progress...":"Recarda en progreso...","Top up {{amountStr}} to debit card ({{cardLastNumber}})":"Recargar {{amountStr}} a la tarjeta de dbito ({{cardLastNumber}})","Total":"Total","Total Locked Balance":"Balance Total Bloqueado","Total number of copayers":"Nmero total de copayers","Total wallet inputs":"Total de entradas de la billetera","Touch ID Failed":"Fall Touch ID","Transaction":"Transaccin","Transaction Created":"Transaccin creada","Transaction History":"Historial de Transacciones","Transaction already broadcasted":"La transaccin ya fue enviada","Transaction has not been created":"La transaccin no ha sido creada","Transaction initiated":"Transaccin iniciada","Transaction not available at this time":"La transaccin no esta disponible en este momento","Transaction not found":"Transaccin no encontrada","Transactions without fee are not supported.":"Las transacciones sin comisin no estn soportadas.","Transfer to":"Transferir a","Transfer to Wallet":"Transferir a billetera","Try again in {{expires}}":"Intenta de nuevo en {{expires}}","Turn bitcoin into dollars, swipe anywhere Visa<sup></sup> is accepted.":"Convierta Bitcoins en Dlares, use Visa<sup>&reg;</sup>.","Type the Recovery Phrase (usually 12 words)":"Escribe la frase de recuperacin (normalmente 12 palabras)","Uh oh...":"Ouch...","Unconfirmed":"Sin confirmar","Unsent transactions":"Transacciones no enviadas","Unused Addresses":"Direcciones no utilizadas","Unused Addresses Limit":"Limite de direcciones sin uso","Update Available":"Actualizacin Disponible","Updating pending proposals. Please stand by":"Actualizando propuestas de pago pendientes. Por favor, espera","Updating transaction history. Please stand by.":"Actualizando el historial de transacciones. Por favor aguarda un momento.","Updating... Please stand by":"Actualizando... Por favor, espera","Urgent":"Urgente","Use Unconfirmed Funds":"Utilizar los fondos sin confirmar","Validating recovery phrase...":"Validando la frase de recuperacin...","Verify your identity":"Verificar tu identidad","Version":"Versin","View":"Ver","View All Addresses":"Ver todas las direcciones","View Terms of Service":"Ver Trminos de Uso","View Transaction on Insight":"Ver Transaccin en Insight","View Update":"Ver Actualizacin","View on blockchain":"Ver en blockchain","Visit mercadolivre.com.br &rarr;":"Ir a Mercadolivre.com.br &rarr;","WARNING: Key derivation is not working on this device/wallet. Actions cannot be performed on this wallet.":"ADVERTENCIA: Derivacin de la clave no funciona en este dispositivo/billetera. Acciones no pueden realizarse en esta billetera.","WARNING: Not including the private key allows to check the wallet balance, transaction history, and create spend proposals from the export. However, does not allow to approve (sign) proposals, so <b>funds will not be accessible from the export</b>.":"ADVERTENCIA: No incluir la clave privada permite verificar el saldo de la billetera, historial de transacciones y crear propuestas de gastos. Sin embargo, no permite aprobar propuestas (firmar), as que <b>los fondos no sern accesibles al exportar</b>.","WARNING: The private key of this wallet is not available. The export allows to check the wallet balance, transaction history, and create spend proposals from the export. However, does not allow to approve (sign) proposals, so <b>funds will not be accessible from the export</b>.":"ADVERTENCIA: La clave privada de esta billetera no est disponible. La exportacin permite verificar el saldo de la billetera, historial de transacciones y crear propuestas de gastos. Sin embargo, no permite aprobar propuestas (firmar), as que <b>los fondos no sern accesibles al exportar</b>.","WARNING: UNTRUSTED CERTIFICATE":"ADVERTENCIA: EL CERTIFICADO NO ES DE CONFIANZA","Waiting for Ledger...":"Esperando a Ledger...","Waiting for Trezor...":"Esperando a Trezor...","Waiting for copayers":"Esperando a los dems copayers","Waiting...":"Esperando...","Wallet Addresses":"Direcciones de la billetera","Wallet Color":"Color de la billetera","Wallet Configuration (m-n)":"Configuracin de la billetera (m-n)","Wallet Created":"Billetera Creada","Wallet Id":"Id de la Billetera","Wallet Information":"Informacin de la Billetera","Wallet Inputs":"Entradas de la billetera","Wallet Invitation":"Invitacin para unirse a la billetera","Wallet Key":"Llave de la billetera","Wallet Name":"Nombre de la billetera","Wallet Name (at creation)":"Nombre de la billetera (al crear)","Wallet Network":"Red de la billetera","Wallet Recovery Phrase":"Frase de recuperacin de la billetera","Wallet Recovery Phrase is invalid":"La frase de recuperacin no es vlida","Wallet Service URL":"Wallet Service URL","Wallet Settings":"Preferencias de la billetera","Wallet Type":"Tipo de billetera","Wallet already exists":"La billetera ya existe","Wallet already in {{appName}}":"El monedero ya existe en {{appName}}","Wallet created":"Billetera Creada","Wallet incomplete and broken":"Billetera incompleta y rota","Wallet is full":"La billetera est completa","Wallet is locked":"Billetera bloqueada","Wallet is not complete":"La billetera no esta completa","Wallet name":"Nombre de la billetera","Wallet needs backup":"La billetera requiere copia de seguridad","Wallet not backed up":"Billetera sin copia de seguridad","Wallet not found":"Billetera no encontrada","Wallet not registered":"Billetera no registrada","Wallet not registered at the wallet service. Recreate it from \"Create Wallet\" using \"Advanced Options\" to set your recovery phrase":"La billetera no esta registrado en Wallet Service. Para volver a crear, utilice \"Crear billetera\", \"Opciones avanzadas\" e ingrese la frase de recuperacin","Wallet recovery phrase not available.":"Frase de recuperacin de la billetera no disponible.","Wallet service not found":"Wallet Service no encontrado","Wallets":"Billeteras","Wallets & Integrations":"Billeteras & Integraciones","Warning!":"Advertencia!","Warning: this transaction has unconfirmed inputs":"Advertencia: esta operacin tiene entradas sin confirmar","Watch out!":"Cuidado!","We'd love to do better.":"Nos encantara hacerlo mejor.","We'll confirm on the next screen.":"Se confirmar en la siguiente pantalla.","We're always looking for ways to improve {{appName}}.":"Siempre estamos buscando maneras de mejorar {{appName}}.","We're always looking for ways to improve {{appName}}. How could we improve your experience?":"Siempre estamos buscando maneras de mejorar {{appName}}. Cmo podramos mejorar tu experiencia?","Website":"Pgina web","Were always looking for translation contributions! You can make corrections or help to make this app available in your native language by joining our community on Crowdin.":"Siempre estamos buscando aportes de traduccin! Puedes ayudar a que esta aplicacin est disponible en tu idioma nativo unindote a nuestra comunidad en Crowdin.","What do you call this wallet?":"Como desea llamar a esta billetera?","When this wallet was created, it was called {{walletName}}. You can change the name displayed on this device below.":"Cuando fue creada esta billetera, se llamaba &ldquo;{{walletName}}&rdquo;. Aqu puede cambiar el nombre que se mostrara en este dispositivo.","Where would you like to receive email notifications about payments?":"A donde le gustara recibir notificaciones por email sobre sus transacciones?","Why?":"Por qu?","Would you be willing to rate {{appName}} in the app store?":"Estara usted dispuesto a opinar sobre {{appName}} en la app store?","Would you like to receive push notifications about payments?":"Quieres recibir notificaciones push sobre sus transacciones?","Wrong number of recovery words:":"Nmero incorrecto de palabras:","Wrong spending password":"Contrasea para pagos incorrecta","Yes":"Si","Yes, skip":"Si, omitir","You can create a backup later from your wallet settings.":"Puedes hacerlo luego desde las preferencias de la billetera.","You can make contributions by signing up on our Crowdin community translation website. Were looking forward to hearing from you!":"Se pueden hacer contribuciones al registrarse en nuestro proyecto de traducciones en Crowdin. Esperamos tener noticias tuyas!","You can scan bitcoin addresses, payment requests, paper wallets, and more.":"Puedes escanear direcciones bitcoin, solicitudes de pago, billeteras de papel y ms.","You can see the latest developments and contribute to this open source app by visiting our project on GitHub.":"Puede ver las ltimas novedades y contribuir a nuestra aplicacin de cdigo abierto visitando nuestro proyecto en GitHub.","You can spend bitcoin at millions of websites and stores worldwide.":"Puedes utilizar bitcoin en millones de pginas web y tiendas en todo el mundo.","You can still export it from Advanced &gt; Export.":"Todava puede exportar en Avanzados &gt; Exportar.","You can trade it for other currencies like US Dollars, Euros, or Pounds.":"Puedes cambiarlo por otras monedas como Dlares, Euros o Libras.","You control your bitcoin.":"Controlas tus bitcoins.","You should not set a fee higher than {{maxFeeRecommended}} satoshis/byte.":"No debera elegir una comisin superior a {{maxFeeRecommended}} satoshis/byte.","You will need to log back for fill in your BitPay Card.":"Tendr que iniciar sesin para completar su BitPay Card.","You'll receive email notifications about payments sent and received from your wallets.":"Recibirs notificaciones por correo electrnico acerca de pagos enviados y recibidos de tus billeteras.","Your BitPay Card is ready. Add funds to your card to start using it at stores and ATMs worldwide.":"Tu Tarjeta BitPay ya esta lista. Agrega fondos para comenzar a utilizarla en negocios y cajeros automticos de todo el mundo.","Your Gift Cards":"Tus Tarjetas de Regalo","Your bitcoin wallet is backed up!":"Su billetera bitcoin est resguardada!","Your bitcoin wallet is ready!":"Su billetera bitcoin est lista!","Your fee is lower than recommended.":"Tu comisin es inferior a la recomendada.","Your ideas, feedback, or comments":"Ideas, sugerencias o comentarios","Your name":"Nombre","Your nickname":"Sobrenombre","Your password":"Contrasea","Your purchase could not be completed":"No se pudo completar la compra","Your purchase was added to the list of pending":"Tu compra fue agregada a la lista de pendientes","Your wallet is never saved to cloud storage or standard device backups.":"Tu billetera nunca se sube a la nube ni se resguarda automticamente en el dispositivo.","Your wallet key will be encrypted. The Spending Password cannot be recovered. Be sure to write it down.":"La clave de la billetera ser cifrada. La contrasea para pagos no puede ser recuperada. Asegrate de anotarla.","[Balance Hidden]":"[Balance Oculto]","[Scanning Funds]":"[Buscando Fondos]","add your BitPay Visa card(s)":"agregar sus tarjetas BitPay Visa","locked by pending payments":"bloqueado por pagos pendientes","me":"yo","name@example.com":"nombre@ejemplo.com","preparing...":"preparando...","{{amountStr}} for Amazon.com Gift Card":"{{amountStr}} en tarjeta de regalo de Amazon.com","{{amountStr}} for Mercado Livre Brazil Gift Card":"{{amountStr}} en Tarjeta de Regalo Mercado Livre Brasil","{{appName}} depends on Bitcore Wallet Service (BWS) for blockchain information, networking and Copayer synchronization. The default configuration points to https://bws.bitpay.com (BitPay's public BWS instance).":"{{appName}} depende de Bitcore Wallet Service (BWS) para obtener informacin sobre blockchain y sincronizacin del Copayer. La configuracin por defecto apunta a https://bws.bitpay.com (instancia pblica de BitPay).","{{fee}} will be deducted for bitcoin networking fees.":"{{fee}} se descontar por comisin de la red bitcoin.","{{tx.txp[wallet.id].feeRatePerStr}}  of the sending amount":"{{tx.txp[wallet.id].feeRatePerStr}} de la cantidad a enviar","{{updatingTxHistoryProgress}} transactions downloaded":"{{updatingTxHistoryProgress}} transacciones descargadas","{{wallet.m}}-of-{{wallet.n}}":"{{wallet.m}}-de-{{wallet.n}}"});
    gettextCatalog.setStrings('fr', {"(Trusted)":"(Fiable)","(possible double spend)":"(double dpense possible)","* A payment proposal can be deleted if 1) you are the creator, and no other copayer has signed, or 2) 24 hours have passed since the proposal was created.":"* Une proposition de paiement peut tre supprime si vous en tes le crateur et qu'aucun des autres copayers n'a sign, ou si 24 heures sont passes depuis la cration de la proposition.","- {{btx.feeRateStr}} of the transaction":"- {{btx.feeRateStr}} de la transaction","- {{tx.feeRateStr}} of the transaction":"- {{tx.feeRateStr}} de la transaction","5-star ratings help us get {{appName}} into more hands, and more users means more resources can be committed to the app!":"Une note de 5 toiles permet  {{appName}} de gagner en popularit, et plus d'utilisateurs signifie davantage de ressources alloues  l'appli !","<b>Only</b> redeemable on Mercado Livre (Brazil)":"<b>Seulement</b> utilisable sur Mercado Livre (Brazil)","A member of the team will review your feedback as soon as possible.":"Un membre de lquipe passera en revue votre avis ds que possible.","A total of {{amountAboveMaxSizeStr}} were excluded. The maximum size allowed for a transaction was exceeded.":"Un total de {{amountAboveMaxSizeStr}} a t exclu. La taille maximale autorise pour une transaction a t dpasse.","A total of {{amountBelowFeeStr}} were excluded. These funds come from UTXOs smaller than the network fee provided.":"Un total de {{amountBelowFeeStr}} a t exclu. Ces fonds proviennent d'UTXOs plus petites que les frais de rseau prvus.","About":" propos","Accepted":"Accepte","Account":"Compte","Account Number":"Numro de compte","Accounts":"Comptes","Activity":"Activit","Add Account":"Ajouter un compte","Add BitPay Account?":"Ajouter un compte BitPay?","Add Contact":"Ajouter un contact","Add Funds":"Ajouter des fonds","Add Memo":"Ajouter une note","Add a password":"Ajouter un mot de passe","Add account":"Ajouter un compte","Add an optional password to secure the recovery phrase":"Ajouter un mot de passe optionnel pour scuriser la phrase de rcupration","Add as a contact":"Ajouter comme contact","Add description":"Ajouter une description","Add funds":"Ajouter des fonds","Add this BitPay account ({{email}})?":"Voulez-vous ajouter ce compte BitPay ({{email}}) ?","Add wallet":"Ajouter un portefeuille","Address":"Adresse","Address Book":"Rpertoire","Address Type":"Type d'adresse","Addresses With Balance":"Adresses avec un solde","Advanced":"Paramtres avancs","Advanced Settings":"Paramtres avancs","All":"Toutes","All Addresses":"Toutes les adresses","All of your bitcoin wallet balance may not be available for immediate spending.":"L'intgralit du solde de votre portefeuille bitcoin peut ne pas tre disponible pour des dpenses immdiates.","All signing devices must be added to this multisig wallet before bitcoin addresses can be created.":"Tous les appareils de signature doivent tre ajouts  ce portefeuille multisig avant que les adresses bitcoin ne puissent tre cres.","Allow Camera Access":"Autoriser l'accs  la camra","Allow notifications":"Autoriser les notifications","Almost done! Let's review.":"C'est presque termin ! Vrifions.","Alternative Currency":"Devise alternative","Amazon.com is not available at this moment. Please try back later.":"Amazon.com nest pas disponible pour le moment. Veuillez ressayer plus tard.","Amount":"Montant","Amount below minimum allowed":"Montant en dessous du minimum autoris","Amount too big":"Le montant est trop lev","Amount too low to spend":"Le montant est trop faible pour tre dpens","An update to this app is available. For your security, please update to the latest version.":"Une mise  jour de cette appli est disponible. Pour votre scurit, veuillez mettre  jour vers la dernire version.","Anyone with your backup phrase can access or spend your bitcoin.":"Quelqu'un disposant de votre phrase de sauvegarde peut dpenser vos bitcoins.","Approximate Bitcoin network fee to transfer wallet's balance (with normal priority)":"Frais de rseau Bitcoin approximatifs pour transfrer le solde du portefeuille (avec des frais normaux)","Are you being watched?":"tes-vous surveill(e) ?","Are you being watched? Anyone with your recovery phrase can access or spend your bitcoin.":"tes-vous surveill(e)? Nimporte qui peut dpenser vos bitcoins grce  votre phrase de rcupration.","Are you sure you want to cancel and delete this wallet?":"tes-vous certain(e) de vouloir annuler et supprimer ce portefeuille ?","Are you sure you want to delete this contact?":"Souhaitez-vous rellement supprimer ce contact ?","Are you sure you want to delete this wallet?":"tes-vous certain(e) de vouloir supprimer ce portefeuille ?","Are you sure you want to reject this transaction?":"tes-vous certain(e) de vouloir rejeter cette transaction ?","Are you sure you want to remove this transaction?":"tes-vous certain(e) de vouloir supprimer cette transaction ?","Are you sure you want to skip it?":"tes-vous sr(e) de vouloir ignorer la sauvegarde ?","Are you sure you would like to log out of your BitPay Card account?":"Souhaitez-vous rellement vous dconnecter de votre compte BitPay Card ?","Are you sure you would like to remove your BitPay Card ({{lastFourDigits}}) from this device?":"tes-vous sr(e) de vouloir supprimer votre BitPay Card ({{lastFourDigits}}) de cet appareil?","Auditable":"Vrifiable","Available":"Disponible","Available Balance":"Solde disponible","Average confirmation time":"Temps de confirmation moyen ","BIP32 path for address derivation":"Chemin BIP32 pour la drivation de l'adresse","BTCZ Wallets":"Portefeuilles BTCZ","Backup":"Sauvegarder","Backup Needed":"Sauvegarde requise","Backup all livenet wallets before using this function":"Sauvegardez tous les portefeuilles (livenet) avant d'utiliser cette fonction","Backup needed":"Sauvegarde requise","Backup now":"Sauvegarder maintenant","Backup wallet":"Sauvegarder le portefeuille","Backup your wallet before using this function":"Sauvegardez votre portefeuille avant d'utiliser cette fonction","Bad wallet invitation":"Mauvaise invitation de portefeuille","Balance By Address":"Solde par adresse","Be sure to store your recovery phrase in a secure place. If this app is deleted, your money cannot be recovered without it.":"Noubliez pas de conserver votre phrase de rcupration dans un endroit sr. Si cette application est supprime, votre argent ne peut pas tre rcupr sans elle.","BitPay Visa Cards":"BitPay Visa&reg; Cards","Bitcoin Address":"Adresse bitcoin","Bitcoin Cash (BCH) Balances":"Soldes Bitcoin Cash (BCH)","Bitcoin Cash Support":"Prise en charge de Bitcoin Cash","Bitcoin Network Fee Policy":"Frais de rseau","Bitcoin cash Payment":"Paiement Bitcoin Cash","Bitcoin is a currency.":"Bitcoin est une monnaie.","Bitcoin is different  it cannot be safely held with a bank or web service.":"Bitcoin est diffrent &ndash; il ne peut pas tre conserv en toute scurit avec un service internet ou bancaire.","Bitcoin is secure,<br>digital money.":"Bitcoin est de l'argent<br>numrique scuris.","Bitcoin transactions include a fee collected by miners on the network.":"Les transactions Bitcoin incluent des frais collects par les mineurs du rseau.","Bought {{amountUnitStr}}":"{{amountUnitStr}} achets","Broadcast Payment":"Diffuser le paiement","Broadcasted":"Diffuse","Broadcasting transaction":"Diffusion de la transaction","Browser unsupported":"Navigateur non support","Buy":"Acheter","Buy &amp; Sell Bitcoin":"Acheter &amp; vendre des bitcoins","Buy Bitcoin":"Acheter des bitcoins","Buy a Gift Card":"Acheter une carte-cadeau","Buy from":"Acheter depuis","Buying Bitcoin...":"Achat de bitcoins...","Calculating fee":"Calcul des frais","Cancel":"Annuler","Cancel invitation":"Annuler l'invitation","Cannot Create Wallet":"Impossible de crer le portefeuille","Cannot join the same wallet more that once":"Impossible de rejoindre le mme portefeuille plus d'une fois","Cards":"Cartes","Certified by":"Certifi par","Check installation and retry.":"Vrifiez linstallation et ressayez.","Choose a backup file from your computer":"Choisissez un fichier de sauvegarde depuis votre ordinateur","Choose your destination wallet":"Choisissez votre portefeuille de destination","Choose your source wallet":"Choisissez votre portefeuille source","Clear":"Effacer","Clear cache":"Vider le cache","Click to accept":"Cliquez pour accepter","Click to pay":"Cliquez pour payer","Click to send":"Cliquez pour envoyer","Close":"Fermer","Coin":"Pice","Color":"Couleur","Commit hash":"Commit hash","Complete the backup process to use this option":"Terminez le processus de sauvegarde pour utiliser cette option","Completed":"Termin","Confirm":"Confirmer","Confirm &amp; Finish":"Confirmer &amp; Terminer","Confirm purchase":"Confirmer l'achat","Confirm your PIN":"Confirmez votre PIN","Confirm your new spending password":"Confirmez votre nouveau code de dpenses","Confirmations":"Confirmations","Confirming":"Confirmation","Connect my BitPay Card":"Connecter ma BitPay Card","Connecting to Coinbase...":"Connexion  Coinbase...","Connecting to Glidera...":"Connexion  Glidera...","Connection reset by peer":"Connexion rinitialise par un pair","Contacts":"Contacts","Continue":"Continuer","Contribute Translations":"Contribuer aux traductions","Copayer already in this wallet":"Copayer dj dans ce portefeuille","Copayer already voted on this spend proposal":"Le Copayer a dj vot pour cette proposition de dpense","Copayer data mismatch":"Les donnes Copayer ne correspondent pas","Copayer joined":"Un Copayer  rejoint","Copayer {{$index}}":"Copayer {{$index}}","Copied to clipboard":"Copi(e) dans le presse-papier","Copy this text as it is to a safe place (notepad or email)":"Copiez ce texte prsent tel quel vers un endroit sr (bloc-notes ou e-mail)","Copy to clipboard":"Copier dans le presse-papier","Could not access Gift Card Service":"Impossible d'accder au service de carte-cadeau","Could not access the wallet at the server. Please check:":"Impossible d'accder au portefeuille via le serveur. Veuillez vrifier :","Could not access to Amazon.com":"Impossible d'accder  Amazon.com","Could not access wallet":"Impossible daccder au portefeuille","Could not add message to imported wallet without shared encrypting key":"Could not add message to imported wallet without shared encrypting key","Could not broadcast payment":"Impossible de diffuser le paiement","Could not build transaction":"Impossible de crer la transaction","Could not create address":"Impossible de crer l'adresse","Could not create the invoice":"Impossible de crer la facture","Could not create transaction":"Impossible de crer la transaction","Could not create using the specified extended private key":"Impossible de crer en utilisant la cl prive tendue spcifie","Could not create using the specified extended public key":"Impossible de crer en utilisant la cl publique tendue spcifie","Could not create: Invalid wallet recovery phrase":"Impossible de crer : Phrase de rcupration du portefeuille invalide","Could not decrypt file, check your password":"Impossible de dchiffrer le fichier, vrifiez votre mot de passe","Could not delete payment proposal":"Impossible de supprimer la proposition de paiement","Could not duplicate":"Impossible de dupliquer","Could not get dynamic fee":"Impossible d'obtenir les frais dynamiques","Could not get dynamic fee for level: {{feeLevel}}":"Impossible d'obtenir les frais dynamiques pour : {{feeLevel}}","Could not get fee levels":"Impossible d'obtenir les niveaux de frais","Could not get the invoice":"Impossible d'obtenir la facture","Could not get transactions":"Impossible de rcuprer les transactions","Could not import":"Impossible d'importer","Could not import. Check input file and spending password":"Impossible d'importer. Vrifiez le fichier d'entre et le code de dpenses","Could not join wallet":"Impossible de rejoindre le portefeuille","Could not reject payment":"Impossible de rejeter le paiement","Could not remove account":"Impossible de supprimer le compte","Could not remove card":"Impossible de supprimer la carte","Could not save preferences on the server":"Impossible d'enregistrer les prfrences sur le serveur","Could not send payment":"Impossible d'envoyer le paiement","Could not send transaction":"Impossible d'envoyer la transaction","Could not update transaction history":"Impossible de mettre  jour l'historique des transactions","Could not update wallet":"Impossible de mettre  jour le portefeuille","Create Personal Wallet":"Crer un portefeuille personnel","Create Shared Wallet":"Crer un portefeuille partag","Create bitcoin wallet":"Crer un portefeuille bitcoin","Create new wallet":"Crer","Create shared wallet":"Crer un portefeuille partag","Create {{formData.requiredCopayers}}-of-{{formData.totalCopayers}} wallet":"Crer un portefeuille {{formData.requiredCopayers}}-sur-{{formData.totalCopayers}}","Created by":"Cre par","Creating Wallet...":"Cration du portefeuille...","Creating transaction":"Cration de la transaction","Current fee rate for this policy":"Frais actuels pour ce choix ","Custom":"Personnaliss","Custom Amount":"Montant personnalis","Custom Fee":"Frais personnaliss","Date":"Date","Delete":"Supprimer","Delete Payment Proposal":"Supprimer la proposition de paiement","Delete Wallet":"Supprimer le portefeuille","Delete it and create a new one":"Le supprimer et en crer un nouveau","Deleting Wallet...":"Suppression du portefeuille...","Deleting payment proposal":"Suppression de la proposition de paiement","Derivation Path":"Chemin de drivation","Derivation Strategy":"Stratgie de drivation","Details":"Dtails","Disabled":"Dsactiv","Do it later":"La faire plus tard","Do not include private key":"Ne pas inclure la cl prive","Don't see your language on Crowdin? Contact the Owner on Crowdin! We'd love to support your language.":"Vous ne voyez pas votre langue sur Crowdin? Contactez le propritaire sur Crowdin! Nous serions ravis de prendre en charge votre langue.","Download":"Tlcharger","Duplicate for BCH":"Dupliquer pour BCH","Duplicating wallet...":"Duplication du portefeuille...","Each bitcoin wallet can generate billions of addresses from your 12-word backup. A new address is automatically generated and shown each time you receive a payment.":"Chaque portefeuille bitcoin peut gnrer des milliards dadresses depuis votre sauvegarde de 12 mots. Une nouvelle adresse est automatiquement gnre et affiche  chaque fois que vous recevez un paiement.","Economy":"Faibles","Edit":"Modifier","Email":"E-mail","Email Address":"Adresse e-mail","Empty addresses limit reached. New addresses cannot be generated.":"La limite d'adresses vides a t atteinte. Les nouvelles adresses ne peuvent plus tre gnres.","Enable Bitcoin Cash wallet creation and operation within the App.":"Permet la cration et la gestion de portefeuilles Bitcoin Cash.","Enable camera access in your device settings to get started.":"Autorisez laccs  la camra dans les rglages de votre appareil pour commencer.","Enable email notifications":"Activer les notifications e-mail","Enable push notifications":"Autoriser les notifications","Enable the camera to get started.":"Autorisez la camra pour commencer.","Enabled":"Active","Enter Spending Password":"Saisissez le code de dpenses","Enter Two Factor for your BitPay account":"Saisissez le code  deux facteurs pour votre compte BitPay","Enter amount":"Saisissez un montant","Enter custom fee":"Saisissez des frais personnaliss","Enter new spending password":"Saisissez un nouveau code de dpenses","Enter the recovery phrase (BIP39)":"Saisissez la phrase de rcupration (BIP39)","Enter your email":"Saisissez votre e-mail","Enter your password":"crivez votre mot de passe","Error":"Erreur","Error at confirm":"Erreur  la confirmation","Error creating gift card":"Erreur de cration de la carte-cadeau","Error creating the invoice":"Erreur de cration de la facture","Error creating wallet":"Erreur de cration du portefeuille","Error getting SendMax information":"Erreur dobtention de l'information SendMax","Error in Payment Protocol":"Erreur dans le protocole de paiement","Error pairing BitPay Account":"Erreur d'appariement du compte BitPay","Error scanning funds:":"Erreur de numrisation des fonds :","Error sweeping wallet:":"Erreur de balayage de portefeuille :","Error updating Debit Cards":"Erreur de mise  jour des cartes de dbit","Exceeded daily limit of $500 per user":"La limite quotidienne de 500$ par utilisateur a t dpasse","Expired":"Expir","Expires":"Expire dans","Export Wallet":"Exporter le portefeuille","Export to file":"Exporter vers un fichier","Export wallet":"Exporter le portefeuille","Exporting via QR not supported for this wallet":"L'exportation via QR n'est pas supporte pour ce portefeuille","Extended Public Keys":"Cls publiques tendues","Extracting Wallet information...":"Extraction des informations du portefeuille...","Failed to export":"Impossible d'exporter","Family vacation funds":"Fonds pour les vacances familiales","Fee":"Frais","Fee level":"Frais","Fee level is not defined":"Le niveau de frais n'est pas dfini","Fee:":"Frais :","Feedback could not be submitted. Please try again later.":"Vos commentaires n'ont pas pu tre envoys. Veuillez ressayer plus tard.","Fetching BitPay Account...":"Rcupration du compte BitPay...","Fetching payment information":"Rcupration des informations de paiement","File/Text":"Fichier / Texte","Filter setting":"Paramtres de filtre","Finger Scan Failed":"La numrisation digitale a chou","Finish":"Terminer","For audit purposes":" des fins de vrification","From":"De","From BitPay account":"Depuis un compte BitPay","From Hardware Wallet":"Depuis un portefeuille matriel","From the destination device, go to Add wallet &gt; Import wallet and scan this QR code":"Depuis l'appareil de destination, allez sur Ajouter un portefeuille &gt; Importer et numrisez ce code QR","Funds are locked by pending spend proposals":"Les fonds sont verrouills par des propositions de dpenses en attente","Funds found:":"Fonds trouvs :","Funds to be added":"Fonds  ajouter","Funds transferred":"Fonds transfrs","Funds were added to debit card":"Les fonds ont t ajouts  la carte de dbit","Funds will be transferred to":"Les fonds seront transfrs  ","Generate new address":"Gnrer une nouvelle adresse","Generating .csv file...":"Gnration du fichier .csv...","Generating new address...":"Gnration d'une nouvelle adresse...","Get local cash anywhere you go, from any Visa<sup></sup> compatible ATM. ATM bank fees may apply.":"Retirez de l'argent partout o vous allez, depuis n'importe quel distributeur compatible Visa<sup>&reg;</sup>. Des frais bancaires de distributeur peuvent s'appliquer.","Get news and updates from BitPay":"Obtenir les actualits et mises  jour de BitPay","Get started":{"button":"Commencer","$$noContext":"Commencez"},"Get started by adding your first one.":"Commencez par ajouter votre premier contact.","Getting fee levels...":"Obtention des niveaux de frais...","Gift Card is not available to use anymore":"La carte-cadeau n'est plus utilisable","Gift card":"Carte-cadeau","Gift card expired":"Carte-cadeau expire","Gift card generated and ready to use.":"Carte-cadeau gnre et prte  lemploi.","Go Back":"Retour","Go back":"Retour","Got it":"J'ai compris","Hardware Wallet":"Portefeuille matriel","Hardware not connected.":"Matriel non connect.","Hardware wallet":"Portefeuille matriel","Hardware wallets are not yet supported with Bitcoin Cash":"Les portefeuilles matriels ne sont pas encore pris en charge avec Bitcoin Cash","Help & Support":"Aide & Support","Help and support information is available at the website.":"De l'aide peut tre trouve sur le site internet (en anglais pour le moment).","Hide":"Masquer","Hide Balance":"Masquer le solde","Hide Next Steps Card":"Masquer la carte Prochaines tapes","Hide advanced options":"Masquer les options avances","Home":"Accueil","How could we improve your experience?":"Comment pourrions-nous amliorer votre exprience ?","How do you like {{appName}}?":"Comment trouvez-vous {{appName}} ?","I don't like it":"Je ne l'aime pas","I have read, understood, and agree to the <a ng-click=\"openTerms()\" translate=\"\">Terms of Use</a>.":"Jai lu, compris et suis d'accord avec les <a ng-click=\"openTerms()\" translate=\"\">Conditions d'utilisation</a>.","I have read, understood, and agree with the Terms of use.":"J'ai lu, compris et suis d'accord avec les conditions d'utilisation.","I have written it down":"Je l'ai bien crit","I like the app":"J'aime l'appli","I think this app is terrible.":"Je dteste cette appli","I understand":"Je comprends","I understand that if this app is moved to another device or deleted, my bitcoin can only be recovered with the backup phrase.":"Je comprends que si cette application est dplace vers un autre appareil ou supprime, mes bitcoins ne peuvent tre rcuprs qu'avec la phrase de sauvegarde.","I understand that my funds are held securely on this device, not by a company.":"Je comprends que mes fonds sont en toute scurit sur cet appareil et non dtenus par une entreprise.","I've written it down":"Je l'ai bien crite","If enabled, all sensitive information (private key and recovery phrase) and actions (spending and exporting) associated with this wallet will be protected.":"Si l'option est active, toutes les informations sensibles (cl prive et phrase de rcupration) ainsi que les oprations (dpenses et exportations) associes  ce portefeuille seront protges.","If enabled, the Recent Transactions card - a list of transactions occuring across all wallets - will appear in the Home tab.":"Si l'option est active, la carte des transactions rcentes - une liste des transactions qui se produisent dans lensemble des portefeuilles - saffichera dans longlet Accueil.","If enabled, wallets will also try to spend unconfirmed funds. This option may cause transaction delays.":"Si l'option est active, les portefeuilles vont essayer de dpenser des fonds non confirms. Cette option peut entraner des retards de transaction.","If this device is replaced or this app is deleted, neither you nor BitPay can recover your funds without a backup.":"Si cet appareil est remplac ou si cette appli est supprime, ni vous ni BitPay ne peuvent rcuprer vos fonds sans une sauvegarde.","If you have additional feedback, please let us know by tapping the \"Send feedback\" option in the Settings tab.":"Si vous avez d'autres commentaires, veuillez nous en informer en appuyant sur l'option Envoyer un avis dans l'onglet Paramtres.","If you take a screenshot, your backup may be viewed by other apps. You can make a safe backup with physical paper and a pen.":"Si vous prenez une capture dcran, votre sauvegarde peut tre vue par dautres applications. Vous pouvez faire une sauvegarde physique scurise avec du papier et un stylo.","Import":"Importer","Import Wallet":"Importer un portefeuille","Import backup":"Importer la sauvegarde","Import wallet":"Importer un portefeuille","Importing Wallet...":"Importation du portefeuille...","In order to verify your wallet backup, please type your password.":"Afin de vrifier la sauvegarde de votre portefeuille, veuillez saisir votre mot de passe.","Inactive":"Inactive","Incomplete":"Non termin","Incomplete wallet":"Portefeuille non termin","Incorrect PIN, try again.":"PIN incorrect, veuillez ressayer.","Incorrect code format":"Format du code incorrect","Incorrect network address":"Adresse rseau invalide","Insufficient funds":"Fonds insuffisants","Insufficient funds for fee":"Fonds insuffisants pour les frais","Invalid":"Invalide","Invalid URL":"URL invalide","Invalid account number":"Numro de compte invalide","Invalid address":"Adresse invalide","Invalid data":"Donnes invalides","Invalid derivation path":"Chemin de drivation invalide","Invitation to share a {{appName}} Wallet":"Invitation pour partager un portefeuille {{appName}}","Invoice expired":"La facture a expir","Is there anything we could do better?":"Y a-t-il quelque chose que nous pourrions amliorer ?","Is this correct?":"Est-ce correct ?","Is this email address correct?":"Cette adresse e-mail est-elle correcte ?","It's a good idea to avoid reusing addresses - this both protects your privacy and keeps your bitcoins secure against hypothetical attacks by quantum computers.":"Cest une bonne ide d'viter la rutilisation des adresses. Cela fois protge votre anonymat et garde vos bitcoins en scurit contre les attaques hypothtiques des ordinateurs quantiques.","It's important that you write your backup phrase down correctly. If something happens to your wallet, you'll need this backup to recover your money. Please review your backup and try again.":"Il est important dcrire correctement votre phrase de sauvegarde. Si quelque chose arrive  votre portefeuille, vous aurez besoin de cette sauvegarde afin de rcuprer votre argent. Vrifiez votre sauvegarde et ressayez.","Join":"Rejoindre","Join my {{appName}} Wallet. Here is the invitation code: {{secret}} You can download {{appName}} for your phone or desktop at {{appUrl}}":"Rejoins mon portefeuille {{appName}}. Voici le code d'invitation : {{secret}} Tu peux tlcharger {{appName}} pour ton tlphone ou pour ton ordinateur sur {{appUrl}}","Join shared wallet":"Rejoindre un portefeuille partag","Joining Wallet...":"Connexion au portefeuille...","Just scan the code to pay.":"Numrisez juste le code pour payer.","Key already associated with an existing wallet":"La cl est dj associe avec un portefeuille existant","Language":"Langue","Last Month":"Le mois dernier","Learn more":"En savoir plus","Let's verify your backup phrase.":"Vrifions votre phrase de sauvegarde.","Loading addresses...":"Chargement des adresses...","Loading transaction info...":"Chargement des infos de transaction...","Lock App":"Verrouiller l'appli","Lock by Fingerprint":"Verrouiller par empreinte digitale","Lock by PIN":"Verrouiller par un code PIN","Locked":"Verrouill","Locktime in effect. Please wait to create a new spend proposal":"Locktime effectif. Veuillez patienter pour crer une nouvelle proposition de dpense","Locktime in effect. Please wait to remove this spend proposal":"Locktime effectif. Veuillez patienter pour supprimer cette proposition de dpense","Log options":"Options de log","Log out":"Se dconnecter","Low amount inputs":"Entres de faible montant","Low fees":"Frais faibles","Makes sense":"C'est logique","Matches:":"Correspondances :","Me":"Moi","Meh - it's alright":"a peut aller","Memo":"Note","Mercado Livre Brazil Gift Cards":"Cartes-cadeaux Mercado Livre Brazil","Mercadolibre Gift Card Service is not available at this moment. Please try back later.":"Le service de carte-cadeau Mercadolibre n'est pas disponible en ce moment. Veuillez ressayer plus tard.","Merchant Message":"Message marchand","Miner Fee":"Frais de minage","Missing parameter":"Paramtre manquant","Missing private keys to sign":"Cls prives manquantes pour signer","More Options":"Plus d'options","Moved":"Dplacs","Moved Funds":"Fonds dplacs","Multiple recipients":"Plusieurs destinataires","NOTE: To import a wallet from a 3rd party software, please go to Add Wallet &gt; Create Wallet, and specify the Recovery Phrase there.":"Remarque : Pour importer un portefeuille dun autre logiciel que Copay, veuillez aller dans Ajouter portefeuille &gt; Crer et spcifier la phrase de rcupration.","Name":"Nom","Network Cost":"Cot de rseau","Network error":"Erreur rseau","New Proposal":"Nouvelle proposition","New address could not be generated. Please try again.":"La nouvelle adresse n'a pas pu tre gnre. Veuillez ressayer.","New personal wallet":"Nouveau portefeuille personnel","Next steps":"Prochaines tapes","No Wallet":"Aucun portefeuille","No access key defined":"Aucune cl daccs dfinie","No backup, no bitcoin.":"Pas de sauvegarde, pas de bitcoin.","No contacts yet":"Aucun contact","No entries for this log level":"Aucune entre pour ce niveau de log","No hardware information available.":"Aucune information matrielle disponible.","No hardware wallets supported on this device":"Aucun portefeuille matriel pris en charge sur cet appareil","No pending proposals":"Aucune proposition en attente","No recent transactions":"Aucune transaction rcente","No signing proposal: No private key":"Aucune proposition de signature: aucune cl prive","No transactions yet":"Aucune transaction","No wallet found":"Aucun portefeuille trouv","No wallet selected":"Aucun portefeuille slectionn","No wallets available":"Aucun portefeuille disponible","No wallets available to receive funds":"Aucun portefeuille disponible pour recevoir des fonds","No wallets eligible for Bitcoin Cash support":"Aucun portefeuille n'est ligible pour Bitcoin Cash","Non eligible BTCZ wallets":"Portefeuilles BTCZ non ligibles","Normal":"Normaux","Not authorized":"Non autoris","Not enough funds for fee":"Pas assez de fonds pour les frais","Not even BitPay can access it.":"Mme BitPay ne peut y accder.","Not funds found":"Aucun fonds trouv","Not now":"Pas maintenant","Note":"Note","Notice: only 1-1 (single signature) wallets can be used for sell bitcoin":"Note : seuls les portefeuilles 1-1 (signature unique) peuvent tre utiliss pour vendre des bitcoins","Notifications":"Notifications","Notifications by email":"Notifications par e-mail","Notify me if confirmed":"Me notifier si la transaction se confirme","Notify me when transactions are confirmed":"Me notifier quand les transactions se confirment","Now is a good time to backup your wallet. If this device is lost, it is impossible to access your funds without a backup.":"C'est un bon moment pour sauvegarder votre portefeuille. Si cet appareil est perdu, vos fonds seront irrcuprables sans une sauvegarde.","Now is a perfect time to assess your surroundings. Nearby windows? Hidden cameras? Shoulder-spies?":"C'est le moment d'observer autour de vous! Personne aux fentres? Derrire vous? Aucune camra cache?","OK":"Ok","OKAY":"OK","Official English Disclaimer":"Clause de non-responsabilit anglaise officielle","Oh no!":"Oh non !","Ok":"Ok","On this screen you can see all your wallets, accounts, and assets.":"Vous pouvez visualiser tous vos portefeuilles, comptes et actifs sur cet cran.","Open":"Ouvrir","Open Crowdin":"Ouvrir Crowdin","Open GitHub":"Ouvrir GitHub","Open GitHub Project":"Ouvrir le projet GitHub","Open Insight":"Ouvrir Insight","Open Settings":"Ouvrir les paramtres","Open Translation Community":"Ouvrir la communaut de traduction","Open Website":"Ouvrir le site internet","Open bitcoincash.org?":"Ouvrir bitcoincash.org ?","Open wallet":"Ouvrir le portefeuille","Open website":"Ouvrir le site internet","Order the BitPay Card":"Commander la BitPay Card","Password":"Mot de passe","Password required. Make sure to enter your password in advanced options":"Mot de passe requis. Veuillez saisir votre mot de passe dans les options avances","Paste invitation here":"Collez l'invitation ici","Paste the backup plain text code":"Collez le code texte de sauvegarde","Pay 0% fees to turn bitcoin into dollars.":"Aucun frais pour changer des bitcoins en dollars.","Pay To":"Payer ","Payment Accepted":"Paiement accept","Payment Expires:":"Le paiement expirera dans :","Payment Proposal":"Proposition de paiement","Payment Proposal Created":"Proposition de paiement cre","Payment Proposals":"Propositions de paiement","Payment Protocol Invalid":"Protocole de paiement invalide","Payment Protocol not supported on Chrome App":"Le protocole de paiement n'est pas support sur l'application Chrome","Payment Received":"Paiement reu","Payment Rejected":"Paiement rejet","Payment Sent":"Paiement envoy","Payment accepted, but not yet broadcasted":"Paiement accept, mais pas encore diffus","Payment accepted. It will be broadcasted by Glidera. In case there is a problem, it can be deleted 6 hours after it was created.":"Paiement accept. Il sera diffus par Glidera. Dans le cas o il y a un problme, il peut tre supprim 6 heures aprs avoir t cr.","Payment address was translated to new Bitcoin Cash address format:":"L'adresse de paiement a t convertie au nouveau format d'adresse Bitcoin Cash :","Payment details":"Dtails du paiement","Payment request":"Demande de paiement","Pending":"En attente","Pending Proposals":"Propositions en attente","Permanently delete this wallet.":"Supprimer dfinitivement ce portefeuille.","Personal Wallet":"Portefeuille personnel","Please carefully write down this phrase.":"Veuillez crire soigneusement cette phrase.","Please connect a camera to get started.":"Veuillez connecter une camra pour commencer.","Please enter the recovery phrase":"Veuillez saisir la phrase de rcupration","Please enter the wallet recovery phrase":"Veuillez saisir la phrase de rcupration du portefeuille","Please enter your PIN":"Veuillez saisir votre PIN","Please tap each word in the correct order.":"Veuillez slectionner chaque mot dans le bon ordre.","Please upgrade Copay to perform this action":"Veuillez mettre  jour Copay pour effectuer cette action","Please wait":"Veuillez patienter","Please, select your backup file":"Veuillez slectionner votre fichier de sauvegarde","Pre-Auth Holds":"Blocages pr-autoriss","Preferences":"Prfrences","Preparing addresses...":"Prparation des adresses...","Preparing backup...":"Prparation de la sauvegarde...","Press again to exit":"Appuyez de nouveau pour quitter","Priority":"levs","Private Key":"Cl prive","Private key encrypted. Enter password":"Cl prive chiffre. Saisissez le mot de passe","Private key is encrypted, cannot sign":"La cl prive est chiffre, impossible de signer","Proposal Accepted":"Proposition accepte","Proposal Created":"Proposition cre","Proposal Deleted":"Proposition supprime","Proposal Rejected":"Proposition rejete","Proposals":"Propositions","Purchase Amount is limited to {{limitPerDay}} {{currency}} per day":"Le montant d'achat est limit  {{limitPerDay}} {{currency}} par jour","Purchase amount must be a value between 50 and 2000":"Le montant d'achat doit tre une valeur comprise entre 50 et 2000","Push Notifications":"Notifications","Push notifications for {{appName}} are currently disabled. Enable them in the Settings app.":"Les notifications pour {{appName}} sont actuellement dsactives. Activez-les dans les paramtres de l'appli.","QR Code":"Code QR","Quick review!":"Rcapitulatif !","Random":"Alatoire","Rate on the app store":"valuer dans la boutique","Read less":"En savoir moins","Read more":"En savoir plus","Read more in our Wiki":"Lisez notre Wiki pour en savoir plus","Receive":"Recevoir","Receive in":"Recevoir dans","Received":"Reus","Received Funds":"Fonds reus","Receiving":"Rception","Recent":"Transactions rcentes","Recent Transaction Card":"Carte des transactions rcentes","Recent Transactions":"Transactions rcentes","Recipient":"Destinataire","Recipients":"Destinataire(s)","Recovery phrase":"Phrase de rcupration","Recreating Wallet...":"Recration du portefeuille...","Redeem now":"Utiliser maintenant","Rejected":"Rejete","Rejecting payment proposal":"Rejet de la proposition de paiement","Release information":"Informations de version","Remove":"Supprimer","Remove BitPay Account?":"Supprimer le compte BitPay ?","Remove BitPay Card?":"Supprimer la BitPay Card ?","Removing your BitPay account will remove all associated BitPay account data from this device. Are you sure you would like to remove your BitPay Account ({{email}}) from this device?":"La suppression de votre compte BitPay supprimera tous les donnes de compte BitPay associes  cet appareil. tes-vous sr(e) de vouloir supprimer votre compte BitPay {{email}} de cet appareil ?","Repeat password":"Confirmez le mot de passe","Repeat the password":"Confirmez le mot de passe","Request Fingerprint":"Demander l'empreinte digitale","Request Specific amount":"Demander un montant prcis","Request Spending Password":"Demander un code de dpenses","Required number of signatures":"Nombre requis de signatures","Restore from backup":"Restaurer  partir d'une sauvegarde","Retrieving inputs information":"Rcupration des informations d'entre","Retry":"Rssayer","Retry Camera":"Ressayer la camra","Save":"Valider","Scan":"Numriser","Scan QR Codes":"Numrisez des codes QR","Scan addresses for funds":"Analyser les adresses pour des fonds","Scan again":"Ranalyser","Scan your fingerprint please":"Veuillez scanner votre empreinte digitale","Scan your wallets for Bitcoin Cash":"Analyser vos portefeuilles pour Bitcoin Cash","Scanning Wallet funds...":"Analyse des fonds du portefeuille...","Scanning funds...":"Analyse des fonds...","Screenshots are not secure":"Les captures dcran ne sont pas scurises","Search Transactions":"Rechercher des transactions","Search or enter bitcoin address":"Recherchez ou saisissez une adresse bitcoin","Search transactions":"Rechercher des transactions","Search your currency":"Rechercher votre monnaie","Security":"Scurit","See invoice":"Voir la facture","Select a backup file":"Slectionner un fichier de sauvegarde","Select a wallet":"Slectionner un portefeuille","Self-signed Certificate":"Certificat auto-sign","Selling Bitcoin...":"Vente de bitcoins...","Send":"Envoyer","Send Feedback":"Envoyer un avis","Send Money":"Envoyer de l'argent","Send addresses by email":"Envoyer les adresses par e-mail","Send by email":"Envoyer par e-mail","Send from":"Envoyer  partir de","Send max amount":"Envoyer le montant maximal","Send payment to this address":"Envoyer le paiement  cette adresse","Send us feedback instead":"Nous envoyer un avis  la place","Sending":"Envoi","Sending 2FA code...":"Envoi du code 2FA...","Sending feedback...":"Envoi de votre avis...","Sending maximum amount":"Envoi du montant maximal","Sending transaction":"Envoi de la transaction","Sending {{amountStr}} from your {{name}} wallet":"Envoi de {{amountStr}} depuis votre portefeuille {{name}}","Sent":"Envoys","Sent Funds":"Fonds envoys","Server response could not be verified":"La rponse du serveur n'a pas pu tre vrifie","Service not available":"Service non disponible","Services":"Services","Session Log":"Journal de session","Session log":"Journal de session","Set up a password":"Spcifiez un mot de passe","Set your own fee in satoshis/byte":"Dfinissez vos propres frais en satoshis/byte","Settings":"Paramtres","Share the love by inviting your friends.":"Partagez lamour en invitant vos amis.","Share this invitation with your copayers":"Partagez cette invitation avec vos copayers","Share {{appName}}":"Partager {{appName}}","Shared Wallet":"Portefeuille partag","Show Recovery Phrase":"Afficher la phrase de rcupration","Show address":"Afficher l'adresse","Show advanced options":"Afficher les options avances","Show bitcoin address":"Afficher vos adresses bitcoin","Show more":"En afficher plus","Signatures rejected by server":"Signatures rejetes par le serveur","Signing transaction":"Signature de la transaction","Since only you control your money, youll need to save your backup phrase in case this app is deleted.":"Puisque vous seul contrlez votre argent, vous devrez enregistrer votre phrase de sauvegarde au cas o cette appli est supprime.","Single Address Wallet":"Portefeuille d'adresse unique","Skip":"Ignorer","Slide to accept":"Faites glisser pour accepter","Slide to buy":"Faites glisser pour acheter","Slide to pay":"Faites glisser pour payer","Slide to send":"Faites glisser pour envoyer","Specify Recovery Phrase...":"Spcifier la phrase de rcupration...","Spend proposal is not accepted":"La proposition de dpense n'est pas accepte","Spend proposal not found":"Propostion de dpense introuvable","Spending Password needed":"Code de dpenses requis","Spending this balance will need significant Bitcoin network fees":"La dpense de ce solde demandera d'importants frais de rseau Bitcoin","Start sending bitcoin":"Commencez  envoyer des bitcoins","Startup Lock":"Verrou au dmarrage de l'appli","Still pending":"En attente","Success":"Succs","Super Economy":"Infimes","Support Bitcoin Cash":"Prendre en charge Bitcoin Cash","Sweep":"Balayer","Sweep paper wallet":"Balayer un portefeuille de papier","Sweeping Wallet...":"Balayage du portefeuille...","THIS ACTION CANNOT BE REVERSED":"CETTE ACTION NE PEUT PAS TRE ANNULE","Take control of your money,<br>get started with bitcoin.":"Prenez le contrle de votre argent,<br>commencez avec bitcoin.","Tap and hold to show":"Appuyez et maintenez pour afficher","Tap to recreate":"Appuyez pour recrer","Tap to retry":"Tapotez pour ressayer","Terms Of Use":"Conditions d'utilisation","Terms of Use":"Conditions d'utilisation","Testnet":"Testnet","Text":"Texte","Thank you!":"Merci!","Thanks!":"Merci!","That's exciting to hear. We'd love to earn that fifth star from you  how could we improve your experience?":"Votre avis nous intresse ! Nous aimerions obtenir une note de 5 toiles de votre part  comment pourrions-nous amliorer votre exprience ?","The Ledger Chrome application is not installed":"L'application Ledger pour Chrome n'est pas installe","The amount of bitcoin immediately spendable from this wallet.":"Le montant des bitcoins immdiatement disponibles depuis ce portefeuille.","The amount of bitcoin stored in this wallet that is allocated as inputs to your pending transaction proposals. The amount is determined using unspent transaction outputs associated with this wallet and may be more than the actual amounts associated with your pending transaction proposals.":"Le montant des bitcoins stocks dans ce portefeuille qui est allou en tant qu'entres  vos propositions de transaction en attente. Le montant est dtermin en utilisant les sorties de transaction non dpenses associes  ce portefeuille et peut tre plus important que les montants rels associs  vos propositions de transaction en attente.","The amount of bitcoin stored in this wallet with less than 1 blockchain confirmation.":"Le montant des bitcoins stocks dans ce portefeuille avec moins d'une confirmation blockchain.","The derivation path":"Le chemin de drivation","The exchange rate changes with the market.":"Le taux de change varie avec le march.","The higher the fee, the greater the incentive a miner has to include that transaction in a block. Current fees are determined based on network load and the selected policy.":"Plus les frais sont importants, plus les mineurs sont incits  inclure votre transaction dans un bloc. Les frais actuels sont dtermins en fonction de la charge du rseau et du choix slectionn.","The maximum number of consecutive unused addresses (20) has been reached. When one of your unused addresses receives a payment, a new address will be generated and shown in your Receive tab.":"Le nombre maximal dadresses inutilises conscutives (20) a t atteint. Lorsqu'une de vos adresses inutilises reoit un paiement, une nouvelle adresse sera gnre et affiche dans votre onglet Recevoir.","The official English Terms of Service are available on the BitPay website.":"Les conditions d'utilisation officielles en anglais sont disponibles sur le site internet de BitPay.","The password of the recovery phrase (if set)":"Le mot de passe de la phrase de rcupration (si configur)","The payment was created but could not be completed. Please try again from home screen":"Le paiement a t cr mais n'a pas pu tre achev. Veuillez ressayer depuis l'cran d'accueil","The payment was removed by creator":"Le paiement a t supprim par le crateur","The recovery phrase could require a password to be imported":"La phrase de rcupration pourrait demander un mot de passe pour tre importe","The request could not be understood by the server":"La demande n'a pas t comprise par le serveur","The restore process will stop when 20 addresses are generated in a row which contain no funds. To safely generate more addresses, make a payment to one of the unused addresses which has already been generated.":"Le processus de restauration sarrte lorsque 20 adresses sont gnres conscutivement sans qu'elles ne contiennent de fonds. Pour gnrer plus d'adresses en toute scurit, effectuez un paiement  lune des adresses inutilises qui a dj t gnre.","The spend proposal is not pending":"La proposition de dpense n'est pas en attente","The total amount of bitcoin stored in this wallet.":"Le montant total des bitcoins stocks dans ce portefeuille.","The transaction history and every new incoming transaction are cached in the app. This feature clean this up and synchronizes again from the server":"Lhistorique des transactions et chaque nouvelle transaction entrante sont mis en cache dans lapplication. Cette fonctionnalit efface cela et synchronise  nouveau  partir du serveur","The wallet service URL":"LURL du service de portefeuille","There is a new version of {{appName}} available":"Une nouvelle version de {{appName}} est disponible","There is an error in the form":"Il y a une erreur dans la forme","There's obviously something we're doing wrong.":"Il y a visiblement quelque chose que nous faisons mal.","This app is fantastic!":"Cette appli est fantastique !","This app stores your bitcoin with cutting-edge security.":"Cette appli conserve vos bitcoins avec une scurit de pointe.","This bitcoin payment request has expired.":"Cette demande de paiement bitcoin a expir.","This password cannot be recovered. If the password is lost, there is no way you could recover your funds.":"Ce mot de passe ne peut pas tre rcupr. Si le mot de passe est perdu, il ny a aucun moyen pour vous de rcuprer vos fonds.","This recovery phrase was created with a password. To recover this wallet both the recovery phrase and password are needed.":"Cette phrase de rcupration a t cre avec un mot de passe. Pour rcuprer ce portefeuille, la phrase de rcupration et le mot de passe sont requis.","This transaction amount is too small compared to current Bitcoin network fees. Spending these funds will need a Bitcoin network fee cost comparable to the funds itself.":"Ce montant de transaction est trop faible par rapport aux actuels frais de rseau Bitcoin. La dpense de ces fonds demandera des frais de rseau Bitcoin comparables aux fonds eux-mmes.","This transaction could take a long time to confirm or could be dropped due to the low fees set by the sender":"Cette transaction pourrait prendre beaucoup de temps pour tre confirme ou pourrait tre abandonne  cause du faible niveau de frais fix par l'expditeur","This wallet is not registered at the given Bitcore Wallet Service (BWS). You can recreate it from the local information.":"Ce portefeuille n'est pas enregistr dans le Bitcore Wallet Service (BWS) donn. Vous pouvez le recrer depuis l'information locale.","Timeline":"Chronologie","To":"","To get started, buy bitcoin or share your address. You can receive bitcoin from any wallet or service.":"Pour commencer, achetez des bitcoins ou partagez votre adresse. Vous pouvez recevoir des bitcoins de n'importe quel portefeuille ou service.","To get started, you'll need to create a bitcoin wallet and get some bitcoin.":"Pour commencer, vous aurez besoin de crer un portefeuille bitcoin et d'obtenir quelques bitcoins.","To {{reason}} you must first add your BitPay account - {{email}}":"Pour {{reason}} vous devez d'abord ajouter votre compte BitPay - {{email}}","Top up in progress...":"Rechargement en cours...","Top up {{amountStr}} to debit card ({{cardLastNumber}})":"Rechargement de {{amountStr}} vers la carte de dbit ({{cardLastNumber}})","Total":"Total","Total Locked Balance":"Solde verrouill total","Total number of copayers":"Nombre total de copayers","Total wallet inputs":"Entres de portefeuille totales","Touch ID Failed":"Touch ID a chou","Transaction":"Transaction","Transaction Created":"Transaction cre","Transaction History":"Historique des transactions","Transaction already broadcasted":"Transaction dj diffuse","Transaction has not been created":"La transaction n'a pas t cre","Transaction initiated":"Transaction initie","Transaction not available at this time":"La transaction n'est pas disponible pour l'instant","Transaction not found":"Transaction introuvable","Transactions without fee are not supported.":"Les transactions sans frais ne sont pas supportes.","Transfer to":"Transfrer ","Transfer to Wallet":"Transfrer vers un portefeuille","Try again in {{expires}}":"Ressayez dans {{expires}}","Turn bitcoin into dollars, swipe anywhere Visa<sup></sup> is accepted.":"Convertissez des bitcoins en dollars et dpensez partout o Visa<sup>&reg;</sup> est accept.","Type the Recovery Phrase (usually 12 words)":"Saisissez la phrase de rcupration (gnralement 12 mots)","Uh oh...":"Oh l l...","Unconfirmed":"Non confirme","Unsent transactions":"Transactions non envoyes","Unused Addresses":"Adresses inutilises","Unused Addresses Limit":"Limite des adresses inutilises","Update Available":"Mise  jour disponible","Updating pending proposals. Please stand by":"Mise  jour des propositions en attente. Veuillez patienter","Updating transaction history. Please stand by.":"Mise  jour de l'historique des transactions. Veuillez patienter.","Updating... Please stand by":"Mise  jour... veuillez patienter","Urgent":"Trs levs","Use Unconfirmed Funds":"Utiliser les fonds non confirms","Validating recovery phrase...":"Validation de la phrase de rcupration...","Verify your identity":"Vrification de votre identit","Version":"Version","View":"Voir","View All Addresses":"Voir toutes les adresses","View Terms of Service":"Voir les conditions d'utilisation","View Transaction on Insight":"Voir la transaction sur Insight","View Update":"Voir la mise  jour","View on blockchain":"Voir sur la blockchain","Visit mercadolivre.com.br &rarr;":"Visiter mercadolivre.com.br &rarr;","WARNING: Key derivation is not working on this device/wallet. Actions cannot be performed on this wallet.":"ATTENTION : La drivation de la cl ne fonctionne pas sur cet appareil / portefeuille. Impossible deffectuer des actions sur ce portefeuille.","WARNING: Not including the private key allows to check the wallet balance, transaction history, and create spend proposals from the export. However, does not allow to approve (sign) proposals, so <b>funds will not be accessible from the export</b>.":"ATTENTION : Ne pas inclure la cl prive permet de vrifier le solde du portefeuille, l'historique des transactions, et de crer des demandes de dpenses depuis le fichier export. Cependant, cela ne permet pas d'approuver (signer) les propositions <b>et les fonds ne seront pas accessibles depuis le fichier export</b>.","WARNING: The private key of this wallet is not available. The export allows to check the wallet balance, transaction history, and create spend proposals from the export. However, does not allow to approve (sign) proposals, so <b>funds will not be accessible from the export</b>.":"ATTENTION : La cl prive de ce portefeuille n'est pas disponible. L'exportation permet de vrifier le solde du portefeuille, l'historique des transactions, et de crer des propositions de dpenses depuis le fichier export. Cependant, cela ne permet pas d'approuver (signer) les propositions <b>et les fonds ne seront pas accessibles depuis le fichier export</b>.","WARNING: UNTRUSTED CERTIFICATE":"ATTENTION : CERTIFICAT NON APPROUV","Waiting for Ledger...":"En attente de Ledger...","Waiting for Trezor...":"En attente de Trezor...","Waiting for copayers":"Attente des copayers","Waiting...":"Attente...","Wallet Addresses":"Adresses du portefeuille","Wallet Color":"Couleur du portefeuille","Wallet Configuration (m-n)":"Configuration du portefeuille (m-n)","Wallet Created":"Portefeuille cr","Wallet Id":"Id du portefeuille","Wallet Information":"Informations du portefeuille","Wallet Inputs":"Entres de portefeuille","Wallet Invitation":"Invitation de portefeuille","Wallet Key":"Cl du portefeuille","Wallet Name":"Nom du portefeuille","Wallet Name (at creation)":"Nom du portefeuille ( la cration)","Wallet Network":"Rseau du portefeuille","Wallet Recovery Phrase":"Phrase de rcupration","Wallet Recovery Phrase is invalid":"La phrase de rcupration du portefeuille est invalide","Wallet Service URL":"Wallet Service URL","Wallet Settings":"Paramtres du portefeuille","Wallet Type":"Type de portefeuille","Wallet already exists":"Le portefeuille existe dj","Wallet already in {{appName}}":"Le portefeuille existe dj dans {{appName}}","Wallet created":"Portefeuille cr","Wallet incomplete and broken":"Portefeuille incomplet et cass ","Wallet is full":"Le portefeuille est plein","Wallet is locked":"Le portefeuille est verrouill","Wallet is not complete":"Le portefeuille n'est pas complet","Wallet name":"Nom du portefeuille","Wallet needs backup":"Le portefeuille a besoin d'une sauvegarde","Wallet not backed up":"Le portefeuille n'est pas sauvegard","Wallet not found":"Portefeuille introuvable","Wallet not registered":"Portefeuille non enregistr","Wallet not registered at the wallet service. Recreate it from \"Create Wallet\" using \"Advanced Options\" to set your recovery phrase":"Le portefeuille n'est pas enregistr au Wallet Service. Vous pouvez le recrer depuis Crer en utilisant les Options avances pour configurer votre phrase de rcupration","Wallet recovery phrase not available.":"La phrase de rcupration du portefeuille est indisponible.","Wallet service not found":"Wallet Service introuvable","Wallets":"Portefeuilles","Wallets & Integrations":"Portefeuilles & intgrations","Warning!":"Attention !","Warning: this transaction has unconfirmed inputs":"ATTENTION : Cette transaction a des entres non confirmes","Watch out!":"Mfiez-vous!","We'd love to do better.":"Nous serions ravis de faire mieux.","We'll confirm on the next screen.":"Nous allons la confirmer sur lcran suivant.","We're always looking for ways to improve {{appName}}.":"Nous recherchons constamment des moyens afin d'amliorer {{appName}}.","We're always looking for ways to improve {{appName}}. How could we improve your experience?":"Nous recherchons constamment des moyens afin d'amliorer {{appName}}. Comment pourrions-nous amliorer votre exprience ?","Website":"Site internet","Were always looking for translation contributions! You can make corrections or help to make this app available in your native language by joining our community on Crowdin.":"Nous recherchons toujours des contributions de traduction! Vous pouvez apporter des corrections ou aider  rendre cette application disponible dans votre langue maternelle en rejoignant notre communaut sur Crowdin.","What do you call this wallet?":"Comment voulez-vous appeler ce portefeuille?","When this wallet was created, it was called {{walletName}}. You can change the name displayed on this device below.":"Lorsque ce portefeuille a t cr, il se nommait &ldquo;{{walletName}}&rdquo;. Vous pouvez modifier ci-dessous le nom affich sur cet appareil.","Where would you like to receive email notifications about payments?":"Souhaitez-vous recevoir des notifications par e-mail  propos des paiements?","Why?":"Pourquoi?","Would you be willing to rate {{appName}} in the app store?":"Seriez-vous prt  valuer {{appName}} dans la boutique d'application?","Would you like to receive push notifications about payments?":"Souhaitez-vous recevoir des notifications relatives aux paiements?","Wrong number of recovery words:":"Nombre incorrect de mots de rcupration :","Wrong spending password":"Code de dpenses incorrect","Yes":"Oui","Yes, skip":"Oui, ignorer","You can create a backup later from your wallet settings.":"Vous pouvez crer une sauvegarde plus tard  partir des paramtres de votre portefeuille.","You can make contributions by signing up on our Crowdin community translation website. Were looking forward to hearing from you!":"Vous pouvez apporter des contributions en vous inscrivant sur notre site internet de traduction communautaire Crowdin. Nous sommes impatients de vous y voir!","You can scan bitcoin addresses, payment requests, paper wallets, and more.":"Vous pouvez numriser des adresses bitcoin, des demandes de paiement, des portefeuilles de papier et plus.","You can see the latest developments and contribute to this open source app by visiting our project on GitHub.":"Vous pouvez voir les derniers dveloppements et contribuer  cette application open source en visitant notre projet sur GitHub.","You can spend bitcoin at millions of websites and stores worldwide.":"Vous pouvez dpenser des bitcoins dans des millions de sites internet et de boutiques  travers le monde.","You can still export it from Advanced &gt; Export.":"Vous pouvez lexporter depuis le menu Avanc &gt; Exporter.","You can trade it for other currencies like US Dollars, Euros, or Pounds.":"Vous pouvez lchanger contre d'autres monnaies comme le dollar amricain, l'euro ou la livre.","You control your bitcoin.":"Vous contrlez vos bitcoins.","You should not set a fee higher than {{maxFeeRecommended}} satoshis/byte.":"Vous ne devriez pas dfinir des frais plus levs que {{maxFeeRecommended}} satoshis/byte.","You will need to log back for fill in your BitPay Card.":"Vous devrez vous reconnecter pour approvisionner votre BitPay Card.","You'll receive email notifications about payments sent and received from your wallets.":"Vous recevrez des notifications par e-mail concernant les paiements envoys et reus depuis vos portefeuilles.","Your BitPay Card is ready. Add funds to your card to start using it at stores and ATMs worldwide.":"Votre BitPay Card est prte. Ajoutez des fonds sur votre carte pour commencer  l'utiliser dans des magasins et distributeurs automatiques  travers le monde entier.","Your Gift Cards":"Vos cartes-cadeaux","Your bitcoin wallet is backed up!":"Votre portefeuille bitcoin est sauvegard !","Your bitcoin wallet is ready!":"Votre portefeuille bitcoin est prt!","Your fee is lower than recommended.":"Vos frais sont infrieurs au niveau recommand.","Your ideas, feedback, or comments":"Vos ides, vos commentaires ou observations","Your name":"Votre nom","Your nickname":"Votre surnom","Your password":"Votre mot de passe","Your purchase could not be completed":"Votre achat n'a pas pu aboutir","Your purchase was added to the list of pending":"Votre achat a t ajout  la liste dattente","Your wallet is never saved to cloud storage or standard device backups.":"Votre portefeuille nest jamais enregistr en dehors de votre appareil ou dans des sauvegardes qui lui sont propres.","Your wallet key will be encrypted. The Spending Password cannot be recovered. Be sure to write it down.":"La cl de votre portefeuille sera chiffre. Le code de dpenses ne peut pas tre rcupr. N'oubliez pas de l'crire.","[Balance Hidden]":"[Solde masqu]","[Scanning Funds]":"[Analyse des fonds]","add your BitPay Visa card(s)":"ajoutez vos cartes BitPay Visa","locked by pending payments":"verrouills par les paiements en attente","me":"moi","name@example.com":"nom@exemple.com","preparing...":"prparation...","{{amountStr}} for Amazon.com Gift Card":"{{amountStr}} pour la carte-cadeau Amazon.com","{{amountStr}} for Mercado Livre Brazil Gift Card":"{{amountStr}} pour la carte-cadeau Mercado Livre Brazil","{{appName}} depends on Bitcore Wallet Service (BWS) for blockchain information, networking and Copayer synchronization. The default configuration points to https://bws.bitpay.com (BitPay's public BWS instance).":"{{appName}} repose sur Bitcore Wallet Service (BWS) pour les informations de blockchain, le rseau et la synchronisation des Copayers. La configuration par dfaut est oriente vers https://bws.bitpay.com (instance BWS publique de BitPay).","{{fee}} will be deducted for bitcoin networking fees.":"{{fee}} seront dduits pour les frais de rseau Bitcoin.","{{tx.txp[wallet.id].feeRatePerStr}}  of the sending amount":"{{tx.txp[wallet.id].feeRatePerStr}} du montant d'envoi","{{updatingTxHistoryProgress}} transactions downloaded":"{{updatingTxHistoryProgress}} transactions tlcharges","{{wallet.m}}-of-{{wallet.n}}":"{{wallet.m}}-sur-{{wallet.n}}"});
    gettextCatalog.setStrings('it', {"(Trusted)":"(Fidato)","(possible double spend)":"(possibile doppia spesa)","* A payment proposal can be deleted if 1) you are the creator, and no other copayer has signed, or 2) 24 hours have passed since the proposal was created.":"* Una proposta di pagamento pu essere eliminata se 1) Tu sei il creatore e nessun altro copayer ha firmato, oppure 2) Sono passate 24 ore da quando la proposta e' stata creata.","- {{btx.feeRateStr}} of the transaction":"- {{btx.feeRateStr}} della transazione","- {{tx.feeRateStr}} of the transaction":"- {{tx.feeRateStr}} della transazione","5-star ratings help us get {{appName}} into more hands, and more users means more resources can be committed to the app!":"Darci un voto a 5 stelle ci aiuta a portare {{appName}} a pi mani, e pi utenti significa pi risorse possono essere impegnate sull'app!","<b>Only</b> redeemable on Mercado Livre (Brazil)":"<b>Solo</b> rimborsabili su Mercado Livre (Brasile)","A member of the team will review your feedback as soon as possible.":"Un membro del team esaminer il tuo feedback appena possibile.","A total of {{amountAboveMaxSizeStr}} were excluded. The maximum size allowed for a transaction was exceeded.":"Un totale di{{amountAboveMaxSizeStr}} sono state escluse. La dimensione massima consentita per una transazione  stata superata.","A total of {{amountBelowFeeStr}} were excluded. These funds come from UTXOs smaller than the network fee provided.":"Un totale di {{amountBelowFeeStr}}  stato escluso. Questi fondi provengono da UTXO pi piccole rispetto alla commissione di rete fornita.","About":"Informazioni","Accepted":"Accettata","Account":"Conto","Account Number":"Numero del Conto","Accounts":"Account","Activity":"Attivit","Add Account":"Aggiungere Account","Add BitPay Account?":"Aggiungere il conto BitPay?","Add Contact":"Aggiungi Contatto","Add Funds":"Aggiungere fondi","Add Memo":"Aggiungi Memo","Add a password":"Aggiungi una password","Add account":"Aggiungere account","Add an optional password to secure the recovery phrase":"Aggiungere una password facoltativa per proteggere la frase di recupero","Add as a contact":"Aggiungi come contatto","Add description":"Aggiungi descrizione","Add funds":"Aggiungi fondi","Add this BitPay account ({{email}})?":"Aggiungere questo account BitPay ({{email}})?","Add wallet":"Aggiungi un portafoglio","Address":"Indirizzo","Address Book":"Rubrica Indirizzi","Address Type":"Tipo di indirizzo","Addresses With Balance":"Indirizzi con saldo","Advanced":"Avanzato","Advanced Settings":"Impostazioni avanzate","All":"Tutto","All Addresses":"Tutti gli indirizzi","All of your bitcoin wallet balance may not be available for immediate spending.":"Tutto il bilancio del tuo portafoglio potrebbe non essere disponibile ad essere speso nell'immediato.","All signing devices must be added to this multisig wallet before bitcoin addresses can be created.":"Tutti i dispositivi firmanti devono essere aggiunti a questo portafoglio multisig prima che si possano creare indirizzi bitcoin.","Allow Camera Access":"Abilita accesso macchina fotografica","Allow notifications":"Consenti notifiche","Almost done! Let's review.":"Quasi finito! Ripassiamo.","Alternative Currency":"Valuta alternativa","Amazon.com is not available at this moment. Please try back later.":"Ia tabella dei guadagni di Amazon.com non  disponibile al momento. Per favore riprova piu tardi.","Amount":"Ammontare","Amount below minimum allowed":"Importo inferiore al minimo consentito","Amount too big":"Quantit troppo grande","Amount too low to spend":"Quantit troppo bassa per essere spesa","An update to this app is available. For your security, please update to the latest version.":"Un aggiornamento dell'app  disponibile. Per la tua sicurezza  consigliato aggiornare all'ultima versione.","Anyone with your backup phrase can access or spend your bitcoin.":"Qualcuno con la tua frase di recupero potrebbe avere accesso o spendere i tuoi bitcoin.","Approximate Bitcoin network fee to transfer wallet's balance (with normal priority)":"La tariffa approssimativa della rete Bitcoin per il trasferimento del saldo del portafoglio ( con priorit normale)","Are you being watched?":"Sei osservato?","Are you being watched? Anyone with your recovery phrase can access or spend your bitcoin.":"Siete osservati? Chiunque con la vostra frase di recupero pu accedere o spendere i vostri bitcoin.","Are you sure you want to cancel and delete this wallet?":"Sei sicuro di voler eliminare questo portafoglio?","Are you sure you want to delete this contact?":"Sei sicuro di voler cancellare questo contatto?","Are you sure you want to delete this wallet?":"Sei sicuro di voler eliminare questo portafoglio?","Are you sure you want to reject this transaction?":"Sei sicuro di voler rifiutare questa transazione?","Are you sure you want to remove this transaction?":"Sei sicuro di voler rimuovere questa transazione?","Are you sure you want to skip it?":"Sei sicuro di voler saltare?","Are you sure you would like to log out of your BitPay Card account?":"Sei sicuro che vuoi uscire dal tuo account BitPay Card?","Are you sure you would like to remove your BitPay Card ({{lastFourDigits}}) from this device?":"Sei certo di volere rimuovere la tua BitPay Card ({{lastFourDigits}}) da questo dispositivo?","Auditable":"Controllabile","Available":"Disponibile","Available Balance":"Saldo disponibile","Average confirmation time":"Tempo previsto per la conferma","BIP32 path for address derivation":"Percorso BIP32 per generare l'indirizzo","BTCZ Wallets":"Portafogli BTCZ","Backup":"Backup","Backup Needed":"Backup necessario","Backup all livenet wallets before using this function":"Fai un backup di tutti i portafogli sulla livenet prima di utilizzare questa funzione","Backup needed":"Backup necessario","Backup now":"Esegui backup ora","Backup wallet":"Backup portafoglio","Backup your wallet before using this function":"Eseguire il backup del tuo portafoglio prima di utilizzare questa funzione","Bad wallet invitation":"Invito al wallet non corretto","Balance By Address":"Bilancio per indirizzo","Be sure to store your recovery phrase in a secure place. If this app is deleted, your money cannot be recovered without it.":"Assicurati di salvare la frase di recupero in un luogo sicuro. Senza di essa, se rimuovi questa applicazione il tuo denaro non potr essere recuperato.","BitPay Visa Cards":"Carte di BitPay Visa","Bitcoin Address":"Indirizzo Bitcoin","Bitcoin Cash (BCH) Balances":"Saldi di Bitcoin Cash (BCH)","Bitcoin Cash Support":"Supporto Bitcoin Cash","Bitcoin Network Fee Policy":"Criterio delle Commissioni del Bitcoin Network","Bitcoin cash Payment":"Pagamento Bitcoin Cash","Bitcoin is a currency.":"Bitcoin  una moneta.","Bitcoin is different  it cannot be safely held with a bank or web service.":"Bitcoin  differente e non pu essere custodito in una banca o con un servizio web.","Bitcoin is secure,<br>digital money.":"Bitcoin  sicuro,<br>moneta digitale.","Bitcoin transactions include a fee collected by miners on the network.":"Le transazioni Bitcoin comprendono un supplemento che viene raccolto dai mines nella rete.","Bought {{amountUnitStr}}":"Comprato {{amountUnitStr}}","Broadcast Payment":"Diffusione del Pagamento","Broadcasted":"Trasmesso","Broadcasting transaction":"Diffondendo la transazione","Browser unsupported":"Browser non supportato","Buy":"Acquista","Buy &amp; Sell Bitcoin":"Comprare &amp; Vendere Bitcoin","Buy Bitcoin":"Acquista Bitcoin","Buy a Gift Card":"Acquista una carta regalo","Buy from":"Acquista da","Buying Bitcoin...":"Comprare Bitcoin...","Calculating fee":"Calcolo commissione","Cancel":"Annulla","Cancel invitation":"Annulla invito","Cannot Create Wallet":"Impossibile creare portafoglio","Cannot join the same wallet more that once":"Non  possibile aggiungere un portafoglio pi di una volta","Cards":"Carte","Certified by":"Certificato da","Check installation and retry.":"Verifica installazione e riprovare.","Choose a backup file from your computer":"Seleziona un file di backup dal tuo computer","Choose your destination wallet":"Scegli il tuo portafoglio di destinazione","Choose your source wallet":"Scegli il tuo portafoglio di origine","Clear":"Elimina","Clear cache":"Svuota la cache","Click to accept":"Fare clic per accettare","Click to pay":"Fai clic per pagare","Click to send":"Clicca per inviare","Close":"Chiudi","Coin":"Moneta","Color":"Colore","Commit hash":"Commit hash","Complete the backup process to use this option":"Completare il processo di backup per utilizzare questa opzione","Completed":"Completato","Confirm":"Conferma","Confirm &amp; Finish":"Confirm &amp; concludi","Confirm purchase":"Conferma acquisto","Confirm your PIN":"Conferma il tuo PIN","Confirm your new spending password":"Conferma la tua nuova password di spesa","Confirmations":"Conferme","Confirming":"Confermando","Connect my BitPay Card":"Collegare la mia Carta BitPay","Connecting to Coinbase...":"Connessione a Coinbase...","Connecting to Glidera...":"Connessione a Glidera...","Connection reset by peer":"Connessione ripristinata dall'utente","Contacts":"Contatti","Continue":"Continua","Contribute Translations":"Contribuisci alle traduzioni","Copayer already in this wallet":"Copayer gi in questo portafoglio","Copayer already voted on this spend proposal":"Copayer gi votato su questa proposta","Copayer data mismatch":"Mancata corrispondenza dei dati del copayer","Copayer joined":"Copayer iscritto","Copayer {{$index}}":"Copayer {{$index}}","Copied to clipboard":"Copiato negli appunti","Copy this text as it is to a safe place (notepad or email)":"Copia questo testo cos com' in un posto sicuro (blocco note o email)","Copy to clipboard":"Copia negli appunti","Could not access Gift Card Service":"Impossibile accedere Servizio Carta Regalo","Could not access the wallet at the server. Please check:":"Non pu accedere al portafoglio sul server. Si prega di controllare:","Could not access to Amazon.com":"Impossibile accedere ad Amazon.com","Could not access wallet":"Impossibile accedere al portafoglio","Could not add message to imported wallet without shared encrypting key":"Non puoi aggiungere un messaggio da importare nel portafoglio senza condividere la chiave criptata","Could not broadcast payment":"Impossibile trasmettere il pagamento","Could not build transaction":"Non  possibile generare la transazione","Could not create address":"Impossibile creare un indirizzo","Could not create the invoice":"Non  stato creata la fattura","Could not create transaction":"Non  possibile creare la transazione","Could not create using the specified extended private key":"Non posso crearlo utilizzando la chiave privata estesa specificata","Could not create using the specified extended public key":"Non  possibile creare usando questa chiave estesa pubblica","Could not create: Invalid wallet recovery phrase":"Impossibile creare: Frase di recupero portafoglio non valida","Could not decrypt file, check your password":"Impossibile decifrare il file, controlla la tua password","Could not delete payment proposal":"Impossibile eliminare la proposta di pagamento","Could not duplicate":"Duplicazione non riuscita","Could not get dynamic fee":"Impossibile avere commissioni dinamiche","Could not get dynamic fee for level: {{feeLevel}}":"Impossibile avere la commissione per il livello: {{feeLevel}}","Could not get fee levels":"Livelli commissione non disponibile","Could not get the invoice":"La fattura non puo essere creata","Could not get transactions":"Non  possibile ottenere le transazioni","Could not import":"Impossibile importare","Could not import. Check input file and spending password":"Impossibile importare. Controlla il file da importare e la password di spesa","Could not join wallet":"Impossibile partecipare al portafoglio","Could not reject payment":"Impossibile rifiutare il pagamento","Could not remove account":"Rimozione account non riuscita","Could not remove card":"Impossibile rimuovere la carta","Could not save preferences on the server":"Impossibile salvare le preferenze nel server","Could not send payment":"Impossibile inviare il pagamento","Could not send transaction":"Non  possibile inviare la transazione","Could not update transaction history":"Impossibile aggiornare la cronologia delle transazioni","Could not update wallet":"Impossibile aggiornare il portafoglio","Create Personal Wallet":"Creare il portafoglio personale","Create Shared Wallet":"Creare portafoglio condiviso","Create bitcoin wallet":"Creare portafoglio bitcoin","Create new wallet":"Crea nuovo portafoglio","Create shared wallet":"Creare portafoglio condiviso","Create {{formData.requiredCopayers}}-of-{{formData.totalCopayers}} wallet":"Creare il portafoglio di {{formData.requiredCopayers}}-di-{{formData.totalCopayers}}","Created by":"Creato da","Creating Wallet...":"Creazione Portafoglio...","Creating transaction":"Creazione transazione","Current fee rate for this policy":"Attuale commissione con questa politica","Custom":"Personalizzata","Custom Amount":"Importo personalizzato","Custom Fee":"Commissione personalizzata","Date":"Data","Delete":"Elimina","Delete Payment Proposal":"Elimina Proposta di Pagamento","Delete Wallet":"Elimina Portafoglio","Delete it and create a new one":"Eliminalo e creane uno nuovo","Deleting Wallet...":"Eliminazione del portafoglio...","Deleting payment proposal":"Cancello la richiesta di pagamento","Derivation Path":"Percorso derivato","Derivation Strategy":"Strategia di derivazione","Details":"Dettagli","Disabled":"Disabilitato","Do it later":"Farlo in seguito","Do not include private key":"Non includere la chiave privata","Don't see your language on Crowdin? Contact the Owner on Crowdin! We'd love to support your language.":"Non vedi la tua lingua su Crowdin? Contatta il proprietario su Crowdin! Ci piacerebbe supportare la lingua.","Download":"Download","Duplicate for BCH":"Duplicato per BCH","Duplicating wallet...":"Duplicazione di portafoglio...","Each bitcoin wallet can generate billions of addresses from your 12-word backup. A new address is automatically generated and shown each time you receive a payment.":"Ogni portafoglio bitcoin  in grado di generare miliardi di indirizzi dal tuo backup di 12 parole. Un nuovo indirizzo verr automaticamente generato e mostrato ogni volta che riceverai un pagamento.","Economy":"Economia","Edit":"Modifica","Email":"Email","Email Address":"Indirizzo Email","Empty addresses limit reached. New addresses cannot be generated.":"Raggiunto il limite degli indirizzi vuoti. Non possono essere generati nuovi indirizzi.","Enable Bitcoin Cash wallet creation and operation within the App.":"Attivare la creazione del portafoglio funzionalit Bitcoin Cash e all'interno dell'App.","Enable camera access in your device settings to get started.":"Abilita l'accesso alla fotocamera dalle impostazioni del tuo dispositivo per iniziare.","Enable email notifications":"Attiva Notifiche Email","Enable push notifications":"Abilitare le notifiche push","Enable the camera to get started.":"Abilita la fotocamera per iniziare.","Enabled":"Abilitato","Enter Spending Password":"Inserisci Password di spesa","Enter Two Factor for your BitPay account":"Inserisci Due Fattori per il tuo account BitPay","Enter amount":"Inserisci importo","Enter custom fee":"Inserisci commissione personalizzata","Enter new spending password":"Inserisci la nuova password di spesa","Enter the recovery phrase (BIP39)":"Inserire la frase di recupero (BIP39)","Enter your email":"Inserisci la tua e-mail","Enter your password":"Inserisci la tua password","Error":"Errore","Error at confirm":"Errore di conferma","Error creating gift card":"Errore nella creazione della Gift card","Error creating the invoice":"Errore nella creazione della fattura","Error creating wallet":"Errore creazione portafoglio","Error getting SendMax information":"Errore nel recupero di informazione SendMax","Error in Payment Protocol":"Errore nel protocollo di pagamento","Error pairing BitPay Account":"Errore di accoppiamento BitPay Account","Error scanning funds:":"Errore di scansione dei fondi:","Error sweeping wallet:":"Errore nello spazzolamento del portafoglio:","Error updating Debit Cards":"Errore durante l'aggiornamento delle carte di debito","Exceeded daily limit of $500 per user":"Superato il limite giornaliero di $500 per utente","Expired":"Scaduta","Expires":"Scadenza","Export Wallet":"Esporta portafoglio","Export to file":"Esporta in un file","Export wallet":"Esporta portafoglio","Exporting via QR not supported for this wallet":"Per questo portafoglio non  supportata l'esportazione tramite QR","Extended Public Keys":"Chiave pubblica estesa","Extracting Wallet information...":"Recupero informazioni del portafoglio...","Failed to export":"Esportazione non riuscita","Family vacation funds":"Fondi vacanza di famiglia","Fee":"Tassa","Fee level":"Livello della commissione","Fee level is not defined":"Livello commissione non definito","Fee:":"Commissione:","Feedback could not be submitted. Please try again later.":"Il feedback non pu essere sottoscritto. Riprova pi tardi.","Fetching BitPay Account...":"Recupero Account BitPay...","Fetching payment information":"Recupero informazione del pagamento","File/Text":"File/Testo","Filter setting":"Impostazione del filtro","Finger Scan Failed":"Scansione dito fallita","Finish":"Fine","For audit purposes":"Per finalit di controllo","From":"Da","From BitPay account":"Dal conto BitPay","From Hardware Wallet":"Dal portafoglio Hardware","From the destination device, go to Add wallet &gt; Import wallet and scan this QR code":"Dal dispositivo di destinazione, andare in Aggiungi portafoglio &gt; Importare portafoglio e scansionare questo codice QR","Funds are locked by pending spend proposals":"I fondi sono bloccati in attesa della proposta di pagamento","Funds found:":"Fondi trovati:","Funds to be added":"Fondi da aggiungere","Funds transferred":"Fondi trasferiti","Funds were added to debit card":"I fondi sono stati aggiunti alla carta di debito","Funds will be transferred to":"I fondi saranno trasferiti a","Generate new address":"Genera un nuovo indirizzo","Generating .csv file...":"Genera un file .csv...","Generating new address...":"Generando un nuovo indirizzo...","Get local cash anywhere you go, from any Visa<sup></sup> compatible ATM. ATM bank fees may apply.":"Ottieni contante locale ovunque tu vada, da qualsiasi ATM bancomat compatibile con Visa<sup>&reg;</sup>. Possibili commissioni bancarie da ATM.","Get news and updates from BitPay":"Ricevi notizie e aggiornamenti da BitPay","Get started":{"button":"Per iniziare","$$noContext":"Inizia"},"Get started by adding your first one.":"Inizia aggiungendo il tuo primo.","Getting fee levels...":"Ottenendo i livelli di commissione...","Gift Card is not available to use anymore":"Gift Card non  pi disponibile per l'uso","Gift card":"Carta regalo","Gift card expired":"Carta regalo scaduta","Gift card generated and ready to use.":"Carta regalo generata e pronta all'uso.","Go Back":"Indietro","Go back":"Indietro","Got it":"Ok","Hardware Wallet":"Portafoglio Hardware","Hardware not connected.":"Hardware non collegato.","Hardware wallet":"Portafoglio hardware","Hardware wallets are not yet supported with Bitcoin Cash":"I portafogli hardware non sono ancora supportati con Bitcoin Cash","Help & Support":"Aiuto e Assistenza","Help and support information is available at the website.":"Guida e informazioni di supporto tecnico sono disponibili sul sito web.","Hide":"Nascondere","Hide Balance":"Nascondere saldo","Hide Next Steps Card":"Nascondere le successive procedure per la carta","Hide advanced options":"Nascondi opzioni avanzate","Home":"Home","How could we improve your experience?":"Come potremmo migliorare la tua esperienza?","How do you like {{appName}}?":"Come ti piace {{appName}}?","I don't like it":"Non mi piace","I have read, understood, and agree to the <a ng-click=\"openTerms()\" translate=\"\">Terms of Use</a>.":"Ho letto, compreso, e sono d'accordo con <a ng-click=\"openTerms()\" translate=\"\"> Condizioni d'uso</a>.","I have read, understood, and agree with the Terms of use.":"Ho letto, compreso, e sono d'accordo con le Condizioni d'uso.","I have written it down":"L'ho scritto","I like the app":"Mi piace l'app","I think this app is terrible.":"Penso che questa app sia terribile.","I understand":"Ho capito","I understand that if this app is moved to another device or deleted, my bitcoin can only be recovered with the backup phrase.":"Ho compreso che se questa app sar trasferita ad un altro dispositivo o cancellata, i miei bitcoin potranno essere recuperati solo tramite la tua frase di recupero.","I understand that my funds are held securely on this device, not by a company.":"Ho capito che i miei fondi sono custoditi in sicurezza in questa dispositivo, non da un'azienda.","I've written it down":"L'ho scritto","If enabled, all sensitive information (private key and recovery phrase) and actions (spending and exporting) associated with this wallet will be protected.":"Se attivata, tutte le informazioni sensibili (chiavi private e la frase di recupero) e azioni (spesa ed esportazione) associate a questo portafoglio saranno protette.","If enabled, the Recent Transactions card - a list of transactions occuring across all wallets - will appear in the Home tab.":"Se abilitata, la scheda delle Transazioni Recenti - una lista di transazioni che avvengono attraverso tutti i portafogli - apparir nella scheda Home.","If enabled, wallets will also try to spend unconfirmed funds. This option may cause transaction delays.":"Se abilitata, i portafogli cercheranno di spendere anche fondi non ancora confermati. Questa opzione pu causare ritardi delle transazioni.","If this device is replaced or this app is deleted, neither you nor BitPay can recover your funds without a backup.":"Se questo dispositivo viene sostituito o eliminato questa app, n tu n BitPay pu recuperare i fondi senza una copia di backup.","If you have additional feedback, please let us know by tapping the \"Send feedback\" option in the Settings tab.":"Se si dispone di ulteriori feedback, fatecelo sapere toccando l'opzione \"Invia feedback\" nella scheda Impostazioni.","If you take a screenshot, your backup may be viewed by other apps. You can make a safe backup with physical paper and a pen.":"Se esegui uno screenshot, il backup pu essere visualizzato da altre applicazioni. Si pu fare un backup sicuro con la carta fisica e una penna.","Import":"Importa","Import Wallet":"Importa Portafoglio","Import backup":"Importa backup","Import wallet":"Importa un portafoglio","Importing Wallet...":"Importazione del Portafoglio...","In order to verify your wallet backup, please type your password.":"Per verificare il backup del tuo portafoglio, inserire la password.","Inactive":"Inattivo","Incomplete":"Incompleto","Incomplete wallet":"Portafoglio incompleto","Incorrect PIN, try again.":"PIN errato, riprovare.","Incorrect code format":"Formato qrcode non corretto","Incorrect network address":"Indirizzo di rete non corretto","Insufficient funds":"Fondi insufficienti","Insufficient funds for fee":"Fondi insufficienti per la commissione","Invalid":"Invalido","Invalid URL":"URL non valido","Invalid account number":"Numero di conto non valido","Invalid address":"Indirizzo non valido","Invalid data":"Dati non validi","Invalid derivation path":"Percorso di derivazione non valido","Invitation to share a {{appName}} Wallet":"Invito a condividere un {{appName}} portafoglio","Invoice expired":"Fattura scaduta","Is there anything we could do better?":"C' qualcosa che potevamo fare meglio?","Is this correct?":" corretto?","Is this email address correct?":"Questo indirizzo email  corretto?","It's a good idea to avoid reusing addresses - this both protects your privacy and keeps your bitcoins secure against hypothetical attacks by quantum computers.":" una buona idea evitare di riutilizzare gli indirizzi - questo protegge la tua privacy e mantiene i Bitcoin al sicuro da ipotetici attacchi di computer quantistici.","It's important that you write your backup phrase down correctly. If something happens to your wallet, you'll need this backup to recover your money. Please review your backup and try again.":" importante annotare la frase di recupero correttamente. Se succede qualcosa al tuo portafoglio, allora avrai bisogno di questo backup per ripristinare il tuo denaro. Si prega di rivedere il backup e riprovare.","Join":"Unisciti","Join my {{appName}} Wallet. Here is the invitation code: {{secret}} You can download {{appName}} for your phone or desktop at {{appUrl}}":"Iscriviti a mio {{appName}} portafoglio. Ecco il codice di invito: {{secret}}  possibile scaricare {{appName}} per il vostro telefono o desktop su {{appUrl}}","Join shared wallet":"Unisciti al portafoglio condiviso","Joining Wallet...":"Unendo al portafoglio...","Just scan the code to pay.":"Scansiona giusto il codice per pagare.","Key already associated with an existing wallet":"Chiave gi associata ad un portafoglio esistente","Language":"Lingua","Last Month":"Scorso Mese","Learn more":"Ulteriori informazioni","Let's verify your backup phrase.":"Verifichiamo la tua frase di backup.","Loading addresses...":"Caricamento indirizzi...","Loading transaction info...":"Caricamento info della transazione...","Lock App":"Blocca app","Lock by Fingerprint":"Blocco con impronte digitali","Lock by PIN":"Blocca tramite PIN","Locked":"Bloccato","Locktime in effect. Please wait to create a new spend proposal":"Locktime in effetto. Si prega di attendere per creare una nuova proposta di pagamento","Locktime in effect. Please wait to remove this spend proposal":"Locktime in effetto. Si prega di attendere per rimuovere questa proposta di pagamento","Log options":"Opzioni di log","Log out":"Esci","Low amount inputs":"Ingressi di quantit bassa","Low fees":"Commissioni basse","Makes sense":"Ho capito","Matches:":"Corrispondenze:","Me":"Io","Meh - it's alright":"Beh -  tutto ok","Memo":"Nota","Mercado Livre Brazil Gift Cards":"Carte regalo di Mercado Livre Brasile","Mercadolibre Gift Card Service is not available at this moment. Please try back later.":"Il Servizio MercadoLibre Gift Card non  disponibile in questo momento. Si prega di provare pi tardi.","Merchant Message":"Messaggio dal commerciante","Miner Fee":"Commissione per miner","Missing parameter":"Parametro mancante","Missing private keys to sign":"Chiavi private per la firma mancanti","More Options":"Altre Opzioni","Moved":"Spostato","Moved Funds":"Fondi trasferiti","Multiple recipients":"Pi destinatari","NOTE: To import a wallet from a 3rd party software, please go to Add Wallet &gt; Create Wallet, and specify the Recovery Phrase there.":"Nota: Per importare un portafoglio da un software di terze parti, si prega di andare in Aggiungi portafoglio &gt; Crea portafoglio, e specificare la frase di recupero.","Name":"Nome","Network Cost":"Costo della rete","Network error":"Errore di rete","New Proposal":"Nuova proposta","New address could not be generated. Please try again.":"Il nuovo indirizzo non pu essere generato. Si prega di riprovare.","New personal wallet":"Nuovo portafoglio personale","Next steps":"Prossimi passi","No Wallet":"Nessun Portafoglio","No access key defined":"Nessuna chiave di accesso definita","No backup, no bitcoin.":"Nessun backup, nessun bitcoin.","No contacts yet":"Ancora nessun contatto","No entries for this log level":"Nessuna voce per questo livello di log","No hardware information available.":"Nessuna informazione del'hardware disponibile.","No hardware wallets supported on this device":"Nessun portafoglio hardware supportato da questo dispositivo","No pending proposals":"Nessuna proposta in attesa","No recent transactions":"Nessuna transazione recente","No signing proposal: No private key":"Nessuna proposta di firma: nessuna chiave privata","No transactions yet":"Ancora nessuna transazione","No wallet found":"Nessun portafoglio trovato","No wallet selected":"Nessun portafoglio selezionato","No wallets available":"Nessun portafoglio disponibile","No wallets available to receive funds":"Nessun portafoglo disponibile per ricevere i fondi","No wallets eligible for Bitcoin Cash support":"Nessun portafogli idoneo al supporto di Bitcoin Cash","Non eligible BTCZ wallets":"Portafogli BTCZ non ammissibili","Normal":"Normale","Not authorized":"Non autorizzato","Not enough funds for fee":"Non ci sono abbastanza fondi per la commissione","Not even BitPay can access it.":"Nemmeno BitPay pu accedervi.","Not funds found":"Fondi non trovati","Not now":"Non ora","Note":"Nota","Notice: only 1-1 (single signature) wallets can be used for sell bitcoin":"Avviso: solo i portafogli 1-1 (con singola firma) possono essere utilizzati per vendere bitcoin","Notifications":"Notifiche","Notifications by email":"Notifiche via email","Notify me if confirmed":"Notificami se confermato","Notify me when transactions are confirmed":"Avvisami quando le transazioni sono confermate","Now is a good time to backup your wallet. If this device is lost, it is impossible to access your funds without a backup.":"Ora  un buon momento per effettuare un backup del tuo portafoglio. Se questo dispositivo andasse perso, sarebbe impossibile accedere ai tuoi fondi senza una copia di backup.","Now is a perfect time to assess your surroundings. Nearby windows? Hidden cameras? Shoulder-spies?":" il momento perfetto per valutare l'ambiente circostante. Finestre nelle vicinanze? Telecamere nascoste? Spie alle spalle?","OK":"Ok","OKAY":"VA BENE","Official English Disclaimer":"Dichiarazione di esclusione di responsabilit ufficiale in inglese","Oh no!":"Oh no!","Ok":"Ok","On this screen you can see all your wallets, accounts, and assets.":"In questa schermata puoi vedere tutti i portafogli, gli account e i beni.","Open":"Apri","Open Crowdin":"Aprire Crowdin","Open GitHub":"Aprire Github","Open GitHub Project":"Aprire il progetto GitHub","Open Insight":"Aprire Insight","Open Settings":"Apri Impostazioni","Open Translation Community":"Aprire comunit traduttori","Open Website":"Apri sito","Open bitcoincash.org?":"Aprire bitcoincash.org?","Open wallet":"Apri Portafoglio","Open website":"Apri il sito","Order the BitPay Card":"Ordinare la carta BitPay","Password":"Password","Password required. Make sure to enter your password in advanced options":"Password necessaria. Assicurarsi di immettere la password nelle impostazioni avanzate","Paste invitation here":"Incolla qui l'invito","Paste the backup plain text code":"Incolla qui il codice di backup","Pay 0% fees to turn bitcoin into dollars.":"Pagare 0% di tasse per trasformare bitcoin in dollari.","Pay To":"Paga A","Payment Accepted":"Pagamento Accettato","Payment Expires:":"Scadenza del pagamento:","Payment Proposal":"Proposta di Pagamento","Payment Proposal Created":"Proposta di Pagamento Creata","Payment Proposals":"Proposte di Pagamento","Payment Protocol Invalid":"Protocollo di pagamento non valido","Payment Protocol not supported on Chrome App":"Proposta di Pagamento non supportata dall'applicazione Chrome","Payment Received":"Pagamento ricevuto","Payment Rejected":"Pagamento Rifiutato","Payment Sent":"Pagamento Inviato","Payment accepted, but not yet broadcasted":"Pagamento accettato, ma non ancora inviata alla rete","Payment accepted. It will be broadcasted by Glidera. In case there is a problem, it can be deleted 6 hours after it was created.":"Pagamento accettato. Esso sar trasmesso attraverso la rete Glidera. Nel caso in cui ci fosse un problema, si potr eliminarlo 6 ore dopo che  stato creato.","Payment address was translated to new Bitcoin Cash address format:":"Indirizzo per il pagamento  stato tradotto al nuovo formato di indirizzo Bitcoin Cash:","Payment details":"Dettagli pagamento","Payment request":"Richiesta di pagamento","Pending":"In sospeso","Pending Proposals":"Proposte in attesa","Permanently delete this wallet.":"Eliminare definitivamente questo portafoglio.","Personal Wallet":"Portafoglio Personale","Please carefully write down this phrase.":"Si prega di annotare accuratamente questa frase.","Please connect a camera to get started.":"Si prega di collegare una telecamera per iniziare.","Please enter the recovery phrase":"Si prega di inserire la frase di recupero","Please enter the wallet recovery phrase":"Si prega di inserire la frase di recupero del portafoglio","Please enter your PIN":"Inserisci il tuo PIN","Please tap each word in the correct order.":"Si prega di toccare ogni parola nell'ordine corretto.","Please upgrade Copay to perform this action":"Si prega di aggiornare Copay per eseguire questa azione","Please wait":"Attendere prego","Please, select your backup file":"Per favore, selezione il tuo file di backup","Pre-Auth Holds":"Detenzione pre-autorizzata","Preferences":"Preferenze","Preparing addresses...":"Preparazione indirizzi...","Preparing backup...":"Preparando il backup...","Press again to exit":"Premi ancora per uscire","Priority":"Priorit","Private Key":"Chiave Privata","Private key encrypted. Enter password":"Chiave privata crittografata. Inserisci la password","Private key is encrypted, cannot sign":"La chiave privata  crittografata, non  possibile accedere","Proposal Accepted":"Proposta accettata","Proposal Created":"Proposta creata","Proposal Deleted":"Proposta eliminata","Proposal Rejected":"Proposta respinta","Proposals":"Proposte","Purchase Amount is limited to {{limitPerDay}} {{currency}} per day":"Importo di acquisto  limitato a {{limitPerDay}} di {{currency}} al giorno","Purchase amount must be a value between 50 and 2000":"Importo di acquisto deve essere un valore compreso tra 50 e 2000","Push Notifications":"Notifiche push","Push notifications for {{appName}} are currently disabled. Enable them in the Settings app.":"Le notifiche push per {{appName}} sono attualmente disabilitate. Abilitale nelle impostazioni app.","QR Code":"Codice QR","Quick review!":"Breve recensione!","Random":"Casuale","Rate on the app store":"Valuta su App Store","Read less":"Riduci","Read more":"Ulteriori informazioni","Read more in our Wiki":"Per saperne di pi sul nostro Wiki","Receive":"Ricevi","Receive in":"Ricevere in","Received":"Ricevuti","Received Funds":"Fondi ricevuti","Receiving":"Ricezione","Recent":"Recente","Recent Transaction Card":"Transazione recente della carta","Recent Transactions":"Transazioni recenti","Recipient":"Destinatario","Recipients":"Destinatari","Recovery phrase":"Frase di Recupero","Recreating Wallet...":"Ricreando Portafoglio...","Redeem now":"Riscattare ora","Rejected":"Respinto","Rejecting payment proposal":"Respingendo proposta di pagamento","Release information":"Informazioni sul rilascio","Remove":"Rimuovere","Remove BitPay Account?":"Rimuovere il conto BitPay?","Remove BitPay Card?":"Rimuovere la Carta BitPay?","Removing your BitPay account will remove all associated BitPay account data from this device. Are you sure you would like to remove your BitPay Account ({{email}}) from this device?":"La rimozione dell'account BitPay eliminer tutti i dati del conto BitPay associati da questo dispositivo. Sei sicuro che vuoi rimuovere il tuo conto BitPay ({{email}}) da questo dispositivo?","Repeat password":"Ripeti password","Repeat the password":"Ripeti la password","Request Fingerprint":"Richiesta delle impronte digitali","Request Specific amount":"Richiedi un importo specifico","Request Spending Password":"Richiedere Password di spesa","Required number of signatures":"Selezionare il numero necessario di firme","Restore from backup":"Ripristinare da backup","Retrieving inputs information":"Recupero delle informazioni iniziali","Retry":"Riprova","Retry Camera":"Riprova con fotocamera","Save":"Salva","Scan":"Scansione","Scan QR Codes":"Scansiona il codici QR","Scan addresses for funds":"Scansione degli indirizzi per fondi","Scan again":"Ripetere la scansione","Scan your fingerprint please":"Per cortesia procedere alla scansione dell'impronta digitale","Scan your wallets for Bitcoin Cash":"Cercare nei tuoi portafogli per Bitcoin Cash","Scanning Wallet funds...":"Scansione fondi Portafoglio...","Scanning funds...":"Scansione dei fondi...","Screenshots are not secure":"Gli screenshot non sono sicuri","Search Transactions":"Cerca Transazioni","Search or enter bitcoin address":"Cerca o inserisci indirizzo bitcoin","Search transactions":"Ricerca transazioni","Search your currency":"Cerca la tua valuta","Security":"Sicurezza","See invoice":"Vedere la fattura","Select a backup file":"Seleziona un file di backup","Select a wallet":"Selezionare un portafoglio","Self-signed Certificate":"Certificato autofirmato","Selling Bitcoin...":"Vendere Bitcoin...","Send":"Invia","Send Feedback":"Invia Feedback","Send Money":"Invia denaro","Send addresses by email":"Invia indirizzi via Email","Send by email":"Invia via email","Send from":"Inviata Da","Send max amount":"Inviare l'importo massimo","Send payment to this address":"Inviare il pagamento a questo indirizzo","Send us feedback instead":"Inviaci invece i tuoi pareri","Sending":"Invio in corso","Sending 2FA code...":"Invio codice 2FA...","Sending feedback...":"Invio feedback...","Sending maximum amount":"Invio dell'importo massimo","Sending transaction":"Invio transazione","Sending {{amountStr}} from your {{name}} wallet":"L'invio di {{amountStr}} dal tuo portafoglio {{name}}","Sent":"Inviato","Sent Funds":"Inviare Fondi","Server response could not be verified":"La risposta del server non pu essere verificata","Service not available":"Servizio non disponibile","Services":"Servizi","Session Log":"Registro di sessione","Session log":"Registro sessione","Set up a password":"Imposta una password","Set your own fee in satoshis/byte":"Impostare la propria commissione in satoshi/byte","Settings":"Impostazioni","Share the love by inviting your friends.":"Condividi il piacere invitando i tuoi amici.","Share this invitation with your copayers":"Condividi questo invito con i tuoi copayers","Share {{appName}}":"Condividi {{appName}}","Shared Wallet":"Portafoglio Condiviso","Show Recovery Phrase":"Visualizza Frase di Recupero","Show address":"Visualizza indirizzo","Show advanced options":"Mostra opzioni avanzate","Show bitcoin address":"Visualizza indirizzo bitcoin","Show more":"Mostra di pi","Signatures rejected by server":"Firme rifiutate dal server","Signing transaction":"Firmando transazione","Since only you control your money, youll need to save your backup phrase in case this app is deleted.":"Dal momento che solo tu controlli il tuo denaro, avrai allora bisogno di salvare la tua frase di recupero nel caso in cui questa applicazione venga eliminata.","Single Address Wallet":"Singolo indirizzo di portafoglio","Skip":"Salta","Slide to accept":"Trascina per accettare","Slide to buy":"Trascina per acquistare","Slide to pay":"Trascina per pagare","Slide to send":"Trascina per inviare","Specify Recovery Phrase...":"Specificare la frase di recupero...","Spend proposal is not accepted":"La proposta di pagamento non  accettata","Spend proposal not found":"Proposta di pagamento non trovata","Spending Password needed":"Necessaria password di spesa","Spending this balance will need significant Bitcoin network fees":"Per spendere questa quantit saranno necessarie significative commissioni di rete Bitcoin","Start sending bitcoin":"Iniziare a inviare bitcoin","Startup Lock":"Blocco all'avvio","Still pending":"Ancora in sospeso","Success":"Completato","Super Economy":"Super Economica","Support Bitcoin Cash":"Supporto Bitcoin Cash","Sweep":"Spazzola","Sweep paper wallet":"Spazzare il portafoglio di carta","Sweeping Wallet...":"Spazzolamento Portafoglio...","THIS ACTION CANNOT BE REVERSED":"QUESTA AZIONE NON PU ESSERE INVERTITA","Take control of your money,<br>get started with bitcoin.":"Prendi il controllo del tuo denaro, <br>inizia con bitcoin.","Tap and hold to show":"Toccare e tenere premuto per mostrare","Tap to recreate":"Toccare per ricreare","Tap to retry":"Tocca per riprovare","Terms Of Use":"Termini di utilizzo","Terms of Use":"Termini di Utilizzo","Testnet":"Testnet","Text":"Testo","Thank you!":"Grazie!","Thanks!":"Grazie!","That's exciting to hear. We'd love to earn that fifth star from you  how could we improve your experience?":"Questo  eccitante da sentire. Ci piacerebbe guadagnare quella quinta stella da te - come potremmo migliorare la tua esperienza?","The Ledger Chrome application is not installed":"Non  installata l'applicazione di contabilit Chrome","The amount of bitcoin immediately spendable from this wallet.":"La quantit di bitcoin immediatamente spendibile da questo portafoglio.","The amount of bitcoin stored in this wallet that is allocated as inputs to your pending transaction proposals. The amount is determined using unspent transaction outputs associated with this wallet and may be more than the actual amounts associated with your pending transaction proposals.":"La quantit di bitcoin memorizzati in questo portafoglio  allocata come input per le sue proposte di transazione in sospeso. L'importo  determinato usando le transazioni in uscita non spese associate a questo portafoglio e potrebbero essere superiori agli importi effettivi associati con le vostre proposte di transazione in sospeso.","The amount of bitcoin stored in this wallet with less than 1 blockchain confirmation.":"La quantit di bitcoin memorizzati in questo portafoglio con meno di una conferma su blockchain.","The derivation path":"Il percorso di derivazione","The exchange rate changes with the market.":"Le variazioni dei tassi di cambio con il mercato.","The higher the fee, the greater the incentive a miner has to include that transaction in a block. Current fees are determined based on network load and the selected policy.":"Pi alta la commissione, maggiore sar l'incentivo di un minatore ad includere tale transazione in un blocco. Le attuali commissioni sono determinate basandosi sul carico di rete e il criterio selezionato.","The maximum number of consecutive unused addresses (20) has been reached. When one of your unused addresses receives a payment, a new address will be generated and shown in your Receive tab.":" stato raggiunto il numero massimo di indirizzi consecutivi inutilizzati (20). Quando uno dei tuoi indirizzi inutilizzati riceve un pagamento, verr generato un nuovo indirizzo e mostrato nella tua scheda di ricezione.","The official English Terms of Service are available on the BitPay website.":"I termini di servizio ufficiali in inglese sono disponibili sul sito web di BitPay.","The password of the recovery phrase (if set)":"La password della frase recupero (se impostata)","The payment was created but could not be completed. Please try again from home screen":"Il pagamento  stato creato ma  stato impossibile completarlo. Per favore prova di nuovo dalla schermata iniziale","The payment was removed by creator":"Il pagamento  stato rimosso dal creatore","The recovery phrase could require a password to be imported":"La frase di recupero potrebbe richiedere una password per essere importata","The request could not be understood by the server":"La richiesta potrebbe non essere compresa dal server","The restore process will stop when 20 addresses are generated in a row which contain no funds. To safely generate more addresses, make a payment to one of the unused addresses which has already been generated.":"Il processo di ripristino verr interrotto quando 20 indirizzi di fila verranno generati senza che contengano fondi. Per generare in modo sicuro pi indirizzi,  necessario effettuare un pagamento ad uno degli indirizzi non utilizzati che  gi stato generato.","The spend proposal is not pending":"La proposta di pagamento non  in sospeso","The total amount of bitcoin stored in this wallet.":"La quantit totale di bitcoin depositati su questo portafoglio.","The transaction history and every new incoming transaction are cached in the app. This feature clean this up and synchronizes again from the server":"La cronologia delle transazioni e ogni nuova transazione in entrata vengono memorizzate nella cache nell'app. Questa funzionalit la ripulisce e sincronizza nuovamente dal server","The wallet service URL":"L'URL del servizio di portafoglio","There is a new version of {{appName}} available":"C' una nuova versione di {{appName}} disponibile","There is an error in the form":"C' un errore nel form","There's obviously something we're doing wrong.":"C' evidentemente qualcosa che stiamo sbagliando.","This app is fantastic!":"Questa applicazione  fantastica!","This app stores your bitcoin with cutting-edge security.":"Questa app memorizza i tuoi bitcoin con sicurezza all'avanguardia.","This bitcoin payment request has expired.":"Questa richiesta di pagamento in bitcoin  scaduta.","This password cannot be recovered. If the password is lost, there is no way you could recover your funds.":"Questa password non pu essere recuperata. Se si dimentica la password, non c' alcun modo possibile per recuperare i fondi.","This recovery phrase was created with a password. To recover this wallet both the recovery phrase and password are needed.":"Questa frase di recupero  stata creata con una password. Per recuperare questo portafoglio sono necessari sia la frase di recupero e che la password.","This transaction amount is too small compared to current Bitcoin network fees. Spending these funds will need a Bitcoin network fee cost comparable to the funds itself.":"Questo importo della transazione  troppo piccolo rispetto alle attuali commissioni della rete Bitcoin. Per spendere questi fondi sar necessaria una commissione Bitcoin paragonabile ai fondi stessi.","This transaction could take a long time to confirm or could be dropped due to the low fees set by the sender":"Questa operazione potrebbe richiedere molto tempo per essere confermata o potrebbe essere abbandonata a causa delle commissioni basse impostate dal mittente","This wallet is not registered at the given Bitcore Wallet Service (BWS). You can recreate it from the local information.":"Questo portafoglio non  registrato al Bitcore Wallet Service (BWS). Puoi ricrearlo dalle informazioni locali.","Timeline":"Cronologia","To":"A","To get started, buy bitcoin or share your address. You can receive bitcoin from any wallet or service.":"Per iniziare, acquista bitcoin o condividi il tuo indirizzo.  possibile ricevere bitcoin da qualsiasi servizio o portafoglio.","To get started, you'll need to create a bitcoin wallet and get some bitcoin.":"Per iniziare,  necessario che tu crei un portafoglio bitcoin e ottenerne qualcuno.","To {{reason}} you must first add your BitPay account - {{email}}":"Per {{reason}}  necessario innanzitutto aggiungere il tuo account BitPay - {{email}}","Top up in progress...":"Ricarica in corso...","Top up {{amountStr}} to debit card ({{cardLastNumber}})":"Ricaricare di {{amountStr}} sulla carta di debito ({{cardLastNumber}})","Total":"Totale","Total Locked Balance":"Totale Importo Bloccato","Total number of copayers":"Numero totale di copayer","Total wallet inputs":"Totale ingressi nel portafoglio","Touch ID Failed":"Touch ID Fallito","Transaction":"Transazione","Transaction Created":"Transazione creata","Transaction History":"Cronologia delle transazioni","Transaction already broadcasted":"Transazione gi trasmessa","Transaction has not been created":"La transazione non  stata creata","Transaction initiated":"Transazione avviata","Transaction not available at this time":"Transazione non disponibile in questo momento","Transaction not found":"Transazione non trovata","Transactions without fee are not supported.":"Non sono supportate transazioni senza commissione.","Transfer to":"Trasferisci a","Transfer to Wallet":"Trasferire su portafoglio","Try again in {{expires}}":"Provare di nuovo in {{expires}}","Turn bitcoin into dollars, swipe anywhere Visa<sup></sup> is accepted.":"Trasformare i bitcoin in dollari, fai scorrere la Visa<sup>&reg;</sup> ovunque sia accettata.","Type the Recovery Phrase (usually 12 words)":"Digitare la Frase di Recupero (tipicamente 12 parole)","Uh oh...":"Oh oh...","Unconfirmed":"Non confermato","Unsent transactions":"Transazioni non inviate","Unused Addresses":"Indirizzi non utilizzati","Unused Addresses Limit":"Limite di indirizzi non utilizzati","Update Available":"Aggiornamento Disponibile","Updating pending proposals. Please stand by":"Aggiornamento in attesa di proposte. Si prega di attendere","Updating transaction history. Please stand by.":"Aggiornamento cronologia delle transazioni. Siete pregati di attendere.","Updating... Please stand by":"In aggiornamento... Attendere","Urgent":"Urgente","Use Unconfirmed Funds":"Usa i fondi non confermati","Validating recovery phrase...":"Validazione della frase di recupero...","Verify your identity":"Verifica della tua identit","Version":"Versione","View":"Visualizza","View All Addresses":"Mostra tutti gli indirizzi","View Terms of Service":"Visualizza i termini di servizio","View Transaction on Insight":"Visualizzazione della transazione su Insight","View Update":"Visualizza aggiornamenti","View on blockchain":"Mostra su blockchain","Visit mercadolivre.com.br &rarr;":"Visita mercadolivre.com.br &rarr;","WARNING: Key derivation is not working on this device/wallet. Actions cannot be performed on this wallet.":"ATTENZIONE: La derivazione della chiave non funziona su questo dispositivo/portafoglio. Le operazioni non possono essere eseguite su questo portafoglio.","WARNING: Not including the private key allows to check the wallet balance, transaction history, and create spend proposals from the export. However, does not allow to approve (sign) proposals, so <b>funds will not be accessible from the export</b>.":"AVVISO: L'esclusione della chiave privata permette di controllare il bilancio del portafoglio, la cronologia delle transazioni e creare proposte di spesa dall'esportazione. Tuttavia, non consente di approvare le proposte (firma), cos <b>fondi non saranno accessibili dall'esportazione</b>.","WARNING: The private key of this wallet is not available. The export allows to check the wallet balance, transaction history, and create spend proposals from the export. However, does not allow to approve (sign) proposals, so <b>funds will not be accessible from the export</b>.":"AVVISO: La chiave privata di questo portafoglio non  disponibile. L'esportazione permette di controllare il bilancio del portafoglio, la cronologia delle transazioni e creare proposte di spesa dall'esportazione. Tuttavia, non consente di approvare le proposte (firma), cos <b>fondi non saranno accessibili dall'esportazione</b>.","WARNING: UNTRUSTED CERTIFICATE":"ATTENZIONE: CERTIFICATO NON ATTENDIBILE","Waiting for Ledger...":"In attesa del Ledger...","Waiting for Trezor...":"In attesa del Trezor...","Waiting for copayers":"In attesa di copayers","Waiting...":"In attesa...","Wallet Addresses":"Indirizzi del portafoglio","Wallet Color":"Colore portafoglio","Wallet Configuration (m-n)":"Configurazione di portafoglio (m-n)","Wallet Created":"Portafoglio creato","Wallet Id":"Id portafoglio","Wallet Information":"Informazioni sul portafoglio","Wallet Inputs":"Ingressi nel portafoglio","Wallet Invitation":"Invito Portafoglio","Wallet Key":"Chiave del portafoglio","Wallet Name":"Nome Portafoglio","Wallet Name (at creation)":"Nome portafoglio (al momento della creazione)","Wallet Network":"Portafoglio di rete","Wallet Recovery Phrase":"Frase di recupero del portafoglio","Wallet Recovery Phrase is invalid":"Frase di recupero del portafoglio non  valida","Wallet Service URL":"URL del servizio di portafoglio","Wallet Settings":"Impostazioni del portafoglio","Wallet Type":"Tipo di portafoglio","Wallet already exists":"Il portafoglio esiste gi","Wallet already in {{appName}}":"Portafoglio  gi in {{appName}}","Wallet created":"Portafoglio creato","Wallet incomplete and broken":"Portafoglio incompleto e danneggiato","Wallet is full":"Portafoglio  pieno","Wallet is locked":"Il portafoglio  bloccato","Wallet is not complete":"Portafoglio non  completo","Wallet name":"Nome Portafoglio","Wallet needs backup":"Il portafoglio richiede password","Wallet not backed up":"Portafoglio senza backup","Wallet not found":"Portafoglio non trovato","Wallet not registered":"Portafoglio non registrato","Wallet not registered at the wallet service. Recreate it from \"Create Wallet\" using \"Advanced Options\" to set your recovery phrase":"Portafoglio non registrato presso il servizio di portafoglio. Ricrearlo da \"Creare portafoglio\" tramite \"Opzioni avanzate\" per impostare la tua frase di recupero","Wallet recovery phrase not available.":"Frase di recupero del portafoglio non disponibile.","Wallet service not found":"Wallet service non trovato","Wallets":"Portafogli","Wallets & Integrations":"Portafogli & integrazioni","Warning!":"Attenzione!","Warning: this transaction has unconfirmed inputs":"Attenzione: questa transazione ha inputs non confermati","Watch out!":"Attento!","We'd love to do better.":"Ci piacerebbe fare di pi.","We'll confirm on the next screen.":"Confermeremo la schermata successiva.","We're always looking for ways to improve {{appName}}.":"Siamo sempre alla ricerca di modi per migliorare {{appName}}.","We're always looking for ways to improve {{appName}}. How could we improve your experience?":"Siamo sempre alla ricerca di modi per migliorare {{appName}}. Come potremmo migliorare la tua esperienza?","Website":"Sito Web","Were always looking for translation contributions! You can make corrections or help to make this app available in your native language by joining our community on Crowdin.":"Stiamo sempre cercando contributi alla traduzione! Si possono apportare correzioni o contribuire a rendere questa app disponibile nella tua lingua nativa unendo le nostre comunit su Crowdin.","What do you call this wallet?":"Come chiameresti questo portafoglio?","When this wallet was created, it was called {{walletName}}. You can change the name displayed on this device below.":"Quando  stato creato questo portafoglio,  stato chiamato &ldquo;{{walletName}}&rdquo;.  possibile modificare qui sotto il nome visualizzato su questo dispositivo.","Where would you like to receive email notifications about payments?":"Dove ti piacerebbe ricevere le notifiche sui pagamenti via email?","Why?":"Perche?","Would you be willing to rate {{appName}} in the app store?":"Sareste disposti a votare {{appName}} sull'app store?","Would you like to receive push notifications about payments?":"Vorresti ricevere le notifiche push sui pagamenti?","Wrong number of recovery words:":"Numero errato delle parole di recupero:","Wrong spending password":"Password per spesa errata","Yes":"S","Yes, skip":"S, saltare","You can create a backup later from your wallet settings.":" possibile creare pi tardi una copia di backup dalle impostazioni del tuo portafoglio.","You can make contributions by signing up on our Crowdin community translation website. Were looking forward to hearing from you!":" possibile contribuire registrandovi sulla comunit di traduzione Crowdin. Non vediamo l'ora di sentirvi!","You can scan bitcoin addresses, payment requests, paper wallets, and more.":" possibile scansionare indirizzi bitcoin, richieste di pagamento, portafogli di carta e altro ancora.","You can see the latest developments and contribute to this open source app by visiting our project on GitHub.":"Potete vedere gli ultimi sviluppi e contribuire a questa applicazione open source andando al nostro progetto su GitHub.","You can spend bitcoin at millions of websites and stores worldwide.":"Si pu spendere bitcoin in milioni di siti web e negozi in tutto il mondo.","You can still export it from Advanced &gt; Export.":" comunque possibile esportare da Avanzate &gt; Esporta.","You can trade it for other currencies like US Dollars, Euros, or Pounds.":" possibile scambiarlo con altre valute come i dollari USA, Euro o Sterline.","You control your bitcoin.":"Controlli i tuoi bitcoin.","You should not set a fee higher than {{maxFeeRecommended}} satoshis/byte.":"Non  necessario impostare una commissione maggiore di {{maxFeeRecommended}} satoshis/byte.","You will need to log back for fill in your BitPay Card.":"Sar necessario accedere nuovamente per riempire la vostra carta BitPay.","You'll receive email notifications about payments sent and received from your wallets.":"Riceverai notifiche e-mail per i pagamenti inviati e ricevuti dai tuoi portafogli.","Your BitPay Card is ready. Add funds to your card to start using it at stores and ATMs worldwide.":"La carta BitPay  pronta. Aggiungi fondi alla tua carta per iniziare ad usarla presso i negozi e gli sportelli automatici in tutto il mondo.","Your Gift Cards":"Le tue carte regalo","Your bitcoin wallet is backed up!":"Il tuo portafoglio bitcoin ha eseguito il backup!","Your bitcoin wallet is ready!":"Il tuo portafoglio bitcoin  pronto!","Your fee is lower than recommended.":"La tua commissione  inferiore a quella consigliata.","Your ideas, feedback, or comments":"Vostre idee, feedback o commenti","Your name":"Il tuo nome","Your nickname":"Il tuo nickname","Your password":"La tua password","Your purchase could not be completed":"Impossibile completare il tuo acquisto","Your purchase was added to the list of pending":"Il tuo acquisto  stato aggiunto alla lista d'attesa","Your wallet is never saved to cloud storage or standard device backups.":"Il tuo portafoglio non viene mai salvato in archiviazione cloud o nel normale backup del dispositivo.","Your wallet key will be encrypted. The Spending Password cannot be recovered. Be sure to write it down.":"La chiave del tuo portafoglio verr cifrata. La Password Per Spendere non pu essere recuperata. Assicurati di scrivertela.","[Balance Hidden]":"[Fondi Nascosti]","[Scanning Funds]":"[Scansione fondi]","add your BitPay Visa card(s)":"aggiungi la tua carta(e) BitPay Visa","locked by pending payments":"bloccati da pagamenti in sospeso","me":"io","name@example.com":"nome@esempio.com","preparing...":"preparazione...","{{amountStr}} for Amazon.com Gift Card":"{{amountStr}} per una carta regalo Amazon.com","{{amountStr}} for Mercado Livre Brazil Gift Card":"{{amountStr}} per Mercado Livre Brasile Gift Card","{{appName}} depends on Bitcore Wallet Service (BWS) for blockchain information, networking and Copayer synchronization. The default configuration points to https://bws.bitpay.com (BitPay's public BWS instance).":"{{appName}} dipende dal servizio portafoglio di Bitcore (BWS) per informazioni blockchain, networking e sincronizzazione di Copayer. La configurazione predefinita fa riferimento a https://bws.bitpay.com (istanza di BitPay BWS pubblica).","{{fee}} will be deducted for bitcoin networking fees.":"{{fee}} verranno detratti come commissione per il network.","{{tx.txp[wallet.id].feeRatePerStr}}  of the sending amount":"{{tx.txp[wallet.id].feeRatePerStr}} dell'importo d'invio","{{updatingTxHistoryProgress}} transactions downloaded":"{{updatingTxHistoryProgress}} transazioni scaricate","{{wallet.m}}-of-{{wallet.n}}":"{{wallet.m}}-di-{{wallet.n}}"});
    gettextCatalog.setStrings('ja', {"(Trusted)":"()","(possible double spend)":"()","* A payment proposal can be deleted if 1) you are the creator, and no other copayer has signed, or 2) 24 hours have passed since the proposal was created.":"* 24","- {{btx.feeRateStr}} of the transaction":"- {{btx.feeRateStr}}","- {{tx.feeRateStr}} of the transaction":"- {{tx.feeRateStr}}","5-star ratings help us get {{appName}} into more hands, and more users means more resources can be committed to the app!":"5","<b>Only</b> redeemable on Mercado Livre (Brazil)":"Mercado Livre ()<b></b>","A member of the team will review your feedback as soon as possible.":"","A total of {{amountAboveMaxSizeStr}} were excluded. The maximum size allowed for a transaction was exceeded.":"{{amountAboveMaxSizeStr}} ","A total of {{amountBelowFeeStr}} were excluded. These funds come from UTXOs smaller than the network fee provided.":" {{amountBelowFeeStr}} ","About":"","Accepted":"","Account":"","Account Number":"","Accounts":"","Activity":"","Add Account":"","Add BitPay Account?":"BitPay ","Add Contact":"","Add Funds":"","Add Memo":"","Add a password":"","Add account":"","Add an optional password to secure the recovery phrase":"","Add as a contact":"","Add description":"","Add funds":"","Add this BitPay account ({{email}})?":"BitPay ({{email}}) ","Add wallet":"","Address":"","Address Book":"","Address Type":"","Addresses With Balance":"","Advanced":"","Advanced Settings":"","All":"","All Addresses":"","All of your bitcoin wallet balance may not be available for immediate spending.":"","All signing devices must be added to this multisig wallet before bitcoin addresses can be created.":"","Allow Camera Access":"","Allow notifications":"","Almost done! Let's review.":"!","Alternative Currency":"","Amazon.com is not available at this moment. Please try back later.":"Amazon.com ","Amount":"","Amount below minimum allowed":"","Amount too big":"","Amount too low to spend":"","An update to this app is available. For your security, please update to the latest version.":"","Anyone with your backup phrase can access or spend your bitcoin.":"","Approximate Bitcoin network fee to transfer wallet's balance (with normal priority)":"()","Are you being watched?":"","Are you being watched? Anyone with your recovery phrase can access or spend your bitcoin.":" ","Are you sure you want to cancel and delete this wallet?":"\n","Are you sure you want to delete this contact?":"","Are you sure you want to delete this wallet?":"\n","Are you sure you want to reject this transaction?":"?","Are you sure you want to remove this transaction?":"?","Are you sure you want to skip it?":"","Are you sure you would like to log out of your BitPay Card account?":"BitPay?","Are you sure you would like to remove your BitPay Card ({{lastFourDigits}}) from this device?":" BitPay  ({{lastFourDigits}}) ","Auditable":"","Available":"","Available Balance":"","Average confirmation time":"","BIP32 path for address derivation":"","Backup":"","Backup Needed":"","Backup all livenet wallets before using this function":"","Backup needed":"","Backup now":"","Backup wallet":"","Backup your wallet before using this function":"","Bad wallet invitation":"","Balance By Address":"","Be sure to store your recovery phrase in a secure place. If this app is deleted, your money cannot be recovered without it.":"","BitPay Visa Cards":"BitPayVISA&reg; ","Bitcoin Address":"","Bitcoin Network Fee Policy":"","Bitcoin is a currency.":"","Bitcoin is different  it cannot be safely held with a bank or web service.":" &ndash; ","Bitcoin is secure,<br>digital money.":"<br>","Bitcoin transactions include a fee collected by miners on the network.":"","Bought {{amountUnitStr}}":"{{amountUnitStr}} ","Broadcast Payment":"","Broadcasted":"","Broadcasting transaction":"","Browser unsupported":"","Buy":"","Buy &amp; Sell Bitcoin":"&amp;","Buy Bitcoin":"","Buy a Gift Card":"","Buy from":"","Buying Bitcoin...":"...","Calculating fee":"...","Cancel":"","Cancel invitation":"","Cannot Create Wallet":"","Cannot join the same wallet more that once":"","Cards":"","Certified by":"","Check installation and retry.":"","Choose a backup file from your computer":"","Choose your destination wallet":"","Choose your source wallet":"","Clear":"","Clear cache":"","Close":"","Color":"","Commit hash":"","Complete the backup process to use this option":"","Completed":"","Confirm":"","Confirm &amp; Finish":"","Confirm purchase":"","Confirm your PIN":"PIN","Confirm your new spending password":"","Confirmations":"","Confirming":"","Connect my BitPay Card":"BitPay ","Connecting to Coinbase...":"Coinbase ","Connecting to Glidera...":"Glidera ","Connection reset by peer":"","Contacts":"","Continue":"","Contribute Translations":"","Copayer already in this wallet":"","Copayer already voted on this spend proposal":"","Copayer data mismatch":"","Copayer joined":"","Copayer {{$index}}":" {{$index}}","Copied to clipboard":"","Copy this text as it is to a safe place (notepad or email)":" ()","Copy to clipboard":"","Could not access Gift Card Service":"","Could not access the wallet at the server. Please check:":":","Could not access to Amazon.com":"Amazon.com","Could not access wallet":"","Could not add message to imported wallet without shared encrypting key":"","Could not broadcast payment":"","Could not build transaction":"","Could not create address":"","Could not create the invoice":"","Could not create transaction":"","Could not create using the specified extended private key":"","Could not create using the specified extended public key":"","Could not create: Invalid wallet recovery phrase":"","Could not decrypt file, check your password":"","Could not delete payment proposal":"","Could not get dynamic fee":"","Could not get dynamic fee for level: {{feeLevel}}":": {{feeLevel}}","Could not get fee levels":"","Could not get the invoice":"","Could not get transactions":"","Could not import":"","Could not import. Check input file and spending password":"","Could not join wallet":"","Could not reject payment":"","Could not remove account":"","Could not remove card":"","Could not save preferences on the server":"","Could not send payment":"","Could not send transaction":"","Could not update transaction history":"","Could not update wallet":"","Create Personal Wallet":"","Create Shared Wallet":"","Create bitcoin wallet":"","Create new wallet":"","Create shared wallet":"","Create {{formData.requiredCopayers}}-of-{{formData.totalCopayers}} wallet":"{{formData.requiredCopayers}}-of-{{formData.totalCopayers}} ","Created by":"","Creating Wallet...":"","Creating transaction":"","Current fee rate for this policy":"","Custom":"","Custom Amount":"","Custom Fee":"","Date":"","Delete":"","Delete Payment Proposal":"","Delete Wallet":"","Delete it and create a new one":"","Deleting Wallet...":"","Deleting payment proposal":"","Derivation Path":"","Derivation Strategy":"","Details":"","Disabled":"","Do it later":"","Do not include private key":"","Don't see your language on Crowdin? Contact the Owner on Crowdin! We'd love to support your language.":"CrowdinCrowdin","Download":"","Each bitcoin wallet can generate billions of addresses from your 12-word backup. A new address is automatically generated and shown each time you receive a payment.":"12","Economy":"","Edit":"","Email":"","Email Address":"","Empty addresses limit reached. New addresses cannot be generated.":"","Enable camera access in your device settings to get started.":"","Enable email notifications":"","Enable push notifications":"","Enable the camera to get started.":"","Enter Spending Password":"","Enter Two Factor for your BitPay account":"BitPay 2","Enter amount":"","Enter custom fee":"","Enter new spending password":"","Enter the recovery phrase (BIP39)":"","Enter your email":"","Enter your password":"","Error":"","Error at confirm":"","Error creating gift card":"","Error creating the invoice":"","Error creating wallet":"","Error getting SendMax information":"","Error in Payment Protocol":"","Error pairing BitPay Account":"Bitpay","Error scanning funds:":"","Error sweeping wallet:":"","Error updating Debit Cards":"","Exceeded daily limit of $500 per user":"1 500 ","Expired":"","Expires":"","Export Wallet":"","Export to file":"","Export wallet":"","Exporting via QR not supported for this wallet":"QR","Extended Public Keys":"","Extracting Wallet information...":"","Failed to export":"","Family vacation funds":"","Fee":"","Fee level":"","Fee level is not defined":"","Fee:":":","Feedback could not be submitted. Please try again later.":"","Fetching BitPay Account...":"BitPay ...","Fetching payment information":"","File/Text":"/","Filter setting":"","Finger Scan Failed":"","Finish":"","For audit purposes":"","From":"","From BitPay account":" BitPay","From Hardware Wallet":"","From the destination device, go to Add wallet &gt; Import wallet and scan this QR code":"QR","Funds are locked by pending spend proposals":"","Funds found:":":","Funds to be added":"","Funds transferred":"","Funds were added to debit card":"","Funds will be transferred to":"","Generate new address":"","Generating .csv file...":"CSV","Generating new address...":"...","Get local cash anywhere you go, from any Visa<sup></sup> compatible ATM. ATM bank fees may apply.":"Visa<sup>&reg;</sup>ATMATMATM","Get news and updates from BitPay":"BitPay ","Get started":{"button":"","$$noContext":""},"Get started by adding your first one.":"","Getting fee levels...":"","Gift Card is not available to use anymore":"","Gift card":"","Gift card expired":"","Gift card generated and ready to use.":"","Go Back":"","Go back":"","Got it":"","Hardware Wallet":"","Hardware not connected.":"","Hardware wallet":"","Help & Support":"","Help and support information is available at the website.":"","Hide":"","Hide Balance":"","Hide Next Steps Card":"","Hide advanced options":"","Home":"","How could we improve your experience?":"","How do you like {{appName}}?":"?","I don't like it":"","I have read, understood, and agree to the <a ng-click=\"openTerms()\" translate=\"\">Terms of Use</a>.":"<a ng-click=\"openTerms()\" translate></a>","I have read, understood, and agree with the Terms of use.":"","I have written it down":"","I like the app":"","I think this app is terrible.":"!","I understand":"","I understand that if this app is moved to another device or deleted, my bitcoin can only be recovered with the backup phrase.":"","I understand that my funds are held securely on this device, not by a company.":"","I've written it down":"","If enabled, all sensitive information (private key and recovery phrase) and actions (spending and exporting) associated with this wallet will be protected.":"()()","If enabled, the Recent Transactions card - a list of transactions occuring across all wallets - will appear in the Home tab.":"","If enabled, wallets will also try to spend unconfirmed funds. This option may cause transaction delays.":"","If this device is replaced or this app is deleted, neither you nor BitPay can recover your funds without a backup.":"BitPay","If you have additional feedback, please let us know by tapping the \"Send feedback\" option in the Settings tab.":"","If you take a screenshot, your backup may be viewed by other apps. You can make a safe backup with physical paper and a pen.":"","Import":"","Import Wallet":"","Import backup":"","Import wallet":"","Importing Wallet...":"","In order to verify your wallet backup, please type your password.":"","Inactive":"","Incomplete":"","Incomplete wallet":"","Incorrect PIN, try again.":"PIN","Incorrect code format":"","Incorrect network address":"","Insufficient funds":"","Insufficient funds for fee":"","Invalid":"","Invalid URL":"URL","Invalid account number":"","Invalid address":"","Invalid data":"","Invalid derivation path":"","Invitation to share a {{appName}} Wallet":"{{appName}} ","Invoice expired":"","Is there anything we could do better?":"","Is this correct?":"","Is this email address correct?":"","It's a good idea to avoid reusing addresses - this both protects your privacy and keeps your bitcoins secure against hypothetical attacks by quantum computers.":"","It's important that you write your backup phrase down correctly. If something happens to your wallet, you'll need this backup to recover your money. Please review your backup and try again.":"","Join":"","Join my {{appName}} Wallet. Here is the invitation code: {{secret}} You can download {{appName}} for your phone or desktop at {{appUrl}}":"{{appName}} {{secret}}  {{appUrl}} ","Join shared wallet":"","Joining Wallet...":"","Just scan the code to pay.":"","Key already associated with an existing wallet":"","Language":"","Last Month":"","Let's verify your backup phrase.":"","Loading addresses...":"...","Loading transaction info...":"...","Lock App":"","Lock by Fingerprint":"","Lock by PIN":"PIN","Locked":"","Locktime in effect. Please wait to create a new spend proposal":"Locktime","Locktime in effect. Please wait to remove this spend proposal":"Locktime","Log options":"","Log out":"","Low amount inputs":"","Low fees":"","Makes sense":"","Matches:":":","Me":"","Meh - it's alright":"","Memo":"","Mercado Livre Brazil Gift Cards":"Mercado Livre Brazil ","Mercadolibre Gift Card Service is not available at this moment. Please try back later.":"Mercadolibre Gift Card Service ","Merchant Message":"","Missing parameter":"","Missing private keys to sign":"","More Options":"","Moved":"","Moved Funds":"","Multiple recipients":"","NOTE: To import a wallet from a 3rd party software, please go to Add Wallet &gt; Create Wallet, and specify the Recovery Phrase there.":" &gt; ","Name":"","Network error":"","New Proposal":"","New address could not be generated. Please try again.":"","New personal wallet":"","Next steps":"","No Wallet":"(`)","No access key defined":"","No backup, no bitcoin.":"","No contacts yet":"","No entries for this log level":"","No hardware information available.":"","No hardware wallets supported on this device":"","No pending proposals":"","No recent transactions":"","No signing proposal: No private key":"","No transactions yet":"","No wallet found":"","No wallet selected":"","No wallets available":"","No wallets available to receive funds":"","Normal":"","Not authorized":"","Not enough funds for fee":"","Not even BitPay can access it.":"BitPay","Not funds found":"","Not now":"","Note":"","Notice: only 1-1 (single signature) wallets can be used for sell bitcoin":"  1-of-1 () ","Notifications":"","Notifications by email":"","Notify me if confirmed":"","Notify me when transactions are confirmed":"","Now is a good time to backup your wallet. If this device is lost, it is impossible to access your funds without a backup.":"","Now is a perfect time to assess your surroundings. Nearby windows? Hidden cameras? Shoulder-spies?":"","OK":"OK","OKAY":"OK","Official English Disclaimer":" ()","Oh no!":"!","Ok":"OK","On this screen you can see all your wallets, accounts, and assets.":"","Open":"","Open Crowdin":"Crowdin","Open GitHub":"GitHub","Open GitHub Project":"GitHub ","Open Insight":"Insight","Open Settings":"","Open Translation Community":"","Open Website":"","Open wallet":"","Open website":"","Order the BitPay Card":"BitPay ","Password":"","Password required. Make sure to enter your password in advanced options":"","Paste invitation here":"","Paste the backup plain text code":"","Pay 0% fees to turn bitcoin into dollars.":"0% ","Pay To":"","Payment Accepted":"","Payment Expires:":":","Payment Proposal":"","Payment Proposal Created":"","Payment Proposals":"","Payment Protocol Invalid":"","Payment Protocol not supported on Chrome App":"","Payment Received":"","Payment Rejected":"","Payment Sent":"","Payment accepted, but not yet broadcasted":"","Payment accepted. It will be broadcasted by Glidera. In case there is a problem, it can be deleted 6 hours after it was created.":"Glidera","Payment details":"","Payment request":"","Pending":"","Pending Proposals":"","Permanently delete this wallet.":"","Personal Wallet":"","Please carefully write down this phrase.":"","Please connect a camera to get started.":"","Please enter the recovery phrase":"","Please enter the wallet recovery phrase":"","Please enter your PIN":"PIN ","Please tap each word in the correct order.":"","Please upgrade Copay to perform this action":"Copay","Please, select your backup file":"","Pre-Auth Holds":"","Preferences":"","Preparing addresses...":"","Preparing backup...":"...","Press again to exit":"","Priority":"","Private Key":"","Private key encrypted. Enter password":"","Private key is encrypted, cannot sign":"","Proposal Accepted":"","Proposal Created":"","Proposal Deleted":"","Proposal Rejected":"","Proposals":"","Purchase Amount is limited to {{limitPerDay}} {{currency}} per day":" {{limitPerDay}} {{currency}} ","Purchase amount must be a value between 50 and 2000":" 502000 ","Push Notifications":"","Push notifications for {{appName}} are currently disabled. Enable them in the Settings app.":"{{appName}}","QR Code":"QR","Quick review!":"","Random":"","Rate on the app store":"App Store","Read less":"","Read more":"","Receive":"","Receive in":"","Received":"","Received Funds":"","Receiving":"","Recent":"","Recent Transaction Card":"","Recent Transactions":"","Recipient":"","Recipients":"","Recovery phrase":"","Recreating Wallet...":"","Redeem now":"","Rejected":"","Rejecting payment proposal":"","Release information":"","Remove":"","Remove BitPay Account?":"BitPay ","Remove BitPay Card?":"BitPay ","Removing your BitPay account will remove all associated BitPay account data from this device. Are you sure you would like to remove your BitPay Account ({{email}}) from this device?":"BitPay  BitPay  BitPay  ({{email}}) ","Repeat password":"","Repeat the password":"","Request Fingerprint":"","Request Specific amount":"","Request Spending Password":"","Required number of signatures":"","Restore from backup":"","Retrieving inputs information":"","Retry":"","Retry Camera":"","Save":"","Scan":"","Scan QR Codes":"QR","Scan addresses for funds":"","Scan again":"","Scan your fingerprint please":"","Scanning Wallet funds...":"","Screenshots are not secure":"","Search Transactions":"","Search or enter bitcoin address":"","Search transactions":"","Search your currency":"","Security":"","See invoice":"","Select a backup file":"","Select a wallet":"","Self-signed Certificate":"","Selling Bitcoin...":"...","Send":"","Send Feedback":"","Send Money":"","Send addresses by email":"","Send by email":"","Send from":"","Send max amount":"","Send payment to this address":"","Send us feedback instead":"","Sending":"","Sending 2FA code...":"2","Sending feedback...":"...","Sending maximum amount":"","Sending transaction":"","Sending {{amountStr}} from your {{name}} wallet":" {{name}}  {{amountStr}} ","Sent":"","Sent Funds":"","Server response could not be verified":"","Service not available":"","Services":"","Session Log":"","Session log":"","Set up a password":"","Set your own fee in satoshis/byte":" satoshis/byte ","Settings":"","Share the love by inviting your friends.":"","Share this invitation with your copayers":"\n\n","Share {{appName}}":"{{appName}}","Shared Wallet":"","Show Recovery Phrase":"","Show address":"","Show advanced options":"","Show bitcoin address":"","Show more":"","Signatures rejected by server":"","Signing transaction":"","Since only you control your money, youll need to save your backup phrase in case this app is deleted.":"","Single Address Wallet":"","Skip":"","Slide to buy":"","Specify Recovery Phrase...":"","Spend proposal is not accepted":"","Spend proposal not found":"","Spending Password needed":"","Spending this balance will need significant Bitcoin network fees":"","Start sending bitcoin":"","Startup Lock":"","Still pending":"","Success":"","Super Economy":"","Sweep":"","Sweep paper wallet":"","Sweeping Wallet...":"","THIS ACTION CANNOT BE REVERSED":" ","Take control of your money,<br>get started with bitcoin.":"<br>","Tap and hold to show":"","Tap to retry":"","Terms Of Use":"","Terms of Use":"","Testnet":"","Text":"","Thank you!":"!","Thanks!":"","That's exciting to hear. We'd love to earn that fifth star from you  how could we improve your experience?":"5","The Ledger Chrome application is not installed":"Ledger","The amount of bitcoin immediately spendable from this wallet.":"","The amount of bitcoin stored in this wallet that is allocated as inputs to your pending transaction proposals. The amount is determined using unspent transaction outputs associated with this wallet and may be more than the actual amounts associated with your pending transaction proposals.":"","The amount of bitcoin stored in this wallet with less than 1 blockchain confirmation.":"1","The derivation path":"","The exchange rate changes with the market.":"","The higher the fee, the greater the incentive a miner has to include that transaction in a block. Current fees are determined based on network load and the selected policy.":"","The maximum number of consecutive unused addresses (20) has been reached. When one of your unused addresses receives a payment, a new address will be generated and shown in your Receive tab.":"(20)","The official English Terms of Service are available on the BitPay website.":" BitPay ","The password of the recovery phrase (if set)":"()","The payment was created but could not be completed. Please try again from home screen":"","The payment was removed by creator":"","The recovery phrase could require a password to be imported":"\n\n","The request could not be understood by the server":"","The restore process will stop when 20 addresses are generated in a row which contain no funds. To safely generate more addresses, make a payment to one of the unused addresses which has already been generated.":"2020","The spend proposal is not pending":"","The total amount of bitcoin stored in this wallet.":"","The transaction history and every new incoming transaction are cached in the app. This feature clean this up and synchronizes again from the server":"","The wallet service URL":"URL","There is a new version of {{appName}} available":"{{appName}} ","There is an error in the form":"","There's obviously something we're doing wrong.":"","This app is fantastic!":"!","This app stores your bitcoin with cutting-edge security.":"","This bitcoin payment request has expired.":"","This password cannot be recovered. If the password is lost, there is no way you could recover your funds.":"","This recovery phrase was created with a password. To recover this wallet both the recovery phrase and password are needed.":"","This transaction amount is too small compared to current Bitcoin network fees. Spending these funds will need a Bitcoin network fee cost comparable to the funds itself.":"","This transaction could take a long time to confirm or could be dropped due to the low fees set by the sender":"","This wallet is not registered at the given Bitcore Wallet Service (BWS). You can recreate it from the local information.":"Bitcore Wallet Service (BWS) ","Timeline":"","To":"","To get started, buy bitcoin or share your address. You can receive bitcoin from any wallet or service.":"","To get started, you'll need to create a bitcoin wallet and get some bitcoin.":"","To {{reason}} you must first add your BitPay account - {{email}}":"{{reason}}BitPay - {{email}}","Top up in progress...":"...","Top up {{amountStr}} to debit card ({{cardLastNumber}})":" ({{cardLastNumber}})  {{amountStr}} ","Total":"","Total Locked Balance":"","Total number of copayers":"","Total wallet inputs":"","Touch ID Failed":"Touch ID ","Transaction":"","Transaction Created":"","Transaction History":"","Transaction already broadcasted":"","Transaction has not been created":"","Transaction initiated":"","Transaction not available at this time":"","Transaction not found":"","Transactions without fee are not supported.":"","Transfer to":"","Transfer to Wallet":"","Try again in {{expires}}":"{{expires}} ","Turn bitcoin into dollars, swipe anywhere Visa<sup></sup> is accepted.":"Visa<sup>&reg;</sup>","Type the Recovery Phrase (usually 12 words)":" ( 12 ) ","Uh oh...":"","Unconfirmed":"","Unsent transactions":"","Unused Addresses":"","Unused Addresses Limit":"","Update Available":"","Updating pending proposals. Please stand by":"","Updating transaction history. Please stand by.":"","Updating... Please stand by":"... ","Urgent":"","Use Unconfirmed Funds":"","Validating recovery phrase...":"","Verify your identity":"","Version":"","View":"","View All Addresses":"","View Terms of Service":"","View Transaction on Insight":"Insight","View Update":"","View on blockchain":"","Visit mercadolivre.com.br &rarr;":"mercadolivre.com.br  &rarr;","WARNING: Key derivation is not working on this device/wallet. Actions cannot be performed on this wallet.":"","WARNING: Not including the private key allows to check the wallet balance, transaction history, and create spend proposals from the export. However, does not allow to approve (sign) proposals, so <b>funds will not be accessible from the export</b>.":"<b> () </b>","WARNING: The private key of this wallet is not available. The export allows to check the wallet balance, transaction history, and create spend proposals from the export. However, does not allow to approve (sign) proposals, so <b>funds will not be accessible from the export</b>.":"<b> () </b>","WARNING: UNTRUSTED CERTIFICATE":": ","Waiting for Ledger...":"Ledger ...","Waiting for Trezor...":"Trezor ...","Waiting for copayers":"","Waiting...":"","Wallet Addresses":"","Wallet Color":"","Wallet Configuration (m-n)":" (m-of-n)","Wallet Created":"","Wallet Id":"ID","Wallet Information":"","Wallet Inputs":"","Wallet Invitation":"","Wallet Key":"","Wallet Name":"","Wallet Name (at creation)":" ()","Wallet Network":"","Wallet Recovery Phrase":"","Wallet Recovery Phrase is invalid":"","Wallet Service URL":"URL","Wallet Settings":"","Wallet Type":"","Wallet already exists":"","Wallet already in {{appName}}":"{{appName}}","Wallet created":"","Wallet incomplete and broken":"","Wallet is full":"","Wallet is locked":"","Wallet is not complete":"","Wallet name":"","Wallet needs backup":"","Wallet not backed up":"","Wallet not found":"","Wallet not registered":"","Wallet not registered at the wallet service. Recreate it from \"Create Wallet\" using \"Advanced Options\" to set your recovery phrase":" Wallet Service ","Wallet recovery phrase not available.":"","Wallet service not found":"Wallet service","Wallets":"","Wallets & Integrations":"","Warning!":"","Warning: this transaction has unconfirmed inputs":": ","Watch out!":"","We'd love to do better.":"","We'll confirm on the next screen.":"","We're always looking for ways to improve {{appName}}.":"{{appName}} ","We're always looking for ways to improve {{appName}}. How could we improve your experience?":"{{appName}}","Website":"","Were always looking for translation contributions! You can make corrections or help to make this app available in your native language by joining our community on Crowdin.":"Crowdin","What do you call this wallet?":"","When this wallet was created, it was called {{walletName}}. You can change the name displayed on this device below.":"{{walletName}}","Where would you like to receive email notifications about payments?":"?","Why?":"","Would you be willing to rate {{appName}} in the app store?":"","Would you like to receive push notifications about payments?":"?","Wrong number of recovery words:":"","Wrong spending password":"","Yes":"","Yes, skip":"","You can create a backup later from your wallet settings.":"","You can make contributions by signing up on our Crowdin community translation website. Were looking forward to hearing from you!":"Crowdin","You can scan bitcoin addresses, payment requests, paper wallets, and more.":"","You can see the latest developments and contribute to this open source app by visiting our project on GitHub.":"GitHub","You can spend bitcoin at millions of websites and stores worldwide.":"EC","You can still export it from Advanced &gt; Export.":"","You can trade it for other currencies like US Dollars, Euros, or Pounds.":"","You control your bitcoin.":"","You should not set a fee higher than {{maxFeeRecommended}} satoshis/byte.":"{{maxFeeRecommended}} satoshis/byte ","You will need to log back for fill in your BitPay Card.":"BitPay","You'll receive email notifications about payments sent and received from your wallets.":"","Your BitPay Card is ready. Add funds to your card to start using it at stores and ATMs worldwide.":"BitPayATM","Your Gift Cards":"","Your bitcoin wallet is backed up!":"!","Your bitcoin wallet is ready!":"!","Your fee is lower than recommended.":"","Your ideas, feedback, or comments":"","Your name":"","Your nickname":"","Your password":"","Your purchase could not be completed":"","Your purchase was added to the list of pending":"","Your wallet is never saved to cloud storage or standard device backups.":"","Your wallet key will be encrypted. The Spending Password cannot be recovered. Be sure to write it down.":"Copay","[Balance Hidden]":"[]","add your BitPay Visa card(s)":"BitPay VISA","locked by pending payments":"","me":"","name@example.com":"name@example.com","preparing...":"...","{{amountStr}} for Amazon.com Gift Card":"{{amountStr}}  Amazon.com ","{{amountStr}} for Mercado Livre Brazil Gift Card":"{{amountStr}}  Mercado Livre Brazil ","{{appName}} depends on Bitcore Wallet Service (BWS) for blockchain information, networking and Copayer synchronization. The default configuration points to https://bws.bitpay.com (BitPay's public BWS instance).":"{{appName}}Bitcore Wallet Service (BWS)BitPay https://bws.bitpay.com (BitPayBWS)","{{fee}} will be deducted for bitcoin networking fees.":"{{fee}} ","{{tx.txp[wallet.id].feeRatePerStr}}  of the sending amount":" {{tx.txp[wallet.id].feeRatePerStr}}","{{updatingTxHistoryProgress}} transactions downloaded":"{{updatingTxHistoryProgress}} ","{{wallet.m}}-of-{{wallet.n}}":"{{wallet.m}}-of-{{wallet.n}}"});
    gettextCatalog.setStrings('nl', {"(Trusted)":"(Vertrouwd)","(possible double spend)":"(mogelijk dubbel besteed)","* A payment proposal can be deleted if 1) you are the creator, and no other copayer has signed, or 2) 24 hours have passed since the proposal was created.":"* Een bestedingsvoorstel kan worden verwijderd als 1) u de aanmaker bent, en geen andere copayer deze heeft ondertekend, of 2) 24 uur zijn verstreken sinds het voorstel werd aangemaakt.","- {{btx.feeRateStr}} of the transaction":"- {{btx.feeRateStr}} van de transactie","- {{tx.feeRateStr}} of the transaction":"- {{tx.feeRateStr}} van de transactie","5-star ratings help us get {{appName}} into more hands, and more users means more resources can be committed to the app!":"Beoordelingen van 5 sterren helpen ons het gebruik van {{appName}} te laten groeien, en meer gebruikers betekent dat wij meer middelen aan de app kunnen wijden!","<b>Only</b> redeemable on Mercado Livre (Brazil)":"<b>Alleen</b> inwisselbaar op Mercado Livre (Brazili)","A member of the team will review your feedback as soon as possible.":"Een lid van het team zal zo spoedig mogelijk uw feedback bekijken.","A total of {{amountAboveMaxSizeStr}} were excluded. The maximum size allowed for a transaction was exceeded.":"Een totaal van {{amountAboveMaxSizeStr}} is uitgesloten. De maximum toegestane grootte voor een transactie is overschreden.","A total of {{amountBelowFeeStr}} were excluded. These funds come from UTXOs smaller than the network fee provided.":"Een totaal van {{amountBelowFeeStr}} is uitgesloten. Dit saldo is afkomstig uit ontvangsten kleiner dan de transactiekosten.","About":"Over","Accepted":"Geaccepteerd","Account":"Account","Account Number":"Account Nummer","Accounts":"Accounts","Activity":"Activiteit","Add Account":"Account Toevoegen","Add BitPay Account?":"BitPay Account Toevoegen?","Add Contact":"Contactpersoon Toevoegen","Add Funds":"Saldo Toevoegen","Add Memo":"Notitie Toevoegen","Add a password":"Een wachtwoord toevoegen","Add account":"Account toevoegen","Add an optional password to secure the recovery phrase":"Een optioneel wachtwoord toevoegen voor het beveiligen van de herstel zin","Add as a contact":"Toevoegen als contactpersoon","Add description":"Beschrijving toevoegen","Add funds":"Saldo toevoegen","Add this BitPay account ({{email}})?":"Deze BitPay account ({{email}}) toevoegen?","Add wallet":"Portemonnee toevoegen","Address":"Adres","Address Book":"Adresboek","Address Type":"Adres Type","Addresses With Balance":"Adressen Met Saldo","Advanced":"Geavanceerd","Advanced Settings":"Geavanceerde Instellingen","All":"Alle","All Addresses":"Alle Adressen","All of your bitcoin wallet balance may not be available for immediate spending.":"Mogelijk is niet het volledige saldo van uw bitcoin portemonnee direct beschikbaar voor uitgaven.","All signing devices must be added to this multisig wallet before bitcoin addresses can be created.":"Alle ondertekenende apparaten moeten worden toegevoegd aan deze meervoudige-ondertekening portemonnee voordat bitcoin adressen kunnen worden aangemaakt.","Allow Camera Access":"Camera Toegang Toestaan","Allow notifications":"Meldingen toestaan","Almost done! Let's review.":"Bijna klaar! Nog eens nakijken.","Alternative Currency":"Alternatieve Valuta","Amazon.com is not available at this moment. Please try back later.":"Amazon.com is niet beschikbaar op dit moment. Probeer het later nog eens.","Amount":"Bedrag","Amount below minimum allowed":"Bedrag lager dan minimum toegestaan","Amount too big":"Bedrag te groot","Amount too low to spend":"Bedrag te laag om te besteden","An update to this app is available. For your security, please update to the latest version.":"Er is een update voor deze app beschikbaar. Update a.u.b. naar de nieuwste versie voor uw veiligheid.","Anyone with your backup phrase can access or spend your bitcoin.":"Iemand die uw herstel zin weet heeft toegang tot uw bitcoin en kan deze uitgeven.","Approximate Bitcoin network fee to transfer wallet's balance (with normal priority)":"Geschatte Bitcoin netwerk transactiekosten voor overdracht van volledige saldo van portemonnee (met normale prioriteit)","Are you being watched?":"Kijkt er iemand mee?","Are you being watched? Anyone with your recovery phrase can access or spend your bitcoin.":"Kijkt er iemand mee? Iedereen die uw herstel zin weet heeft toegang tot uw bitcoin en kan het uitgeven.","Are you sure you want to cancel and delete this wallet?":"Weet u zeker dat u wilt annuleren en deze portemonnee verwijderen?","Are you sure you want to delete this contact?":"Weet u zeker dat u deze contactpersoon wilt verwijderen?","Are you sure you want to delete this wallet?":"Weet u zeker dat u deze portemonnee wilt verwijderen?","Are you sure you want to reject this transaction?":"Weet u zeker dat u deze transactie wilt afwijzen?","Are you sure you want to remove this transaction?":"Weet u zeker dat u deze transactie wilt verwijderen?","Are you sure you want to skip it?":"Weet u zeker dat u dit wilt overslaan?","Are you sure you would like to log out of your BitPay Card account?":"Weet u zeker dat u wilt uitloggen uit uw BitPay Kaart account?","Are you sure you would like to remove your BitPay Card ({{lastFourDigits}}) from this device?":"Weet u zeker dat u de BitPay Kaart ({{lastFourDigits}}) van dit apparaat wilt verwijderen?","Auditable":"Auditeerbaar","Available":"Beschikbaar","Available Balance":"Beschikbaar Saldo","Average confirmation time":"Gemiddelde bevestigingstijd","BIP32 path for address derivation":"BIP32 pad voor adres derivatie","BTCZ Wallets":"BTCZ-portemonnees","Backup":"Backup","Backup Needed":"Backup Nodig","Backup all livenet wallets before using this function":"Maak een backup van alle livenet portemonnees voordat u deze functie gebruikt","Backup needed":"Backup nodig","Backup now":"Backup maken","Backup wallet":"Backup van portemonnee maken","Backup your wallet before using this function":"Maak een backup van uw portemonnee voordat u deze functie gebruikt","Bad wallet invitation":"Foutieve portemonnee-uitnodiging","Balance By Address":"Saldo Per Adres","Be sure to store your recovery phrase in a secure place. If this app is deleted, your money cannot be recovered without it.":"Zorg dat u de herstel zin op een veilige plek bewaard. Als deze app verwijderd is, kan uw saldo niet meer worden hersteld zonder de herstel zin.","BitPay Visa Cards":"BitPay Visa&reg; Kaarten","Bitcoin Address":"Bitcoin Adres","Bitcoin Cash Support":"Ondersteuning voor Bitcoin Cash","Bitcoin Network Fee Policy":"Bitcoin Netwerk Transactiekosten Beleid","Bitcoin is a currency.":"Bitcoin is een valuta.","Bitcoin is different  it cannot be safely held with a bank or web service.":"Bitcoin is anders &ndash; het kan niet veilig worden bewaard bij een bank of online dienst.","Bitcoin is secure,<br>digital money.":"Bitcoin is veilig,<br>digitaal geld.","Bitcoin transactions include a fee collected by miners on the network.":"Bitcoin transacties bevatten transactiekosten betaald aan de miners in het netwerk.","Bought {{amountUnitStr}}":"Gekocht {{amountUnitStr}}","Broadcast Payment":"Betaling Verzenden","Broadcasted":"Verzonden","Broadcasting transaction":"Transactie verzenden","Browser unsupported":"Browser niet ondersteund","Buy":"Kopen","Buy &amp; Sell Bitcoin":"Koop &amp; Verkoop Bitcoin","Buy Bitcoin":"Bitcoin kopen","Buy a Gift Card":"Een Cadeaubon kopen","Buy from":"Kopen van","Buying Bitcoin...":"Bitcoin kopen...","Calculating fee":"Transactiekosten berekenen","Cancel":"Annuleren","Cancel invitation":"Uitnodiging annuleren","Cannot Create Wallet":"Kan Portemonnee Niet Aanmaken","Cannot join the same wallet more that once":"Kan niet meerdere keren tegelijk deelnemen aan een portemonnee","Cards":"Kaarten","Certified by":"Gecertificeerd door","Check installation and retry.":"Controleer de installatie en probeer het opnieuw.","Choose a backup file from your computer":"Kies een backup bestand op uw computer","Choose your destination wallet":"Kies uw doel portemonnee","Choose your source wallet":"Kies uw bron portemonnee","Clear":"Leegmaken","Clear cache":"Cache legen","Click to accept":"Klik om te accepteren","Click to pay":"Klik om te betalen","Click to send":"Klik om te verzenden","Close":"Sluiten","Coin":"Munt","Color":"Kleur","Commit hash":"Commit hash","Complete the backup process to use this option":"Voltooi het backup proces voordat u deze optie gebruikt","Completed":"Voltooid","Confirm":"Bevestigen","Confirm &amp; Finish":"Bevestigen &amp; Voltooien","Confirm purchase":"Bevestig aankoop","Confirm your PIN":"Bevestig uw PIN","Confirm your new spending password":"Bevestig uw nieuwe bestedingswachtwoord","Confirmations":"Bevestigingen","Confirming":"Bevestigen","Connect my BitPay Card":"Koppelen met mijn BitPay Kaart","Connecting to Coinbase...":"Verbinding maken met Coinbase...","Connecting to Glidera...":"Verbinding maken met Glidera...","Connection reset by peer":"Verbinding is gereset door peer","Contacts":"Contactpersonen","Continue":"Ga verder","Contribute Translations":"Bijdragen aan Vertalingen","Copayer already in this wallet":"Copayer reeds in deze portemonnee","Copayer already voted on this spend proposal":"Copayer heeft al gestemd op dit bestedingsvoorstel","Copayer data mismatch":"Copayer gegevens komen niet overeen","Copayer joined":"Copayer toegetreden","Copayer {{$index}}":"Copayer {{$index}}","Copied to clipboard":"Gekopieerd naar klembord","Copy this text as it is to a safe place (notepad or email)":"Kopieer deze tekst zonder te wijzigen naar een veilige plek (kladblok of email)","Copy to clipboard":"Naar klembord kopiren","Could not access Gift Card Service":"Kon geen verbinding maken met de Cadeaubon Service","Could not access the wallet at the server. Please check:":"Kon geen toegang krijgen tot de portemonnee op de server. Graag dit checken:","Could not access to Amazon.com":"Kon geen verbinding maken met Amazon.com","Could not access wallet":"Kon geen toegang krijgen tot portemonnee","Could not add message to imported wallet without shared encrypting key":"Kon geen bericht toegevoegd worden aan gemporteerde portemonnee zonder gedeelde sleutel","Could not broadcast payment":"Kon betaling niet verzenden","Could not build transaction":"Kon transactie niet opzetten","Could not create address":"Kon adres niet aanmaken","Could not create the invoice":"Kon factuur niet aanmaken","Could not create transaction":"Kon transactie niet aanmaken","Could not create using the specified extended private key":"Kon niet aanmaken met de gebruikte verlengde priv sleutel","Could not create using the specified extended public key":"Kon niet aanmaken met de opgegeven verlengde publieke sleutel","Could not create: Invalid wallet recovery phrase":"Kon niet worden gemaakt: Ongeldige portemonnee herstel zin","Could not decrypt file, check your password":"Kon bestand niet ontsleutelen, check uw wachtwoord","Could not delete payment proposal":"Kon betalingsvoorstel niet verwijderen","Could not duplicate":"Kon niet dupliceren","Could not get dynamic fee":"Kon dynamische transactiekosten niet bepalen","Could not get dynamic fee for level: {{feeLevel}}":"Kon dynamische transactiekosten niet bepalen voor niveau: {{feeLevel}}","Could not get fee levels":"Kon niveaus transactiekosten niet opvragen","Could not get the invoice":"Kon factuur niet opvragen","Could not get transactions":"Kon transacties niet opvragen","Could not import":"Kon niet importeren","Could not import. Check input file and spending password":"Kon niet importeren. Controleer bestand en bestedingswachtwoord","Could not join wallet":"Kon niet toetreden tot portemonnee","Could not reject payment":"Kon betaling niet weigeren","Could not remove account":"Kon account niet verwijderen","Could not remove card":"Kon kaart niet verwijderen","Could not save preferences on the server":"Kon voorkeuren niet opslaan op de server","Could not send payment":"Kon betaling niet versturen","Could not send transaction":"Kon transactie niet versturen","Could not update transaction history":"Kon transactiehistorie niet bijwerken","Could not update wallet":"Kon portemonnee niet bijwerken","Create Personal Wallet":"Persoonlijke Portemonnee Aanmaken","Create Shared Wallet":"Gedeelde Portemonnee Aanmaken","Create bitcoin wallet":"Bitcoin portemonnee aanmaken","Create new wallet":"Nieuwe portemonnee aanmaken","Create shared wallet":"Gedeelde portemonnee aanmaken","Create {{formData.requiredCopayers}}-of-{{formData.totalCopayers}} wallet":"{{formData.requiredCopayers}}-van-{{formData.totalCopayers}} portemonnee aanmaken","Created by":"Aangemaakt door","Creating Wallet...":"Portemonnee Aanmaken...","Creating transaction":"Transactie aanmaken","Current fee rate for this policy":"Huidige transactiekosten voor dit beleid","Custom":"Aangepast","Custom Amount":"Aangepast Bedrag","Custom Fee":"Aangepaste Transactiekosten","Date":"Datum","Delete":"Verwijderen","Delete Payment Proposal":"Verwijder Bestedingsvoorstel","Delete Wallet":"Portemonnee Verwijderen","Delete it and create a new one":"Verwijderen en een nieuwe maken","Deleting Wallet...":"Portemonnee Verwijderen...","Deleting payment proposal":"Betalingsvoorstel verwijderen","Derivation Path":"Derivatie Pad","Derivation Strategy":"Derivatie Strategie","Details":"Details","Disabled":"Uitgeschakeld","Do it later":"Doe het later","Do not include private key":"Priv sleutel niet bijvoegen","Don't see your language on Crowdin? Contact the Owner on Crowdin! We'd love to support your language.":"Ziet u uw taal niet op Crowdin? Neem contact op met de Eigenaar op Crowdin! We willen graag uw taal ondersteunen.","Download":"Download","Duplicate for BCH":"Dupliceren voor BCH","Duplicating wallet...":"Portemonnee dupliceren...","Each bitcoin wallet can generate billions of addresses from your 12-word backup. A new address is automatically generated and shown each time you receive a payment.":"Elke bitcoin portemonnee kan miljarden adressen genereren vanuit uw backup bestaand uit 12 woorden. Elke keer dat u een betaling ontvangt wordt automatisch een nieuw adres gegenereerd en getoond.","Economy":"Zuinig","Edit":"Bewerken","Email":"Email","Email Address":"Emailadres","Empty addresses limit reached. New addresses cannot be generated.":"Limiet lege adressen bereikt. Nieuwe adressen kunnen niet worden gegenereerd.","Enable Bitcoin Cash wallet creation and operation within the App.":"Aanmaken en gebruiken van Bitcoin Cash portemonnees inschakelen binnen de App.","Enable camera access in your device settings to get started.":"Schakel camera toegang in vanuit uw apparaat instellingen om aan de slag te gaan.","Enable email notifications":"Email meldingen inschakelen","Enable push notifications":"Push meldingen inschakelen","Enable the camera to get started.":"Schakel de camera in om aan de slag te gaan.","Enabled":"Ingeschakeld","Enter Spending Password":"Voer Bestedingswachtwoord in","Enter Two Factor for your BitPay account":"Voer Two Factor in voor uw BitPay account","Enter amount":"Vul bedrag in","Enter custom fee":"Vul aangepaste transactiekosten in","Enter new spending password":"Voer nieuw bestedingswachtwoord in","Enter the recovery phrase (BIP39)":"Vul de herstel zin in (BIP39)","Enter your email":"Vul uw email in","Enter your password":"Voer uw wachtwoord in","Error":"Fout","Error at confirm":"Fout bij bevestigen","Error creating gift card":"Fout tijdens maken cadeaubon","Error creating the invoice":"Fout tijdens maken van de factuur","Error creating wallet":"Fout tijdens maken portemonnee","Error getting SendMax information":"Fout tijdens opvragen VerstuurMaximum informatie","Error in Payment Protocol":"Fout in Betalings Protocol","Error pairing BitPay Account":"Fout tijdens koppelen BitPay Account","Error scanning funds:":"Fout tijdens scannen saldo:","Error sweeping wallet:":"Fout tijdens opnemen saldo portemonnee:","Error updating Debit Cards":"Fout tijdens bijwerken Debet Kaarten","Exceeded daily limit of $500 per user":"Dagelijkse limiet van $500 per gebruiker overschreden","Expired":"Verlopen","Expires":"Verloopt","Export Wallet":"Exporteer Portemonnee","Export to file":"Exporteren naar bestand","Export wallet":"Exporteer portemonnee","Exporting via QR not supported for this wallet":"Exporteren via QR niet ondersteund voor deze portemonnee","Extended Public Keys":"Verlengde Publieke Sleutels","Extracting Wallet information...":"Portemonnee informatie ophalen...","Failed to export":"Exporteren mislukt","Family vacation funds":"Familie vakantie fonds","Fee":"Transactiekosten","Fee level":"Niveau transactiekosten","Fee level is not defined":"Niveau transactiekosten is niet ingesteld","Fee:":"Transactiekosten:","Feedback could not be submitted. Please try again later.":"Feedback kon niet worden ingediend. Probeer het later nog eens.","Fetching BitPay Account...":"Ophalen BitPay Account...","Fetching payment information":"Ophalen van betalingsgegevens","File/Text":"Bestand/Tekst","Filter setting":"Filter instellingen","Finger Scan Failed":"Vingerscan Mislukt","Finish":"Voltooien","For audit purposes":"Voor audit doeleinden","From":"Van","From BitPay account":"Van BitPay account","From Hardware Wallet":"Vanuit Hardware Portemonnee","From the destination device, go to Add wallet &gt; Import wallet and scan this QR code":"Ga op het ontvangende apparaat naar Portemonnee toevoegen &gt; Importeer portemonnee, en scan deze QR code","Funds are locked by pending spend proposals":"Saldo is vergrendeld in afwachting van bestedingsvoorstellen","Funds found:":"Gevonden saldo:","Funds to be added":"Saldo toe te voegen","Funds transferred":"Overgemaakt saldo","Funds were added to debit card":"Saldo is toegevoegd aan debetkaart","Funds will be transferred to":"Saldo zal worden overgemaakt naar","Generate new address":"Genereer nieuw adres","Generating .csv file...":".csv bestand genereren...","Generating new address...":"Nieuw adres genereren...","Get local cash anywhere you go, from any Visa<sup></sup> compatible ATM. ATM bank fees may apply.":"Verkrijg lokaal contant geld waar je ook gaat, van elke Visa<sup>&reg;</sup> ondersteunende pinautomaat. Kosten voor gebruik van de pinautomaat kunnen in rekening gebracht worden.","Get news and updates from BitPay":"Ontvang nieuws en updates van BitPay","Get started":{"button":"Aan de slag","$$noContext":"Aan de slag"},"Get started by adding your first one.":"Ga aan de slag door uw eerste toe te voegen.","Getting fee levels...":"Hoogte transactiekosten opvragen...","Gift Card is not available to use anymore":"Cadeaukaart is niet meer beschikbaar voor gebruik","Gift card":"Cadeaubon","Gift card expired":"Cadeaubon verlopen","Gift card generated and ready to use.":"Cadeaubon aangemaakt en klaar voor gebruik.","Go Back":"Terug","Go back":"Terug","Got it":"Ik begrijp het","Hardware Wallet":"Hardware Portemonnee","Hardware not connected.":"Hardware niet aangesloten.","Hardware wallet":"Hardware portemonnee","Hardware wallets are not yet supported with Bitcoin Cash":"Hardwareportemonnees worden nog niet ondersteund voor Bitcoin Cash","Help & Support":"Hulp & Ondersteuning","Help and support information is available at the website.":"Hulp en ondersteuning is beschikbaar op de website.","Hide":"Verberg","Hide Balance":"Verberg Saldo","Hide Next Steps Card":"Verberg Volgende Stappen Kaart","Hide advanced options":"Verberg geavanceerde opties","Home":"Start","How could we improve your experience?":"Hoe zouden wij uw ervaring kunnen verbeteren?","How do you like {{appName}}?":"Hoe bevalt {{appName}}?","I don't like it":"Ik vind hem niet goed","I have read, understood, and agree to the <a ng-click=\"openTerms()\" translate=\"\">Terms of Use</a>.":"Ik heb gelezen, begrepen, en ga akkoord met de <a ng-click=\"openTerms()\" translate=\"\">Gebruiksvoorwaarden</a>.","I have read, understood, and agree with the Terms of use.":"Ik heb gelezen, begrepen, en ga akkoord met de Gebruiksvoorwaarden.","I have written it down":"Ik heb het opgeschreven","I like the app":"De app bevalt mij goed","I think this app is terrible.":"Ik vind de app verschrikkelijk.","I understand":"Ik begrijp het","I understand that if this app is moved to another device or deleted, my bitcoin can only be recovered with the backup phrase.":"Ik begrijp dat als deze app wordt verwijderd of verplaatst naar een ander apparaat, ik mijn bitcoin alleen kan herstellen met de herstel zin.","I understand that my funds are held securely on this device, not by a company.":"Ik begrijp dat mijn saldo veilig op dit apparaat bewaard wordt, en niet in handen is van een bedrijf.","I've written it down":"Ik heb het opgeschreven","If enabled, all sensitive information (private key and recovery phrase) and actions (spending and exporting) associated with this wallet will be protected.":"Indien ingeschakeld, zullen alle gevoelige informatie (priv sleutel en herstel zin) en acties (uitgeven en exporteren) geassocieerd met deze portemonnee worden beschermd.","If enabled, the Recent Transactions card - a list of transactions occuring across all wallets - will appear in the Home tab.":"Indien ingeschakeld, zal de Recente Transacties kaart - een lijst van transacties van alle portemonnees - worden weergegeven in het tabblad Start.","If enabled, wallets will also try to spend unconfirmed funds. This option may cause transaction delays.":"Indien ingeschakeld, zullen portemonnees ook onbevestigd saldo proberen te besteden. Deze optie kan transactie vertragingen veroorzaken.","If this device is replaced or this app is deleted, neither you nor BitPay can recover your funds without a backup.":"Als dit apparaat wordt vervangen of deze app wordt verwijderd, kunnen u noch BitPay uw saldo herstellen zonder backup.","If you have additional feedback, please let us know by tapping the \"Send feedback\" option in the Settings tab.":"Als u meer feedback heeft, laat het ons dan weten via de \"Geef feedback\" optie in het tabblad Instellingen.","If you take a screenshot, your backup may be viewed by other apps. You can make a safe backup with physical paper and a pen.":"Als u een screenshot neemt kunnen andere apps uw backup zien. U kunt een veilige backup maken met fysieke pen en papier.","Import":"Importeren","Import Wallet":"Importeer Portemonnee","Import backup":"Backup importeren","Import wallet":"Importeer portemonnee","Importing Wallet...":"Portemonnee importeren...","In order to verify your wallet backup, please type your password.":"Vul uw wachtwoord in om de backup van uw portemonnee te verifiren.","Inactive":"Inactief","Incomplete":"Onvolledig","Incomplete wallet":"Onvolledige portemonnee","Incorrect PIN, try again.":"Onjuiste PIN, probeer het opnieuw.","Incorrect code format":"Onjuist code format","Incorrect network address":"Onjuist netwerk adres","Insufficient funds":"Onvoldoende saldo","Insufficient funds for fee":"Onvoldoende saldo voor transactiekosten","Invalid":"Ongeldig","Invalid URL":"Ongeldige URL","Invalid account number":"Ongeldig account nummer","Invalid address":"Ongeldig adres","Invalid data":"Ongeldige gegevens","Invalid derivation path":"Ongeldig derivatie pad","Invitation to share a {{appName}} Wallet":"Uitnodiging om {{appName}} Portemonnee te delen","Invoice expired":"Factuur verlopen","Is there anything we could do better?":"Is er iets dat we beter kunnen doen?","Is this correct?":"Klopt dit?","Is this email address correct?":"Is dit emailadres juist?","It's a good idea to avoid reusing addresses - this both protects your privacy and keeps your bitcoins secure against hypothetical attacks by quantum computers.":"Het is aan te raden adressen niet te hergebruiken - dit beschermt uw privacy en beveiligd uw bitcoins tegen een hypothetische aanval door quantum computers.","It's important that you write your backup phrase down correctly. If something happens to your wallet, you'll need this backup to recover your money. Please review your backup and try again.":"Het is van belang uw backup zin correct op te schrijven. Als er iets gebeurt met uw portemonnee, heeft u deze backup nodig om toegang tot uw geld te herstellen. Controleer uw backup en probeer het nogmaals.","Join":"Deelnemen","Join my {{appName}} Wallet. Here is the invitation code: {{secret}} You can download {{appName}} for your phone or desktop at {{appUrl}}":"Neem deel aan mijn {{appName}} Portemonnee. Hier is de uitnodigingscode: {{secret}} U kunt {{appName}} voor uw telefoon of desktop hier downloaden {{appUrl}}","Join shared wallet":"Deelnemen aan gedeelde portemonnee","Joining Wallet...":"Deelnemen aan Portemonnee...","Just scan the code to pay.":"Scan de code om te betalen.","Key already associated with an existing wallet":"Sleutel is reeds geassocieerd met een bestaande portemonnee","Language":"Taal","Last Month":"Vorige Maand","Learn more":"Meer informatie","Let's verify your backup phrase.":"Laten we de backup zin verifiren.","Loading addresses...":"Adressen laden...","Loading transaction info...":"Transactie info laden...","Lock App":"Vergrendel App","Lock by Fingerprint":"Vergrendelen met Vingerafdruk","Lock by PIN":"Vergrendelen met PIN","Locked":"Vergrendeld","Locktime in effect. Please wait to create a new spend proposal":"Tijdslot van kracht. Wacht a.u.b. met het maken van een nieuw bestedingsvoorstel","Locktime in effect. Please wait to remove this spend proposal":"Tijdslot van kracht. Wacht a.u.b. met het verwijderen van dit bestedingsvoorstel","Log options":"Log opties","Log out":"Uitloggen","Low amount inputs":"Kleine ontvangsten","Low fees":"Lage transactiekosten","Makes sense":"Klinkt logisch","Matches:":"Overeenkomsten:","Me":"Ik","Meh - it's alright":"Meh - het is OK","Memo":"Notitie","Mercado Livre Brazil Gift Cards":"Mercado Livre Brazil Cadeaubonnen","Mercadolibre Gift Card Service is not available at this moment. Please try back later.":"Mercadolibre Cadeaubon Service is niet beschikbaar op dit moment. Probeer het later nog eens.","Merchant Message":"Bericht Verkoper","Miner Fee":"Transactiekosten Miner","Missing parameter":"Ontbrekende parameter","Missing private keys to sign":"Priv sleutels om te ondertekenen ontbreken","More Options":"Meer Opties","Moved":"Verplaatst","Moved Funds":"Saldo Verplaatst","Multiple recipients":"Meerdere ontvangers","NOTE: To import a wallet from a 3rd party software, please go to Add Wallet &gt; Create Wallet, and specify the Recovery Phrase there.":"OPMERKING: Om een portemonnee te importeren vanuit software van een 3e partij, ga naar Portemonnee Toevoegen &gt; Portemonnee Aanmaken, en vul daar de herstel zin in.","Name":"Naam","Network Cost":"Transactiekosten","Network error":"Netwerk fout","New Proposal":"Nieuw Voorstel","New address could not be generated. Please try again.":"Nieuw adres kon niet worden gegenereerd. Probeer het opnieuw.","New personal wallet":"Nieuwe persoonlijke portemonnee","Next steps":"Volgende stappen","No Wallet":"Geen Portemonnee","No access key defined":"Geen toegangsknop ingesteld","No backup, no bitcoin.":"Geen backup, geen bitcoin.","No contacts yet":"Nog geen contactpersonen","No entries for this log level":"Geen items voor dit logboek niveau","No hardware information available.":"Geen hardware informatie beschikbaar.","No hardware wallets supported on this device":"Er worden geen hardware portemonnees ondersteund op dit apparaat","No pending proposals":"Geen voorstellen in behandeling","No recent transactions":"Geen recente transacties","No signing proposal: No private key":"Geen voorstel voor ondertekenen: Geen priv sleutel","No transactions yet":"Nog geen transacties","No wallet found":"Geen portemonnee gevonden","No wallet selected":"Geen portemonnee geselecteerd","No wallets available":"Geen portemonnees beschikbaar","No wallets available to receive funds":"Geen portemonnees beschikbaar om saldo te ontvangen","No wallets eligible for Bitcoin Cash support":"Geen geschikte portemonnees voor Bitcoin Cash-ondersteuning","Non eligible BTCZ wallets":"Geen geschikte BTCZ-portemonnees","Normal":"Normaal","Not authorized":"Niet geautoriseerd","Not enough funds for fee":"Onvoldoende saldo voor transactiekosten","Not even BitPay can access it.":"Zelfs BitPay heeft geen toegang.","Not funds found":"Geen saldo gevonden","Not now":"Niet nu","Note":"Notitie","Notice: only 1-1 (single signature) wallets can be used for sell bitcoin":"Let op: alleen 1-1 (enkele ondertekening) portemonnees kunnen gebruikt worden voor het verkopen van bitcoin","Notifications":"Meldingen","Notifications by email":"Meldingen per email","Notify me if confirmed":"Geef mij een melding wanneer bevestigd","Notify me when transactions are confirmed":"Geef mij een melding wanneer transacties zijn bevestigd","Now is a good time to backup your wallet. If this device is lost, it is impossible to access your funds without a backup.":"Dit is een goed moment om een backup van de portemonnee te maken. Als dit apparaat kwijt raakt is het onmogelijk om toegang tot uw saldo te krijgen zonder een backup.","Now is a perfect time to assess your surroundings. Nearby windows? Hidden cameras? Shoulder-spies?":"Dit is het juiste moment om uw omgeving te bekijken. Ramen in de buurt? Verborgen camera's? Kijkt er iemand mee over uw schouder?","OK":"OK","OKAY":"OK","Official English Disclaimer":"Officile Engelse Voorwaardelijkheidsverklaring","Oh no!":"Oh nee!","Ok":"OK","On this screen you can see all your wallets, accounts, and assets.":"Op dit scherm ziet u al uw portemonnees, accounts en eigendommen.","Open":"Openen","Open Crowdin":"Crowdin openen","Open GitHub":"GitHub openen","Open GitHub Project":"GitHub Project openen","Open Insight":"Insight openen","Open Settings":"Instellingen openen","Open Translation Community":"Vertalings Gemeenschap openen","Open Website":"Website Openen","Open bitcoincash.org?":"Bitcoincash.org openen?","Open wallet":"Portemonnee openen","Open website":"Website openen","Order the BitPay Card":"Bestel de BitPay Kaart","Password":"Wachtwoord","Password required. Make sure to enter your password in advanced options":"Wachtwoord vereist. Vul uw wachtwoord in bij de geavanceerde opties","Paste invitation here":"Plak hier de uitnodiging","Paste the backup plain text code":"Plak de platte tekst backup","Pay 0% fees to turn bitcoin into dollars.":"Betaal 0% transactiekosten om bitcoin om te zetten naar dollars.","Pay To":"Betalen Aan","Payment Accepted":"Betaling Geaccepteerd","Payment Expires:":"Betaling Verloopt:","Payment Proposal":"Betalingsvoorstel","Payment Proposal Created":"Betalingsvoorstel Aangemaakt","Payment Proposals":"Betalingsvoorstellen","Payment Protocol Invalid":"Betaling Protocol Ongeldig","Payment Protocol not supported on Chrome App":"Betalingsvoorstel niet ondersteund door Chrome App","Payment Received":"Betaling Ontvangen","Payment Rejected":"Betaling Afgewezen","Payment Sent":"Betaling Verzonden","Payment accepted, but not yet broadcasted":"Betaling geaccepteerd, maar nog niet verzonden","Payment accepted. It will be broadcasted by Glidera. In case there is a problem, it can be deleted 6 hours after it was created.":"Betaling geaccepteerd. Deze zal worden verzonden door Glidera. In geval van problemen kan de betaling worden verwijderd 6 uur na aanmaken.","Payment address was translated to new Bitcoin Cash address format:":"Betalingsadres is vertaald naar nieuw adresformaat voor Bitcoin Cash:","Payment details":"Details Betaling","Payment request":"Betalingsverzoek","Pending":"In behandeling","Pending Proposals":"Voorstellen in behandeling","Permanently delete this wallet.":"Deze portemonnee definitief verwijderen.","Personal Wallet":"Persoonlijke Portemonnee","Please carefully write down this phrase.":"Schrijf zorgvuldig deze zin op.","Please connect a camera to get started.":"Sluit een camera aan om aan de slag te gaan.","Please enter the recovery phrase":"Vul de herstel zin in","Please enter the wallet recovery phrase":"Vul de herstel zin van de portemonnee in","Please enter your PIN":"Vul uw PIN in","Please tap each word in the correct order.":"Druk a.u.b. op elk woord in de juiste volgorde.","Please upgrade Copay to perform this action":"Upgrade Copay om deze actie uit te voeren","Please wait":"Even geduld","Please, select your backup file":"Selecteer uw backup bestand","Pre-Auth Holds":"Pre-Authorisatie Inhoudingen","Preferences":"Voorkeuren","Preparing addresses...":"Adressen voorbereiden...","Preparing backup...":"Backup voorbereiden...","Press again to exit":"Druk nogmaals om te sluiten","Priority":"Dringend","Private Key":"Priv Sleutel","Private key encrypted. Enter password":"Priv sleutel versleuteld. Voer wachtwoord in","Private key is encrypted, cannot sign":"Priv sleutel is versleuteld, kan niet ondertekenen","Proposal Accepted":"Voorstel Geaccepteerd","Proposal Created":"Voorstel Aangemaakt","Proposal Deleted":"Voorstel Verwijderd","Proposal Rejected":"Voorstel Afgewezen","Proposals":"Voorstellen","Purchase Amount is limited to {{limitPerDay}} {{currency}} per day":"Aankoop Bedrag is beperkt tot {{limitPerDay}} {{currency}} per dag","Purchase amount must be a value between 50 and 2000":"Aankoop bedrag moet een getal zijn tussen de 50 en 2000","Push Notifications":"Push Meldingen","Push notifications for {{appName}} are currently disabled. Enable them in the Settings app.":"Push meldingen voor {{appName}} zijn op dit moment uitgeschakeld. Schakel deze in vanuit de Instellingen app.","QR Code":"QR Code","Quick review!":"Kort samenvatten!","Random":"Willekeurig","Rate on the app store":"Beoordelen in de app store","Read less":"Lees minder","Read more":"Lees meer","Read more in our Wiki":"Lees meer in onze Wiki","Receive":"Ontvangen","Receive in":"Ontvangen in","Received":"Ontvangen","Received Funds":"Ontvangen Saldo","Receiving":"Ontvangen","Recent":"Recent","Recent Transaction Card":"Recente Transacties Kaart","Recent Transactions":"Recente Transacties","Recipient":"Ontvanger","Recipients":"Ontvangers","Recovery phrase":"Herstel zin","Recreating Wallet...":"Portemonnee herstellen...","Redeem now":"Nu inwisselen","Rejected":"Afgewezen","Rejecting payment proposal":"Betalingsvoorstel afwijzen","Release information":"Release informatie","Remove":"Verwijderen","Remove BitPay Account?":"BitPay Account verwijderen?","Remove BitPay Card?":"BitPay Kaart verwijderen?","Removing your BitPay account will remove all associated BitPay account data from this device. Are you sure you would like to remove your BitPay Account ({{email}}) from this device?":"Het verwijderen van uw BitPay account zal alle geassocieerde BitPay accountgegevens van dit apparaat verwijderen. Weet u zeker dat u de BitPay Account ({{email}}) van dit apparaat wilt verwijderen?","Repeat password":"Herhaal wachtwoord","Repeat the password":"Herhaal het wachtwoord","Request Fingerprint":"Vereis Vingerafdruk","Request Specific amount":"Vraag Specifiek bedrag","Request Spending Password":"Vereis Bestedingswachtwoord","Required number of signatures":"Vereiste aantal ondertekeningen","Restore from backup":"Herstellen vanuit backup","Retrieving inputs information":"Opvragen informatie ontvangsten","Retry":"Probeer opnieuw","Retry Camera":"Camera opnieuw proberen","Save":"Opslaan","Scan":"Scannen","Scan QR Codes":"Scan QR Codes","Scan addresses for funds":"Scan adressen voor saldo","Scan again":"Scan nogmaals","Scan your fingerprint please":"Scan uw vingerafdruk","Scanning Wallet funds...":"Saldo Portemonnee scannen...","Screenshots are not secure":"Screenshots zijn niet veilig","Search Transactions":"Doorzoek Transacties","Search or enter bitcoin address":"Zoeken of bitcoin adres invullen","Search transactions":"Doorzoek transacties","Search your currency":"Zoek uw valuta","Security":"Beveiliging","See invoice":"Bekijk factuur","Select a backup file":"Selecteer een backup bestand","Select a wallet":"Selecteer een portemonnee","Self-signed Certificate":"Zelf-gesigneerd Certificaat","Selling Bitcoin...":"Bitcoin verkopen...","Send":"Verzenden","Send Feedback":"Feedback Sturen","Send Money":"Stuur Geld","Send addresses by email":"Verstuur adressen per email","Send by email":"Verstuur via email","Send from":"Verzenden vanuit","Send max amount":"Verzend maximale hoeveelheid","Send payment to this address":"Verstuur betaling naar dit adres","Send us feedback instead":"Stuur in plaats daarvan feedback","Sending":"Verzenden","Sending 2FA code...":"2FA code verzenden...","Sending feedback...":"Feedback verzenden...","Sending maximum amount":"Maximale hoeveelheid verzenden","Sending transaction":"Transactie verzenden","Sending {{amountStr}} from your {{name}} wallet":"Verzenden van {{amountStr}} vanuit uw {{name}} portemonnee","Sent":"Verzonden","Sent Funds":"Verzonden Bedrag","Server response could not be verified":"Server reactie kon niet geverifieerd worden","Service not available":"Service niet beschikbaar","Services":"Diensten","Session Log":"Sessie Log","Session log":"Sessie log","Set up a password":"Stel wachtwoord in","Set your own fee in satoshis/byte":"Kies uw eigen transactiekosten in satoshi/byte","Settings":"Instellingen","Share the love by inviting your friends.":"Deel het plezier door uw vrienden uit te nodigen.","Share this invitation with your copayers":"Deel deze uitnodiging met uw copayers","Share {{appName}}":"Deel {{appName}}","Shared Wallet":"Gedeelde Portemonnee","Show Recovery Phrase":"Toon Herstel Zin","Show address":"Toon adres","Show advanced options":"Geavanceerde opties weergeven","Show bitcoin address":"Toon bitcoin adres","Show more":"Meer weergeven","Signatures rejected by server":"Ondertekeningen geweigerd door server","Signing transaction":"Transactie ondertekenen","Since only you control your money, youll need to save your backup phrase in case this app is deleted.":"Omdat u de enige bent die uw geld beheert, zult u de herstel zin moeten bewaren indien deze app verwijderd wordt.","Single Address Wallet":"Portemonnee met 1 Adres","Skip":"Overslaan","Slide to accept":"Schuiven om te accepteren","Slide to buy":"Schuif om te kopen","Slide to pay":"Schuiven om te betalen","Slide to send":"Schuiven om te verzenden","Specify Recovery Phrase...":"Voer Herstel Zin in...","Spend proposal is not accepted":"Bestedingsvoorstel is niet geaccepteerd","Spend proposal not found":"Bestedingsvoorstel niet gevonden","Spending Password needed":"Bestedingswachtwoord vereist","Spending this balance will need significant Bitcoin network fees":"Dit bedrag uitgeven vereist aanzienlijke transactiekosten","Start sending bitcoin":"Begin met het sturen van bitcoin","Startup Lock":"Opstart Slot","Still pending":"Nog in behandeling","Success":"Geslaagd","Super Economy":"Super Zuinig","Support Bitcoin Cash":"Steun Bitcoin Cash","Sweep":"Saldo opnemen","Sweep paper wallet":"Saldo papieren portemonnee opnemen","Sweeping Wallet...":"Saldo Portemonnee opnemen...","THIS ACTION CANNOT BE REVERSED":"DEZE ACTIE IS ONOMKEERBAAR","Take control of your money,<br>get started with bitcoin.":"Neem controle over uw geld,<br>aan de slag met bitcoin.","Tap and hold to show":"Tik en houd vast om te tonen","Tap to recreate":"Tik om opnieuw aan te maken","Tap to retry":"Tik om opnieuw te proberen","Terms Of Use":"Gebruiksvoorwaarden","Terms of Use":"Gebruikersvoorwaarden","Testnet":"Testnet","Text":"Tekst","Thank you!":"Dank u!","Thanks!":"Bedankt!","That's exciting to hear. We'd love to earn that fifth star from you  how could we improve your experience?":"Dat is goed om te horen. Wij zouden graag die vijfde ster verdienen - hoe kunnen wij uw ervaring verbeteren?","The Ledger Chrome application is not installed":"De Ledger Chrome applicatie is niet genstalleerd","The amount of bitcoin immediately spendable from this wallet.":"De hoeveelheid bitcoin die direct te besteden is vanuit deze portemonnee.","The amount of bitcoin stored in this wallet that is allocated as inputs to your pending transaction proposals. The amount is determined using unspent transaction outputs associated with this wallet and may be more than the actual amounts associated with your pending transaction proposals.":"De hoeveelheid bitcoin opgeslagen in deze portemonnee die is toegewezen als invoer voor uw wachtende betalingsvoorstellen. De hoeveelheid is bepaald door te kijken naar ongebruikte transactie uitvoer geassocieerd met deze portemonnee en kan meer zijn dan de daadwerkelijke hoeveelheid geassocieerd met de wachtende betalingsvoorstellen.","The amount of bitcoin stored in this wallet with less than 1 blockchain confirmation.":"De hoeveelheid bitcoin opgeslagen in deze portemonnee met minder dan 1 blockchain bevestiging.","The derivation path":"Het derivatie pad","The exchange rate changes with the market.":"De wisselkoers wijzigt aan de hand van de markt.","The higher the fee, the greater the incentive a miner has to include that transaction in a block. Current fees are determined based on network load and the selected policy.":"Des te hoger de betaalde transactiekosten, des te meer reden een miner heeft om de transactie in een blok op te nemen. De huidige transactiekosten worden bepaald aan de hand van de drukte op het netwerk en het gekozen beleid.","The maximum number of consecutive unused addresses (20) has been reached. When one of your unused addresses receives a payment, a new address will be generated and shown in your Receive tab.":"Het maximum aantal opeenvolgende ongebruikte adressen (20) is bereikt. Wanneer een van uw ongebruikte adressen een betaling ontvangt zal een nieuw adres worden gegenereerd en worden getoond in het tabblad Ontvangen.","The official English Terms of Service are available on the BitPay website.":"De officile Engelse Gebruiksvoorwaarden zijn beschikbaar op de BitPay website.","The password of the recovery phrase (if set)":"Het wachtwoord van de herstel zin (indien ingesteld)","The payment was created but could not be completed. Please try again from home screen":"De betaling is aangemaakt maar kon niet worden voltooid. Probeer het nogmaals vanuit het start scherm","The payment was removed by creator":"De betaling is verwijderd door de aanmaker","The recovery phrase could require a password to be imported":"Voor het importeren van de herstel zin zou een wachtwoord nodig kunnen zijn","The request could not be understood by the server":"Het verzoek kon niet worden begrepen door de server","The restore process will stop when 20 addresses are generated in a row which contain no funds. To safely generate more addresses, make a payment to one of the unused addresses which has already been generated.":"Het herstel proces zal stoppen wanneer er 20 adressen achter elkaar zijn gegenereerd die geen saldo bevatten. Om veilig meer adressen te genereren kan een betaling gedaan worden naar een van de reeds gegenereerde adressen.","The spend proposal is not pending":"Het bestedingsvoorstel is niet meer in behandeling","The total amount of bitcoin stored in this wallet.":"De totale hoeveelheid bitcoin opgeslagen in deze portemonnee.","The transaction history and every new incoming transaction are cached in the app. This feature clean this up and synchronizes again from the server":"De transactiegeschiedenis en elke ontvangen transactie worden gecached in de app. Deze optie schoont de cache op en synchroniseert opnieuw met de server","The wallet service URL":"De portemonnee service URL","There is a new version of {{appName}} available":"Er is een nieuwe versie van {{appName}} beschikbaar","There is an error in the form":"Het formulier bevat een fout","There's obviously something we're doing wrong.":"Er is duidelijk iets dat we verkeerd doen.","This app is fantastic!":"Deze app is fantastisch!","This app stores your bitcoin with cutting-edge security.":"Deze app bewaart uw bitcoin met de nieuwste beveiliging.","This bitcoin payment request has expired.":"Dit bitcoin betalingsverzoek is verlopen.","This password cannot be recovered. If the password is lost, there is no way you could recover your funds.":"Dit wachtwoord kan niet worden achterhaald. Als het wachtwoord verloren gaat is er geen mogelijkheid om toegang tot uw saldo te herstellen.","This recovery phrase was created with a password. To recover this wallet both the recovery phrase and password are needed.":"Deze herstel zin is aangemaakt met een wachtwoord. Om deze portemonnee te herstellen heeft u de herstel zin en het wachtwoord nodig.","This transaction amount is too small compared to current Bitcoin network fees. Spending these funds will need a Bitcoin network fee cost comparable to the funds itself.":"Het bedrag van deze transactie is te klein vergeleken met huidige Bitcoin netwerk transactiekosten. Bij dit bedrag betaald u transactiekosten vergelijkbaar met het bedrag zelf.","This transaction could take a long time to confirm or could be dropped due to the low fees set by the sender":"Deze transactie zou lang kunnen wachten op een bevestiging of kan worden geschrapt vanwege de lage transactiekosten die de verzender heeft gekozen","This wallet is not registered at the given Bitcore Wallet Service (BWS). You can recreate it from the local information.":"Deze portemonnee is niet geregistreerd bij de opgegeven Bitcore Wallet Service (BWS). U kunt deze opnieuw aanmaken vanuit de lokale informatie.","Timeline":"Tijdlijn","To":"Naar","To get started, buy bitcoin or share your address. You can receive bitcoin from any wallet or service.":"Om aan de slag te gaan, koop bitcoin of deel uw adres. U kunt bitcoin ontvangen van elke portemonnee of dienst.","To get started, you'll need to create a bitcoin wallet and get some bitcoin.":"Om aan de slag te gaan zult u een bitcoin portemonnee moeten aanmaken en wat bitcoin moeten verkrijgen.","To {{reason}} you must first add your BitPay account - {{email}}":"Om {{reason}} zult u eerst uw BitPay account moeten toevoegen - {{email}}","Top up in progress...":"Bezig met opladen...","Top up {{amountStr}} to debit card ({{cardLastNumber}})":"Vul debet kaart ({{cardLastNumber}}) aan met {{amountStr}}","Total":"Totaal","Total Locked Balance":"Totaal Vergrendeld Saldo","Total number of copayers":"Totaal aantal copayers","Total wallet inputs":"Totaal portemonnee ontvangsten","Touch ID Failed":"Touch ID Mislukt","Transaction":"Transactie","Transaction Created":"Transactie Aangemaakt","Transaction History":"Transactiehistorie","Transaction already broadcasted":"Transactie reeds verzonden","Transaction has not been created":"Transactie is niet aangemaakt","Transaction initiated":"Transactie gestart","Transaction not available at this time":"Transactie momenteel niet beschikbaar","Transaction not found":"Transactie niet gevonden","Transactions without fee are not supported.":"Transacties zonder transactiekosten worden niet ondersteund.","Transfer to":"Overmaken naar","Transfer to Wallet":"Overmaken naar Portemonnee","Try again in {{expires}}":"Probeer het nogmaals over {{expires}}","Turn bitcoin into dollars, swipe anywhere Visa<sup></sup> is accepted.":"Zet bitcoin om in dollars, betaal overal waar Visa<sup>&reg;</sup> wordt geaccepteerd.","Type the Recovery Phrase (usually 12 words)":"Vul de Herstel Zin in (meestal 12 woorden)","Uh oh...":"Oh oh...","Unconfirmed":"Onbevestigd","Unsent transactions":"Niet-verzonden transacties","Unused Addresses":"Ongebruikte Adressen","Unused Addresses Limit":"Ongebruikte Adressen Limiet","Update Available":"Update Beschikbaar","Updating pending proposals. Please stand by":"Bestedingsvoorstellen in behandeling bijwerken. Een moment geduld","Updating transaction history. Please stand by.":"Transactie historie bijwerken. Een moment geduld.","Updating... Please stand by":"Bijwerken... Een moment geduld","Urgent":"Spoed","Use Unconfirmed Funds":"Onbevestigd Saldo Gebruiken","Validating recovery phrase...":"Herstel zin valideren...","Verify your identity":"Verifieer uw identiteit","Version":"Versie","View":"Weergeven","View All Addresses":"Toon Alle Adressen","View Terms of Service":"Toon Algemene Voorwaarden","View Transaction on Insight":"Bekijk Transactie op Insight","View Update":"Update Bekijken","View on blockchain":"Bekijk op blockchain","Visit mercadolivre.com.br &rarr;":"Bezoek mercadolivre.com.br &rarr;","WARNING: Key derivation is not working on this device/wallet. Actions cannot be performed on this wallet.":"WAARSCHUWING: Sleutel derivatie werkt op dit moment niet op dit apparaat/deze portemonnee. Er kunnen geen acties worden uitgevoerd met deze portemonnee.","WARNING: Not including the private key allows to check the wallet balance, transaction history, and create spend proposals from the export. However, does not allow to approve (sign) proposals, so <b>funds will not be accessible from the export</b>.":"WAARSCHUWING: De priv sleutel niet toevoegen maakt het wel mogelijk om het saldo en de transactiehistorie in te zien, en bestedingsvoorstellen aan te maken vanuit de export. Dit maakt het echter niet mogelijk om bestedingsvoorstellen goed te keuren (ondertekeken), dus <b>saldo is niet toegankelijk vanuit de export</b>.","WARNING: The private key of this wallet is not available. The export allows to check the wallet balance, transaction history, and create spend proposals from the export. However, does not allow to approve (sign) proposals, so <b>funds will not be accessible from the export</b>.":"WAARSCHUWING: De priv sleutel van deze portemonnee is niet beschikbaar. De export maakt het wel mogelijk om het saldo en de transactiehistorie in te zien, en bestedingsvoorstellen aan te maken. De export maakt het echter niet mogelijk om bestedingsvoorstellen goed te keuren (ondertekeken), dus <b>het saldo is niet toegankelijk vanuit de export</b>.","WARNING: UNTRUSTED CERTIFICATE":"WAARSCHUWING: NIET-VERTROUWD CERTIFICAAT","Waiting for Ledger...":"Wachten op Ledger...","Waiting for Trezor...":"Wachten op Trezor...","Waiting for copayers":"Wachten op copayers","Waiting...":"Wachten...","Wallet Addresses":"Adressen Portemonnee","Wallet Color":"Kleur Portemonnee","Wallet Configuration (m-n)":"Configuratie Portemonnee (m-n)","Wallet Created":"Portemonnee Aangemaakt","Wallet Id":"Portemonnee Id","Wallet Information":"Portemonnee Informatie","Wallet Inputs":"Ontvangsten Portemonnee","Wallet Invitation":"Portemonnee Uitnodiging","Wallet Key":"Sleutel Portemonnee","Wallet Name":"Naam Portemonnee","Wallet Name (at creation)":"Naam Portemonnee (ten tijde van aanmaken)","Wallet Network":"Portemonnee Netwerk","Wallet Recovery Phrase":"Portemonnee Herstel Zin","Wallet Recovery Phrase is invalid":"Portemonnee Herstel Zin is ongeldig","Wallet Service URL":"Portemonnee Service URL","Wallet Settings":"Portemonnee Instellingen","Wallet Type":"Portemonnee Type","Wallet already exists":"Portemonnee bestaat al","Wallet already in {{appName}}":"Portemonnee reeds in {{appName}}","Wallet created":"Portemonnee aangemaakt","Wallet incomplete and broken":"Portemonnee onvolledig en onwerkzaam","Wallet is full":"Portemonnee is vol","Wallet is locked":"Portemonnee is vergrendeld","Wallet is not complete":"Portemonnee is niet volledig","Wallet name":"Naam portemonnee","Wallet needs backup":"Portemonnee vereist backup","Wallet not backed up":"Nog geen backup van de portemonnee gemaakt","Wallet not found":"Portemonnee niet gevonden","Wallet not registered":"Portemonnee niet geregistreerd","Wallet not registered at the wallet service. Recreate it from \"Create Wallet\" using \"Advanced Options\" to set your recovery phrase":"Portemonnee niet geregistreerd bij de wallet service. Maak deze opnieuw aan vanuit \"Portemonnee Aanmaken\" en maak gebruik van \"Geavanceerde Opties\" om uw herstel zin in te voeren","Wallet recovery phrase not available.":"Portemonnee herstel zin niet beschikbaar.","Wallet service not found":"Wallet service niet gevonden","Wallets":"Portemonnees","Wallets & Integrations":"Portemonnees & Integratie","Warning!":"Waarschuwing!","Warning: this transaction has unconfirmed inputs":"Waarschuwing: deze transactie heeft onbevestigde ontvangsten","Watch out!":"Pas op!","We'd love to do better.":"Wij doen het graag nog beter.","We'll confirm on the next screen.":"We bevestigen dit op het volgende scherm.","We're always looking for ways to improve {{appName}}.":"Wij zoeken altijd naar manieren om {{appName}} te verbeteren.","We're always looking for ways to improve {{appName}}. How could we improve your experience?":"Wij zoeken altijd naar manieren om {{appName}} te verbeteren. Hoe kunnen wij uw ervaring verbeteren?","Website":"Website","Were always looking for translation contributions! You can make corrections or help to make this app available in your native language by joining our community on Crowdin.":"Wij zijn altijd op zoek naar hulp met vertalingen! U kunt correcties aanbrengen of helpen deze app beschikbaar te maken in uw eigen taal door deel te nemen aan onze gemeenschap op Crowdin.","What do you call this wallet?":"Hoe noemt u deze portemonnee?","When this wallet was created, it was called {{walletName}}. You can change the name displayed on this device below.":"Ten tijde van aanmaken kreeg deze portemonnee de naam &ldquo;{{walletName}}&rdquo;. U kunt de naam wijzigen die op dit apparaat weergegeven wordt.","Where would you like to receive email notifications about payments?":"Waar wilt u email meldingen ontvangen over betalingen?","Why?":"Waarom?","Would you be willing to rate {{appName}} in the app store?":"Zou u bereid zijn om {{appName}} te beoordelen in de app store?","Would you like to receive push notifications about payments?":"Wilt u push meldingen ontvangen over betalingen?","Wrong number of recovery words:":"Onjuist aantal herstel woorden:","Wrong spending password":"Onjuist bestedingswachtwoord","Yes":"Ja","Yes, skip":"Ja, overslaan","You can create a backup later from your wallet settings.":"U kunt later een backup maken vanuit uw portemonnee instellingen.","You can make contributions by signing up on our Crowdin community translation website. Were looking forward to hearing from you!":"U kunt een bijdrage leveren door u aan te melden bij onze Crowdin gemeenschap vertalings website. Wij kijken er naar uit om van u te horen!","You can scan bitcoin addresses, payment requests, paper wallets, and more.":"U kunt bitcoin adressen scannen, betalingsverzoeken, papieren portemonnees, en meer.","You can see the latest developments and contribute to this open source app by visiting our project on GitHub.":"U kunt de laatste ontwikkelingen volgen en bijdragen aan deze open source app door onze project pagina te bezoeken op GitHub.","You can spend bitcoin at millions of websites and stores worldwide.":"U kunt met bitcoin betalen bij miljoenen websites en winkels over de hele wereld.","You can still export it from Advanced &gt; Export.":"U kunt deze nog steeds exporteren vanuit Geavanceerd &gt; Exporteren.","You can trade it for other currencies like US Dollars, Euros, or Pounds.":"U kunt het inwisselen voor valuta's zoals de Amerikaanse Dollar, de Euro, of Ponden.","You control your bitcoin.":"U heeft de controle over uw bitcoin.","You should not set a fee higher than {{maxFeeRecommended}} satoshis/byte.":"Het is af te raden transactiekosten te kiezen hoger dan {{maxFeeRecommended}} satoshi's/byte.","You will need to log back for fill in your BitPay Card.":"U zult opnieuw moeten inloggen om uw BitPay Kaart op te laden.","You'll receive email notifications about payments sent and received from your wallets.":"U zult email meldingen ontvangen over verzonden en ontvangen betalingen van uw portemonnee.","Your BitPay Card is ready. Add funds to your card to start using it at stores and ATMs worldwide.":"Uw BitPay Kaart is gereed. Voeg saldo toe aan uw kaart om deze te kunnen gebruiken in winkels en pinautomaten over de hele wereld.","Your Gift Cards":"Uw Cadeaubonnen","Your bitcoin wallet is backed up!":"Er is een backup gemaakt van uw bitcoin portemonnee!","Your bitcoin wallet is ready!":"Uw bitcoin portemonnee is gereed!","Your fee is lower than recommended.":"Uw gekozen transactiekosten zijn lager dan aangeraden.","Your ideas, feedback, or comments":"Uw ideen, feedback of opmerkingen","Your name":"Uw naam","Your nickname":"Uw bijnaam","Your password":"Uw wachtwoord","Your purchase could not be completed":"Uw aankoop kon niet worden voltooid","Your purchase was added to the list of pending":"Uw aankoop is op de in-behandeling lijst gezet","Your wallet is never saved to cloud storage or standard device backups.":"Uw portemonnee wordt nooit opgeslagen in de cloud of in standaard apparaat backups.","Your wallet key will be encrypted. The Spending Password cannot be recovered. Be sure to write it down.":"Uw priv sleutel wordt versleuteld. Het Bestedingswachtwoord kan niet worden achterhaald, schrijf deze zorgvuldig op.","[Balance Hidden]":"[Saldo Verborgen]","add your BitPay Visa card(s)":"voeg uw BitPay Visa kaart(en) toe","locked by pending payments":"vergrendeld door betalingen in behandeling","me":"ik","name@example.com":"naam@voorbeeld.nl","preparing...":"voorbereiden...","{{amountStr}} for Amazon.com Gift Card":"{{amountStr}} voor Amazon.com Cadeaubon","{{amountStr}} for Mercado Livre Brazil Gift Card":"{{amountStr}} voor Mercado Livre Brazil Cadeaubon","{{appName}} depends on Bitcore Wallet Service (BWS) for blockchain information, networking and Copayer synchronization. The default configuration points to https://bws.bitpay.com (BitPay's public BWS instance).":"{{appName}} is afhankelijk van Bitcore Wallet Service (BWS) voor blockchain informatie, netwerk verbinding en Copayer synchronisatie. De standaard instelling wijst naar https://bws.bitpay.com (BitPay's openbare BWS instance).","{{fee}} will be deducted for bitcoin networking fees.":"{{fee}} wordt in mindering gebracht voor bitcoin transactiekosten.","{{tx.txp[wallet.id].feeRatePerStr}}  of the sending amount":"{{tx.txp[wallet.id].feeRatePerStr}} van het te verzenden bedrag","{{updatingTxHistoryProgress}} transactions downloaded":"{{updatingTxHistoryProgress}} transacties gedownload","{{wallet.m}}-of-{{wallet.n}}":"{{wallet.m}}-van-{{wallet.n}}"});
    gettextCatalog.setStrings('pl', {"(Trusted)":"(Zaufany)","(possible double spend)":"(moliwa podwjna wypata)","* A payment proposal can be deleted if 1) you are the creator, and no other copayer has signed, or 2) 24 hours have passed since the proposal was created.":"* Wniosek wypaty moe by usunity jeli: 1) Po utworzeniu nie zatwierdzi go aden inny wspwaciciel portfela lub 2) miny 24 godziny od kiedy wniosek zosta utworzony.","- {{btx.feeRateStr}} of the transaction":"{{btx.feeRateStr}} transakcji","- {{tx.feeRateStr}} of the transaction":"{{tx.feeRateStr}} transakcji","5-star ratings help us get {{appName}} into more hands, and more users means more resources can be committed to the app!":"5-gwiazdkowa ocena pozwoli na wzrost popularnoci {{appName}}, a wiksza ilo uytkownikw da nam do dyspozycji wicej rodkw na rozwj aplikacji!","A member of the team will review your feedback as soon as possible.":"Czonek zespou zweryfikuje twoj opini tak szybko, jak to moliwe.","A total of {{amountAboveMaxSizeStr}} were excluded. The maximum size allowed for a transaction was exceeded.":"Uwaga: cznie kwota {{amountAboveMaxSizeStr}} zostaa wyczona. Zosta przekroczony maksymalny rozmiar dozwolony dla transakcji.","A total of {{amountBelowFeeStr}} were excluded. These funds come from UTXOs smaller than the network fee provided.":"Uwaga: cznie kwota {{amountBelowFeeStr}} zostaa wyczona. rodki te pochodz z UTXOs mniejszych ni gwarantowana prowizja sieci.","About":"O programie","Accepted":"Zatwierdzono","Account":"Konto","Account Number":"Numer konta","Accounts":"Konta","Activity":"Transakcje","Add Account":"Dodaj konto","Add BitPay Account?":"Doda konto BitPay?","Add Contact":"Dodaj kontakt","Add Funds":"Dodaj rodki","Add Memo":"Dodaj notatk","Add a password":"Dodaj haso","Add account":"Dodaj konto","Add an optional password to secure the recovery phrase":"Dodaj opcjonalnie haso w celu zabezpieczenia kluczowej frazy","Add as a contact":"Dodaj jako kontakt","Add description":"Dodaj opis","Add funds":"Dodaj fundusze","Add this BitPay account ({{email}})?":"Doda to konto BitPay ({{email}})?","Add wallet":"Dodaj portfel","Address":"Adres","Address Book":"Ksika adresowa","Address Type":"Rodzaj adresu","Addresses With Balance":"Adresy z funduszami","Advanced":"Zaawansowane","Advanced Settings":"Ustawienia zaawansowane","All":"Wszystko","All Addresses":"Wszystkie adresy","All of your bitcoin wallet balance may not be available for immediate spending.":"Wszystkie salda portfela bitcoin mog nie by dostpne do natychmiastowego wydania.","All signing devices must be added to this multisig wallet before bitcoin addresses can be created.":"Wszystkie podpisane urzdzenia musz zosta dodane do tego portfela przed utworzeniem adresw bitcoin.","Allow Camera Access":"Zezwalaj na dostp do kamery","Allow notifications":"Pozwl na otrzymywanie powiadomie","Almost done! Let's review.":"Prawie gotowe! Dokonajmy przegldu.","Alternative Currency":"Alternatywna waluta","Amazon.com is not available at this moment. Please try back later.":"Amazon.com jest aktualnie niedostpny. Sprbuj pniej.","Amount":"Kwota","Amount below minimum allowed":"Kwota poniej minimum dozwolona","Amount too big":"Zbyt dua kwota","Amount too low to spend":"Zbyt niska kwota do wysania","An update to this app is available. For your security, please update to the latest version.":"Dostpna jest aktualizacja aplikacji. Ze wzgldw bezpieczestwa naley zaktualizowa do najnowszej wersji.","Anyone with your backup phrase can access or spend your bitcoin.":"Kady, kto ma Twoj kluczow fraz moe uzyska dostp lub wyda Twoje bitcoiny.","Are you being watched?":"Czy jeste obserwowany?","Are you being watched? Anyone with your recovery phrase can access or spend your bitcoin.":"Czy jeste obserwowany? Kady, kto zdobdzie twoj kluczow fraz moe uzyska dostp do portfela i wyda twoje bitcoiny.","Are you sure you want to cancel and delete this wallet?":"Czy na pewno chcesz usun ten portfel?","Are you sure you want to delete this contact?":"Czy na pewno chcesz usun ten kontakt?","Are you sure you want to delete this wallet?":"Czy na pewno chcesz usun ten portfel?","Are you sure you want to reject this transaction?":"Czy na pewno chcesz odrzuci t transakcj?","Are you sure you want to remove this transaction?":"Czy na pewno chcesz usun t transakcj?","Are you sure you want to skip it?":"Czy na pewno chcesz pomin?","Are you sure you would like to log out of your BitPay Card account?":"Czy na pewno chcesz si wylogowa z konta BitPay Card?","Are you sure you would like to remove your BitPay Card ({{lastFourDigits}}) from this device?":"Czy na pewno chcesz usun kart BitPay ({{lastFourDigits}}) z tego urzdzenia?","Auditable":"Weryfikowalny","Available":"Dostpne","Available Balance":"Dostpne saldo","Average confirmation time":"Spodziewany czas potwierdzania","BIP32 path for address derivation":"BIP32 cieka dla adresu derywacji","Backup":"Kopia zapasowa","Backup Needed":"Potrzebna kopia zapasowa","Backup all livenet wallets before using this function":"Zrb kopi zapasow wszystkich swoich portfeli przed uyciem tej funkcji","Backup needed":"Potrzebna kopia zapasowa","Backup now":"Utwrz kopi zapasow teraz","Backup wallet":"Kopia zapasowa portfela","Backup your wallet before using this function":"Zrb kopi zapasow portfela przed uyciem tej funkcji","Bad wallet invitation":"Nieprawidowe zaproszenie","Balance By Address":"Saldo wg adresu","Be sure to store your recovery phrase in a secure place. If this app is deleted, your money cannot be recovered without it.":"Pamitaj aby przechowywa swoj kluczow fraz w bezpiecznym miejscu. Jeli ta aplikacja zostanie usunita, nie bdziesz mg bez niej odzyska swoich pienidzy.","BitPay Visa Cards":"Karty BitPay Visa&reg;","Bitcoin Address":"Adres bitcoin","Bitcoin Network Fee Policy":"Polityka prowizji sieci bitcoin","Bitcoin is a currency.":"Bitcoin jest walut.","Bitcoin is different  it cannot be safely held with a bank or web service.":"Bitcoin jest inny &ndash; nie moe by bezpiecznie przechowywany w banku lub usudze internetowej.","Bitcoin is secure,<br>digital money.":"Bitcoin jest bezpieczny, <br>cyfrowe pienidze.","Bitcoin transactions include a fee collected by miners on the network.":"Transakcje Bitcoin obejmuj prowizj pobieran przez grnikw w sieci.","Bought {{amountUnitStr}}":"Kupiono {{amountUnitStr}}","Broadcast Payment":"Przeka patno","Broadcasted":"Nadawane","Broadcasting transaction":"Przekazywanie transakcji","Browser unsupported":"Przegldarka nieobsugiwana","Buy":"Kup","Buy &amp; Sell Bitcoin":"Kup &amp; sprzedaj bitcoiny","Buy Bitcoin":"Kup bitcoiny","Buy from":"Kup od","Buying Bitcoin...":"Zakup bitcoinw...","Calculating fee":"Obliczanie prowizji","Cancel":"Anuluj","Cancel invitation":"Anuluj zaproszenie","Cannot Create Wallet":"Nie mona utworzy portfela","Cannot join the same wallet more that once":"Nie mona doczy tego samego portfela wicej ni raz","Cards":"Karty","Certified by":"Certyfikowane przez","Check installation and retry.":"Sprawd instalacj i ponw prb.","Choose a backup file from your computer":"Wybierz plik kopii zapasowej z komputera","Choose your destination wallet":"Wybierz swj portfel docelowy","Choose your source wallet":"Wybierz swj portfel rdowy","Clear":"Wyczy","Clear cache":"Wyczy pami podrczn","Close":"Zamknij","Color":"Kolor","Commit hash":"Zatwierdzony hash","Complete the backup process to use this option":"Zakocz proces tworzenia kopii zapasowej, aby uy tej opcji","Completed":"Zakoczono","Confirm":"Potwierd","Confirm &amp; Finish":"Potwierd &amp; zakoczenie","Confirm purchase":"Potwierd zakup","Confirm your PIN":"Potwierd kod PIN","Confirm your new spending password":"Potwierd nowe haso wypat","Confirmations":"Potwierdzenia","Confirming":"Potwierdzajcy","Connect my BitPay Card":"Podcz kart BitPay","Connecting to Coinbase...":"czenie z Coinbase...","Connecting to Glidera...":"czenie z Gildera...","Connection reset by peer":"Poczenie zostao zresetowane","Contacts":"Kontakty","Continue":"Dalej","Contribute Translations":"Wkad do tumaczenia","Copayer already in this wallet":"Uytkownik jest ju w tym portfelu","Copayer already voted on this spend proposal":"Uytkownik gosowa ju za tym wnioskiem wypaty","Copayer data mismatch":"Niezgodno danych wspwaciciela portfela","Copayer joined":"Wspwaciciel doczy","Copayer {{$index}}":"Wspwaciciele {{$index}}","Copied to clipboard":"Skopiowano do schowka","Copy this text as it is to a safe place (notepad or email)":"Skopiuj ten tekst w bezpiecznym miejscu (notatnik lub e-mail)","Copy to clipboard":"Skopiuj do schowka","Could not access the wallet at the server. Please check:":"Nie mona uzyska dostpu do portfela na serwerze. Prosz sprawdzi:","Could not access to Amazon.com":"Nie moe uzyska dostpu do Amazon.com","Could not access wallet":"Nie mona uzyska dostpu do portfela","Could not add message to imported wallet without shared encrypting key":"Nie mona doda wiadomo do importowanego portfela bez udostpnionego klucza szyfrowania","Could not broadcast payment":"Wypata nie moe zosta wysana","Could not build transaction":"Nie udao si utworzy transakcji","Could not create address":"Nie mona utworzy adresu","Could not create the invoice":"Nie mona utworzy faktury","Could not create transaction":"Nie mona utworzy transakcji","Could not create using the specified extended private key":"Nie mona utworzy przy uyciu okrelonego rozszerzonego klucza prywatnego","Could not create using the specified extended public key":"Nie mona utworzy przy uyciu okrelonego rozszerzonego klucza publicznego","Could not create: Invalid wallet recovery phrase":"Nie mona utworzy: niepoprawna kluczowa fraza","Could not decrypt file, check your password":"Nie mona odszyfrowa pliku, sprawd haso","Could not delete payment proposal":"Nie mona usun wniosku wypaty","Could not get dynamic fee":"Nie mona pobra dynamicznej prowizji","Could not get dynamic fee for level: {{feeLevel}}":"Nie mona uzyska dynamicznej prowizji dla poziomu: {{feeLevel}}","Could not get fee levels":"Nie mona uzyska poziomw prowizji","Could not get the invoice":"Nie mona pobra faktury","Could not get transactions":"Nie mona pobra transakcji","Could not import":"Nie mona zaimportowa","Could not import. Check input file and spending password":"Nie mona zaimportowa. Sprawd plik wejciowy i haso","Could not join wallet":"Nie mona doczy portfela","Could not reject payment":"Wypata nie moe by odrzucona","Could not remove account":"Nie mona usun konta","Could not remove card":"Nie mona usun karty","Could not save preferences on the server":"Nie mona zapisa ustawie na serwerze","Could not send payment":"Wypata nie moe zosta wysana","Could not send transaction":"Nie mona wysa transakcji","Could not update transaction history":"Nie mona zaktualizowa historii transakcji","Could not update wallet":"Nie mona zaktualizowa portfela","Create Personal Wallet":"Utwrz osobisty portfel","Create Shared Wallet":"Utwrz wspdzielony portfel","Create bitcoin wallet":"Utwrz portfel bitcoin","Create new wallet":"Utwrz nowy portfel","Create shared wallet":"Utwrz wspdzielony portfel","Create {{formData.requiredCopayers}}-of-{{formData.totalCopayers}} wallet":"Utwrz portfel {{formData.requiredCopayers}} z {{formData.totalCopayers}}","Created by":"Utworzony przez","Creating Wallet...":"Tworzenie portfela...","Creating transaction":"Tworzenie transakcji","Current fee rate for this policy":"Aktualna stawka prowizji dla tej polityki","Custom":"Niestandardowy","Custom Amount":"Kwota wasna","Custom Fee":"Niestandardowa Prowizja","Date":"Data","Delete":"Usu","Delete Payment Proposal":"Usu wniosek wypaty","Delete Wallet":"Usu portfel","Delete it and create a new one":"Usu i utwrz nowy portfel","Deleting Wallet...":"Usuwanie portfela...","Deleting payment proposal":"Usu propozycj patnoci","Derivation Path":"cieka derywacji","Derivation Strategy":"Strategia derywacji","Details":"Szczegy","Disabled":"Wycz","Do it later":"Zrb to pniej","Do not include private key":"Nie uwzgldniaj klucza prywatnego","Don't see your language on Crowdin? Contact the Owner on Crowdin! We'd love to support your language.":"Nie widzisz swojego jzyka na Crowdin? Skontaktuj si z wacicielem projektu, poniewa bardzo chcielibymy, wspiera twj jzyk.","Download":"Pobierz","Each bitcoin wallet can generate billions of addresses from your 12-word backup. A new address is automatically generated and shown each time you receive a payment.":"Kady portfel bitcoin moe wygenerowa miliardy adresw z twojej 12-wyrazowej kopii zapasowej. Nowy adres jest automatycznie generowany i pokazany za kadym razem, kiedy otrzymasz patno.","Economy":"Ekonomiczna","Edit":"Edytuj","Email":"E-mail","Email Address":"Adres e-mail","Empty addresses limit reached. New addresses cannot be generated.":"Puste adresy osigny limit. Nowe adresy nie mog by generowane.","Enable camera access in your device settings to get started.":"Udostpnij kamer w ustawieniach urzdzenia, aby rozpocz prac.","Enable email notifications":"Wcz powiadomienia e-mail","Enable push notifications":"Wcz powiadomienia","Enable the camera to get started.":"Wcz kamer aby rozpocz.","Enter Spending Password":"Wprowad haso wypaty","Enter Two Factor for your BitPay account":"Wprowad podwjne uwierzytelnienie swojego konta BitPay","Enter custom fee":"Wprowad niestandardow kwot prowizji","Enter new spending password":"Wprowad nowe haso wypaty","Enter the recovery phrase (BIP39)":"Wprowad kluczow fraz (BIP39)","Enter your email":"Wpisz swj adres e-mail","Enter your password":"Wprowad haso","Error":"Bd","Error at confirm":"Bd w potwierdzeniu","Error creating gift card":"Bd przy tworzeniu karty upominkowej","Error creating wallet":"Bd podczas tworzenia portfela","Error getting SendMax information":"Wystpi bd podczas uzyskiwania informacji SendMax","Error in Payment Protocol":"Bd w protokole patnoci","Error pairing BitPay Account":"Bd parowania konta Bitpay","Error scanning funds:":"Bd skanowania rodkw:","Error sweeping wallet:":"Bd oprniania portfela:","Error updating Debit Cards":"Bd aktualizacji kart debetowych","Exceeded daily limit of $500 per user":"Dzienny limit 500$ na uytkownika zosta przekroczony","Expired":"Wygas","Expires":"Wygasa","Export Wallet":"Eksport portfela","Export to file":"Eksportuj do pliku","Export wallet":"Eksportuj portfel","Exporting via QR not supported for this wallet":"Dla tego portfela nie jest obsugiwany eksport za pomoc kodu QR","Extended Public Keys":"Rozszerzone klucze publiczne","Failed to export":"Nie udao si wyeksportowa","Family vacation funds":"rodki na rodzinne wakacje","Fee":"Prowizja","Fee level":"Poziom opaty","Fee level is not defined":"Poziom opaty nie jest zdefiniowany","Fee:":"Prowizja:","Feedback could not be submitted. Please try again later.":"Twj komentarz nie moe zosta wysany. Sprbuj ponownie pniej.","Fetching BitPay Account...":"Odzyskiwanie konta BitPay...","Fetching payment information":"Pobieranie informacji o patnoci","File/Text":"Plik/Tekst","Finger Scan Failed":"Skanowanie odcisku nie powiodo si","Finish":"Zakocz","For audit purposes":"Do celw audytu","From":"Z","From BitPay account":"Z konta BitPay","From Hardware Wallet":"Z portfela sprztowego","From the destination device, go to Add wallet &gt; Import wallet and scan this QR code":"Z urzdzenia docelowego, przejd do Dodaj portfel &gt; Import portfela i Zeskanuj ten kod QR","Funds are locked by pending spend proposals":"rodki s zablokowane przez rozpatrywane wniosku wypaty","Funds found:":"Znaleziono rodki:","Funds to be added":"rodki, ktre zostan dodane","Funds transferred":"rodki przelewane","Funds were added to debit card":"Fundusze zostay dodane do karty debetowej","Funds will be transferred to":"rodki bd przekazane do","Generate new address":"Generuj nowy adres","Generating .csv file...":"Generowanie pliku csv...","Generating new address...":"Generowanie nowego adresu...","Get local cash anywhere you go, from any Visa<sup></sup> compatible ATM. ATM bank fees may apply.":"Wypa pienidze gdziekolwiek jeste, z dowolnego bankomatu honorujcego karty Visa<sup>&reg;</sup>. Od tej transakcji bank moe pobra prowizj.","Get news and updates from BitPay":"Otrzymywanie wiadomoci i aktualizacji z BitPay","Get started":"Zacznij","Get started by adding your first one.":"Zacznij dodajc swj pierwszy kontakt.","Getting fee levels...":"Uzyskiwanie informacji o prowizji...","Gift card":"Karta podarunkowa","Gift card expired":"Karta upominkowa wygasa","Gift card generated and ready to use.":"Karta podarunkowa wygenerowana i gotowa do uycia.","Go Back":"Powrt","Go back":"Powrt","Got it":"Rozumiem","Hardware Wallet":"Portfel sprztowy","Hardware not connected.":"Sprzt nie podczony.","Hardware wallet":"Portfel sprztowy","Help & Support":"Centrum pomocy","Help and support information is available at the website.":"Informacja o pomocy i wsparciu technicznym jest dostpna na stronie internetowej.","Hide":"Ukryj","Hide Balance":"Ukryj rodki","Hide Next Steps Card":"Ukryj nastpne kroki karty","Hide advanced options":"Ukryj opcje zaawansowane","Home":"Strona gwna","How could we improve your experience?":"Co moglibymy jeszcze wedug Ciebie poprawi?","How do you like {{appName}}?":"Jak Ci si podoba {{appName}}?","I don't like it":"Nie podoba mi si","I have read, understood, and agree to the <a ng-click=\"openTerms()\" translate=\"\">Terms of Use</a>.":"Przeczytaem, zrozumiaem i wyraam zgod na <a ng-click=\"openTerms()\" translate=\"\"> warunki uytkowania</a>.","I have read, understood, and agree with the Terms of use.":"Przeczytaem, zrozumiaem i zgadzam si z Warunkami uytkowania.","I have written it down":"Zapisaem to","I like the app":"Lubi aplikacj","I think this app is terrible.":"Myl, e ta aplikacja jest straszna.","I understand":"Rozumiem","I understand that if this app is moved to another device or deleted, my bitcoin can only be recovered with the backup phrase.":"Rozumiem, e jeli aplikacja zostanie przeniesiona na inne urzdzenie, lub usunita moje bitcoiny mog zosta odzyskane tylko przy uyciu kluczowej frazy.","I understand that my funds are held securely on this device, not by a company.":"Rozumiem, e moje rodki s bezpieczne na tym urzdzeniu i nie znajduj si w posiadaniu spki.","I've written it down":"Zapisaem to","If enabled, all sensitive information (private key and recovery phrase) and actions (spending and exporting) associated with this wallet will be protected.":"Jeli opcja jest wczona, wszystkie poufne informacje (klucz prywatny i kluczowa fraza) oraz operacje (wydatki i eksport) zwizane z tym portfelem bd chronione.","If enabled, the Recent Transactions card - a list of transactions occuring across all wallets - will appear in the Home tab.":"Jeli ta opcja jest wczona, na ekranie gwnym pojawi si lista wszystkich transakcji z portfela.","If enabled, wallets will also try to spend unconfirmed funds. This option may cause transaction delays.":"Jeli opcja jest wczona, portfele bd rwnie stara si wydawa niepotwierdzone rodki. Moe to prowadzi do opnie transakcji.","If this device is replaced or this app is deleted, neither you nor BitPay can recover your funds without a backup.":"Jeli to urzdzenie zostanie wymienione lub jeli aplikacja zostanie usunita, ani ty, ani BitPay nie bdzie mg odzyska rodkw bez kopii zapasowej.","If you have additional feedback, please let us know by tapping the \"Send feedback\" option in the Settings tab.":"Jeli masz dodatkowe uwagi, prosimy o poinformowanie nas poprzez nacinicie przycisku \"Wylij zgoszenie\" w zakadce Ustawienia.","If you take a screenshot, your backup may be viewed by other apps. You can make a safe backup with physical paper and a pen.":"Jeli zrobisz zrzut ekranu, twoja kopia zapasowa moe by widziana przez inne aplikacje. Najbezpieczniejsza metoda utworzenia kopii zapasowej to dugopis i papier.","Import":"Importuj","Import Wallet":"Importuj portfel","Import backup":"Importuj kopi zapasow","Import wallet":"Importuj portfel","Importing Wallet...":"Importowanie portfela...","In order to verify your wallet backup, please type your password.":"W celu weryfikacji kopii zapasowej portfela wpisz swoje haso.","Incomplete":"Nie wszyscy wspwaciciele doczyli","Incomplete wallet":"Nie wszyscy wspwaciciele doczyli","Incorrect PIN, try again.":"Nieprawidowy kod PIN. Sprbuj ponownie.","Incorrect code format":"Niepoprawny format kodu","Incorrect network address":"Nieprawidowy adres","Insufficient funds":"Nie ma wystarczajcej iloci rodkw","Insufficient funds for fee":"Niewystarczajce rodki na prowizj","Invalid":"Nieprawidowy","Invalid URL":"Nieprawidowy adres URL","Invalid account number":"Nieprawidowy numer konta","Invalid address":"Nieprawidowy adres","Invalid data":"Nieprawidowe dane","Invalid derivation path":"Nieprawidowa cieka derywacji","Invitation to share a {{appName}} Wallet":"Zaproszenie do wspdzielenia portfela {{appName}}","Is there anything we could do better?":"Czy jest co, co moemy poprawi?","Is this correct?":"Czy dane s poprawne?","Is this email address correct?":"Czy ten adres e-mail jest poprawny?","It's a good idea to avoid reusing addresses - this both protects your privacy and keeps your bitcoins secure against hypothetical attacks by quantum computers.":"To dobry pomys, aby unikn ponownego wykorzystywania adresw - to chroni Twoj prywatno i zabezpiecza Twoje bitcoiny przed hipotetycznymi atakami przez komputery kwantowe.","It's important that you write your backup phrase down correctly. If something happens to your wallet, you'll need this backup to recover your money. Please review your backup and try again.":"Wane, aby prawidowo zapisa kluczow fraz. Jeli co stanie si z Twoim portfelem, bdzie ona potrzebna, aby mg odzyska pienidze. Sprawd dokadnie zapis i sprbuj ponownie.","Join":"Docz","Join my {{appName}} Wallet. Here is the invitation code: {{secret}} You can download {{appName}} for your phone or desktop at {{appUrl}}":"Docz do mojego portfela {{appName}}. Kod zaproszenia: {{secret}}. Wersj desktopow lub aplikacj na telefon mona pobra z {{appUrl}}","Join shared wallet":"Docz do portfela","Joining Wallet...":"Doczanie do portfela...","Just scan the code to pay.":"Zeskanuj kod, aby zapaci.","Key already associated with an existing wallet":"Klucz jest ju powizany z istniejcym portfelem","Language":"Jzyk","Last Month":"Zeszy miesic","Let's verify your backup phrase.":"Sprawd swoj kluczow fraz.","Loading addresses...":"adowanie adresw...","Loading transaction info...":"adowanie informacji o transakcji...","Lock App":"Blokada aplikacji","Lock by Fingerprint":"Blokada przez odcisk palca","Lock by PIN":"Blokada przez PIN","Locked":"Zablokowane","Locktime in effect. Please wait to create a new spend proposal":"Skuteczna blokada. Prosz czeka, aby utworzy nowy wniosek wypaty","Locktime in effect. Please wait to remove this spend proposal":"Skuteczna blokada. Prosz czeka, aby usun wniosek wypaty","Log out":"Wyloguj si","Low fees":"Niskie opaty","Makes sense":"Brzmi sensownie","Matches:":"Dopasowania:","Me":"Ja","Meh - it's alright":"Spoko - moe by","Memo":"Notatka","Merchant Message":"Wiadomo handlowa","Missing parameter":"Brak parametru","Missing private keys to sign":"Brak kluczy prywatnych do podpisania","More Options":"Wicej opcji","Moved":"Przeniesiony","Moved Funds":"Przesu rodki","Multiple recipients":"Wielu odbiorcw","NOTE: To import a wallet from a 3rd party software, please go to Add Wallet &gt; Create Wallet, and specify the Recovery Phrase there.":"Uwaga: Aby zaimportowa portfel z oprogramowania innego ni Copay, przejd do \"Dodaj portfel\" &gt; \"Utwrz portfel\", i podaj tam kluczow fraz.","Name":"Nazwa","Network error":"Bd sieci","New Proposal":"Nowa propozycja","New address could not be generated. Please try again.":"Nowy adres nie mg zosta utworzony. Sprbuj jeszcze raz.","New personal wallet":"Nowy portfel osobisty","Next steps":"Kolejne kroki","No Wallet":"Brak portfela","No access key defined":"Klucz dostpu nie jest zdefiniowany","No backup, no bitcoin.":"Nie ma kopii zapasowej - nie ma bitcoinw.","No contacts yet":"Brak kontaktw","No hardware information available.":"Brak dostpnych informacji o sprzcie.","No hardware wallets supported on this device":"Portfele sprztowe nie s obsugiwane przez to urzdzenie","No pending proposals":"Brak propozycji patnoci","No recent transactions":"Brak wczeniejszych transakcji","No transactions yet":"Brak transakcji","No wallet found":"Nie znaleziono portfela","No wallet selected":"Nie wybrano portfela","No wallets available":"Brak dostpnych portfeli","No wallets available to receive funds":"Brak portfeli do otrzymania rodkw","Normal":"Zwyka","Not authorized":"Brak autoryzacji","Not enough funds for fee":"Brak rodkw na opacenie prowizji","Not even BitPay can access it.":"Nawet BitPay nie ma do niego dostpu.","Not funds found":"Nie znaleziono rodkw","Not now":"Nie teraz","Note":"Notatka","Notice: only 1-1 (single signature) wallets can be used for sell bitcoin":"Uwaga: tylko 1-1 portfela (pojedynczy podpis) moe by wykorzystywany do sprzeday bitcoinw","Notifications":"Powiadomienia","Notifications by email":"Powiadomienia e-mail","Notify me if confirmed":"Powiadom mnie, jeli potwierdzono","Notify me when transactions are confirmed":"Powiadom mnie, gdy transakcja zostanie potwierdzona","Now is a good time to backup your wallet. If this device is lost, it is impossible to access your funds without a backup.":"Najwyszy czas na wykonanie kopii zapasowej portfela. Jeli utracisz to urzdzenie, dostp do rodkw bez kopii zapasowej bdzie niemoliwy.","Now is a perfect time to assess your surroundings. Nearby windows? Hidden cameras? Shoulder-spies?":"Nadszed czas, aby sprawdzi swoje otoczenie. Czy jeste w pobliu okna? Czy s gdzie ukryte kamery? Osoby zerkajce przez rami?","OK":"OK","OKAY":"W PORZDKU","Official English Disclaimer":"Oficjalna rezygnacja w jzyku angielskim","Oh no!":"O nie!","On this screen you can see all your wallets, accounts, and assets.":"Na tym ekranie mona zobaczy wszystkie swoje portfele, konta i rodki.","Open":"Otwrz","Open Crowdin":"Otwrz Crowdin","Open GitHub":"Otwrz GitHub","Open GitHub Project":"Otwrz projekt GitHub","Open Insight":"Otwrz Insight","Open Settings":"Otwrz ustawienia","Open Translation Community":"Spoeczno tumaczy","Open Website":"Otwrz stron internetow","Open wallet":"Otwrz portfel","Open website":"Otwrz stron","Order the BitPay Card":"Zamw kart BitPay","Password":"Haso","Password required. Make sure to enter your password in advanced options":"Wymagane haso. Upewnij si, aby wprowadzi haso w opcjach zaawansowanych","Paste invitation here":"Wklej tutaj zaproszenie","Paste the backup plain text code":"Wklej tekst kodu kopii zapasowej","Pay 0% fees to turn bitcoin into dollars.":"Zapa 0% prowizji za wymian bitcoinw na dolary.","Pay To":"Zapa","Payment Accepted":"Wypata zaakceptowana","Payment Expires:":"Patno wygasa:","Payment Proposal":"Wniosek wypaty","Payment Proposal Created":"Wniosek wypaty utworzony","Payment Proposals":"Wniosek wypaty","Payment Protocol Invalid":"Protok wypaty nieprawidowy","Payment Protocol not supported on Chrome App":"Protok wypaty nieobsugiwany przez Chrome","Payment Received":"Patno otrzymana","Payment Rejected":"Wypata odrzucona","Payment Sent":"Patno wysana","Payment accepted, but not yet broadcasted":"Wypata zaakceptowana, ale jeszcze nie nadana","Payment accepted. It will be broadcasted by Glidera. In case there is a problem, it can be deleted 6 hours after it was created.":"Wypata zaakceptowana. Bdzie nadana przez Glidera. W przypadku wystpienia problemu, moe by usunita 6 godzin po utworzeniu.","Payment details":"Szczegy wypaty","Payment request":"Wniosek o patno","Pending Proposals":"Rozpatrywane patnoci","Permanently delete this wallet.":"Trwale usu portfel.","Personal Wallet":"Portfel osobisty","Please carefully write down this phrase.":"Prosz dokadnie zanotowa t kluczow fraz.","Please connect a camera to get started.":"Prosz podczy kamer, aby zacz.","Please enter the recovery phrase":"Wpisz kluczow fraz","Please enter the wallet recovery phrase":"Wpisz kluczow fraz portfela","Please enter your PIN":"Wprowad kod PIN","Please tap each word in the correct order.":"Prosz wpisa kade sowo we waciwej kolejnoci.","Please upgrade Copay to perform this action":"Prosz uaktualni Copay, by mc wykona t operacj","Please, select your backup file":"Prosz wybra plik kopii zapasowej","Preferences":"Ustawienia","Preparing addresses...":"Przygotowywanie adresw...","Preparing backup...":"Przygotowywanie kopii zapasowej...","Press again to exit":"Nacinij ponownie, aby wyj","Priority":"Priorytetowa","Private Key":"Klucz prywatny","Private key encrypted. Enter password":"Klucz prywatny jest zaszyfrowany. Wprowad haso","Private key is encrypted, cannot sign":"Klucz prywatny jest zaszyfrowany, nie mona podpisa","Proposal Accepted":"Patno przyjta","Proposal Created":"Patno utworzona","Proposal Deleted":"Patno usunita","Proposal Rejected":"Patno odrzucona","Proposals":"Proponowane patnoci","Push Notifications":"Wyskakujce powiadomienia","Push notifications for {{appName}} are currently disabled. Enable them in the Settings app.":"Wyskakujce powiadomienia {{appName}} s obecnie wyczone. Wcz je w ustawieniach aplikacji.","QR Code":"Kod QR","Quick review!":"Szybki przegld!","Random":"Losowo","Rate on the app store":"Oce w App Store","Read less":"Zobacz mniej","Read more":"Zobacz wicej","Receive":"Otrzymaj","Received":"Otrzymane","Received Funds":"Otrzymane rodki","Receiving":"Otrzymywanie","Recent":"Ostatnie","Recent Transaction Card":"Ostatnia transakcja kart","Recent Transactions":"Ostatnie transakcje","Recipient":"Odbiorca","Recipients":"Odbiorcy","Recovery phrase":"Kluczowa fraza","Recreating Wallet...":"Przywracanie portfela...","Rejected":"Odrzucono","Rejecting payment proposal":"Odrzucenie patnoci","Release information":"Informacje o wersji","Remove":"Usu","Remove BitPay Account?":"Usun konto BitPay?","Remove BitPay Card?":"Usun kart BitPay?","Removing your BitPay account will remove all associated BitPay account data from this device. Are you sure you would like to remove your BitPay Account ({{email}}) from this device?":"Usunicie konta BitPay spowoduje usunicie z tego urzdzenia wszystkich skojarzonych z tym kontem danych. Czy na pewno chcesz usun konto BitPay ({{email}}) z tego urzdzenia?","Repeat password":"Powtrz haso","Repeat the password":"Powtrz haso","Request Fingerprint":"Zapytaj o odcisk palca","Request Specific amount":"Proba o konkretn kwot","Request Spending Password":"Wprowad haso wypaty","Required number of signatures":"Wymagana liczba podpisw","Restore from backup":"Przywr z kopii zapasowej","Retrieving inputs information":"Pobieranie informacji o danych wejciowych","Retry":"Sprbuj ponownie","Retry Camera":"Sprbuj ponownie z aparatem","Save":"Zapisz","Scan":"Zeskanuj","Scan QR Codes":"Zeskanuj kod QR","Scan addresses for funds":"Skanuj adresy w celu znalezienia rodkw","Scan again":"Skanuj ponownie","Scan your fingerprint please":"Prosz zeskanowa linie papilarne","Scanning Wallet funds...":"Skanowanie rodkw portfela...","Screenshots are not secure":"Zrzuty ekranu nie s bezpieczne","Search Transactions":"Szukaj transakcji","Search or enter bitcoin address":"Wyszukaj lub wpisz adres bitcoin","Search transactions":"Szukaj transakcji","Search your currency":"Znajd swoj walut","Security":"Bezpieczestwo","Select a backup file":"Wybierz plik kopii zapasowej","Select a wallet":"Wybierz portfel","Self-signed Certificate":"Certyfikat z podpisem wasnym","Selling Bitcoin...":"Sprzedawanie bitcoinw...","Send":"Wylij","Send Feedback":"Wylij opini","Send Money":"Wylij pienidze","Send addresses by email":"Wylij adresy przez e-mail","Send by email":"Wylij przez e-mail","Send from":"Wylij z","Send max amount":"Wylij ca kwot","Send payment to this address":"Wylij patno na ten adres","Send us feedback instead":"Zamiast tego wylij nam swoj opini","Sending":"Wysyanie","Sending 2FA code...":"Wysyanie kodu 2FA...","Sending feedback...":"Wysyanie opinii...","Sending maximum amount":"Wysyanie caej kwoty","Sending transaction":"Wysyanie transakcji","Sending {{amountStr}} from your {{name}} wallet":"Wysyanie {{amountStr}} z twojego portfela {{name}}","Sent":"Wysane","Sent Funds":"Wysane rodki","Server response could not be verified":"Odpowied serwera nie moga zosta zweryfikowana","Service not available":"Usuga nie jest dostpna","Services":"Usugi","Session Log":"Dziennik sesji","Session log":"Dziennik sesji","Set up a password":"Ustal haso","Set your own fee in satoshis/byte":"Ustaw wasn opat w satoshis/bajt","Settings":"Ustawienia","Share the love by inviting your friends.":"Podziel si mioci, zapraszajc swoich przyjaci.","Share this invitation with your copayers":"Wylij zaproszenie wspwacicielom portfela","Share {{appName}}":"Podziel si {{appName}}","Shared Wallet":"Wspdzielony portfel","Show Recovery Phrase":"Poka kluczow fraz","Show address":"Poka adres","Show advanced options":"Poka opcje zaawansowane","Show bitcoin address":"Poka adres bitcoin","Show more":"Poka wicej","Signatures rejected by server":"Podpisy odrzucone przez serwer","Signing transaction":"Podpisywanie transakcji","Since only you control your money, youll need to save your backup phrase in case this app is deleted.":"Poniewa jedynie Ty kontrolujesz swoje pienidze, musisz zapisa kluczow fraz na wypadek skasowania aplikacji {{appName}}.","Single Address Wallet":"Pojedynczy adres portfela","Skip":"Pomi","Slide to buy":"Przesu, aby kupi","Specify Recovery Phrase...":"Podaj kluczow fraz...","Spend proposal is not accepted":"Wniosek wypaty nie zosta przyjty","Spend proposal not found":"Wniosek wypaty nie zosta znaleziony","Spending Password needed":"Wymagane haso wypat","Start sending bitcoin":"Zacznij wysya bitcoiny","Startup Lock":"Blokada uruchamiania","Success":"Udao si","Super Economy":"Super Ekonomiczna","Sweep":"Oprnij","Sweep paper wallet":"Wyczy papierowy portfel","Sweeping Wallet...":"Sczytywanie portfela...","THIS ACTION CANNOT BE REVERSED":"TEJ CZYNNOCI NIE MONA COFN","Take control of your money,<br>get started with bitcoin.":"Przejmij kontrol nad swoimi pienidzmi,<br>zacznij korzysta z bitcoinw.","Tap and hold to show":"Dotknij i przytrzymaj, aby pokaza","Tap to retry":"Ponw prb","Terms Of Use":"Warunki uytkowania","Terms of Use":"Warunki uytkowania","Testnet":"Testnet","Text":"Tekst","Thank you!":"Dzikujemy!","Thanks!":"Dziki!","That's exciting to hear. We'd love to earn that fifth star from you  how could we improve your experience?":"Bardzo nam mio. Chcielibymy dosta od Ciebie 5 gwiazdek - co jeszcze moemy poprawi?","The Ledger Chrome application is not installed":"Aplikacja Ledger Chrome nie jest zainstalowana","The amount of bitcoin immediately spendable from this wallet.":"Moliwa jest natychmiastowa wypata wszystkich rodkw z tego portfela.","The amount of bitcoin stored in this wallet that is allocated as inputs to your pending transaction proposals. The amount is determined using unspent transaction outputs associated with this wallet and may be more than the actual amounts associated with your pending transaction proposals.":"Kwota bitcoinw przechowywana w tym portfelu, przydzielona jako wejcie dla oczekujcych wnioskw wypat. Kwota ta jest ustalana za pomoc niewykorzystanych wyj transakcji zwizanych z tym portfelem i moe przekroczy kwoty zwizane z proponowanymi wnioskami wypat.","The amount of bitcoin stored in this wallet with less than 1 blockchain confirmation.":"Ilo bitcoinw przechowywana w tym portfel z mniej ni jednym potwierdzeniem w blockchainie.","The derivation path":"cieka derywacji","The exchange rate changes with the market.":"Zmiany kursowe zalene od rynku.","The higher the fee, the greater the incentive a miner has to include that transaction in a block. Current fees are determined based on network load and the selected policy.":"Im wysza prowizja, tym wiksza zachta dla grnikw do zawarcia tej transakcji w bloku. Obecne prowizje ustala si w oparciu o obcienia sieci i wybran polityk.","The maximum number of consecutive unused addresses (20) has been reached. When one of your unused addresses receives a payment, a new address will be generated and shown in your Receive tab.":"Maksymalna liczba kolejnych niewykorzystanych adresw (20) zostaa osignita. Gdy na jeden z nieuywanych adresw wpynie zapata, nowy adres zostanie wygenerowany i pokazany w zakadce Otrzymane.","The official English Terms of Service are available on the BitPay website.":"Oficjalne Warunki uytkowania w jzyku angielskim dostpne s na stronie internetowej BitPay.","The password of the recovery phrase (if set)":"Haso kluczowej frazy (jeli ustawione)","The payment was created but could not be completed. Please try again from home screen":"Wypata zostaa utworzona, ale nie moe by zakoczona. Sprbuj ponownie na stronie gwnej","The payment was removed by creator":"Wypata zostaa usunita przez jej twrc","The recovery phrase could require a password to be imported":"Kluczowa fraza moe wymaga hasa do zaimportowania","The request could not be understood by the server":"Wniosek nie zosta zrozumiany przez serwer","The restore process will stop when 20 addresses are generated in a row which contain no funds. To safely generate more addresses, make a payment to one of the unused addresses which has already been generated.":"Proces przywracania bdzie przerwany kiedy zostanie wygenerowanych 20 nastpujcych po sobie adresw, na ktrych nie ma adnych rodkw. Aby bezpiecznie wygenerowa wicej adresw, dokonaj patnoci na jeden z nieuywanych adresw, ktre zostay ju wygenerowane.","The spend proposal is not pending":"Wniosek o wypat nie jest w oczekujcych","The total amount of bitcoin stored in this wallet.":"czna ilo bitcoinw przechowywana w tym portfelu.","The transaction history and every new incoming transaction are cached in the app. This feature clean this up and synchronizes again from the server":"Historia transakcji i kada nowoprzychodzca transakcja s zapisywane w aplikacji. Ta funkcja czyci te dane i ponownie synchronizuje z serwerem","The wallet service URL":"Adres URL usugi portfela","There is a new version of {{appName}} available":"Dostpna jest nowa wersja {{appName}}","There is an error in the form":"Wystpi bd w postaci","There's obviously something we're doing wrong.":"To oczywiste, e co robimy le.","This app is fantastic!":"Ta aplikacja jest fantastyczna!","This app stores your bitcoin with cutting-edge security.":"Ta aplikacja przechowuje Twoje bitcoiny z zaawansowanymi zabezpieczeniami.","This bitcoin payment request has expired.":"Ten wniosek patnoci wygas.","This password cannot be recovered. If the password is lost, there is no way you could recover your funds.":"To haso nie moe zosta odzyskane. Jeli je utracisz, nie bdziesz mg odzyska swoich rodkw.","This recovery phrase was created with a password. To recover this wallet both the recovery phrase and password are needed.":"Ta kluczowa fraza zosta utworzona przy uyciu hasa. Aby odzyska portfel potrzebna jest kluczowa fraza i haso.","This transaction could take a long time to confirm or could be dropped due to the low fees set by the sender":"Potwierdzenie transakcja moe trwa dugo lub zosta przerwane z powodu niskiej prowizji ustalonej przez nadawc","This wallet is not registered at the given Bitcore Wallet Service (BWS). You can recreate it from the local information.":"Ten portfel nie jest zarejestrowany na Bitcore Wallet Service (BWS). Moesz go odtworzy z lokalnego nonika.","Timeline":"Historia","To":"Do","To get started, buy bitcoin or share your address. You can receive bitcoin from any wallet or service.":"Aby zacz, kup bitcoiny lub udostpnij swj adres. Moesz otrzyma bitcoiny z dowolnego portfela lub usugi.","To get started, you'll need to create a bitcoin wallet and get some bitcoin.":"Aby rozpocz naley utworzy portfel i dosta troch bitcoinw.","Total":"cznie","Total Locked Balance":"cznie zablokowane rodki","Total number of copayers":"Liczba wspwacicieli portfela","Touch ID Failed":"Odczyt Touch ID nie powid si","Transaction":"Transakcja","Transaction Created":"Transakcja utworzona","Transaction History":"Historia transakcji","Transaction already broadcasted":"Transakcja zostaa ju wysana","Transaction initiated":"Transakcja zainicjowana","Transaction not available at this time":"Transakcja w tej chwili niedostpna","Transaction not found":"Nie znaleziono transakcji","Transactions without fee are not supported.":"Transakcje bez opaty nie s obsugiwane.","Transfer to":"Przeka do","Transfer to Wallet":"Przenie do portfela","Try again in {{expires}}":"Sprbuj ponownie w {{expires}}","Turn bitcoin into dollars, swipe anywhere Visa<sup></sup> is accepted.":"Zamie bitcoiny na dolary - pa wszdzie gdzie akceptowane s karty Visa <sup>&reg;</sup>.","Type the Recovery Phrase (usually 12 words)":"Wpisz kluczow fraz (zwyczajowo 12 sw)","Uh oh...":"Ups...","Unconfirmed":"Niepotwierdzone","Unsent transactions":"Niewysane transakcje","Unused Addresses":"Nieuywane adresy","Unused Addresses Limit":"Limit nieuywanych adresw","Update Available":"Dostpna aktualizacja","Updating pending proposals. Please stand by":"Aktualizacja wnioskw patnoci. Prosz czeka","Updating transaction history. Please stand by.":"Aktualizowanie historii transakcji. Prosz czeka.","Updating... Please stand by":"Aktualizacja... Prosz czeka","Urgent":"Pilna","Use Unconfirmed Funds":"Uyj niepotwierdzonych rodkw","Validating recovery phrase...":"Sprawdzanie poprawnoci kluczowej frazy...","Verify your identity":"Weryfikacja konta uytkownika","Version":"Wersja","View":"Widok","View All Addresses":"Zobacz wszystkie adresy","View Terms of Service":"Zobacz zasady uytkowania","View Transaction on Insight":"Zobacz transakcje na Insight","View Update":"Zobacz aktualizacje","View on blockchain":"Zobacz na blockchainie","WARNING: Key derivation is not working on this device/wallet. Actions cannot be performed on this wallet.":"Ostrzeenie: klucz derywacji nie dziaa na tym urzdzeniu/portfelu. Dziaania dla tego portfela nie mona wykona.","WARNING: Not including the private key allows to check the wallet balance, transaction history, and create spend proposals from the export. However, does not allow to approve (sign) proposals, so <b>funds will not be accessible from the export</b>.":"UWAGA: Jeli plik eksportu nie zawiera klucza prywatnego, moliwe bdzie jedynie sprawdzenie salda i historii transakcji, jak rwnie wygenerowanie wnioskw o patno. Nie moe by on jednak uywany do sprawdzania poprawnoci (podpisywania) wnioskw patnoci, wic <b>rodki z wyeksportowanego pliku nie bd dostpne</b>.","WARNING: The private key of this wallet is not available. The export allows to check the wallet balance, transaction history, and create spend proposals from the export. However, does not allow to approve (sign) proposals, so <b>funds will not be accessible from the export</b>.":"UWAGA: Klucz prywatny nie jest dostpny. Ten eksport umoliwia sprawdzenie salda i historii transakcji, jak rwnie wygenerowanie wnioskw o patno. Nie moe by on jednak uywany do sprawdzania poprawnoci (podpisywania) wnioskw patnoci, wic <b>rodki z wyeksportowanego pliku nie bd dostpne</b>.","WARNING: UNTRUSTED CERTIFICATE":"OSTRZEENIE: CERTYFIKAT NIEZAUFANY","Waiting for Ledger...":"Oczekiwanie na Ledger...","Waiting for Trezor...":"Oczekiwanie na Trezor...","Waiting for copayers":"Oczekiwanie na wspwacicieli portfela","Waiting...":"Oczekiwanie...","Wallet Addresses":"Adresy portfela","Wallet Color":"Kolor portfela","Wallet Configuration (m-n)":"Konfiguracja portfela (m-n)","Wallet Created":"Portfel zosta utworzony","Wallet Id":"Id Portfela","Wallet Information":"Informacje o portfelu","Wallet Invitation":"Zaproszenie do portfela","Wallet Key":"Kluczowa fraza","Wallet Name":"Nazwa portfela","Wallet Name (at creation)":"Nazwa portfela (oryginalna)","Wallet Network":"Sie portfela","Wallet Recovery Phrase":"Kluczowa fraza portfela","Wallet Recovery Phrase is invalid":"Kluczowa fraza jest nieprawidowa","Wallet Service URL":"Adres usug portfela","Wallet Settings":"Ustawienia portfela","Wallet Type":"Rodzaj portfela","Wallet already exists":"Portfel ju istnieje","Wallet created":"Portfel zosta utworzony","Wallet incomplete and broken":"Portfel niekompletny lub uszkodzony","Wallet is full":"Portfel jest peny","Wallet is locked":"Portfel jest zablokowany","Wallet is not complete":"Portfel jest niekompletny","Wallet name":"Nazwa portfela","Wallet needs backup":"Portfel wymaga kopii zapasowej","Wallet not backed up":"Portfel nie ma kopii zapasowej","Wallet not found":"Nie znaleziono portfela","Wallet not registered":"Portfel nie jest zarejestrowany","Wallet not registered at the wallet service. Recreate it from \"Create Wallet\" using \"Advanced Options\" to set your recovery phrase":"Portfel nie jest zarejestrowany w Wallet Service. Odtwrz go uywajc polecenia \"Utwrz portfel\" z wykorzystaniem kluczowej frazy w ustawieniach zaawansowanych","Wallet recovery phrase not available.":"Kluczowa fraza niedostpna.","Wallet service not found":"Nie znaleziono serwera","Wallets":"Portfele","Wallets & Integrations":"Portfele i integracja","Warning!":"Ostrzeenie!","Warning: this transaction has unconfirmed inputs":"Ostrzeenie: ta transakcja ma niepotwierdzone dane wejciowe","Watch out!":"Uwaaj!","We'd love to do better.":"Chcielibymy zrobi to lepiej.","We'll confirm on the next screen.":"Potwierdzimy na nastpnym ekranie.","We're always looking for ways to improve {{appName}}.":"Zawsze szukamy sposobw na popraw {{appName}}.","We're always looking for ways to improve {{appName}}. How could we improve your experience?":"Zawsze szukamy sposobw na ulepszenie {{appName}}. Co Twoim zdaniem mona jeszcze poprawi?","Website":"Strona","Were always looking for translation contributions! You can make corrections or help to make this app available in your native language by joining our community on Crowdin.":"Cay czas szukamy osb, ktre chciayby przyczy si do tumaczenia! Moesz dokona korekt lub pomc, aby aplikacja bya dostpna w Twoim jzyku ojczystym przez doczenie do naszej spoecznoci na Crowdin.","What do you call this wallet?":"Jak chcesz nazwa ten portfel?","When this wallet was created, it was called {{walletName}}. You can change the name displayed on this device below.":"Kiedy portfel zosta utworzony, otrzyma nazw &ldquo;{{walletName}}&rdquo;. Moesz zmieni nazw wywietlan poniej.","Where would you like to receive email notifications about payments?":"Czy chcesz otrzymywa powiadomienia e-mail o patnociach?","Why?":"Dlaczego?","Would you be willing to rate {{appName}} in the app store?":"Czy zechciaby oceni {{appName}} w app store?","Would you like to receive push notifications about payments?":"Czy chcesz otrzymywa wyskakujce powiadomienia o patnociach?","Wrong number of recovery words:":"Nieprawidowa ilo sw frazy:","Wrong spending password":"Nieprawidowe haso wypat","Yes":"Tak","Yes, skip":"Tak, pomi","You can create a backup later from your wallet settings.":"Kopi zapasow mona utworzy pniej w ustawieniach portfela.","You can make contributions by signing up on our Crowdin community translation website. Were looking forward to hearing from you!":"Moesz przyczyni si do rozwoju aplikacji rejestrujc si na Crowdin - naszej stronie dla tumaczy. Bdziemy wdziczni za kontakt!","You can scan bitcoin addresses, payment requests, paper wallets, and more.":"Moesz zeskanowa adresy bitcoin, wnioski patnoci, portfele papierowe i wiele innych.","You can see the latest developments and contribute to this open source app by visiting our project on GitHub.":"Moesz zobaczy postpy prac i przyczyni si do rozwoju tej aplikacji open source odwiedzajc nasz projekt na GitHub.","You can spend bitcoin at millions of websites and stores worldwide.":"Bitcoiny moesz wyda w milionach sklepw i stron internetowych na caym wiecie.","You can still export it from Advanced &gt; Export.":"Nadal moesz go wyeksportowa w Zaawansowane &gt; Eksport.","You can trade it for other currencies like US Dollars, Euros, or Pounds.":"Moesz je wymieni na inne waluty, takie jak dolary amerykaskie, euro lub funty.","You control your bitcoin.":"Ty kontrolujesz swoje bitcoiny.","You should not set a fee higher than {{maxFeeRecommended}} satoshis/byte.":"Nie naley ustawia opat wysz ni {{maxFeeRecommended}} satoshis/bajt.","You'll receive email notifications about payments sent and received from your wallets.":"Bdziesz otrzymywa powiadomienia e-mail o patnoci wysyanych i odbieranych ze swoich portfeli.","Your BitPay Card is ready. Add funds to your card to start using it at stores and ATMs worldwide.":"Twoja karta BitPay jest gotowa. Zasil kart, aby zacz j uywa w sklepach i bankomatach na caym wiecie.","Your bitcoin wallet is backed up!":"Kopia zapasowa portfela zostaa utworzona!","Your bitcoin wallet is ready!":"Twj portfel jest gotowy!","Your fee is lower than recommended.":"Opata jest nisza ni zalecana.","Your ideas, feedback, or comments":"Twoje pomysy, opinie lub komentarze","Your name":"Twj nick","Your nickname":"Twj nick","Your password":"Twoje haso","Your purchase could not be completed":"Nie mona ukoczy zakupu","Your purchase was added to the list of pending":"Zakup zosta dodany do listy oczekujcych","Your wallet is never saved to cloud storage or standard device backups.":"Twj portfel nigdy nie jest przechowywany w chmurze lub na urzdzeniach do tworzenia kopii zapasowych.","Your wallet key will be encrypted. The Spending Password cannot be recovered. Be sure to write it down.":"Twj portfel bdzie zaszyfrowany. Haso wypat nie bdzie mogo by odzyskane. Pamitaj, aby je zapisa.","[Balance Hidden]":"[Balans ukryty]","add your BitPay Visa card(s)":"dodaj swoje karty BitPay Visa","locked by pending payments":"zablokowane przez oczekujce wypaty","me":"ja","name@example.com":"nazwa@przyklad.com","preparing...":"Przygotowywanie...","{{amountStr}} for Amazon.com Gift Card":"{{amountStr}} dla karty upominkowej Amazon.com","{{appName}} depends on Bitcore Wallet Service (BWS) for blockchain information, networking and Copayer synchronization. The default configuration points to https://bws.bitpay.com (BitPay's public BWS instance).":"{{appName}} jest zaleny od Bitcore Wallet Service (BWS) jeli chodzi o informacje dotyczce blokcheina, sieci i synchronizacji wspwacicieli portfela. Domylnie jest to https://bws.bitpay.com (BitPay's public BWS instance).","{{fee}} will be deducted for bitcoin networking fees.":"{{fee}} zostanie potrcone jako prowizja sieci bitcoin.","{{updatingTxHistoryProgress}} transactions downloaded":"{{updatingTxHistoryProgress}} transakcje pobrane","{{wallet.m}}-of-{{wallet.n}}":"{{wallet.m}}-z-{{wallet.n}}"});
    gettextCatalog.setStrings('pt', {"(Trusted)":"(Confivel)","(possible double spend)":"(Possvel gasto duplo)","* A payment proposal can be deleted if 1) you are the creator, and no other copayer has signed, or 2) 24 hours have passed since the proposal was created.":"* Uma proposta de pagamento pode ser apagada se 1) voc  o criador e outro copayer no subscreveu, ou 2) Passaram-se 24 horas desde que a proposta foi criada.","- {{btx.feeRateStr}} of the transaction":"- {{btx.feeRateStr}} da transao","- {{tx.feeRateStr}} of the transaction":"- {{tx.feeRateStr}} da transao","5-star ratings help us get {{appName}} into more hands, and more users means more resources can be committed to the app!":"Classificaes de 5 estrelas ajudam-nos a que o {{appName}} chegue s mos de mais e mais utilizadores, que significa que mais recursos sero includos na aplicao!","<b>Only</b> redeemable on Mercado Livre (Brazil)":"<b>Somente</b> resgatvel no Mercado Livre (Brasil)","A member of the team will review your feedback as soon as possible.":"Um membro da equipa ir rever a sua avaliao assim que possvel.","A total of {{amountAboveMaxSizeStr}} were excluded. The maximum size allowed for a transaction was exceeded.":"O montante de {{amountAboveMaxSizeStr}} foi excluido. O valor mximo permitido para uma transao foi excedido.","A total of {{amountBelowFeeStr}} were excluded. These funds come from UTXOs smaller than the network fee provided.":"O montante de {{amountBelowFeeStr}} foi excluido. Estes fundos vieram de UTXOs menores que a taxa de rede fornecida.","About":"Sobre","Accepted":"Aceite","Account":"Conta","Account Number":"Nmero de conta","Accounts":"Contas","Activity":"Atividade","Add Account":"Adicionar conta","Add BitPay Account?":"Adicionar conta BitPay?","Add Contact":"Adicionar contacto","Add Funds":"Adicionar fundos","Add Memo":"Adicionar nota","Add a password":"Adicionar uma senha","Add account":"Adicionar conta","Add an optional password to secure the recovery phrase":"Adicionar uma senha opcional para asegurar a frase de recuperao","Add as a contact":"Adicionar como um contato","Add description":"Adicionar descrio","Add funds":"Adicionar fundos","Add this BitPay account ({{email}})?":"Adicionar esta conta BitPay ({{email}})?","Add wallet":"Adicionar carteira","Address":"Endereo","Address Book":"Livros de endereos","Address Type":"Tipo de Endereo","Addresses With Balance":"Endereos com valores","Advanced":"Avanado","Advanced Settings":"Definies avanadas","All":"Todos","All Addresses":"Todos os endereos","All of your bitcoin wallet balance may not be available for immediate spending.":"Todos os seus bitcoins na carteira podero no estar disponveis de imediato para gastar.","All signing devices must be added to this multisig wallet before bitcoin addresses can be created.":"Todos os dispositivos de autenticao devem ser adicionados a esta carteira de multi-assinatura antes dos endereos bitcoin poderem ser criados.","Allow Camera Access":"Permitir o acesso  cmera","Allow notifications":"Permitir notificaes","Almost done! Let's review.":"Quase pronto! Vamos rever.","Alternative Currency":"Moeda Alternativa","Amazon.com is not available at this moment. Please try back later.":"Amazon.com no est disponvel neste momento. Por favor, tente mais tarde.","Amount":"Valor","Amount below minimum allowed":"Montante abaixo do mnimo permitido","Amount too big":"Montante muito grande","Amount too low to spend":"Quantidade muito baixa para gastar","An update to this app is available. For your security, please update to the latest version.":"Est disponvel uma actualizao para esta aplicao. Para sua segurana, por favor atualize para a verso mais recente.","Anyone with your backup phrase can access or spend your bitcoin.":"Qualquer pessoa com sua frase de segurana pode aceder ou gastar os seus bitcoins.","Approximate Bitcoin network fee to transfer wallet's balance (with normal priority)":"Taxa de rede Bitcoin aproximada para transferir o saldo da carteira (com prioridade normal)","Are you being watched?":"Voc est sendo vigiado?","Are you being watched? Anyone with your recovery phrase can access or spend your bitcoin.":"Voc est sendo observado? Qualquer pessoa com sua frase de recuperao pode acessar ou gastar seu bitcoin.","Are you sure you want to cancel and delete this wallet?":"Tem certeza que deseja cancelar e eliminar esta carteira?","Are you sure you want to delete this contact?":"Tem certeza que deseja excluir este contato?","Are you sure you want to delete this wallet?":"Tem certeza que deseja excluir esta carteira?","Are you sure you want to reject this transaction?":"Tem certeza que deseja cancelar esta transao?","Are you sure you want to remove this transaction?":"Tem certeza que deseja remover esta transao?","Are you sure you want to skip it?":"Tem a certeza que deseja ignorar?","Are you sure you would like to log out of your BitPay Card account?":"Tem certeza que voc deseja sair da sua conta do BitPay Card?","Are you sure you would like to remove your BitPay Card ({{lastFourDigits}}) from this device?":"Tem a certeza de que quer remover o seu Carto BitPay ({{lastFourDigits}}) deste dispositivo?","Auditable":"Audivel","Available":"Disponvel","Available Balance":"Saldo Disponvel","Average confirmation time":"Tempo de confirmao (em mdia)","BIP32 path for address derivation":"Pacote BIP32 para endereo de derivao","BTCZ Wallets":"Carteiras BTCZ","Backup":"Backup","Backup Needed":"Cpia de segurana necessria","Backup all livenet wallets before using this function":"Faa backup de todas as carteiras do livenet antes de usar esta funo","Backup needed":"Backup necessrio","Backup now":"Backup agora","Backup wallet":"Criar cpia da carteira","Backup your wallet before using this function":"Faa backup da sua carteira antes de usar esta funo","Bad wallet invitation":"Convite para carteira invlido","Balance By Address":"Saldo por endereo","Be sure to store your recovery phrase in a secure place. If this app is deleted, your money cannot be recovered without it.":"Certifique-se de armazenar a sua frase de recuperao num lugar seguro. Se esta aplicao for eliminada o seu dinheiro no pode ser recuperado sem ela.","BitPay Visa Cards":"Cartes BitPay Visa&reg","Bitcoin Address":"Endereo Bitcoin","Bitcoin Cash (BCH) Balances":"Saldos Bitcoin Cash (BCH)","Bitcoin Cash Support":"Suportar Bitcoin Cash","Bitcoin Network Fee Policy":"Poltica de taxa de rede Bitcoin","Bitcoin cash Payment":"Pagamento Bitcoin Cash","Bitcoin is a currency.":"Bitcoin  uma moeda.","Bitcoin is different  it cannot be safely held with a bank or web service.":"Bitcoin  diferente &ndash; ela no pode ser retida com segurana por um servio web ou banco.","Bitcoin is secure,<br>digital money.":"Bitcoin  seguro,<br>moeda digital.","Bitcoin transactions include a fee collected by miners on the network.":"As transaes Bitcoin incluem uma taxa cobrada pelos mineiros na rede.","Bought {{amountUnitStr}}":"Comprado {{amountUnitStr}}","Broadcast Payment":"Transmitir Pagamento","Broadcasted":"Transmitido","Broadcasting transaction":"Transmitindo transao","Browser unsupported":"Navegador no suportado","Buy":"Comprar","Buy &amp; Sell Bitcoin":"Comprar &amp; Vender Bitcoin","Buy Bitcoin":"Comprar Bitcoin","Buy a Gift Card":"Comprar um Vale-presente","Buy from":"Comprar de","Buying Bitcoin...":"A comprar Bitcoin...","Calculating fee":"A calcular taxa","Cancel":"Cancelar","Cancel invitation":"Cancelar convite","Cannot Create Wallet":"No  possvel criar a carteira","Cannot join the same wallet more that once":"No pode juntar-se a mesma carteira mais que uma vez","Cards":"Cartes","Certified by":"Certificado por","Check installation and retry.":"Verifique a instalao e tente novamente.","Choose a backup file from your computer":"Escolha um arquivo de backup do seu computador","Choose your destination wallet":"Escolha a sua carteira de destino","Choose your source wallet":"Escolha a sua carteira de origem","Clear":"Eliminar","Clear cache":"Limpar cache","Click to accept":"Clique para aceitar","Click to pay":"Clique para pagar","Click to send":"Clique para enviar","Close":"Fechar","Coin":"Moeda","Color":"Cor","Commit hash":"Commit de hash","Complete the backup process to use this option":"Complete o processo de backup para usar esta opo","Completed":"Concludo","Confirm":"Confirmar","Confirm &amp; Finish":"Confirmar &amp; Terminado","Confirm purchase":"Confirmar compra","Confirm your PIN":"Confirme o seu PIN","Confirm your new spending password":"Confirme a nova senha de pagamento","Confirmations":"Confirmaes","Confirming":"A confirmar","Connect my BitPay Card":"Introduzir o meu carto do BitPay","Connecting to Coinbase...":"A conectar ao Coinbase...","Connecting to Glidera...":"A conectar ao Glidera...","Connection reset by peer":"Ligao redefinida pelo mesmo nvel","Contacts":"Contactos","Continue":"Continuar","Contribute Translations":"Contribuir para a traduo","Copayer already in this wallet":"Copayer j est nesta carteira","Copayer already voted on this spend proposal":"Copayer j votou nesta proposta de pagamento","Copayer data mismatch":"Informao do Copayer invlida","Copayer joined":"Copayer juntou-se","Copayer {{$index}}":"Copayer {{$index}}","Copied to clipboard":"Copiado para a rea de transferncia","Copy this text as it is to a safe place (notepad or email)":"Copie este texto como est para um lugar seguro (bloco de notas ou e-mail)","Copy to clipboard":"Copiar para rea de transferncia","Could not access Gift Card Service":"No foi possvel acessar o servio de vale-presente","Could not access the wallet at the server. Please check:":"No foi possvel acessar a carteira no servidor. Por favor, verifique:","Could not access to Amazon.com":"No foi possvel acessar a Amazon.com","Could not access wallet":"Impossvel aceder  carteira","Could not add message to imported wallet without shared encrypting key":"No foi possvel adicionar mensagem  carteira importada sem chave de criptografia compartilhada","Could not broadcast payment":"No foi possvel transmitir o pagamento","Could not build transaction":"No foi possvel criar a transaco","Could not create address":"No foi possvel criar o endereo","Could not create the invoice":"No foi possvel criar a fatura","Could not create transaction":"No foi possvel criar a transao","Could not create using the specified extended private key":"No foi possvel criar usando a chave privada estendida especificada","Could not create using the specified extended public key":"No foi possvel criar usando a chave privada estendida especificada","Could not create: Invalid wallet recovery phrase":"No foi possvel criar: Frase de recuperao de carteira invlida","Could not decrypt file, check your password":"No foi possvel descriptografar o arquivo, verifique sua senha","Could not delete payment proposal":"No foi possvel excluir a proposta de pagamento","Could not duplicate":"No foi possvel duplicar","Could not get dynamic fee":"No foi possvel obter taxa dinmica","Could not get dynamic fee for level: {{feeLevel}}":"No foi possvel obter a taxa dinmica para nvel: {{feeLevel}}","Could not get fee levels":"No foi possvel obter nveis de taxa","Could not get the invoice":"No foi possvel obter a fatura","Could not get transactions":"No foi possvel obter o histrico das transaes","Could not import":"No foi possvel importar","Could not import. Check input file and spending password":"No foi possvel importar. Verifique o arquivo de entrada e senha de compra","Could not join wallet":"Impossvel juntar  carteira","Could not reject payment":"No foi possvel rejeitar o pagamento","Could not remove account":"No foi possvel remover a conta","Could not remove card":"No foi possvel remover o carto","Could not save preferences on the server":"No foi possvel guardar as suas preferncias no servidor","Could not send payment":"No foi possvel enviar o pagamento","Could not send transaction":"No foi possvel enviar a transao","Could not update transaction history":"No foi possvel atualizar o histrico de transaes","Could not update wallet":"No foi possvel atualizar a carteira","Create Personal Wallet":"Criar carteira pessoal","Create Shared Wallet":"Criar carteira partilhada","Create bitcoin wallet":"Criar carteira bitcoin","Create new wallet":"Criando nova carteira","Create shared wallet":"Criar carteira partilhada","Create {{formData.requiredCopayers}}-of-{{formData.totalCopayers}} wallet":"Criar carteira de {{formData.requiredCopayers}}-de-{{formData.totalCopayers}}","Created by":"Criado por","Creating Wallet...":"Criando Carteira","Creating transaction":"Criando transao","Current fee rate for this policy":"Taxa atual para esta poltica","Custom":"Personalizado","Custom Amount":"Montante personalizado","Custom Fee":"Taxa personalizada","Date":"Data","Delete":"Eliminar","Delete Payment Proposal":"Excluir Proposta de Pagamento","Delete Wallet":"Excluir Carteira","Delete it and create a new one":"Apagar e criar um novo","Deleting Wallet...":"A eliminar carteira...","Deleting payment proposal":"A eliminar proposta de pagamento","Derivation Path":"Caminho de derivao","Derivation Strategy":"Estratgia de derivao","Details":"Detalhes","Disabled":"Desativado","Do it later":"Faz-lo mais tarde","Do not include private key":"No inclui chave privada","Don't see your language on Crowdin? Contact the Owner on Crowdin! We'd love to support your language.":"No v o seu idioma no Crowdin? Contacte o Dono no Crowdin! Ns adoraramos suportar a sua linguagem.","Download":"Download","Duplicate for BCH":"Duplicado para BCH","Duplicating wallet...":"Duplicando carteira...","Each bitcoin wallet can generate billions of addresses from your 12-word backup. A new address is automatically generated and shown each time you receive a payment.":"Cada carteira de Bitcoin pode gerar bilies de endereos atravs do seu backup de 12-palavras. Um novo endereo  gerado automticamente e mostrado cada vez que receber um pagamento.","Economy":"Economia","Edit":"Editar","Email":"Email","Email Address":"Endereo de email","Empty addresses limit reached. New addresses cannot be generated.":"Limite de endereos vazios atingido. Novos endereo no podem ser gerados.","Enable Bitcoin Cash wallet creation and operation within the App.":"Permitir a criao e operao de carteira Bitcoin Cash dentro do aplicativo.","Enable camera access in your device settings to get started.":"Permita o acesso de cmera nas configuraes do seu dispositivo para comear.","Enable email notifications":"Ativar notificaes por email","Enable push notifications":"Ativar notificaes push","Enable the camera to get started.":"Ative a cmera para comear.","Enabled":"Habilitado","Enter Spending Password":"Inserir senha de compra","Enter Two Factor for your BitPay account":"Insira verificao dois passos para sua conta BitPay","Enter amount":"Digite a quantidade","Enter custom fee":"Digite a taxa personalizada","Enter new spending password":"Insira a nova senha para pagamento","Enter the recovery phrase (BIP39)":"Digite a frase de recuperao (BIP39)","Enter your email":"Digite seu e-mail","Enter your password":"Digite sua senha","Error":"Erro","Error at confirm":"Erro na confirmao","Error creating gift card":"Erro ao criar vale-presente","Error creating the invoice":"Erro ao criar a fatura","Error creating wallet":"Erro na criao da carteira","Error getting SendMax information":"Erro ao obter informaes de SendMax","Error in Payment Protocol":"Erro no Protocolo de Pagamento","Error pairing BitPay Account":"Erro de emparelhamento na Conta BitPay","Error scanning funds:":"Erro na varredura dos fundos:","Error sweeping wallet:":"Erro na varredura da carteira:","Error updating Debit Cards":"Erro na atualizao dos Cartes de Dbito","Exceeded daily limit of $500 per user":"Excedido limite dirio de $500 por usurio","Expired":"Expirado","Expires":"Expira","Export Wallet":"Exportar Carteira","Export to file":"Exportar para arquivo","Export wallet":"Exportar carteira","Exporting via QR not supported for this wallet":"Exportao via QR code no suportada por essa carteira","Extended Public Keys":"Chave Pblica Estendida","Extracting Wallet information...":"Extraindo informaes da Carteira...","Failed to export":"Falha ao exportar","Family vacation funds":"Fundos de frias com a famlia","Fee":"Taxa","Fee level":"Nvel de taxa","Fee level is not defined":"Nvel de taxa no est definido","Fee:":"Taxa:","Feedback could not be submitted. Please try again later.":"Comentrio pode no ter sido enviado. Por favor, tente novamente mais tarde.","Fetching BitPay Account...":"Buscando Conta BitPay...","Fetching payment information":"Buscando informao de pagamento","File/Text":"Arquivo/Texto","Filter setting":"Configurao de filtro","Finger Scan Failed":"Leitura de Impresso Digital falhou","Finish":"Encerrar","For audit purposes":"Para fins de auditoria","From":"De","From BitPay account":"De conta BitPay","From Hardware Wallet":"De uma Carteira de Hardware","From the destination device, go to Add wallet &gt; Import wallet and scan this QR code":"Do dispositivo de destino, go em Adicionar Carteira &gt; Importar Carteira e faa a varredura do cdigo QR","Funds are locked by pending spend proposals":"O saldo est bloqueado por um pedido de gasto pendente","Funds found:":"Saldos encontrados:","Funds to be added":"Fundos a ser adicionado","Funds transferred":"Saldos transferidos","Funds were added to debit card":"Os fundos foram adicionados ao carto de dbito","Funds will be transferred to":"Os saldos sero transferidos para","Generate new address":"Gerar novo endereo","Generating .csv file...":"Gerando arquivo .csv...","Generating new address...":"Gerando novo endereo...","Get local cash anywhere you go, from any Visa<sup></sup> compatible ATM. ATM bank fees may apply.":"Sacar dinheiro em qualquer lugar que voc v, de qualquer Caixa Eletrnico Visa<sup>&reg;</sup> compatvel. Tarifas bancrias podem ser geradas.","Get news and updates from BitPay":"Receba notcias e atualizaes da BitPay","Get started":{"button":"Comear","$$noContext":"Comear"},"Get started by adding your first one.":"Comece adicionando o primeiro.","Getting fee levels...":"Obtendo nveis de taxa...","Gift Card is not available to use anymore":"Vale-presente no est mais disponvel para uso","Gift card":"Vale-presente","Gift card expired":"Vale-presente expirado","Gift card generated and ready to use.":"Vale-presente gerado e pronto para uso.","Go Back":"Retroceder","Go back":"Retroceder","Got it":"Compreendi","Hardware Wallet":"Carteira de hardware","Hardware not connected.":"Hardware no conectado.","Hardware wallet":"Carteira de hardware","Hardware wallets are not yet supported with Bitcoin Cash":"Carteiras de hardware ainda no so suportadas com Bitcoin Cash","Help & Support":"Ajuda e suporte","Help and support information is available at the website.":"Informaes de Ajuda e Suporte esto disponveis no site.","Hide":"Esconder","Hide Balance":"Esconder saldos","Hide Next Steps Card":"Esconder prximo passo do carto","Hide advanced options":"Ocultar opes avanadas","Home":"Incio","How could we improve your experience?":"Como poderamos melhorar sua experincia?","How do you like {{appName}}?":"Como voc gosta do {{appName}}?","I don't like it":"Eu no gosto","I have read, understood, and agree to the <a ng-click=\"openTerms()\" translate=\"\">Terms of Use</a>.":"Li, entendi e concordo com os <a ng-click=\"openTerms()\" translate=\"\">Termos de uso</a>.","I have read, understood, and agree with the Terms of use.":"Eu li, entendi,  concordo com os Termos de uso.","I have written it down":"Eu escrevi isso","I like the app":"Eu gosto da aplicao","I think this app is terrible.":"Acho que esta aplicao  terrvel.","I understand":"Eu compreendi","I understand that if this app is moved to another device or deleted, my bitcoin can only be recovered with the backup phrase.":"Eu entendi que se esse aplicativo for movido para outro dispositivo ou deletado, meus bitcoins s podem ser recuperados com frase de backup.","I understand that my funds are held securely on this device, not by a company.":"Eu entendi que meu saldo so mantidos em segurana neste dispositivo e no por uma empresa.","I've written it down":"J escrevi isso","If enabled, all sensitive information (private key and recovery phrase) and actions (spending and exporting) associated with this wallet will be protected.":"Se habilitado, todas as informaes sensveis (chave privada e frase de recuperao) e aes (gastos e exportaes) associados  essa carteira ser protegido.","If enabled, the Recent Transactions card - a list of transactions occuring across all wallets - will appear in the Home tab.":"Se habilitado, o Carto de Transaes - Lista todas as transaes que ocorreram em todas as Carteiras - aparecer na aba Incio.","If enabled, wallets will also try to spend unconfirmed funds. This option may cause transaction delays.":"Se habilitado, as carteiras iro tentar gastar fundos no confirmados. Est opo pode causar atrasos de transaes.","If this device is replaced or this app is deleted, neither you nor BitPay can recover your funds without a backup.":"Se esse dispositivo  substitudo ou este aplicativo deletado, nem voc nem a BitPay poder recuperar seus fundos sem um backup.","If you have additional feedback, please let us know by tapping the \"Send feedback\" option in the Settings tab.":"Se voc tem sugestes adicionais, por favor, informe-nos atravs da opo \"Enviar Sugestes\" na Aba Configuraes.","If you take a screenshot, your backup may be viewed by other apps. You can make a safe backup with physical paper and a pen.":"Se voc fizer uma Captura de tela, seu backup poder ser visto por outros aplicativos. Voc pode fazer um backup fsico com um papel e caneta.","Import":"Importar","Import Wallet":"Importar carteira","Import backup":"Importar backup","Import wallet":"Importar carteira","Importing Wallet...":"A importar a carteira...","In order to verify your wallet backup, please type your password.":"A fim de verificar o seu backup de carteira, por favor, digite sua senha.","Inactive":"Inativo","Incomplete":"Incompleto","Incomplete wallet":"Carteira incompleta","Incorrect PIN, try again.":"PIN incorreto, tente novamente.","Incorrect code format":"Formato de cdigo incorreto","Incorrect network address":"Endereo de rede incorreto","Insufficient funds":"Fundos insuficientes","Insufficient funds for fee":"Fundos insuficientes para taxa","Invalid":"Invlido","Invalid URL":"URL invlida","Invalid account number":"Nmero de conta invlido","Invalid address":"Endereo invlido","Invalid data":"Dados invlidos","Invalid derivation path":"Caminho de derivao invlido","Invitation to share a {{appName}} Wallet":"Convite para compartilhar a Carteira {{appName}}","Invoice expired":"Fatura expirada","Is there anything we could do better?":"H algo mais que podemos ajudar?","Is this correct?":"Isto est correto?","Is this email address correct?":"Este endereo de e-mail est correto?","It's a good idea to avoid reusing addresses - this both protects your privacy and keeps your bitcoins secure against hypothetical attacks by quantum computers.":" uma boa ideia evitar a reutilizao de endereos - isto tambm protege a sua privacidade e mantm seus bitcoins seguros, contra provveis ataques de computadores qunticos.","It's important that you write your backup phrase down correctly. If something happens to your wallet, you'll need this backup to recover your money. Please review your backup and try again.":" importante que voc escreva sua frase backup corretamente. Se algo acontecer a sua carteira, voc vai precisar deste backup para recuperar seu dinheiro. Por favor, revise seu backup e tente novamente.","Join":"Participar","Join my {{appName}} Wallet. Here is the invitation code: {{secret}} You can download {{appName}} for your phone or desktop at {{appUrl}}":"Junte-se a minha Carteira {{appName}}. Aqui est o cdigo de convite: {{secret}} voc pode baixar {{appName}} para seu celular ou desktop em {{appUrl}}","Join shared wallet":"Associando carteira compartilhada","Joining Wallet...":"Associando-se a Carteira","Just scan the code to pay.":"Apenas digitalize o cdigo para pagar.","Key already associated with an existing wallet":"Chave j associada com uma carteira existente","Language":"Idioma","Last Month":"Ms anterior","Learn more":"Saiba mais","Let's verify your backup phrase.":"Vamos verificar a sua frase de backup.","Loading addresses...":"A carregar endereos...","Loading transaction info...":"A carregar informao da transao...","Lock App":"Bloquear aplicativo","Lock by Fingerprint":"Bloquear por impresso digital","Lock by PIN":"Bloquear por PIN","Locked":"Bloqueado","Locktime in effect. Please wait to create a new spend proposal":"Bloqueio de tempo em ao. Por favor, espere para criar uma nova proposta de gasto.","Locktime in effect. Please wait to remove this spend proposal":"Bloqueio de tempo em ao. Por favor espere para remover esta proposta de gasto.","Log options":"Opes de log","Log out":"Sair","Low amount inputs":"Quantidade de entrada baixa","Low fees":"Baixas taxas","Makes sense":"Faz sentido","Matches:":"Correspondncias:","Me":"Eu","Meh - it's alright":"Meh - est tudo bem","Memo":"Nota","Mercado Livre Brazil Gift Cards":"Vales-presente do Mercado Livre Brasil","Mercadolibre Gift Card Service is not available at this moment. Please try back later.":"Servio de Vale-Presente Mercado Livre no est disponvel neste momento. Por favor, tente mais tarde.","Merchant Message":"Mensagem Publicitria","Miner Fee":"Taxa do Minerador","Missing parameter":"Parmetro em falta","Missing private keys to sign":"Faltam chaves privadas para assinar","More Options":"Mais opes","Moved":"Movido","Moved Funds":"Valores transferidos","Multiple recipients":"Vrios destinatrios","NOTE: To import a wallet from a 3rd party software, please go to Add Wallet &gt; Create Wallet, and specify the Recovery Phrase there.":"Nota: Para importar uma carteira de software de terceiros, por favor, v para: Adicionar carteira, Criar Carteira, e ento especifique a frase de recuperao.","Name":"Nome","Network Cost":"Custo de rede","Network error":"Erro de rede","New Proposal":"Nova proposta","New address could not be generated. Please try again.":"Novo endereo no pode ser gerado. Por favor tente novamente","New personal wallet":"Nova carteira pessoal","Next steps":"Prximos passos","No Wallet":"Sem carteira","No access key defined":"Nenhuma chave de acesso definida","No backup, no bitcoin.":"Sem backup, sem bitcoin.","No contacts yet":"Ainda no existem contactos","No entries for this log level":"No h entradas para este nvel de log","No hardware information available.":"Nenhuma informao de hardware disponvel.","No hardware wallets supported on this device":"No h carteiras de hardware com suporte neste dispositivo","No pending proposals":"Sem propostas pendentes","No recent transactions":"No h transaes recentes","No signing proposal: No private key":"Nenhuma proposta de assinatura: Nenhuma chave privada","No transactions yet":"Nenhuma transao ainda","No wallet found":"Carteira no encontrada","No wallet selected":"Sem carteira selecionada","No wallets available":"No h carteiras disponveis","No wallets available to receive funds":"Nenhuma Carteira disponvel para receber fundos","No wallets eligible for Bitcoin Cash support":"Sem carteiras elegveis para suporte a Bitcoin Cash","Non eligible BTCZ wallets":"Carteiras BTCZ no elegveis","Normal":"Normal","Not authorized":"No autorizada","Not enough funds for fee":"No h fundos para taxa","Not even BitPay can access it.":"Nem mesmo Bitpay pode acessar isso.","Not funds found":"Nenhum fundo encontrado","Not now":"Agora no","Note":"Nota","Notice: only 1-1 (single signature) wallets can be used for sell bitcoin":"Aviso: Apenas Carteiras 1-1 (de assinatura nica) podem ser usadas para vender bitcoins","Notifications":"Notificaes","Notifications by email":"Notificaes por e-mail","Notify me if confirmed":"Me informe se confirmado","Notify me when transactions are confirmed":"Notificar-me quando as transaes so confirmadas","Now is a good time to backup your wallet. If this device is lost, it is impossible to access your funds without a backup.":"Agora  uma boa hora para fazer backup de sua carteira. Se este dispositivo for perdido,  impossvel acessar seus fundos sem um backup.","Now is a perfect time to assess your surroundings. Nearby windows? Hidden cameras? Shoulder-spies?":"Agora  a hora perfeita para olhar em volta. Prximo de janelas? Cmeras escondidas? Espio atrs do ombro?","OK":"OK","OKAY":"OK","Official English Disclaimer":"Aviso Legal Oficial em Ingls","Oh no!":"Oh no!","Ok":"Ok","On this screen you can see all your wallets, accounts, and assets.":"Nesta tela voc pode ver todas as suas carteiras, contas e ativos.","Open":"Abrir","Open Crowdin":"Abrir Crowdin","Open GitHub":"Abrir GitHub","Open GitHub Project":"Abrir Projeto no GitHub","Open Insight":"Abrir Insight","Open Settings":"Abrir definies","Open Translation Community":"Abrir Comunidade de Traduo","Open Website":"Abrir Site","Open bitcoincash.org?":"Abrir bitcoincash.org?","Open wallet":"Abrir Carteira","Open website":"Abrir pgina da Web","Order the BitPay Card":"Solicitar o Carto Bitpay","Password":"Senha","Password required. Make sure to enter your password in advanced options":"Necessrio Senha. Certifique-se de digitar sua senha em opes avanadas","Paste invitation here":"Cole o convite aqui","Paste the backup plain text code":"Cole o texto puro do backup aqui","Pay 0% fees to turn bitcoin into dollars.":"Pague taxas de 0% para transformar bitcoin em dlar.","Pay To":"Pagar Para","Payment Accepted":"Pagamento Aceito","Payment Expires:":"Pagamento expirado:","Payment Proposal":"Proposta de Pagamento","Payment Proposal Created":"Proposta de Pagamento Criada","Payment Proposals":"Propostas de Pagamento","Payment Protocol Invalid":"Protocolo de Pagamento Invlido","Payment Protocol not supported on Chrome App":"Protocolo de pagamento no suportado no Chrome App","Payment Received":"Pagamento Recebido","Payment Rejected":"Pagamento Rejeitado","Payment Sent":"Pagamento Enviado","Payment accepted, but not yet broadcasted":"Pagamento aceito, mas ainda no publicado","Payment accepted. It will be broadcasted by Glidera. In case there is a problem, it can be deleted 6 hours after it was created.":"Pagamento aceito. Ele ser publicado por Glidera. Em caso de problema, pode ser deletado at 6 horas depois de criado.","Payment address was translated to new Bitcoin Cash address format:":"Endereo de pagamento foi traduzido para o novo formato de endereo Bitcoin Cash:","Payment details":"Detalhes do pagamento","Payment request":"Pedido de pagamento","Pending":"Pendente","Pending Proposals":"Proposta pendente","Permanently delete this wallet.":"Excluir permanentemente esta carteira.","Personal Wallet":"Carteira Pessoal","Please carefully write down this phrase.":"Por favor, anote esta frase com cuidado.","Please connect a camera to get started.":"Por favor conecte uma cmera para iniciar.","Please enter the recovery phrase":"Por favor, digite a frase de recuperao","Please enter the wallet recovery phrase":"Por favor, digite a frase de recuperao da carteira","Please enter your PIN":"Introduza o seu PIN","Please tap each word in the correct order.":"Por favor escolhe cada palavra na ordem correta.","Please upgrade Copay to perform this action":"Por favor atualize Copay para executar esta ao","Please wait":"Por favor aguarde","Please, select your backup file":"Por favor, selecione seu arquivo de backup","Pre-Auth Holds":"Bloqueio Pr-Autorizao","Preferences":"Preferncias","Preparing addresses...":"A preparar os endereos...","Preparing backup...":"A preparar o backup...","Press again to exit":"Pressione novamente para sair","Priority":"Prioridade","Private Key":"Chave Privada","Private key encrypted. Enter password":"Chave privada criptografada. Digite a senha","Private key is encrypted, cannot sign":"A Chave privada est criptografada, no  possvel acessar","Proposal Accepted":"Proposta aceite","Proposal Created":"Proposta criada","Proposal Deleted":"Proposta eliminada","Proposal Rejected":"Proposta rejeitada","Proposals":"Propostas","Purchase Amount is limited to {{limitPerDay}} {{currency}} per day":"Valor da compra  limitado a {{limitPerDay}} {{currency}} por dia","Purchase amount must be a value between 50 and 2000":"Valor da compra deve ser um valor entre 50 e 2000","Push Notifications":"Notificaes","Push notifications for {{appName}} are currently disabled. Enable them in the Settings app.":"Notificaes de push para {{appName}} esto desativadas no momento. Habilite nas Configuraes do aplicativo.","QR Code":"Cdigo QR","Quick review!":"Avaliao rpida!","Random":"Aleatrio","Rate on the app store":"Avalie-nos na App Store","Read less":"Ler menos","Read more":"Ler mais","Read more in our Wiki":"Leia mais em nosso Wiki","Receive":"Receber","Receive in":"Receber em","Received":"Recebido","Received Funds":"Valores recebidos","Receiving":"A receber","Recent":"Recente","Recent Transaction Card":"Transaes recentes do carto","Recent Transactions":"Transaes recentes","Recipient":"Destinatrio","Recipients":"Destinatrios","Recovery phrase":"Frase de recuperao","Recreating Wallet...":"Recriando Carteira","Redeem now":"Resgatar agora","Rejected":"Rejeitado","Rejecting payment proposal":"Proposta de pagamento recusada","Release information":"Informao de lanamento","Remove":"Remover","Remove BitPay Account?":"Remover conta do BitPay?","Remove BitPay Card?":"Remover carto do BitPay?","Removing your BitPay account will remove all associated BitPay account data from this device. Are you sure you would like to remove your BitPay Account ({{email}}) from this device?":"Remover sua conta BitPay remover todos os dados da conta associada ao BitPay neste dispositivo. Tem certeza que quer remover sua conta BitPay ({{email}}) deste dispositivo?","Repeat password":"Repetir Senha","Repeat the password":"Repita a nova senha","Request Fingerprint":"Solicitao de impresso digital","Request Specific amount":"Solicitar quantia exata","Request Spending Password":"Solicitar senha de pagamento","Required number of signatures":"Nmero necessrio de assinaturas","Restore from backup":"Restaurar do backup","Retrieving inputs information":"Recuperando informaes de entradas","Retry":"Repetir","Retry Camera":"Tentar Camera novamente","Save":"Salvar","Scan":"Digitalizar","Scan QR Codes":"Digitalizar cdigos QR","Scan addresses for funds":"Pesquisando endereos por fundos","Scan again":"Escanear novamente","Scan your fingerprint please":"Escaneie sua impresso digital, por favor","Scan your wallets for Bitcoin Cash":"Pesquisar suas carteiras por Bitcoin Cash","Scanning Wallet funds...":"Pesquisando fundos de carteira","Scanning funds...":"Pesquisando fundos...","Screenshots are not secure":"Capturas de Tela no so seguras","Search Transactions":"Procurar transaes","Search or enter bitcoin address":"Procure ou digite o endereo bitcoin","Search transactions":"Procurar transaes","Search your currency":"Procure a sua moeda","Security":"Segurana","See invoice":"Ver fatura","Select a backup file":"Selecione um arquivo de backup","Select a wallet":"Selecione uma carteira","Self-signed Certificate":"Certificado Auto-Assinado","Selling Bitcoin...":"Vendendo Bitcoin...","Send":"Enviar","Send Feedback":"Enviar Sugesto","Send Money":"Enviar Dinheiro","Send addresses by email":"Enviar endereos por e-mail","Send by email":"Enviar por E-mail","Send from":"Enviar De","Send max amount":"Quantidade Mxima de envio","Send payment to this address":"Enviar pagamento para este endereo","Send us feedback instead":"Em vez disso, Envie-nos comentrios","Sending":"Enviando","Sending 2FA code...":"Enviando cdigo 2FA...","Sending feedback...":"Enviando sugesto...","Sending maximum amount":"Quantidade mxima de envio","Sending transaction":"Enviando transao","Sending {{amountStr}} from your {{name}} wallet":"Enviando {{amountStr}} de sua carteira {{name}}","Sent":"Enviado","Sent Funds":"Enviar Fundos","Server response could not be verified":"Resposta do servidor no pde ser verificada","Service not available":"Servio indisponvel","Services":"Servios","Session Log":"Log da sesso","Session log":"Log da sesso","Set up a password":"Configure uma senha","Set your own fee in satoshis/byte":"Defina sua prpria taxa em satoshis/byte","Settings":"Configuraes","Share the love by inviting your friends.":"Compartilhe o amor convidando seus amigos.","Share this invitation with your copayers":"Compartilhe este convite com seus copayers","Share {{appName}}":"Compartilhar {{appName}}","Shared Wallet":"Compartilhar Carteira","Show Recovery Phrase":"Mostrar Frase de Recuperao","Show address":"Mostrar endereo","Show advanced options":"Mostrar opes avanadas","Show bitcoin address":"Mostrar endereo bitcoin","Show more":"Mostrar mais","Signatures rejected by server":"Assinaturas rejeitadas pelo servidor","Signing transaction":"Assinando Transao","Since only you control your money, youll need to save your backup phrase in case this app is deleted.":"Uma vez que s voc controla o seu dinheiro, voc precisar salvar sua frase de backup no caso deste app ser excludo.","Single Address Wallet":"nico endereo carteira","Skip":"Pular","Slide to accept":"Deslize para aceitar","Slide to buy":"Deslize para comprar","Slide to pay":"Deslize para pagar","Slide to send":"Deslize para enviar","Specify Recovery Phrase...":"Especifique a frase de recuperao...","Spend proposal is not accepted":"A proposta de gasto no  aceita","Spend proposal not found":"Proposta de pagamento no encontrada","Spending Password needed":"Digitar a senha  necessria","Spending this balance will need significant Bitcoin network fees":"Gastar este balano necessitar uma taxa de rede Bitcoin significativa","Start sending bitcoin":"Comece a enviar bitcoin","Startup Lock":"Bloqueio de Inicializao","Still pending":"Ainda pendente","Success":"Sucesso","Super Economy":"Super Econmico","Support Bitcoin Cash":"Suportar Bitcoin Cash","Sweep":"Limpar","Sweep paper wallet":"Varrer a carteira de papel","Sweeping Wallet...":"Carteira de varredura...","THIS ACTION CANNOT BE REVERSED":"ESTA AO NO PODE SER REVERTIDA","Take control of your money,<br>get started with bitcoin.":"Assuma o controle de seu dinheiro, <br> comear com bitcoin.","Tap and hold to show":"Toque e mantenha para mostrar","Tap to recreate":"Toque para recriar","Tap to retry":"Bata para repetir","Terms Of Use":"Termos de uso","Terms of Use":"Termos de uso","Testnet":"Testnet","Text":"Texto","Thank you!":"Obrigado!","Thanks!":"Obrigado!","That's exciting to hear. We'd love to earn that fifth star from you  how could we improve your experience?":"Isso  emocionante de ouvir. Gostaramos de ganhar essa quinta estrela de voc - como poderamos melhorar sua experincia?","The Ledger Chrome application is not installed":"O aplicativo Ledger Chrome no est instalado","The amount of bitcoin immediately spendable from this wallet.":"A quantidade de bitcoin imediatamente spendable desta carteira.","The amount of bitcoin stored in this wallet that is allocated as inputs to your pending transaction proposals. The amount is determined using unspent transaction outputs associated with this wallet and may be more than the actual amounts associated with your pending transaction proposals.":"A quantidade de bitcoin armazenada nesta carteira que  alocada como entradas para suas propostas de transao pendentes. O valor  determinado usando sadas de transao no utilizadas associadas a essa carteira e podem ser maiores do que os valores reais associados s suas propostas de transaes pendentes.","The amount of bitcoin stored in this wallet with less than 1 blockchain confirmation.":"A quantidade de bitcoin armazenada nesta carteira com menos de 1 confirmao blockchain.","The derivation path":"O caminho de derivao","The exchange rate changes with the market.":"A taxa de cmbio muda com o mercado.","The higher the fee, the greater the incentive a miner has to include that transaction in a block. Current fees are determined based on network load and the selected policy.":"Quanto maior a taxa, maior o incentivo um mineiro tem que incluir essa transao em um bloco. As taxas atuais so determinadas com base na carga da rede e na poltica selecionada.","The maximum number of consecutive unused addresses (20) has been reached. When one of your unused addresses receives a payment, a new address will be generated and shown in your Receive tab.":"O nmero mximo de endereos no utilizados consecutivos (20) foi atingido. Quando um de seus endereos no utilizados recebe um pagamento, um novo endereo ser gerado e mostrado na sua guia Receber.","The official English Terms of Service are available on the BitPay website.":"Os Termos de Servio oficiais esto disponveis no site BitPay.","The password of the recovery phrase (if set)":"A senha da frase de recuperao (se configurada)","The payment was created but could not be completed. Please try again from home screen":"O pagamento foi criado mas no pode ser completado. Por favor, tente novamente a partir da tela inicial.","The payment was removed by creator":"O pagamento foi removido pelo criador","The recovery phrase could require a password to be imported":"A frase de recuperao pode exigir que uma senha seja importada","The request could not be understood by the server":"O pedido no pde ser entendido pelo servidor","The restore process will stop when 20 addresses are generated in a row which contain no funds. To safely generate more addresses, make a payment to one of the unused addresses which has already been generated.":"O processo de restaurao ir parar quando 20 endereos so gerados em uma linha que no contm fundos. Para gerar segurana mais endereos, fazer um pagamento a um dos endereos no utilizados que j foi gerado.","The spend proposal is not pending":"A proposta de gasto no est pendente","The total amount of bitcoin stored in this wallet.":"A quantidade total de bitcoin armazenado nesta carteira.","The transaction history and every new incoming transaction are cached in the app. This feature clean this up and synchronizes again from the server":"O histrico de transaes e todas as novas transaes recebidas so armazenados em cache no aplicativo. Este recurso limpa isso e sincroniza novamente a partir do servidor","The wallet service URL":"O URL do servio carteira","There is a new version of {{appName}} available":"Existe uma nova verso do {{appName}} disponvel","There is an error in the form":"Existe um erro no formulrio","There's obviously something we're doing wrong.":"Obviamente h algo que estamos fazendo de errado.","This app is fantastic!":"Esta aplicao  fantstica!","This app stores your bitcoin with cutting-edge security.":"Este aplicativo armazena seu bitcoin com segurana de ponta.","This bitcoin payment request has expired.":"Este bitcoin pagamento pedido expirou.","This password cannot be recovered. If the password is lost, there is no way you could recover your funds.":"Esta senha no pode ser recuperada. Se a senha for perdida, no h nenhuma maneira que voc poderia recuperar seus fundos.","This recovery phrase was created with a password. To recover this wallet both the recovery phrase and password are needed.":"Esta frase de recuperao foi criada com uma senha. Para recuperar esta carteira, tanto a frase de recuperao como a senha so necessrias.","This transaction amount is too small compared to current Bitcoin network fees. Spending these funds will need a Bitcoin network fee cost comparable to the funds itself.":"Este valor de transao  muito pequeno em comparao com as taxas de rede Bitcoin atuais. Gastar estes fundos tero uma taxa de rede Bitcoin maior do que o fundo em si.","This transaction could take a long time to confirm or could be dropped due to the low fees set by the sender":"Esta operao poder demorar muito tempo para ser confirmada ou poder ser descartada devido s baixas taxas definidas pelo remetente","This wallet is not registered at the given Bitcore Wallet Service (BWS). You can recreate it from the local information.":"Esta carteira no est registrada no dado servio Wallet Service Bitcore (BWS) informado. Voc pode recri-la a partir da informao local.","Timeline":"Cronograma","To":"Para","To get started, buy bitcoin or share your address. You can receive bitcoin from any wallet or service.":"Para comear, compre bitcoins ou compartilhe seu endereo. Voc pode receber bitcoins de qualquer carteira ou servio.","To get started, you'll need to create a bitcoin wallet and get some bitcoin.":"Para comear, voc precisa criar uma carteira de bitcoins e obter alguns bitcoins.","To {{reason}} you must first add your BitPay account - {{email}}":"Para {{reason}} voc deve primeiro adicionar sua conta BitPay - {{email}}","Top up in progress...":"Recarga em andamento...","Top up {{amountStr}} to debit card ({{cardLastNumber}})":"Recarga de {{amountStr}} para carto de dbito ({{cardLastNumber}})","Total":"Total","Total Locked Balance":"Saldo Total Bloqueado","Total number of copayers":"Nmero total de copayers","Total wallet inputs":"Total de entradas da carteira","Touch ID Failed":"Falha no Touch ID","Transaction":"Transao","Transaction Created":"Transao Criada","Transaction History":"Histrico de Transaes","Transaction already broadcasted":"Transao foi publicada","Transaction has not been created":"Transao no foi criada","Transaction initiated":"Transao iniciada","Transaction not available at this time":"Transao no est disponvel neste momento","Transaction not found":"Transao no encontrada","Transactions without fee are not supported.":"Transaes sem taxa no so suportadas.","Transfer to":"Transferir para","Transfer to Wallet":"Transferir para carteira","Try again in {{expires}}":"Tente novamente em {{expires}}","Turn bitcoin into dollars, swipe anywhere Visa<sup></sup> is accepted.":"Transforme bitcoin em dlares, deslize em qualquer lugar que Visa <sup>&reg;</sup> seja aceito.","Type the Recovery Phrase (usually 12 words)":"Digite a frase de recuperao (normalmente 12 palavras)","Uh oh...":"Uh oh...","Unconfirmed":"No confirmado","Unsent transactions":"Transaes no enviadas","Unused Addresses":"Endereos no utilizados","Unused Addresses Limit":"Limite de endereos no utilizados","Update Available":"Atualizao Disponvel","Updating pending proposals. Please stand by":"Atualizando propostas pendentes. Por favor, aguarde","Updating transaction history. Please stand by.":"Atualizando o histrico de transaes. Por favor, aguarde.","Updating... Please stand by":"Atualizando... Por favor, aguarde","Urgent":"Urgente","Use Unconfirmed Funds":"Utilizar fundos no confirmados","Validating recovery phrase...":"Validando a frase de recuperao...","Verify your identity":"Verifique a sua identidade","Version":"Verso","View":"Ver","View All Addresses":"Ver todos os endereos","View Terms of Service":"Ver os Termos de Servio","View Transaction on Insight":"Exibir Transao no Insight","View Update":"Ver atualizaes","View on blockchain":"Ver no blockchain","Visit mercadolivre.com.br &rarr;":"Visite mercadolivre.com.br &rarr;","WARNING: Key derivation is not working on this device/wallet. Actions cannot be performed on this wallet.":"Aviso: Derivao de chave no est funcionando neste dispositivo/carteira. Aes no podem ser executadas nesta carteira.","WARNING: Not including the private key allows to check the wallet balance, transaction history, and create spend proposals from the export. However, does not allow to approve (sign) proposals, so <b>funds will not be accessible from the export</b>.":"ATENO: No incluir a chave privada permite verificar o saldo da carteira, o histrico de transaes e criar propostas de gastos a partir da exportao. No entanto, no permite aprovar (assinar) propostas, assim <b>fundos no sero acessveis a partir da exportao</b>.","WARNING: The private key of this wallet is not available. The export allows to check the wallet balance, transaction history, and create spend proposals from the export. However, does not allow to approve (sign) proposals, so <b>funds will not be accessible from the export</b>.":"ATENO: A chave privada desta carteira no est disponvel. A exportao permite verificar o saldo da carteira, o histrico de transaes e criar propostas de gastos a partir da exportao. No entanto, no permite aprovar (assinar) propostas, assim <b>fundos no sero acessveis a partir da exportao</b>.","WARNING: UNTRUSTED CERTIFICATE":"AVISO: CERTIFICADO NO CONFIVEL","Waiting for Ledger...":"Esperando por Ledger...","Waiting for Trezor...":"Esperando por Trezor...","Waiting for copayers":"Aguardando copayers","Waiting...":"Aguardando","Wallet Addresses":"Endereos da carteira","Wallet Color":"Cor da carteira","Wallet Configuration (m-n)":"Configurao da carteira (m-n)","Wallet Created":"Carteira criada","Wallet Id":"Id da carteira","Wallet Information":"Informaes da carteira","Wallet Inputs":"Entradas da carteira","Wallet Invitation":"Convite para Carteira","Wallet Key":"Chave da carteira","Wallet Name":"Nome da carteira","Wallet Name (at creation)":"Nome da carteira (na criao)","Wallet Network":"Network da carteira","Wallet Recovery Phrase":"Frase de recuperao da carteira","Wallet Recovery Phrase is invalid":"Frase de recuperao da carteira  invlida","Wallet Service URL":"URL do servio de carteira","Wallet Settings":"Configuraes da carteira","Wallet Type":"Tipo da carteira","Wallet already exists":"A carteira j existe","Wallet already in {{appName}}":"Carteira j existente no {{appName}}","Wallet created":"Carteira criada","Wallet incomplete and broken":"Carteira incompleta e quebrada","Wallet is full":"Carteira est cheia","Wallet is locked":"Carteira est bloqueada","Wallet is not complete":"Carteira no est completa","Wallet name":"Nome da carteira","Wallet needs backup":"Carteira precisa de backup","Wallet not backed up":"Carteira sem backup","Wallet not found":"Carteira no encontrada","Wallet not registered":"Carteira no registrada","Wallet not registered at the wallet service. Recreate it from \"Create Wallet\" using \"Advanced Options\" to set your recovery phrase":"Carteira no registrada no servio de carteira. Recri-la em \"Criar carteira\" usando \"Opes avanadas\" para definir a sua frase de recuperao","Wallet recovery phrase not available.":"Frase de recuperao da carteira no disponvel.","Wallet service not found":"Servio de carteira no encontrado","Wallets":"Carteiras","Wallets & Integrations":"Carteiras & Integraes","Warning!":"Ateno!","Warning: this transaction has unconfirmed inputs":"Aviso: esta transao tem entradas no confirmadas","Watch out!":"Cuidado!","We'd love to do better.":"Ns adoraramos fazer melhor.","We'll confirm on the next screen.":"Confirmaremos na prxima tela.","We're always looking for ways to improve {{appName}}.":"Estamos sempre procurando maneiras de melhorar o {{appName}}.","We're always looking for ways to improve {{appName}}. How could we improve your experience?":"Estamos sempre procurando maneiras de melhorar o {{appName}}. Como melhorar sua experincia?","Website":"Pgina da Web","Were always looking for translation contributions! You can make corrections or help to make this app available in your native language by joining our community on Crowdin.":"Estamos sempre procurando por contribuies de traduo! Voc pode fazer correes ou ajudar a tornar este app disponvel em seu idioma nativo ao aderir  nossa comunidade na Crowdin.","What do you call this wallet?":"Como voc chama essa carteira?","When this wallet was created, it was called {{walletName}}. You can change the name displayed on this device below.":"Quando esta carteira foi criada, foi chamada de &ldquo;{{walletName}}&rdquo;. Abaixo voc poder alterar o nome exibido neste dispositivo.","Where would you like to receive email notifications about payments?":"Onde voc gostaria de receber os e-mails de notificaes sobre os pagamentos?","Why?":"Por qu?","Would you be willing to rate {{appName}} in the app store?":"Voc estaria disposto a dar uma nota ao {{appName}} na app store?","Would you like to receive push notifications about payments?":"Gostaria de receber notificaes push sobre pagamentos?","Wrong number of recovery words:":"Nmero errado de palavras de recuperao:","Wrong spending password":"Senha de gastos errada","Yes":"Sim","Yes, skip":"Sim, pule","You can create a backup later from your wallet settings.":"Voc poder criar um backup de suas configuraes de carteira mais tarde.","You can make contributions by signing up on our Crowdin community translation website. Were looking forward to hearing from you!":"Voc pode fazer contribuies inscrevendo-se no nosso site da comunidade de traduo Crowdin. Estamos ansiosos para ouvir de voc!","You can scan bitcoin addresses, payment requests, paper wallets, and more.":"Voc pode escanear endereos bitcoins, pedidos de pagamento carteiras de papel e muito mais.","You can see the latest developments and contribute to this open source app by visiting our project on GitHub.":"Voc pode ver os mais recentes desenvolvimentos e contribuir para este aplicativo de cdigo aberto, visitando nosso projeto no GitHub.","You can spend bitcoin at millions of websites and stores worldwide.":"Voc pode gastar bitcoins em milhes de sites e lojas em todo o mundo.","You can still export it from Advanced &gt; Export.":"Voc ainda pode export-la em Avanado &gt; Exportar.","You can trade it for other currencies like US Dollars, Euros, or Pounds.":"Voc pode troc-lo por outras moedas como dlares americanos, Euros ou libras.","You control your bitcoin.":"Voc controla o seu bitcoin.","You should not set a fee higher than {{maxFeeRecommended}} satoshis/byte.":"Voc no deve definir uma taxa maior do que {{maxFeeRecommended}} satoshis/byte.","You will need to log back for fill in your BitPay Card.":"Voc precisar entrar de novo para completar seu BitPay Card.","You'll receive email notifications about payments sent and received from your wallets.":"Voc receber notificaes por e-mail sobre pagamentos enviados e recebidos de suas carteiras.","Your BitPay Card is ready. Add funds to your card to start using it at stores and ATMs worldwide.":"Seu BitPay Card est pronto. Adicione fundos ao seu carto para comear a us-lo em lojas e caixas eletrnicos em todo o mundo.","Your Gift Cards":"Seus Vales-presente","Your bitcoin wallet is backed up!":"O backup de sua carteira de bitcoins est feito!","Your bitcoin wallet is ready!":"Sua carteira de bitcoins est pronta!","Your fee is lower than recommended.":"Sua taxa  mais baixa do que a recomendada.","Your ideas, feedback, or comments":"Suas ideias, comentrios ou observaes","Your name":"Seu nome","Your nickname":"Seu apelido","Your password":"Sua senha","Your purchase could not be completed":"Sua compra no pde ser concluda","Your purchase was added to the list of pending":"Sua compra foi adicionada  lista de pendncias","Your wallet is never saved to cloud storage or standard device backups.":"Sua carteira nunca foi salva num armazenamento em nuvem ou dispositivo padro de backups.","Your wallet key will be encrypted. The Spending Password cannot be recovered. Be sure to write it down.":"Sua chave da carteira ser criptografada. A senha de gastos no poder ser recuperada. No se esquea de anot-la.","[Balance Hidden]":"[Valores escondidos]","[Scanning Funds]":"[Pesquisando fundos]","add your BitPay Visa card(s)":"Adicionar seu(s) carto(es) BitPay Visa","locked by pending payments":"bloqueado por pagamentos pendentes","me":"eu","name@example.com":"nome@exemplo.pt","preparing...":"a preparar...","{{amountStr}} for Amazon.com Gift Card":"{{amountStr}} em Vale-presente da Amazon.com","{{amountStr}} for Mercado Livre Brazil Gift Card":"{{amountStr}} em Vale-presente do Mercado Livre Brasil","{{appName}} depends on Bitcore Wallet Service (BWS) for blockchain information, networking and Copayer synchronization. The default configuration points to https://bws.bitpay.com (BitPay's public BWS instance).":"{{appName}} depende do Bitcore Wallet Service (BWS) para informaes sobre cadeias de blocos, rede e sincronizao Copayer. A configurao padro aponta para https://bws.bitpay.com (instncia pblica BWS do BitPay).","{{fee}} will be deducted for bitcoin networking fees.":"{{fee}} ser deduzido para taxas de rede bitcoins.","{{tx.txp[wallet.id].feeRatePerStr}}  of the sending amount":"{{tx.txp[wallet.id].feeRatePerStr}} da quantidade de envio","{{updatingTxHistoryProgress}} transactions downloaded":"Transaes de {{updatingTxHistoryProgress}} transferidas","{{wallet.m}}-of-{{wallet.n}}":"{{wallet.m}}-de-{{wallet.n}}"});
    gettextCatalog.setStrings('ru', {"(Trusted)":"()","(possible double spend)":"(  )","* A payment proposal can be deleted if 1) you are the creator, and no other copayer has signed, or 2) 24 hours have passed since the proposal was created.":"*       1)          ,  2)    24     .","- {{btx.feeRateStr}} of the transaction":"{{feeRateStr}} ","5-star ratings help us get {{appName}} into more hands, and more users means more resources can be committed to the app!":"=896t7!","A member of the team will review your feedback as soon as possible.":"       .","A total of {{amountAboveMaxSizeStr}} were excluded. The maximum size allowed for a transaction was exceeded.":" {{amountAboveMaxSizeStr}}  .   ,   .","A total of {{amountBelowFeeStr}} were excluded. These funds come from UTXOs smaller than the network fee provided.":":    {{amountBelowFeeStr}}  .      UTXOs    .","About":" ","Accepted":"","Account":" ","Account Number":"  ","Accounts":"","Activity":"","Add Account":"  ","Add BitPay Account?":"L; pkoi[jpiouhouihuiykjb jvgbgyfcthgfvjyuhnij; okml',./; lkmjnhbg v?","Add Contact":" ","Add Funds":" ","Add Memo":" ","Add a password":" ","Add account":"gfhcdtgfdth","Add an optional password to secure the recovery phrase":"      ","Add as a contact":" ","Add description":" ","Add funds":" ","Add wallet":" ","Address":"","Address Book":"A ","Address Type":" ","Addresses With Balance":"  ","Advanced":" ","Advanced Settings":" ","All":"","All Addresses":" ","All of your bitcoin wallet balance may not be available for immediate spending.":"            .","All signing devices must be added to this multisig wallet before bitcoin addresses can be created.":"        ,      .","Allow Camera Access":"   ","Allow notifications":" ","Almost done! Let's review.":" !  .","Alternative Currency":" ","Amount":"","Amount below minimum allowed":"   ","Amount too big":"  ","An update to this app is available. For your security, please update to the latest version.":" .    , ,    .","Anyone with your backup phrase can access or spend your bitcoin.":",        ,    .","Are you being watched?":"   - ?","Are you being watched? Anyone with your recovery phrase can access or spend your bitcoin.":"  ?             .","Are you sure you want to cancel and delete this wallet?":"       ?","Are you sure you want to delete this contact?":"     ?","Are you sure you want to delete this wallet?":"     ?","Are you sure you want to reject this transaction?":"     ?","Are you sure you want to remove this transaction?":"     ?","Are you sure you want to skip it?":"     ?","Are you sure you would like to remove your BitPay Card ({{lastFourDigits}}) from this device?":" ,       BitPay Card ({{lastFourDigits}})   ?","Auditable":"","Available":"","Available Balance":" ","Average confirmation time":"  ","BIP32 path for address derivation":" BIP32   ","Backup":" ","Backup Needed":"  ","Backup all livenet wallets before using this function":"    livenet     ","Backup needed":"  ","Backup now":"  ","Backup wallet":" ","Backup your wallet before using this function":"        ","Bad wallet invitation":" ","Balance By Address":"  ","Be sure to store your recovery phrase in a secure place. If this app is deleted, your money cannot be recovered without it.":"      .  {{appName}}  ,        .","BitPay Visa Cards":"BitPay Visa llllll","Bitcoin Address":"-","Bitcoin Network Fee Policy":"   ","Bitcoin is a currency.":" -  .","Bitcoin is different  it cannot be safely held with a bank or web service.":"Bitcoin is different &ndash; it cannot be safely held with a bank or web service.","Bitcoin is secure,<br>digital money.":"  ,<br> .","Bitcoin transactions include a fee collected by miners on the network.":"Bitcoin transactions include a fee collected by miners on the network.","Broadcast Payment":" ","Broadcasted":"","Broadcasting transaction":" ","Browser unsupported":"  ","Buy":"","Buy &amp; Sell Bitcoin":" &amp;  ","Buy Bitcoin":" ","Buy a Gift Card":"  ","Buy from":"","Buying Bitcoin...":" ...","Calculating fee":" ","Cancel":"","Cancel invitation":" ?","Cannot Create Wallet":"   ","Cannot join the same wallet more that once":"          ","Cards":"","Certified by":"","Check installation and retry.":"    .","Choose a backup file from your computer":"   ","Choose your destination wallet":"  ","Choose your source wallet":"  ","Clear":"","Clear cache":" ","Click to accept":"","Click to pay":"","Click to send":"","Close":"","Color":"","Commit hash":" ","Complete the backup process to use this option":"       ","Completed":"","Confirm":"","Confirm &amp; Finish":" &amp; ","Confirm purchase":" ","Confirm your PIN":"  PIN-","Confirm your new spending password":"    ","Confirmations":"","Confirming":" ","Connect my BitPay Card":"  BitPay Card","Connecting to Coinbase...":"  Coinbase...","Connecting to Glidera...":"  Glidera...","Connection reset by peer":"   ","Contacts":"","Continue":"","Contribute Translations":"  ","Copayer already in this wallet":"   ","Copayer already voted on this spend proposal":"     ","Copayer data mismatch":"   ","Copayer joined":" ","Copayer {{$index}}":" {{$index}}","Copied to clipboard":"   ","Copy this text as it is to a safe place (notepad or email)":"     (   )","Copy to clipboard":"   ","Could not access the wallet at the server. Please check:":"       . , :","Could not access wallet":"     ","Could not add message to imported wallet without shared encrypting key":"          ","Could not broadcast payment":"   ","Could not build transaction":"   ","Could not create address":"   ","Could not create using the specified extended private key":"       ","Could not create using the specified extended public key":"       ","Could not create: Invalid wallet recovery phrase":"  :   ","Could not decrypt file, check your password":"   ,  ","Could not delete payment proposal":"    ","Could not get dynamic fee":"    ","Could not get dynamic fee for level: {{feeLevel}}":"      : {{feeLevel}}","Could not get transactions":"   ","Could not import":"  ","Could not import. Check input file and spending password":"  .      ","Could not join wallet":"    ","Could not reject payment":"   ","Could not remove account":"   ","Could not remove card":"   ","Could not save preferences on the server":"     ","Could not send payment":"   ","Could not update transaction history":"    ","Could not update wallet":"   ","Create Personal Wallet":"  ","Create Shared Wallet":"  ","Create bitcoin wallet":" -","Create new wallet":"  ","Create shared wallet":"  ","Create {{formData.requiredCopayers}}-of-{{formData.totalCopayers}} wallet":"  {{formData.requiredCopayers}}--{{formData.totalCopayers}}","Created by":"","Creating Wallet...":" ...","Creating transaction":" ","Current fee rate for this policy":"    ","Custom Amount":"","Date":"","Delete":"","Delete Payment Proposal":"  ","Delete Wallet":" ","Delete it and create a new one":"   ","Deleting Wallet...":" ...","Deleting payment proposal":"  ","Derivation Path":" ","Derivation Strategy":" ","Details":"","Disabled":"","Do it later":"","Do not include private key":"   ","Don't see your language on Crowdin? Contact the Owner on Crowdin! We'd love to support your language.":"     Crowdin?     Crowdin!      .","Download":"","Each bitcoin wallet can generate billions of addresses from your 12-word backup. A new address is automatically generated and shown each time you receive a payment.":" -        .      ,    .","Economy":"","Edit":"","Email":"Email","Email Address":"Email","Empty addresses limit reached. New addresses cannot be generated.":"   .       .","Enable camera access in your device settings to get started.":" ,        .","Enable email notifications":" email-","Enable push notifications":" push-","Enable the camera to get started.":" ,  .","Enabled":"","Enter Spending Password":"  ","Enter Two Factor for your BitPay account":"      BitPay","Enter amount":" ","Enter new spending password":"   ","Enter the recovery phrase (BIP39)":"   (BIP39)","Enter your email":"  email","Enter your password":" ","Error":"","Error at confirm":"  ","Error creating gift card":"   ","Error creating wallet":"  ","Error scanning funds:":"  :","Error sweeping wallet:":"  :","Error updating Debit Cards":"   ","Exceeded daily limit of $500 per user":"    500$  ","Expired":"","Expires":"","Export Wallet":" ","Export to file":"  ","Export wallet":" ","Exporting via QR not supported for this wallet":" QR-     ","Extended Public Keys":"  ","Failed to export":"  ","Family vacation funds":" ","Fee":"","Fee:":":","Feedback could not be submitted. Please try again later.":"    . ,  .","Fetching BitPay Account...":"   BitPay...","File/Text":"/","Filter setting":" ","Finger Scan Failed":"    ","Finish":"","For audit purposes":"  ","From":"","From BitPay account":"  BitPay","From the destination device, go to Add wallet &gt; Import wallet and scan this QR code":"    \" \" &gt; \" \"    QR-","Funds are locked by pending spend proposals":"   ","Funds found:":" :","Funds transferred":" ","Funds will be transferred to":"   ","Generate new address":"  ","Generating .csv file...":" .sv-...","Generating new address...":"  ...","Get local cash anywhere you go, from any Visa<sup></sup> compatible ATM. ATM bank fees may apply.":"   ,       Visa<sup>&reg;</sup>.    .","Get news and updates from BitPay":"     BitPay","Get started":{"button":"","$$noContext":""},"Get started by adding your first one.":",   .","Getting fee levels...":"   ...","Gift card":" ","Go Back":"","Go back":"","Got it":"","Hardware Wallet":" ","Hardware not connected.":"   .","Hardware wallet":" ","Help & Support":"  ","Help and support information is available at the website.":"       .","Hide":"","Hide Balance":" ","Hide Next Steps Card":"  ","Hide advanced options":"  ","Home":"","How could we improve your experience?":"     ?","How do you like {{appName}}?":"   {{appName}}?","I don't like it":"  ","I have read, understood, and agree to the <a ng-click=\"openTerms()\" translate=\"\">Terms of Use</a>.":" , ,    <a ng-click=\"openTerms()\" translate=\"\"> </a>.","I have read, understood, and agree with the Terms of use.":" , ,     .","I have written it down":" ","I like the app":" ","I think this app is terrible.":" .","I understand":" ","I understand that if this app is moved to another device or deleted, my bitcoin can only be recovered with the backup phrase.":" ,   {{appName}}     ,  ,         .","I understand that my funds are held securely on this device, not by a company.":" ,       ,   .","I've written it down":" ","If enabled, all sensitive information (private key and recovery phrase) and actions (spending and exporting) associated with this wallet will be protected.":" ,    (     )   (  )      .","If enabled, the Recent Transactions card - a list of transactions occuring across all wallets - will appear in the Home tab.":"   ,          .","If enabled, wallets will also try to spend unconfirmed funds. This option may cause transaction delays.":"   , {{appName}}     ,       .","If this device is replaced or this app is deleted, neither you nor BitPay can recover your funds without a backup.":"    ,   {{appName}}  ,  ,  BitPay          .","If you have additional feedback, please let us know by tapping the \"Send feedback\" option in the Settings tab.":"   -   , ,  \" \"   .","If you take a screenshot, your backup may be viewed by other apps. You can make a safe backup with physical paper and a pen.":"   ,        .     -   .","Import":"","Import Wallet":" ","Import backup":"  ","Import wallet":" ","Importing Wallet...":" ...","In order to verify your wallet backup, please type your password.":"      .","Incomplete":"   ","Incomplete wallet":"   ","Incorrect PIN, try again.":" PIN-,  .","Incorrect code format":"  QR-","Insufficient funds":" ","Insufficient funds for fee":"   ","Invalid":"","Invalid URL":" URL","Invalid account number":"   ","Invalid address":" ","Invalid data":" ","Invalid derivation path":"  ","Invitation to share a {{appName}} Wallet":"    {{appName}}","Is there anything we could do better?":"  -,      ?","Is this correct?":"?","Is this email address correct?":"  email?","It's a good idea to avoid reusing addresses - this both protects your privacy and keeps your bitcoins secure against hypothetical attacks by quantum computers.":"    -                .","It's important that you write your backup phrase down correctly. If something happens to your wallet, you'll need this backup to recover your money. Please review your backup and try again.":"      .       ,  -    . ,      .","Join":"","Join my {{appName}} Wallet. Here is the invitation code: {{secret}} You can download {{appName}} for your phone or desktop at {{appUrl}}":"    {{appName}}.  : {{secret}}    {{appName}}         {{appUrl}}","Join shared wallet":"   ","Joining Wallet...":"  ...","Just scan the code to pay.":"     QR-.","Key already associated with an existing wallet":"     ","Language":"","Last Month":" ","Let's verify your backup phrase.":"    .","Loading addresses...":" ...","Loading transaction info...":" ...","Lock App":" ","Lock by Fingerprint":"  ","Lock by PIN":" PIN-","Locked":"","Locktime in effect. Please wait to create a new spend proposal":" . , ,    ","Locktime in effect. Please wait to remove this spend proposal":" . , ,    ","Log out":"B","Low fees":" ","Makes sense":" ","Matches:":":","Me":"","Meh - it's alright":" , ","Memo":"","Merchant Message":"  ","Missing parameter":" ","Missing private keys to sign":"    ","More Options":" ","Moved":"","Moved Funds":" ","Multiple recipients":" ","NOTE: To import a wallet from a 3rd party software, please go to Add Wallet &gt; Create Wallet, and specify the Recovery Phrase there.":":        \" \" &gt; \"  \",     .","Name":"","Network error":" ","New Proposal":" ","New address could not be generated. Please try again.":"    .  .","New personal wallet":"  ","Next steps":" ","No Wallet":" ","No backup, no bitcoin.":"   -  .","No contacts yet":" ","No hardware information available.":"    .","No hardware wallets supported on this device":"      ","No pending proposals":"  ","No recent transactions":"  ","No transactions yet":"   ","No wallet found":"  ","No wallet selected":"  ","No wallets available to receive funds":"  ","Normal":"","Not authorized":" ","Not enough funds for fee":"    ","Not even BitPay can access it.":"BitPay     .","Not funds found":"C  ","Not now":"","Note":"","Notice: only 1-1 (single signature) wallets can be used for sell bitcoin":":  1-1  (  )      ","Notifications":"","Now is a good time to backup your wallet. If this device is lost, it is impossible to access your funds without a backup.":"    ,         .     .","Now is a perfect time to assess your surroundings. Nearby windows? Hidden cameras? Shoulder-spies?":"   .  ?  ? ?","OK":"","OKAY":"","Official English Disclaimer":" ","Oh no!":", !","On this screen you can see all your wallets, accounts, and assets.":"        ,    .","Open":"","Open Crowdin":" Crowdin","Open GitHub":" GitHub","Open GitHub Project":"  GitHub","Open Insight":" Insight","Open Settings":" ","Open Translation Community":" ","Open Website":"  ","Open wallet":" ","Open website":" ","Order the BitPay Card":" BitPay Card","Password":"","Password required. Make sure to enter your password in advanced options":" . ,        ","Paste invitation here":"  ","Paste the backup plain text code":"     ","Pay 0% fees to turn bitcoin into dollars.":"        .","Pay To":" ","Payment Accepted":" ","Payment Expires:":" :","Payment Proposal":" ","Payment Proposal Created":" ","Payment Proposals":" ","Payment Protocol Invalid":"  ","Payment Protocol not supported on Chrome App":"      Chrome","Payment Received":" ","Payment Rejected":" ","Payment Sent":" ","Payment accepted, but not yet broadcasted":" ,    ","Payment accepted. It will be broadcasted by Glidera. In case there is a problem, it can be deleted 6 hours after it was created.":"     Glidera.            .","Payment details":" ","Payment request":" ","Pending Proposals":" ","Permanently delete this wallet.":"   .","Personal Wallet":" ","Please carefully write down this phrase.":"   .","Please connect a camera to get started.":" ,  .","Please enter the recovery phrase":"  ","Please enter the wallet recovery phrase":"   ","Please enter your PIN":",   PIN-","Please tap each word in the correct order.":"     .","Please upgrade Copay to perform this action":",  Copay    ","Please wait":", ","Please, select your backup file":",     ","Preferences":"","Preparing addresses...":" ...","Preparing backup...":"  ...","Press again to exit":"    ","Priority":"","Private Key":" ","Private key encrypted. Enter password":"  .  ","Private key is encrypted, cannot sign":"  ,   ","Proposal Accepted":" ","Proposal Created":" ","Proposal Deleted":" ","Proposal Rejected":" ","Proposals":" ","Push Notifications":"Push-","Push notifications for {{appName}} are currently disabled. Enable them in the Settings app.":"Push-  {{appName}}    .    .","QR Code":"QR-","Quick review!":" !","Random":"","Rate on the app store":"   ","Read less":" ","Read more":" ","Receive":"","Received":"","Received Funds":" ","Receiving":"","Recent":"","Recent Transaction Card":" ","Recent Transactions":" ","Recipient":"","Recipients":"","Recovery phrase":" ","Recreating Wallet...":" ...","Rejected":"","Rejecting payment proposal":" ","Release information":"  ","Remove":"","Remove BitPay Account?":" BitPay ?","Remove BitPay Card?":" BitPay ?","Removing your BitPay account will remove all associated BitPay account data from this device. Are you sure you would like to remove your BitPay Account ({{email}}) from this device?":"   BitPay       BitPay   .  ,       BitPay  ({{email}})   ?","Repeat password":" ","Repeat the password":" ","Request Fingerprint":"  ","Request Specific amount":"  ","Request Spending Password":"  ","Required number of signatures":"  ","Restore from backup":"   ","Retrieving inputs information":"   ","Retry":" ","Retry Camera":" ","Save":"","Scan":"","Scan QR Codes":" QR-","Scan addresses for funds":"    ","Scan your fingerprint please":",    ","Scanning Wallet funds...":"  ...","Screenshots are not secure":"  ","Search Transactions":" ","Search or enter bitcoin address":"   -","Search transactions":" ","Search your currency":"  ","Security":"","Select a backup file":"   ","Select a wallet":" ","Self-signed Certificate":" ","Selling Bitcoin...":" ...","Send":"","Send Feedback":" ","Send Money":" ","Send addresses by email":"   email","Send by email":"  email","Send from":" ","Send max amount":" . ","Send us feedback instead":"   ","Sending":"","Sending 2FA code...":"  ...","Sending feedback...":" ...","Sending maximum amount":"  ","Sending transaction":" ","Sending {{amountStr}} from your {{name}} wallet":" {{amountStr}}    {{name}}","Sent":"","Sent Funds":" ","Server response could not be verified":"     ","Services":"","Session Log":" ","Session log":" ","Set up a password":" ","Settings":"","Share the love by inviting your friends.":"    .","Share this invitation with your copayers":"   ","Share {{appName}}":" {{appName}}","Shared Wallet":" ","Show Recovery Phrase":"   ","Show address":" ","Show advanced options":"  ","Show bitcoin address":" -","Show more":" ","Signatures rejected by server":"  ","Signing transaction":" ","Since only you control your money, youll need to save your backup phrase in case this app is deleted.":"      ,         {{appName}}.","Single Address Wallet":"   ","Skip":"","Specify Recovery Phrase...":"  ...","Spend proposal is not accepted":"  ","Spend proposal not found":"  ","Spending Password needed":"  ","Start sending bitcoin":"  bitcoin","Startup Lock":"  ","Success":"","Super Economy":" ","Sweep":"","Sweep paper wallet":"   ","Sweeping Wallet...":" ...","THIS ACTION CANNOT BE REVERSED":"     ","Take control of your money,<br>get started with bitcoin.":"    ,<br>  .","Tap and hold to show":"  ,  ","Tap to retry":"","Terms Of Use":" ","Terms of Use":" ","Testnet":"Testnet","Text":"","Thank you!":"!","Thanks!":"!","The Ledger Chrome application is not installed":" Ledger  Chrome  ","The amount of bitcoin immediately spendable from this wallet.":"     .","The amount of bitcoin stored in this wallet that is allocated as inputs to your pending transaction proposals. The amount is determined using unspent transaction outputs associated with this wallet and may be more than the actual amounts associated with your pending transaction proposals.":" ,        .    ,    ,    ,    .","The amount of bitcoin stored in this wallet with less than 1 blockchain confirmation.":"   ,   .","The derivation path":" ","The higher the fee, the greater the incentive a miner has to include that transaction in a block. Current fees are determined based on network load and the selected policy.":"  ,        .           .","The official English Terms of Service are available on the BitPay website.":"         BitPay.","The password of the recovery phrase (if set)":"   ( )","The payment was created but could not be completed. Please try again from home screen":"  ,     . ,       ","The payment was removed by creator":"    ","The recovery phrase could require a password to be imported":"      ","The request could not be understood by the server":"   ","The spend proposal is not pending":"     ","The total amount of bitcoin stored in this wallet.":"    .","The wallet service URL":"  Bitcore","There is a new version of {{appName}} available":"   {{appName}}","There is an error in the form":"  ","This app is fantastic!":" !","This bitcoin payment request has expired.":"   .","This recovery phrase was created with a password. To recover this wallet both the recovery phrase and password are needed.":"      .         .","This wallet is not registered at the given Bitcore Wallet Service (BWS). You can recreate it from the local information.":"       Bitcore.       .","Timeline":"","To":"","To get started, buy bitcoin or share your address. You can receive bitcoin from any wallet or service.":"  ,      .         .","To get started, you'll need to create a bitcoin wallet and get some bitcoin.":"  ,       .","Total":" ","Total Locked Balance":"  ","Total number of copayers":" ","Touch ID Failed":" Touch ID","Transaction":"","Transaction History":" ","Transaction already broadcasted":"  ","Transaction not available at this time":"    ","Transaction not found":"  ","Transfer to":" ","Transfer to Wallet":"  ","Try again in {{expires}}":"   {{expires}}","Turn bitcoin into dollars, swipe anywhere Visa<sup></sup> is accepted.":"     -  ,    Visa<sup>&reg;</sup>.","Type the Recovery Phrase (usually 12 words)":"   (  )","Uh oh...":"...","Unconfirmed":"","Unsent transactions":" ","Unused Addresses":" ","Unused Addresses Limit":"  ","Update Available":" ","Updating pending proposals. Please stand by":"   . , ","Updating transaction history. Please stand by.":"  . , .","Updating... Please stand by":"... , ","Urgent":"","Use Unconfirmed Funds":"  ","Validating recovery phrase...":"  ...","Verify your identity":" ","Version":"","View":"","View All Addresses":"  ","View Terms of Service":"  ","View Transaction on Insight":"   Insight","View Update":" ","View on blockchain":"  ","WARNING: Key derivation is not working on this device/wallet. Actions cannot be performed on this wallet.":":       /.         .","WARNING: Not including the private key allows to check the wallet balance, transaction history, and create spend proposals from the export. However, does not allow to approve (sign) proposals, so <b>funds will not be accessible from the export</b>.":":      ,     ,     . ,       ()  ,  <b>      </b>.","WARNING: The private key of this wallet is not available. The export allows to check the wallet balance, transaction history, and create spend proposals from the export. However, does not allow to approve (sign) proposals, so <b>funds will not be accessible from the export</b>.":":     .      ,     . ,       ()  ,  <b>      </b>.","WARNING: UNTRUSTED CERTIFICATE":":  ","Waiting for Ledger...":" Ledger...","Waiting for Trezor...":" Trezor...","Waiting for copayers":"  ","Waiting...":"...","Wallet Addresses":" ","Wallet Color":" ","Wallet Configuration (m-n)":"  (m-n)","Wallet Created":" ","Wallet Id":" ","Wallet Information":"  ","Wallet Invitation":"   ","Wallet Key":" ","Wallet Name":" ","Wallet Name (at creation)":"  ( )","Wallet Network":" ","Wallet Recovery Phrase":"  ","Wallet Recovery Phrase is invalid":"   ","Wallet Service URL":"  Bitcore","Wallet Settings":" ","Wallet Type":" ","Wallet already exists":"  ","Wallet created":" ","Wallet incomplete and broken":"   ,  ","Wallet is full":"  ","Wallet is locked":" ","Wallet is not complete":"   ","Wallet name":" ","Wallet needs backup":"   ","Wallet not backed up":"   ","Wallet not found":"  ","Wallet not registered":"  ","Wallet not registered at the wallet service. Recreate it from \"Create Wallet\" using \"Advanced Options\" to set your recovery phrase":"     Bitcore.     ,    ","Wallet recovery phrase not available.":"  .","Wallet service not found":" Bitcore  ","Wallets":"","Wallets & Integrations":"  ","Warning!":"!","Warning: this transaction has unconfirmed inputs":":     ","Watch out!":"!","We'd love to do better.":"    .","We'll confirm on the next screen.":"   .","We're always looking for ways to improve {{appName}}.":"     {{appName}}.","Website":"","What do you call this wallet?":"    ?","When this wallet was created, it was called {{walletName}}. You can change the name displayed on this device below.":"    ,   &ldquo;{{walletName}}&rdquo;.      .","Where would you like to receive email notifications about payments?":"     email-  ?","Why?":"?","Would you like to receive push notifications about payments?":"    push-  ?","Wrong number of recovery words:":"     :","Wrong spending password":"  ","Yes":"","Yes, skip":", ","You can create a backup later from your wallet settings.":"        .","You can scan bitcoin addresses, payment requests, paper wallets, and more.":"   -,  ,  ,   .","You can still export it from Advanced &gt; Export.":"       &gt; .","You control your bitcoin.":"   bitcoin-.","You'll receive email notifications about payments sent and received from your wallets.":"   email-     .","Your Gift Cards":"  ","Your bitcoin wallet is backed up!":"   !","Your bitcoin wallet is ready!":"  !","Your ideas, feedback, or comments":" ,   ","Your name":" ","Your nickname":" ","Your password":" ","Your wallet is never saved to cloud storage or standard device backups.":"            .","Your wallet key will be encrypted. The Spending Password cannot be recovered. Be sure to write it down.":"   .    .   .","[Balance Hidden]":"[ ]","add your BitPay Visa card(s)":"  BitPay Visa ()","locked by pending payments":"  ","me":"","name@example.com":"name@example.com","preparing...":"...","{{appName}} depends on Bitcore Wallet Service (BWS) for blockchain information, networking and Copayer synchronization. The default configuration points to https://bws.bitpay.com (BitPay's public BWS instance).":"{{appName}}  Bitcore        . -   https://bws.bitpay.com (  Bitcore  BitPay).","{{fee}} will be deducted for bitcoin networking fees.":"{{fee}}     .","{{updatingTxHistoryProgress}} transactions downloaded":"{{updatingTxHistoryProgress}}  ","{{wallet.m}}-of-{{wallet.n}}":"{{wallet.m}}--{{wallet.n}}"});
    gettextCatalog.setStrings('zh', {"(Trusted)":"","(possible double spend)":"","* A payment proposal can be deleted if 1) you are the creator, and no other copayer has signed, or 2) 24 hours have passed since the proposal was created.":"*  1)  copayer  2) 24 ","- {{btx.feeRateStr}} of the transaction":"-{{btx.feeRateStr}} ","- {{tx.feeRateStr}} of the transaction":"-{{tx.feeRateStr}} ","5-star ratings help us get {{appName}} into more hands, and more users means more resources can be committed to the app!":"5 , {{appName}} !","<b>Only</b> redeemable on Mercado Livre (Brazil)":"<b>Only</b>  ()","A member of the team will review your feedback as soon as possible.":"","A total of {{amountAboveMaxSizeStr}} were excluded. The maximum size allowed for a transaction was exceeded.":"{{amountAboveMaxSizeStr}} ","A total of {{amountBelowFeeStr}} were excluded. These funds come from UTXOs smaller than the network fee provided.":"{{amountBelowFeeStr}}  UTXOs ","About":"","Accepted":"","Account":"","Account Number":"","Accounts":"","Activity":"","Add Account":"","Add BitPay Account?":" BitPay ","Add Contact":"","Add Funds":"","Add Memo":"","Add a password":"","Add account":"","Add an optional password to secure the recovery phrase":"","Add as a contact":"","Add description":"","Add funds":"","Add this BitPay account ({{email}})?":"BitPay:{{email}} ","Add wallet":"","Address":"","Address Book":"","Address Type":"","Addresses With Balance":"","Advanced":"","Advanced Settings":"","All":"","All Addresses":"","All of your bitcoin wallet balance may not be available for immediate spending.":"","All signing devices must be added to this multisig wallet before bitcoin addresses can be created.":"","Allow Camera Access":"","Allow notifications":"","Almost done! Let's review.":" ","Alternative Currency":"","Amazon.com is not available at this moment. Please try back later.":"","Amount":"","Amount below minimum allowed":"","Amount too big":"","Amount too low to spend":"","An update to this app is available. For your security, please update to the latest version.":"","Anyone with your backup phrase can access or spend your bitcoin.":"","Approximate Bitcoin network fee to transfer wallet's balance (with normal priority)":" ()","Are you being watched?":"","Are you being watched? Anyone with your recovery phrase can access or spend your bitcoin.":"","Are you sure you want to cancel and delete this wallet?":"","Are you sure you want to delete this contact?":"","Are you sure you want to delete this wallet?":"","Are you sure you want to reject this transaction?":"","Are you sure you want to remove this transaction?":"","Are you sure you want to skip it?":"","Are you sure you would like to log out of your BitPay Card account?":"BitPay Card","Are you sure you would like to remove your BitPay Card ({{lastFourDigits}}) from this device?":" BitPay  ({{lastFourDigits}})","Auditable":"","Available":"","Available Balance":"","Average confirmation time":"","BIP32 path for address derivation":"BIP32 ","Backup":"","Backup Needed":"","Backup all livenet wallets before using this function":"","Backup needed":"","Backup now":"","Backup wallet":"","Backup your wallet before using this function":"","Bad wallet invitation":"","Balance By Address":"","Be sure to store your recovery phrase in a secure place. If this app is deleted, your money cannot be recovered without it.":"","BitPay Visa Cards":"BitPay Visa&reg; ","Bitcoin Address":"","Bitcoin Network Fee Policy":"","Bitcoin is a currency.":"","Bitcoin is different  it cannot be safely held with a bank or web service.":"    web ","Bitcoin is secure,<br>digital money.":" <br>","Bitcoin transactions include a fee collected by miners on the network.":"","Bought {{amountUnitStr}}":"{{amountUnitStr}}","Broadcast Payment":"","Broadcasted":"","Broadcasting transaction":"","Browser unsupported":"","Buy":"","Buy &amp; Sell Bitcoin":"","Buy Bitcoin":"","Buy a Gift Card":"","Buy from":"","Buying Bitcoin...":" ...","Calculating fee":"","Cancel":"","Cancel invitation":"","Cannot Create Wallet":"","Cannot join the same wallet more that once":"","Cards":"","Certified by":"","Check installation and retry.":"","Choose a backup file from your computer":"","Choose your destination wallet":"","Choose your source wallet":"","Clear":"","Clear cache":"","Close":"","Color":"","Commit hash":"","Complete the backup process to use this option":"","Completed":"","Confirm":"","Confirm &amp; Finish":"","Confirm purchase":"","Confirm your PIN":"PIN","Confirm your new spending password":"","Confirmations":"","Confirming":"","Connect my BitPay Card":" BitPay ","Connecting to Coinbase...":" Coinbase...","Connecting to Glidera...":" Glidera...","Connection reset by peer":"","Contacts":"","Continue":"","Contribute Translations":"","Copayer already in this wallet":"Copayer ","Copayer already voted on this spend proposal":"Copayer ","Copayer data mismatch":"Copayer ","Copayer joined":"Copayer ","Copayer {{$index}}":"Copayer {{$index}}","Copied to clipboard":"","Copy this text as it is to a safe place (notepad or email)":"","Copy to clipboard":"","Could not access Gift Card Service":"","Could not access the wallet at the server. Please check:":"","Could not access to Amazon.com":"","Could not access wallet":"","Could not add message to imported wallet without shared encrypting key":"","Could not broadcast payment":"","Could not build transaction":"","Could not create address":"","Could not create the invoice":"","Could not create transaction":"","Could not create using the specified extended private key":"","Could not create using the specified extended public key":"","Could not create: Invalid wallet recovery phrase":"  ","Could not decrypt file, check your password":"","Could not delete payment proposal":"","Could not get dynamic fee":"","Could not get dynamic fee for level: {{feeLevel}}":" {{feeLevel}}","Could not get fee levels":"","Could not get the invoice":"","Could not get transactions":"","Could not import":"","Could not import. Check input file and spending password":"","Could not join wallet":"","Could not reject payment":"","Could not remove account":"","Could not remove card":"","Could not save preferences on the server":"","Could not send payment":"","Could not send transaction":"","Could not update transaction history":"","Could not update wallet":"","Create Personal Wallet":"","Create Shared Wallet":"","Create bitcoin wallet":"","Create new wallet":"","Create shared wallet":"","Create {{formData.requiredCopayers}}-of-{{formData.totalCopayers}} wallet":" {{formData.requiredCopayers}} {{formData.totalCopayers}} ","Created by":":","Creating Wallet...":"...","Creating transaction":"","Current fee rate for this policy":"","Custom":"","Custom Amount":"","Custom Fee":"","Date":"","Delete":"","Delete Payment Proposal":"","Delete Wallet":"","Delete it and create a new one":"","Deleting Wallet...":"...","Deleting payment proposal":"","Derivation Path":"","Derivation Strategy":"","Details":"","Disabled":"","Do it later":"","Do not include private key":"","Don't see your language on Crowdin? Contact the Owner on Crowdin! We'd love to support your language.":" Crowdin  Crowdin ","Download":"","Each bitcoin wallet can generate billions of addresses from your 12-word backup. A new address is automatically generated and shown each time you receive a payment.":" 12 ","Economy":"","Edit":"","Email":"","Email Address":"","Empty addresses limit reached. New addresses cannot be generated.":"","Enable camera access in your device settings to get started.":"","Enable email notifications":"","Enable push notifications":"","Enable the camera to get started.":"","Enter Spending Password":"","Enter Two Factor for your BitPay account":" BitPay ","Enter amount":"","Enter custom fee":"","Enter new spending password":"","Enter the recovery phrase (BIP39)":" (BIP39)","Enter your email":"","Enter your password":"","Error":"","Error at confirm":"","Error creating gift card":"","Error creating the invoice":"","Error creating wallet":"","Error getting SendMax information":"SendMax","Error in Payment Protocol":"","Error pairing BitPay Account":" BitPay ","Error scanning funds:":"","Error sweeping wallet:":"","Error updating Debit Cards":"","Exceeded daily limit of $500 per user":" 500 ","Expired":"","Expires":"","Export Wallet":"","Export to file":"","Export wallet":"","Exporting via QR not supported for this wallet":" QR ","Extended Public Keys":"","Extracting Wallet information...":"...","Failed to export":"","Family vacation funds":"","Fee":"","Fee level":"","Fee level is not defined":"","Fee:":":","Feedback could not be submitted. Please try again later.":"","Fetching BitPay Account...":" BitPay ...","Fetching payment information":"","File/Text":"/","Filter setting":"","Finger Scan Failed":"","Finish":"","For audit purposes":"","From":"","From BitPay account":" BitPay ","From Hardware Wallet":"","From the destination device, go to Add wallet &gt; Import wallet and scan this QR code":" &gt;  QR ","Funds are locked by pending spend proposals":"","Funds found:":"","Funds to be added":"","Funds transferred":"","Funds were added to debit card":"","Funds will be transferred to":"","Generate new address":"","Generating .csv file...":" .csv ...","Generating new address...":"...","Get local cash anywhere you go, from any Visa<sup></sup> compatible ATM. ATM bank fees may apply.":" Visa<sup></sup>  ATM ","Get news and updates from BitPay":" BitPay ","Get started":{"button":"","$$noContext":""},"Get started by adding your first one.":"","Getting fee levels...":"...","Gift Card is not available to use anymore":"","Gift card":"","Gift card expired":"","Gift card generated and ready to use.":"","Go Back":"\t#","Go back":"","Got it":"","Hardware Wallet":"","Hardware not connected.":"","Hardware wallet":"","Help & Support":"","Help and support information is available at the website.":"&","Hide":"","Hide Balance":"","Hide Next Steps Card":"","Hide advanced options":"","Home":"","How could we improve your experience?":"","How do you like {{appName}}?":" {{appName}}","I don't like it":"","I have read, understood, and agree to the <a ng-click=\"openTerms()\" translate=\"\">Terms of Use</a>.":"  <a ng-click=\"openTerms()\"translate=\"\"> </a>","I have read, understood, and agree with the Terms of use.":" ","I have written it down":"","I like the app":"","I think this app is terrible.":"","I understand":"","I understand that if this app is moved to another device or deleted, my bitcoin can only be recovered with the backup phrase.":"","I understand that my funds are held securely on this device, not by a company.":"","I've written it down":"","If enabled, all sensitive information (private key and recovery phrase) and actions (spending and exporting) associated with this wallet will be protected.":",()  ().","If enabled, the Recent Transactions card - a list of transactions occuring across all wallets - will appear in the Home tab.":"--","If enabled, wallets will also try to spend unconfirmed funds. This option may cause transaction delays.":"","If this device is replaced or this app is deleted, neither you nor BitPay can recover your funds without a backup.":" BitPay ","If you have additional feedback, please let us know by tapping the \"Send feedback\" option in the Settings tab.":"\"\"","If you take a screenshot, your backup may be viewed by other apps. You can make a safe backup with physical paper and a pen.":"","Import":"","Import Wallet":"","Import backup":"","Import wallet":"","Importing Wallet...":"...","In order to verify your wallet backup, please type your password.":"","Inactive":"","Incomplete":"","Incomplete wallet":"","Incorrect PIN, try again.":"PIN","Incorrect code format":"","Incorrect network address":"","Insufficient funds":"","Insufficient funds for fee":"","Invalid":"","Invalid URL":"URL","Invalid account number":"","Invalid address":"","Invalid data":"","Invalid derivation path":"","Invitation to share a {{appName}} Wallet":" {{appName}} ","Invoice expired":"","Is there anything we could do better?":"","Is this correct?":"","Is this email address correct?":"","It's a good idea to avoid reusing addresses - this both protects your privacy and keeps your bitcoins secure against hypothetical attacks by quantum computers.":"   ","It's important that you write your backup phrase down correctly. If something happens to your wallet, you'll need this backup to recover your money. Please review your backup and try again.":"","Join":"","Join my {{appName}} Wallet. Here is the invitation code: {{secret}} You can download {{appName}} for your phone or desktop at {{appUrl}}":" {{appName}}  {{secret}}  {{appUrl}} {{appName}}","Join shared wallet":"","Joining Wallet...":"...","Just scan the code to pay.":"","Key already associated with an existing wallet":"","Language":"","Last Month":"","Let's verify your backup phrase.":"","Loading addresses...":"...","Loading transaction info...":"...","Lock App":"","Lock by Fingerprint":"","Lock by PIN":"PIN","Locked":"","Locktime in effect. Please wait to create a new spend proposal":"Locktime ","Locktime in effect. Please wait to remove this spend proposal":"Locktime ","Log options":"","Log out":"","Low amount inputs":"","Low fees":"","Makes sense":"","Matches:":"","Me":"","Meh - it's alright":"-","Memo":"","Mercado Livre Brazil Gift Cards":"","Mercadolibre Gift Card Service is not available at this moment. Please try back later.":"","Merchant Message":"","Missing parameter":"","Missing private keys to sign":"","More Options":"","Moved":"","Moved Funds":"","Multiple recipients":"","NOTE: To import a wallet from a 3rd party software, please go to Add Wallet &gt; Create Wallet, and specify the Recovery Phrase there.":" &gt; ","Name":"","Network error":"","New Proposal":"","New address could not be generated. Please try again.":"","New personal wallet":"","Next steps":"","No Wallet":"","No access key defined":"","No backup, no bitcoin.":"","No contacts yet":"","No entries for this log level":"","No hardware information available.":"","No hardware wallets supported on this device":"","No pending proposals":"","No recent transactions":"","No signing proposal: No private key":" ","No transactions yet":"","No wallet found":"","No wallet selected":"","No wallets available":"","No wallets available to receive funds":"","Normal":"","Not authorized":"","Not enough funds for fee":"","Not even BitPay can access it.":" BitPay ","Not funds found":"","Not now":"","Note":"","Notice: only 1-1 (single signature) wallets can be used for sell bitcoin":"  1-1  ","Notifications":"","Notifications by email":"","Notify me if confirmed":"","Notify me when transactions are confirmed":"","Now is a good time to backup your wallet. If this device is lost, it is impossible to access your funds without a backup.":"","Now is a perfect time to assess your surroundings. Nearby windows? Hidden cameras? Shoulder-spies?":"-","OK":"","OKAY":"OKAY","Official English Disclaimer":"","Oh no!":"","Ok":"","On this screen you can see all your wallets, accounts, and assets.":" ","Open":"","Open Crowdin":" Crowdin","Open GitHub":" GitHub","Open GitHub Project":" GitHub ","Open Insight":"","Open Settings":"","Open Translation Community":"","Open Website":"","Open wallet":"","Open website":"","Order the BitPay Card":" BitPay ","Password":"","Password required. Make sure to enter your password in advanced options":"","Paste invitation here":"","Paste the backup plain text code":"","Pay 0% fees to turn bitcoin into dollars.":"0%","Pay To":"","Payment Accepted":"","Payment Expires:":"","Payment Proposal":"","Payment Proposal Created":"","Payment Proposals":"","Payment Protocol Invalid":"","Payment Protocol not supported on Chrome App":" Chrome ","Payment Received":"","Payment Rejected":"","Payment Sent":"","Payment accepted, but not yet broadcasted":"","Payment accepted. It will be broadcasted by Glidera. In case there is a problem, it can be deleted 6 hours after it was created.":" Glidera  6 ","Payment details":"","Payment request":"","Pending":"","Pending Proposals":"","Permanently delete this wallet.":"","Personal Wallet":"","Please carefully write down this phrase.":"","Please connect a camera to get started.":"","Please enter the recovery phrase":"","Please enter the wallet recovery phrase":"","Please enter your PIN":"PIN","Please tap each word in the correct order.":"","Please upgrade Copay to perform this action":" Copay ","Please, select your backup file":"","Pre-Auth Holds":"","Preferences":"","Preparing addresses...":"...","Preparing backup...":"...","Press again to exit":"","Priority":"","Private Key":"","Private key encrypted. Enter password":"","Private key is encrypted, cannot sign":"","Proposal Accepted":"","Proposal Created":"","Proposal Deleted":"","Proposal Rejected":"","Proposals":"","Purchase Amount is limited to {{limitPerDay}} {{currency}} per day":"{{limitPerDay}}{{currency}}","Purchase amount must be a value between 50 and 2000":" 50  2000","Push Notifications":"","Push notifications for {{appName}} are currently disabled. Enable them in the Settings app.":"{{appName}} ","QR Code":"QR ","Quick review!":" ","Random":"","Rate on the app store":"","Read less":"","Read more":"","Receive":"","Receive in":"","Received":"","Received Funds":"","Receiving":"","Recent":"","Recent Transaction Card":"","Recent Transactions":"","Recipient":"","Recipients":"","Recovery phrase":"","Recreating Wallet...":"...","Redeem now":"","Rejected":"","Rejecting payment proposal":"","Release information":"","Remove":"","Remove BitPay Account?":" BitPay ","Remove BitPay Card?":" BitPay ","Removing your BitPay account will remove all associated BitPay account data from this device. Are you sure you would like to remove your BitPay Account ({{email}}) from this device?":" BitPay  BitPay  BitPay :({{email}})","Repeat password":"","Repeat the password":"","Request Fingerprint":"","Request Specific amount":"","Request Spending Password":"","Required number of signatures":"","Restore from backup":"","Retrieving inputs information":"","Retry":"","Retry Camera":"","Save":"","Scan":"","Scan QR Codes":" QR ","Scan addresses for funds":"","Scan again":"","Scan your fingerprint please":"","Scanning Wallet funds...":"...","Screenshots are not secure":"","Search Transactions":"","Search or enter bitcoin address":"","Search transactions":"","Search your currency":"","Security":"","See invoice":"","Select a backup file":"","Select a wallet":"","Self-signed Certificate":"","Selling Bitcoin...":"......","Send":"","Send Feedback":"","Send Money":"","Send addresses by email":"","Send by email":"","Send from":"","Send max amount":"","Send payment to this address":"","Send us feedback instead":"","Sending":"","Sending 2FA code...":" 2FA ...","Sending feedback...":"...","Sending maximum amount":"","Sending transaction":"","Sending {{amountStr}} from your {{name}} wallet":" {{name}}  {{amountStr}}","Sent":"","Sent Funds":"","Server response could not be verified":"","Service not available":"","Services":"","Session Log":"","Session log":"","Set up a password":"","Set your own fee in satoshis/byte":"(satoshi)","Settings":"","Share the love by inviting your friends.":"","Share this invitation with your copayers":" copayers ","Share {{appName}}":" {{appName}}","Shared Wallet":"","Show Recovery Phrase":"","Show address":"","Show advanced options":"","Show bitcoin address":"","Show more":"","Signatures rejected by server":"","Signing transaction":"","Since only you control your money, youll need to save your backup phrase in case this app is deleted.":"","Single Address Wallet":"","Skip":"","Slide to buy":"","Specify Recovery Phrase...":"......","Spend proposal is not accepted":"","Spend proposal not found":"","Spending Password needed":"","Spending this balance will need significant Bitcoin network fees":"","Start sending bitcoin":"","Startup Lock":"","Still pending":"","Success":"","Super Economy":"","Sweep":"","Sweep paper wallet":"Sweep ","Sweeping Wallet...":"","THIS ACTION CANNOT BE REVERSED":"","Take control of your money,<br>get started with bitcoin.":"<br>","Tap and hold to show":"","Tap to retry":"","Terms Of Use":"","Terms of Use":"","Testnet":"Testnet","Text":"","Thank you!":"","Thanks!":" ","That's exciting to hear. We'd love to earn that fifth star from you  how could we improve your experience?":"   ","The Ledger Chrome application is not installed":"Ledger Chrome ","The amount of bitcoin immediately spendable from this wallet.":"","The amount of bitcoin stored in this wallet that is allocated as inputs to your pending transaction proposals. The amount is determined using unspent transaction outputs associated with this wallet and may be more than the actual amounts associated with your pending transaction proposals.":"","The amount of bitcoin stored in this wallet with less than 1 blockchain confirmation.":" 1 blockchain ","The derivation path":"","The exchange rate changes with the market.":"","The higher the fee, the greater the incentive a miner has to include that transaction in a block. Current fees are determined based on network load and the selected policy.":" ","The maximum number of consecutive unused addresses (20) has been reached. When one of your unused addresses receives a payment, a new address will be generated and shown in your Receive tab.":" (20) ","The official English Terms of Service are available on the BitPay website.":" BitPay ","The password of the recovery phrase (if set)":" ()","The payment was created but could not be completed. Please try again from home screen":"","The payment was removed by creator":"","The recovery phrase could require a password to be imported":"","The request could not be understood by the server":"","The restore process will stop when 20 addresses are generated in a row which contain no funds. To safely generate more addresses, make a payment to one of the unused addresses which has already been generated.":" 20 ","The spend proposal is not pending":"","The total amount of bitcoin stored in this wallet.":"","The transaction history and every new incoming transaction are cached in the app. This feature clean this up and synchronizes again from the server":"","The wallet service URL":" URL","There is a new version of {{appName}} available":" {{appName}}","There is an error in the form":"","There's obviously something we're doing wrong.":"","This app is fantastic!":" ","This app stores your bitcoin with cutting-edge security.":"","This bitcoin payment request has expired.":"","This password cannot be recovered. If the password is lost, there is no way you could recover your funds.":"","This recovery phrase was created with a password. To recover this wallet both the recovery phrase and password are needed.":"","This transaction amount is too small compared to current Bitcoin network fees. Spending these funds will need a Bitcoin network fee cost comparable to the funds itself.":"","This transaction could take a long time to confirm or could be dropped due to the low fees set by the sender":"","This wallet is not registered at the given Bitcore Wallet Service (BWS). You can recreate it from the local information.":" Bitcore Wallet Service (BWS) ","Timeline":"","To":"","To get started, buy bitcoin or share your address. You can receive bitcoin from any wallet or service.":"","To get started, you'll need to create a bitcoin wallet and get some bitcoin.":"","To {{reason}} you must first add your BitPay account - {{email}}":" {{reason}} BitPay -{{email}}","Top up in progress...":"...","Top up {{amountStr}} to debit card ({{cardLastNumber}})":" {{amountStr}} ({{cardLastNumber}})","Total":"","Total Locked Balance":"","Total number of copayers":"Copayers ","Total wallet inputs":"","Touch ID Failed":" ID ","Transaction":"","Transaction Created":"","Transaction History":"","Transaction already broadcasted":"","Transaction has not been created":"","Transaction initiated":"","Transaction not available at this time":"","Transaction not found":"","Transactions without fee are not supported.":"","Transfer to":"","Transfer to Wallet":"","Try again in {{expires}}":" {{expires}} ","Turn bitcoin into dollars, swipe anywhere Visa<sup></sup> is accepted.":" Visa<sup></sup> ","Type the Recovery Phrase (usually 12 words)":"  12 ","Uh oh...":"......","Unconfirmed":"","Unsent transactions":"","Unused Addresses":"","Unused Addresses Limit":"","Update Available":"","Updating pending proposals. Please stand by":"","Updating transaction history. Please stand by.":"","Updating... Please stand by":" ","Urgent":"","Use Unconfirmed Funds":"","Validating recovery phrase...":"","Verify your identity":"","Version":"","View":"","View All Addresses":"","View Terms of Service":"","View Transaction on Insight":"","View Update":"","View on blockchain":" blockchain ","Visit mercadolivre.com.br &rarr;":" mercadolivre.com.br &rarr;","WARNING: Key derivation is not working on this device/wallet. Actions cannot be performed on this wallet.":"/","WARNING: Not including the private key allows to check the wallet balance, transaction history, and create spend proposals from the export. However, does not allow to approve (sign) proposals, so <b>funds will not be accessible from the export</b>.":" <b></b>","WARNING: The private key of this wallet is not available. The export allows to check the wallet balance, transaction history, and create spend proposals from the export. However, does not allow to approve (sign) proposals, so <b>funds will not be accessible from the export</b>.":" <b></b>","WARNING: UNTRUSTED CERTIFICATE":"","Waiting for Ledger...":" Ledger...","Waiting for Trezor...":" Trezor...","Waiting for copayers":" copayers","Waiting...":"...","Wallet Addresses":"","Wallet Color":"","Wallet Configuration (m-n)":" (m n)","Wallet Created":"","Wallet Id":" Id","Wallet Information":"","Wallet Inputs":"","Wallet Invitation":"","Wallet Key":"","Wallet Name":"","Wallet Name (at creation)":"","Wallet Network":"","Wallet Recovery Phrase":"","Wallet Recovery Phrase is invalid":"","Wallet Service URL":" URL","Wallet Settings":"","Wallet Type":"","Wallet already exists":"","Wallet already in {{appName}}":" {{appName}} ","Wallet created":"","Wallet incomplete and broken":"","Wallet is full":"","Wallet is locked":"","Wallet is not complete":"","Wallet name":"","Wallet needs backup":"","Wallet not backed up":"","Wallet not found":"","Wallet not registered":"","Wallet not registered at the wallet service. Recreate it from \"Create Wallet\" using \"Advanced Options\" to set your recovery phrase":" Wallet Service \"\"\"","Wallet recovery phrase not available.":"","Wallet service not found":" Wallet Service","Wallets":"","Wallets & Integrations":" & ","Warning!":"","Warning: this transaction has unconfirmed inputs":"","Watch out!":" ","We'd love to do better.":"","We'll confirm on the next screen.":"","We're always looking for ways to improve {{appName}}.":"{{appName}}","We're always looking for ways to improve {{appName}}. How could we improve your experience?":"{{appName}}","Website":"","Were always looking for translation contributions! You can make corrections or help to make this app available in your native language by joining our community on Crowdin.":"  Crowdin ","What do you call this wallet?":"","When this wallet was created, it was called {{walletName}}. You can change the name displayed on this device below.":"\"{{walletName}}\"","Where would you like to receive email notifications about payments?":"","Why?":"","Would you be willing to rate {{appName}} in the app store?":" {{appName}} app store ","Would you like to receive push notifications about payments?":"","Wrong number of recovery words:":"","Wrong spending password":"","Yes":"","Yes, skip":"","You can create a backup later from your wallet settings.":"","You can make contributions by signing up on our Crowdin community translation website. Were looking forward to hearing from you!":" Crowdin  ","You can scan bitcoin addresses, payment requests, paper wallets, and more.":"  ","You can see the latest developments and contribute to this open source app by visiting our project on GitHub.":" GitHub ","You can spend bitcoin at millions of websites and stores worldwide.":"","You can still export it from Advanced &gt; Export.":" &gt; ","You can trade it for other currencies like US Dollars, Euros, or Pounds.":" ","You control your bitcoin.":"","You should not set a fee higher than {{maxFeeRecommended}} satoshis/byte.":" {{maxFeeRecommended}} satoshis/ ","You will need to log back for fill in your BitPay Card.":" BitPay ","You'll receive email notifications about payments sent and received from your wallets.":"","Your BitPay Card is ready. Add funds to your card to start using it at stores and ATMs worldwide.":" BitPay ","Your Gift Cards":"","Your bitcoin wallet is backed up!":" ","Your bitcoin wallet is ready!":" ","Your fee is lower than recommended.":"","Your ideas, feedback, or comments":" ","Your name":"","Your nickname":"","Your password":"","Your purchase could not be completed":"","Your purchase was added to the list of pending":"","Your wallet is never saved to cloud storage or standard device backups.":"","Your wallet key will be encrypted. The Spending Password cannot be recovered. Be sure to write it down.":"","[Balance Hidden]":"[]","add your BitPay Visa card(s)":" BitPay ","locked by pending payments":"","me":"","name@example.com":"name@example.com","preparing...":"...","{{amountStr}} for Amazon.com Gift Card":"{{amountStr}} ","{{amountStr}} for Mercado Livre Brazil Gift Card":" {{amountStr}}","{{appName}} depends on Bitcore Wallet Service (BWS) for blockchain information, networking and Copayer synchronization. The default configuration points to https://bws.bitpay.com (BitPay's public BWS instance).":"{{appName}}  Bitcore Wallet Service (BWS) Copayer synchronization https://bws.bitpay.com (BitPay  BWS )","{{fee}} will be deducted for bitcoin networking fees.":"{{fee}} ","{{tx.txp[wallet.id].feeRatePerStr}}  of the sending amount":" {{tx.txp[wallet.id].feeRatePerStr}}","{{updatingTxHistoryProgress}} transactions downloaded":" {{updatingTxHistoryProgress}} ","{{wallet.m}}-of-{{wallet.n}}":"{{wallet.m}}{{wallet.n}}"});
/* jshint +W100 */
}]);
window.version="1.0.0";
window.commitHash="6ade069";
window.appConfig={"//":"        Modify it in the app-template directory","packageName":"copay","packageDescription":"MyBitcoinZ Bitcoin Wallet","packageNameId":"com.btczcom.mybitcoinz","statusBarColor":"#192c3a","userVisibleName":"MyBitcoinZ","purposeLine":"MyBitcoinZ BitcoinZ Wallet","bundleName":"copay","appUri":"copay","name":"copay","nameNoSpace":"copay","nameCase":"MyBitcoinZ","nameCaseNoSpace":"MyBitcoinZ","gitHubRepoName":"copay","gitHubRepoUrl":"git://github.com/anthony19114/mybitcoinz.git","gitHubRepoBugs":"https://github.com/anthony19114/mybitcoinz/issues","disclaimerUrl":"https://copay.io/disclaimer","url":"https://suite.bitcoinz.ph","appDescription":"MyBitcoinZ BitcoinZ Wallet","winAppName":"MyBitcoinZ","WindowsStoreIdentityName":"18C7659D.Copay-SecureBitcoinWallet","WindowsStoreDisplayName":"MyBitcoinZ - Secure BitcoinZ Wallet","windowsAppId":"804636ee-b017-4cad-8719-e58ac97ffa5c","pushSenderId":"1036948132229","description":"A Secure BitcoinZ Wallet","version":"1.0.0","androidVersion":"382001","_extraCSS":null,"_enabledExtensions":{"coinbase":false,"glidera":false,"amazon":false}};
window.externalServices={};
'use strict';

angular.element(document).ready(function() {

  // Run copayApp after device is ready.
  var startAngular = function() {
    angular.bootstrap(document, ['copayApp']);
  };


  function handleOpenURL(url) {
    if ('cordova' in window) {
      console.log('DEEP LINK:' + url);
      cordova.fireDocumentEvent('handleopenurl', {
        url: url
      });
    } else {
      console.log("ERROR: Cannont handle open URL in non-cordova apps")
    }
  };

  /* Cordova specific Init */
  if ('cordova' in window) {

    window.handleOpenURL = handleOpenURL;


    document.addEventListener('deviceready', function() {

      window.open = cordova.InAppBrowser.open;

      // Create a sticky event for handling the app being opened via a custom URL
      cordova.addStickyDocumentEventHandler('handleopenurl');
      startAngular();
    }, false);

  } else {
    startAngular();
  }

});

window.TREZOR_CHROME_URL = './bower_components/trezor-connect/chrome/wrapper.html';


/**
 * (C) 2017 SatoshiLabs
 *
 * GPLv3
 */

if (!Array.isArray) {
    Array.isArray = function(arg) {
        return Object.prototype.toString.call(arg) === '[object Array]';
    };
}

var HD_HARDENED = 0x80000000;

// react sometimes adds some other parameters that should not be there
function _fwStrFix(obj, fw) {
    if (typeof fw === 'string') {
        obj.requiredFirmware = fw;
    }
    return obj;
}

this.TrezorConnect = (function () {
    'use strict';

    var chrome = window.chrome;
    var IS_CHROME_APP = chrome && chrome.app && chrome.app.window;

    var ERR_TIMED_OUT = 'Loading timed out';
    var ERR_WINDOW_CLOSED = 'Window closed';
    var ERR_WINDOW_BLOCKED = 'Window blocked';
    var ERR_ALREADY_WAITING = 'Already waiting for a response';
    var ERR_CHROME_NOT_CONNECTED = 'Internal Chrome popup is not responding.';

    var DISABLE_LOGIN_BUTTONS = window.TREZOR_DISABLE_LOGIN_BUTTONS || false;
    var CHROME_URL = window.TREZOR_CHROME_URL || './chrome/wrapper.html';
    var POPUP_URL = window.TREZOR_POPUP_URL || 'https://connect.trezor.io/1/popup/popup.html';
    var POPUP_PATH = window.TREZOR_POPUP_PATH || 'https://connect.trezor.io/1';
    var POPUP_ORIGIN = window.TREZOR_POPUP_ORIGIN || 'https://connect.trezor.io';

    var INSIGHT_URLS = window.TREZOR_INSIGHT_URLS || 
        [
            'https://bitcore1.trezor.io/api/',
            'https://bitcore3.trezor.io/api/',
        ];

    var POPUP_INIT_TIMEOUT = 15000;

    /**
     * Public API.
     */
    function TrezorConnect() {

        var manager = new PopupManager();

        /**
         * Popup errors.
         */
        this.ERR_TIMED_OUT = ERR_TIMED_OUT;
        this.ERR_WINDOW_CLOSED = ERR_WINDOW_CLOSED;
        this.ERR_WINDOW_BLOCKED = ERR_WINDOW_BLOCKED;
        this.ERR_ALREADY_WAITING = ERR_ALREADY_WAITING;
        this.ERR_CHROME_NOT_CONNECTED = ERR_CHROME_NOT_CONNECTED;

        /**
         * Open the popup for further communication. All API functions open the
         * popup automatically, but if you need to generate some parameters
         * asynchronously, use `open` first to avoid popup blockers.
         * @param {function(?Error)} callback
         */
        this.open = function (callback) {
            var onchannel = function (result) {
                if (result instanceof Error) {
                    callback(result);
                } else {
                    callback();
                }
            };
            manager.waitForChannel(onchannel);
        };

        /**
         * Close the opened popup, if any.
         */
        this.close = function () { manager.close(); };

        /**
         * Enable or disable closing the opened popup after a successful call.
         * @param {boolean} value
         */
        this.closeAfterSuccess = function (value) { manager.closeAfterSuccess = value; };

        /**
         * Enable or disable closing the opened popup after a failed call.
         * @param {boolean} value
         */
        this.closeAfterFailure = function (value) { manager.closeAfterFailure = value; };

        /**
         * @typedef XPubKeyResult
         * @param {boolean} success
         * @param {?string} error
         * @param {?string} xpubkey  serialized extended public key
         * @param {?string} path     BIP32 serializd path of the key
         */

        /**
         * Load BIP32 extended public key by path.
         *
         * Path can be specified either in the string form ("m/44'/1/0") or as
         * raw integer array. In case you omit the path, user is asked to select
         * a BIP32 account to export, and the result contains m/44'/0'/x' node
         * of the account.
         *
         * @param {?(string|array<number>)} path
         * @param {function(XPubKeyResult)} callback
         * @param {?(string|array<number>)} requiredFirmware
         */
        this.getXPubKey = function (path, callback, requiredFirmware) {
            if (typeof path === 'string') {
                path = parseHDPath(path);
            }
            manager.sendWithChannel(_fwStrFix({
                type: 'xpubkey',
                path: path
            }, requiredFirmware), callback);
        };

        this.getFreshAddress = function (callback, requiredFirmware) {
            var wrapperCallback = function (result) {
                if (result.success) {
                    callback({success: true, address: result.freshAddress});
                } else {
                    callback(result);
                }
            }

            manager.sendWithChannel(_fwStrFix({
                type: 'accountinfo'
            }, requiredFirmware), wrapperCallback);
        }

        this.getAccountInfo = function (input, callback, requiredFirmware) {
            try {
                var description = parseAccountInfoInput(input);
                manager.sendWithChannel(_fwStrFix({
                    type: 'accountinfo',
                    description: description
                }, requiredFirmware), callback);
            } catch(e) {
                callback({success: false, error: e});
            }
        }

        this.getBalance = function (callback, requiredFirmware) {
            manager.sendWithChannel(_fwStrFix({
                type: 'accountinfo'
            }, requiredFirmware), callback)
        }

        /**
         * @typedef SignTxResult
         * @param {boolean} success
         * @param {?string} error
         * @param {?string} serialized_tx      serialized tx, in hex, including signatures
         * @param {?array<string>} signatures  array of input signatures, in hex
         */

        /**
         * Sign a transaction in the device and return both serialized
         * transaction and the signatures.
         *
         * @param {array<TxInputType>} inputs
         * @param {array<TxOutputType>} outputs
         * @param {function(SignTxResult)} callback
         * @param {?(string|array<number>)} requiredFirmware
         *
         * @see https://github.com/trezor/trezor-common/blob/master/protob/types.proto
         */
        this.signTx = function (inputs, outputs, callback, requiredFirmware) {
            manager.sendWithChannel(_fwStrFix({
                type: 'signtx',
                inputs: inputs,
                outputs: outputs
            }, requiredFirmware), callback);
        };

        this.signEthereumTx = function (
            address_n,
            nonce,
            gas_price,
            gas_limit,
            to,
            value,
            data,
            chain_id,
            callback,
            requiredFirmware
        ) {
            if (requiredFirmware == null) {
                requiredFirmware = '1.4.0'; // first firmware that supports ethereum
            }
            if (typeof address_n === 'string') {
                address_n = parseHDPath(address_n);
            }
            manager.sendWithChannel(_fwStrFix({
                type: 'signethtx',
                address_n: address_n,
                nonce: nonce,
                gas_price: gas_price,
                gas_limit: gas_limit,
                to: to,
                value: value,
                data: data,
                chain_id: chain_id,
            }, requiredFirmware), callback);
        };

        /**
         * @typedef TxRecipient
         * @param {number} amount   the amount to send, in satoshis
         * @param {string} address  the address of the recipient
         */

        /**
         * Compose a transaction by doing BIP-0044 discovery, letting the user
         * select an account, and picking UTXO by internal preferences.
         * Transaction is then signed and returned in the same format as
         * `signTx`.  Only supports BIP-0044 accounts (single-signature).
         *
         * @param {array<TxRecipient>} recipients
         * @param {function(SignTxResult)} callback
         * @param {?(string|array<number>)} requiredFirmware
         */
        this.composeAndSignTx = function (recipients, callback, requiredFirmware) {
            manager.sendWithChannel(_fwStrFix({
                type: 'composetx',
                recipients: recipients
            }, requiredFirmware), callback);
        };

        /**
         * @typedef RequestLoginResult
         * @param {boolean} success
         * @param {?string} error
         * @param {?string} public_key  public key used for signing, in hex
         * @param {?string} signature   signature, in hex
         */

        /**
         * Sign a login challenge for active origin.
         *
         * @param {?string} hosticon
         * @param {string} challenge_hidden
         * @param {string} challenge_visual
         * @param {string|function(RequestLoginResult)} callback
         * @param {?(string|array<number>)} requiredFirmware
         *
         * @see https://github.com/trezor/trezor-common/blob/master/protob/messages.proto
         */
        this.requestLogin = function (
            hosticon,
            challenge_hidden,
            challenge_visual,
            callback,
            requiredFirmware
        ) {
            if (typeof callback === 'string') {
                // special case for a login through <trezor:login> button.
                // `callback` is name of global var
                callback = window[callback];
            }
            if (!callback) {
                throw new TypeError('TrezorConnect: login callback not found');
            }
            manager.sendWithChannel(_fwStrFix({
                type: 'login',
                icon: hosticon,
                challenge_hidden: challenge_hidden,
                challenge_visual: challenge_visual
            }, requiredFirmware), callback);
        };

        /**
         * @typedef SignMessageResult
         * @param {boolean} success
         * @param {?string} error
         * @param {?string} address address (in base58check)
         * @param {?string} signature   signature, in base64
         */

        /**
         * Sign a message
         *
         * @param {string|array} path  
         * @param {string} message to sign (ascii)
         * @param {string|function(SignMessageResult)} callback
         * @param {?string} opt_coin - (optional) name of coin (default Bitcoin)
         * @param {?(string|array<number>)} requiredFirmware
         *
         */
        this.signMessage = function (
            path,
            message,
            callback,
            opt_coin,
            requiredFirmware
        ) {
            if (typeof path === 'string') {
                path = parseHDPath(path);
            }
            if (!opt_coin) {
                opt_coin = 'Bitcoin';
            }
            if (!callback) {
                throw new TypeError('TrezorConnect: callback not found');
            }
            manager.sendWithChannel(_fwStrFix({
                type: 'signmsg',
                path: path,
                message: message,
                coin: {coin_name: opt_coin},
            }, requiredFirmware), callback);
        };

        /**
         * Verify message
         *
         * @param {string} address
         * @param {string} signature (base64)
         * @param {string} message (string)
         * @param {string|function()} callback
         * @param {?string} opt_coin - (optional) name of coin (default Bitcoin)
         * @param {?(string|array<number>)} requiredFirmware
         *
         */
        this.verifyMessage = function (
            address,
            signature,
            message,
            callback,
            opt_coin,
            requiredFirmware
        ) {
            if (!opt_coin) {
                opt_coin = 'Bitcoin';
            }
            if (!callback) {
                throw new TypeError('TrezorConnect: callback not found');
            }
            manager.sendWithChannel(_fwStrFix({
                type: 'verifymsg',
                address: address,
                signature: signature,
                message: message,
                coin: {coin_name: opt_coin},
            }, requiredFirmware), callback);
        };

        /**
         * Symmetric key-value encryption
         *
         * @param {string|array} path
         * @param {string} key to show on device display
         * @param {string} value hexadecimal value, length a multiple of 16 bytes
         * @param {boolean} encrypt / decrypt direction
         * @param {boolean} ask_on_encrypt (should user confirm on encrypt?)
         * @param {boolean} ask_on_decrypt (should user confirm on decrypt?)
         * @param {string|function()} callback
         * @param {?(string|array<number>)} requiredFirmware
         *
         */
        this.cipherKeyValue = function (
            path,
            key,
            value,
            encrypt,
            ask_on_encrypt,
            ask_on_decrypt,
            callback,
            requiredFirmware
        ) {
            if (typeof path === 'string') {
                path = parseHDPath(path);
            }
            if (typeof value !== 'string') {
                throw new TypeError('TrezorConnect: Value must be a string');
            }
            if (!(/^[0-9A-Fa-f]*$/.test(value))) {
                throw new TypeError('TrezorConnect: Value must be hexadecimal');
            }
            if (value.length % 32 !== 0) {
                // 1 byte == 2 hex strings
                throw new TypeError('TrezorConnect: Value length must be multiple of 16 bytes');
            }
            if (!callback) {
                throw new TypeError('TrezorConnect: callback not found');
            }
            manager.sendWithChannel(_fwStrFix({
                type: 'cipherkeyvalue',
                path: path,
                key: key,
                value: value,
                encrypt: !!encrypt,
                ask_on_encrypt: !!ask_on_encrypt,
                ask_on_decrypt: !!ask_on_decrypt
            }, requiredFirmware), callback);
        };

        this.pushTransaction = function (
          rawTx,
          callback
        ) {
            if (!(/^[0-9A-Fa-f]*$/.test(rawTx))) {
                throw new TypeError('TrezorConnect: Transaction must be hexadecimal');
            }
            if (!callback) {
                throw new TypeError('TrezorConnect: callback not found');
            }

            var tryUrl = function(i) {
                var insight_url = INSIGHT_URLS[i];
                var xhr = new XMLHttpRequest();
                var method = 'POST';
                var url = insight_url + '/tx/send';
                var data = {
                    rawtx: rawTx
                };

                xhr.open(method, url, true);
                xhr.setRequestHeader('Content-Type', 'application/json');
                xhr.onreadystatechange = function () {
                    if (xhr.readyState === XMLHttpRequest.DONE) {
                        if (xhr.status === 200) {
                            var txid = JSON.parse(xhr.responseText).txid;
                            callback({success: true, txid: txid});
                        } else {
                            if (i === INSIGHT_URLS.length - 1) {
                                callback({error: new Error(xhr.responseText)});
                            } else {
                                tryUrl(i + 1);
                            }
                        }
                    }
                };
                xhr.send(JSON.stringify(data));
            }

            tryUrl(0);
        }

        var LOGIN_CSS =
            '<style>@import url("@connect_path@/login_buttons.css")</style>';

        var LOGIN_ONCLICK =
            'TrezorConnect.requestLogin('
            + "'@hosticon@','@challenge_hidden@','@challenge_visual@','@callback@'"
            + ')';

        var LOGIN_HTML =
            '<div id="trezorconnect-wrapper">'
            + '  <a id="trezorconnect-button" onclick="' + LOGIN_ONCLICK + '">'
            + '    <span id="trezorconnect-icon"></span>'
            + '    <span id="trezorconnect-text">@text@</span>'
            + '  </a>'
            + '  <span id="trezorconnect-info">'
            + '    <a id="trezorconnect-infolink" href="https://www.buytrezor.com/"'
            + '       target="_blank">What is TREZOR?</a>'
            + '  </span>'
            + '</div>';

        /**
         * Find <trezor:login> elements and replace them with login buttons.
         * It's not required to use these special elements, feel free to call
         * `TrezorConnect.requestLogin` directly.
         */
        this.renderLoginButtons = function () {
            var elements = document.getElementsByTagName('trezor:login');

            for (var i = 0; i < elements.length; i++) {
                var e = elements[i];
                var text = e.getAttribute('text') || 'Sign in with TREZOR';
                var callback = e.getAttribute('callback') || '';
                var hosticon = e.getAttribute('icon') || '';
                var challenge_hidden = e.getAttribute('challenge_hidden') || '';
                var challenge_visual = e.getAttribute('challenge_visual') || '';

                // it's not valid to put markup into attributes, so let users
                // supply a raw text and make TREZOR bold
                text = text.replace('TREZOR', '<strong>TREZOR</strong>');
                e.outerHTML =
                    (LOGIN_CSS + LOGIN_HTML)
                    .replace('@text@', text)
                    .replace('@callback@', callback)
                    .replace('@hosticon@', hosticon)
                    .replace('@challenge_hidden@', challenge_hidden)
                    .replace('@challenge_visual@', challenge_visual)
                    .replace('@connect_path@', POPUP_PATH);
            }
        };
    }

    /*
     * `getXPubKey()`
     */

    function parseHDPath(string) {
        return string
            .toLowerCase()
            .split('/')
            .filter(function (p) { return p !== 'm'; })
            .map(function (p) {
                var hardened = false;
                if (p[p.length - 1] === "'") {
                    hardened = true;
                    p = p.substr(0, p.length - 1);
                }
                if (isNaN(p)) {
                   throw new Error('Not a valid path.');
                }
                var n = parseInt(p);
                if (hardened) { // hardened index
                    n = (n | 0x80000000) >>> 0;
                }
                return n;
            });
    }


    function getIdFromPath(path) {
        if (path.length !== 3) {
            throw new Error();
        }
        if ((path[0] >>> 0) !== ((44 | HD_HARDENED) >>> 0)) {
            throw new Error();
        }
        if ((path[1] >>> 0) !== ((0 | HD_HARDENED) >>> 0)) {
            throw new Error();
        }
        return ((path[2] & ~HD_HARDENED) >>> 0);
    }

    // parses first argument from getAccountInfo
    function parseAccountInfoInput(input) {
        if (input == null) {
            return null;
        }

        if (typeof input === 'string') {
            if (input.substr(0, 4) === 'xpub') {
                return input;
            }
            if (isNaN(input)) {
                var parsedPath = parseHDPath(input);
                return getIdFromPath(parsedPath);
            } else {
                return parseInt(input);
            }
        } else if (Array.isArray(input)) {
            return getIdFromPath(input);
        } else if (typeof input === 'number') {
            return input;
        }
        throw new Error('Unknown input format.');
    }

    /*
     * Popup management
     */

    function ChromePopup(url, name, width, height) {
        var left = (screen.width - width) / 2;
        var top = (screen.height - height) / 2;
        var opts = {
            id: name,
            innerBounds: {
                width: width,
                height: height,
                left: left,
                top: top
            }
        };

        var closed = function () {
            if (this.onclose) {
                this.onclose(false); // never report as blocked
            }
        }.bind(this);

        var opened = function (w) {
            this.window = w;
            this.window.onClosed.addListener(closed);
        }.bind(this);

        chrome.app.window.create(url, opts, opened);

        this.name = name;
        this.window = null;
        this.onclose = null;
    }

    function ChromeChannel(popup, waiting) {
        var port = null;

        var respond = function (data) {
            if (waiting) {
                var w = waiting;
                waiting = null;
                w(data);
            }
        };

        var setup = function (p) {
            if (p.name === popup.name) {
                port = p;
                port.onMessage.addListener(respond);
                chrome.runtime.onConnect.removeListener(setup);
            }
        };

        chrome.runtime.onConnect.addListener(setup);

        this.respond = respond;

        this.close = function () {
            chrome.runtime.onConnect.removeListener(setup);
            port.onMessage.removeListener(respond);
            port.disconnect();
            port = null;
        };

        this.send = function (value, callback) {
            if (waiting === null) {
                waiting = callback;

                if (port) {
                    port.postMessage(value);
                } else {
                    throw new Error(ERR_CHROME_NOT_CONNECTED);
                }
            } else {
                throw new Error(ERR_ALREADY_WAITING);
            }
        };
    }

    function Popup(url, origin, name, width, height) {
        var left = (screen.width - width) / 2;
        var top = (screen.height - height) / 2;
        var opts =
            'width=' + width +
            ',height=' + height +
            ',left=' + left +
            ',top=' + top +
            ',menubar=no' +
            ',toolbar=no' +
            ',location=no' +
            ',personalbar=no' +
            ',status=no';
        var w = window.open(url, name, opts);

        var interval;
        var blocked = w.closed;
        var iterate = function () {
            if (w.closed) {
                clearInterval(interval);
                if (this.onclose) {
                    this.onclose(blocked);
                }
            }
        }.bind(this);
        interval = setInterval(iterate, 100);

        this.window = w;
        this.origin = origin;
        this.onclose = null;
    }

    function Channel(popup, waiting) {

        var respond = function (data) {
            if (waiting) {
                var w = waiting;
                waiting = null;
                w(data);
            }
        };

        var receive = function (event) {
            if (event.source === popup.window && event.origin === popup.origin) {
                respond(event.data);
            }
        };

        window.addEventListener('message', receive);

        this.respond = respond;

        this.close = function () {
            window.removeEventListener('message', receive);
        };

        this.send = function (value, callback) {
            if (waiting === null) {
                waiting = callback;
                popup.window.postMessage(value, popup.origin);
            } else {
                throw new Error(ERR_ALREADY_WAITING);
            }
        };
    }

    function ConnectedChannel(p) {

        var ready = function () {
            clearTimeout(this.timeout);
            this.popup.onclose = null;
            this.ready = true;
            this.onready();
        }.bind(this);

        var closed = function (blocked) {
            clearTimeout(this.timeout);
            this.channel.close();
            if (blocked) {
                this.onerror(new Error(ERR_WINDOW_BLOCKED));
            } else {
                this.onerror(new Error(ERR_WINDOW_CLOSED));
            }
        }.bind(this);

        var timedout = function () {
            this.popup.onclose = null;
            if (this.popup.window) {
                this.popup.window.close();
            }
            this.channel.close();
            this.onerror(new Error(ERR_TIMED_OUT));
        }.bind(this);

        if (IS_CHROME_APP) {
            this.popup = new ChromePopup(p.chromeUrl, p.name, p.width, p.height);
            this.channel = new ChromeChannel(this.popup, ready);
        } else {
            this.popup = new Popup(p.url, p.origin, p.name, p.width, p.height);
            this.channel = new Channel(this.popup, ready);
        }

        this.timeout = setTimeout(timedout, POPUP_INIT_TIMEOUT);

        this.popup.onclose = closed;

        this.ready = false;
        this.onready = null;
        this.onerror = null;
    }

    function PopupManager() {
        var cc = null;

        var closed = function () {
            cc.channel.respond(new Error(ERR_WINDOW_CLOSED));
            cc.channel.close();
            cc = null;
        };

        var open = function (callback) {
            cc = new ConnectedChannel({
                name: 'trezor-connect',
                width: 600,
                height: 500,
                origin: POPUP_ORIGIN,
                path: POPUP_PATH,
                url: POPUP_URL,
                chromeUrl: CHROME_URL
            });
            cc.onready = function () {
                cc.popup.onclose = closed;
                callback(cc.channel);
            };
            cc.onerror = function (error) {
                cc = null;
                callback(error);
            };
        }.bind(this);

        this.closeAfterSuccess = true;
        this.closeAfterFailure = true;

        this.close = function () {
            if (cc && cc.popup.window) {
                cc.popup.window.close();
            }
        };

        this.waitForChannel = function (callback) {
            if (cc) {
                if (cc.ready) {
                    callback(cc.channel);
                } else {
                    callback(new Error(ERR_ALREADY_WAITING));
                }
            } else {
                try {
                    open(callback);
                } catch (e) {
                    callback(new Error(ERR_WINDOW_BLOCKED));
                }
            }
        };

        this.sendWithChannel = function (message, callback) {

            var respond = function (response) {
                var succ = response.success && this.closeAfterSuccess;
                var fail = !response.success && this.closeAfterFailure;
                if (succ || fail) {
                    this.close();
                }
                callback(response);
            }.bind(this);

            var onresponse = function (response) {
                if (response instanceof Error) {
                    var error = response;
                    respond({ success: false, error: error.message });
                } else {
                    respond(response);
                }
            };

            var onchannel = function (channel) {
                if (channel instanceof Error) {
                    var error = channel;
                    respond({ success: false, error: error.message });
                } else {
                    channel.send(message, onresponse);
                }
            };

            this.waitForChannel(onchannel);
        };
    }

    var exports = new TrezorConnect();

    if (!IS_CHROME_APP && !DISABLE_LOGIN_BUTTONS) {
        exports.renderLoginButtons();
    }

    return exports;

}());

!function(r){if("object"==typeof exports&&"undefined"!=typeof module)module.exports=r();else if("function"==typeof define&&define.amd)define([],r);else{var n;n="undefined"!=typeof window?window:"undefined"!=typeof global?global:"undefined"!=typeof self?self:this,n.BezierEasing=r()}}(function(){return function r(n,e,t){function o(u,i){if(!e[u]){if(!n[u]){var a="function"==typeof require&&require;if(!i&&a)return a(u,!0);if(f)return f(u,!0);var c=new Error("Cannot find module '"+u+"'");throw c.code="MODULE_NOT_FOUND",c}var d=e[u]={exports:{}};n[u][0].call(d.exports,function(r){var e=n[u][1][r];return o(e?e:r)},d,d.exports,r,n,e,t)}return e[u].exports}for(var f="function"==typeof require&&require,u=0;u<t.length;u++)o(t[u]);return o}({1:[function(r,n,e){function t(r,n){return 1-3*n+3*r}function o(r,n){return 3*n-6*r}function f(r){return 3*r}function u(r,n,e){return((t(n,e)*r+o(n,e))*r+f(n))*r}function i(r,n,e){return 3*t(n,e)*r*r+2*o(n,e)*r+f(n)}function a(r,n,e,t,o){var f,i,a=0;do i=n+(e-n)/2,f=u(i,t,o)-r,f>0?e=i:n=i;while(Math.abs(f)>p&&++a<s);return i}function c(r,n,e,t){for(var o=0;d>o;++o){var f=i(n,e,t);if(0===f)return n;var a=u(n,e,t)-r;n-=a/f}return n}var d=4,l=.001,p=1e-7,s=10,v=11,y=1/(v-1),w="function"==typeof Float32Array;n.exports=function(r,n,e,t){function o(n){for(var t=0,o=1,u=v-1;o!==u&&f[o]<=n;++o)t+=y;--o;var d=(n-f[o])/(f[o+1]-f[o]),p=t+d*y,s=i(p,r,e);return s>=l?c(n,p,r,e):0===s?p:a(n,t,t+y,r,e)}if(!(r>=0&&1>=r&&e>=0&&1>=e))throw new Error("bezier x values must be in [0, 1] range");var f=w?new Float32Array(v):new Array(v);if(r!==n||e!==t)for(var d=0;v>d;++d)f[d]=u(d*y,r,e);return function(f){return r===n&&e===t?f:0===f?0:1===f?1:u(o(f),n,t)}}},{}]},{},[1])(1)});

!function(e,t){"object"==typeof exports&&"object"==typeof module?module.exports=t():"function"==typeof define&&define.amd?define("QRScanner",[],t):"object"==typeof exports?exports.QRScanner=t():e.QRScanner=t()}(this,function(){return function(e){function t(r){if(n[r])return n[r].exports;var i=n[r]={i:r,l:!1,exports:{}};return e[r].call(i.exports,i,i.exports,t),i.l=!0,i.exports}var n={};return t.m=e,t.c=n,t.i=function(e){return e},t.d=function(e,n,r){t.o(e,n)||Object.defineProperty(e,n,{configurable:!1,enumerable:!0,get:r})},t.n=function(e){var n=e&&e.__esModule?function(){return e.default}:function(){return e};return t.d(n,"a",n),n},t.o=function(e,t){return Object.prototype.hasOwnProperty.call(e,t)},t.p="",t(t.s=13)}([function(e,t,n){"use strict";var r=!0,i={disableLog:function(e){return"boolean"!=typeof e?new Error("Argument type: "+typeof e+". Please use a boolean."):(r=e,e?"adapter.js logging disabled":"adapter.js logging enabled")},log:function(){if("object"==typeof window){if(r)return;"undefined"!=typeof console&&"function"==typeof console.log&&console.log.apply(console,arguments)}},extractVersion:function(e,t,n){var r=e.match(t);return r&&r.length>=n&&parseInt(r[n],10)},detectBrowser:function(){var e={};if(e.browser=null,e.version=null,"undefined"==typeof window||!window.navigator)return e.browser="Not a browser.",e;if(navigator.mozGetUserMedia)e.browser="firefox",e.version=this.extractVersion(navigator.userAgent,/Firefox\/(\d+)\./,1);else if(navigator.webkitGetUserMedia)if(window.webkitRTCPeerConnection)e.browser="chrome",e.version=this.extractVersion(navigator.userAgent,/Chrom(e|ium)\/(\d+)\./,2);else{if(!navigator.userAgent.match(/Version\/(\d+).(\d+)/))return e.browser="Unsupported webkit-based browser with GUM support but no WebRTC support.",e;e.browser="safari",e.version=this.extractVersion(navigator.userAgent,/AppleWebKit\/(\d+)\./,1)}else if(navigator.mediaDevices&&navigator.userAgent.match(/Edge\/(\d+).(\d+)$/))e.browser="edge",e.version=this.extractVersion(navigator.userAgent,/Edge\/(\d+).(\d+)$/,2);else{if(!navigator.mediaDevices||!navigator.userAgent.match(/AppleWebKit\/(\d+)\./))return e.browser="Not a supported browser.",e;e.browser="safari",e.version=this.extractVersion(navigator.userAgent,/AppleWebKit\/(\d+)\./,1)}return e},shimCreateObjectURL:function(){if("object"==typeof window&&window.HTMLMediaElement&&"srcObject"in window.HTMLMediaElement.prototype){var e=URL.createObjectURL.bind(URL),t=URL.revokeObjectURL.bind(URL),n=new Map,r=0;URL.createObjectURL=function(t){if("getTracks"in t){var i="polyblob:"+ ++r;return n.set(i,t),console.log("URL.createObjectURL(stream) is deprecated! Use elem.srcObject = stream instead!"),i}return e(t)},URL.revokeObjectURL=function(e){t(e),n.delete(e)};var i=Object.getOwnPropertyDescriptor(window.HTMLMediaElement.prototype,"src");Object.defineProperty(window.HTMLMediaElement.prototype,"src",{get:function(){return i.get.apply(this)},set:function(e){return this.srcObject=n.get(e)||null,i.set.apply(this,[e])}});var o=HTMLMediaElement.prototype.setAttribute;HTMLMediaElement.prototype.setAttribute=function(){return 2===arguments.length&&"src"===(""+arguments[0]).toLowerCase()&&(this.srcObject=n.get(arguments[1])||null),o.apply(this,arguments)}}}};e.exports={log:i.log,disableLog:i.disableLog,browserDetails:i.detectBrowser(),extractVersion:i.extractVersion,shimCreateObjectURL:i.shimCreateObjectURL,detectBrowser:i.detectBrowser.bind(i)}},function(e,t,n){n(5);var r=n(3);e.exports=function(){function e(e){e.getTracks().forEach(function(e){e.stop()})}function t(t){function n(e,t,n,r){var i={audio:!1,video:{}};return i.video.deviceId={exact:e},t&&(i.video.facingMode={exact:t}),n&&(i.video.width={exact:n}),r&&(i.video.height={exact:r}),i}function r(t){return new Promise(function(n){return t.reduce(function(t,n){return t.then(function(t){return t.found?t:(t.nextConstraint=n,window.navigator.mediaDevices.getUserMedia(t.nextConstraint).then(function(n){return e(n),t.found=!0,t},function(){return t}))})},Promise.resolve({found:!1,nextConstraint:{}})).then(function(e){n(e.found?e.nextConstraint:null)})})}var i=Y.map(function(e){return n(t,e)}),o=Q.map(function(e){return n(t,null,e)}),a=Q.map(function(e){return n(t,null,null,e)});return r(i).then(function(e){return r(o).then(function(n){return r(a).then(function(r){return{deviceId:t,facingMode:null===e?null:e.video.facingMode.exact,width:null===n?null:n.video.width.exact,height:null===r?null:r.video.height.exact}})})})}function n(){var e=window.navigator.mediaDevices.enumerateDevices();return e.then(function(e){var t=e.filter(function(e){return"videoinput"===e.kind}).map(function(e){return e.deviceId});return t}).then(function(e){var n=[];return e.forEach(function(e){n.push(t(e))}),Promise.all(n)}).then(function(e){return e.filter(function(e){if(null!==e&&null!==e.width&&null!==e.height)return!0}).sort(function(e,t){return t.width-e.width})}).then(function(e){for(var t=null,n=null,r=0;r<e.length;r++)if("environment"===e[r].facingMode){t=e[r],e.splice(r,1);break}return null===t&&(e.length>0?(t=e[0],e.splice(0,1)):t=!1),n=e.length>0&&e[0],{backCamera:t,frontCamera:n}})}function i(){return null!==j}function o(){e(j),j=null}function a(){return document.getElementById(I.preview)}function s(){return document.getElementById(I.still)}function c(){return _}function d(){return 1===_?B:A}function u(){var e=s();e&&(e.style.visibility="visible",U=!1)}function h(){var e=s();e&&(e.style.visibility="hidden",U=!0)}function f(){return null!==A}function l(){return!!A&&!!B}function p(){return{authorized:null!==A&&A!==!1?"1":"0",denied:"0",restricted:"0",prepared:f()?"1":"0",scanning:F?"1":"0",previewing:U?"1":"0",showing:a()?"1":"0",lightEnabled:"0",canOpenSettings:"0",canEnableLight:"0",canChangeCamera:l()?"1":"0",currentCamera:_.toString()}}function w(e,t){var n=c(),r=d();window.navigator.mediaDevices.getUserMedia({audio:!1,video:{deviceId:{exact:r.deviceId},width:{ideal:r.width},height:{ideal:r.height}}}).then(function(t){j=t;var n=a();n.src=URL.createObjectURL(t),e(p())},function(e){e=null;var r=n?4:3;t(r)})}function v(e){var t=document.createElement("canvas"),n=d();t.height=n.height,t.width=n.width;var r=t.getContext("2d");return r.drawImage(e,0,0,n.width,n.height),{canvas:t,context:r}}function m(e){var t=v(e);return t.context.getImageData(0,0,t.canvas.width,t.canvas.height)}function g(e){return v(e).canvas.toDataURL("image/png")}function b(e,t){if(null===G){var i=new Blob([r],{type:"text/javascript"});G=new Worker(URL.createObjectURL(i))}if(!a()){var o=document.createElement("video");o.setAttribute("autoplay","autoplay"),o.setAttribute("id",I.preview),o.setAttribute("style","display:block;position:fixed;top:50%;left:50%;width:auto;height:auto;min-width:100%;min-height:100%;z-index:"+N.preview+";-moz-transform: translateX(-50%) translateY(-50%);-webkit-transform: translateX(-50%) translateY(-50%);transform:translateX(-50%) translateY(-50%);background-size:cover;background-position:50% 50%;background-color:#FFF;"),o.addEventListener("loadeddata",function(){h()});var s=document.createElement("div");s.setAttribute("id",I.still),s.setAttribute("style","display:block;position:fixed;top:50%;left:50%;visibility: hidden;width:auto;height:auto;min-width:100%;min-height:100%;z-index:"+N.still+";-moz-transform: translateX(-50%) translateY(-50%);-webkit-transform: translateX(-50%) translateY(-50%);transform:translateX(-50%) translateY(-50%);background-size:cover;background-position:50% 50%;background-color:#FFF;"),document.body.appendChild(o),document.body.appendChild(s)}null===A?n().then(function(n){A=n.backCamera,B=n.frontCamera,A!==!1?e():t(5)},function(e){e=null,t(0)}):A===!1?t(5):e()}function y(e,t){b(function(){e(p())},t)}function C(e,t){function n(){i()?e(p()):w(e,t)}f()?n():b(function(){n()},t)}function P(e,t){t=null,i()&&o();var n=a();n&&(n.src=""),e(p())}function S(e,t){C(function(n){n=null;var r=a(),i=!1;F=!0,G.onmessage=function(t){var n=t.data;n.result&&!i&&(i=!0,V=null,e(n.result))},(V=function(){G.postMessage(m(r)),null!==X&&X();var e=window.QRScanner_SCAN_INTERVAL||130;z=window.setTimeout(V,e),X=function(e){window.clearTimeout(z),z=null,X=null,e&&t(6)}})()},t)}function k(e,t){t=null,null!==X&&X(!0),F=!1,"function"==typeof e&&e(p())}function E(e,t){if(t=null,i()){null!==X&&X();var n=a();n.pause();var r=new Image;r.src=g(n),s().style.backgroundImage="url("+r.src+")",u(),o(),e(p())}else e(p())}function T(e,t){null!==V&&V(),C(e,t)}function R(e,t){t(7)}function M(e,t){t(7)}function x(e,t,n){var r=n[0],i=f();r!==_?i&&1===r&&!l()?t(4):(_=r,i?(P(function(e){e=null}),C(e,t)):e(p())):e(p())}function D(e,t){t(8)}function O(e,t){t=null,e(p())}function L(e,t){t=null,k(),i()&&o(),A=null,B=null;var n=a(),r=s();n&&n.remove(),r&&r.remove(),e(p())}var I={preview:"cordova-plugin-qrscanner-video-preview",still:"cordova-plugin-qrscanner-still"},N={preview:-100,still:-99},A=null,B=null,_=0,j=null,F=!1,U=!1,G=null,V=null,z=null,X=null,Q=[5120,4096,3840,3440,3200,3072,3e3,2880,2800,2736,2732,2560,2538,2400,2304,2160,2100,2048,2e3,1920,1856,1824,1800,1792,1776,1728,1700,1680,1600,1536,1440,1400,1392,1366,1344,1334,1280,1200,1152,1136,1120,1080,1050,1024,1e3,960,900,854,848,832,800,768,750,720,640,624,600,576,544,540,512,480,320,240],Y=["environment","user"];return{prepare:y,show:C,hide:P,scan:S,cancelScan:k,pausePreview:E,resumePreview:T,enableLight:R,disableLight:M,useCamera:x,openSettings:D,getStatus:O,destroy:L}}},function(e,t){e.exports=function(e){function t(e){switch(e){case"1":return!0;case"0":return!1;default:throw new Error("QRScanner plugin returned an invalid boolean number-string: "+e)}}function n(e){return{authorized:t(e.authorized),denied:t(e.denied),restricted:t(e.restricted),prepared:t(e.prepared),scanning:t(e.scanning),previewing:t(e.previewing),showing:t(e.showing),lightEnabled:t(e.lightEnabled),canOpenSettings:t(e.canOpenSettings),canEnableLight:t(e.canEnableLight),canChangeCamera:t(e.canChangeCamera),currentCamera:parseInt(e.currentCamera)}}function r(){var e=document.body;e.style&&(e.style.backgroundColor="rgba(0,0,0,0.01)",e.style.backgroundImage="",setTimeout(function(){e.style.backgroundColor="transparent"},1),e.parentNode&&e.parentNode.style&&(e.parentNode.style.backgroundColor="transparent",e.parentNode.style.backgroundImage=""))}function i(e){return e?function(t){var n=parseInt(t),r={};switch(n){case 0:r={name:"UNEXPECTED_ERROR",code:0,_message:"QRScanner experienced an unexpected error."};break;case 1:r={name:"CAMERA_ACCESS_DENIED",code:1,_message:"The user denied camera access."};break;case 2:r={name:"CAMERA_ACCESS_RESTRICTED",code:2,_message:"Camera access is restricted."};break;case 3:r={name:"BACK_CAMERA_UNAVAILABLE",code:3,_message:"The back camera is unavailable."};break;case 4:r={name:"FRONT_CAMERA_UNAVAILABLE",code:4,_message:"The front camera is unavailable."};break;case 5:r={name:"CAMERA_UNAVAILABLE",code:5,_message:"The camera is unavailable."};break;case 6:r={name:"SCAN_CANCELED",code:6,_message:"Scan was canceled."};break;case 7:r={name:"LIGHT_UNAVAILABLE",code:7,_message:"The device light is unavailable."};break;case 8:r={name:"OPEN_SETTINGS_UNAVAILABLE",code:8,_message:"The device is unable to open settings."};break;default:r={name:"UNEXPECTED_ERROR",code:0,_message:"QRScanner returned an invalid error code."}}e(r)}:null}function o(e){return e?function(t){e(null,n(t))}:null}function a(e,t){return e?function(i){t&&r(),e(n(i))}:null}return{prepare:function(t){e.exec(o(t),i(t),"QRScanner","prepare",[])},destroy:function(t){e.exec(a(t,!0),null,"QRScanner","destroy",[])},scan:function(t){if(!t)throw new Error("No callback provided to scan method.");var n=function(e){t(null,e)};e.exec(n,i(t),"QRScanner","scan",[])},cancelScan:function(t){e.exec(a(t),null,"QRScanner","cancelScan",[])},show:function(t){e.exec(a(t,!0),null,"QRScanner","show",[])},hide:function(t){e.exec(a(t,!0),null,"QRScanner","hide",[])},pausePreview:function(t){e.exec(a(t),null,"QRScanner","pausePreview",[])},resumePreview:function(t){e.exec(a(t),null,"QRScanner","resumePreview",[])},enableLight:function(t){e.exec(o(t),i(t),"QRScanner","enableLight",[])},disableLight:function(t){e.exec(o(t),i(t),"QRScanner","disableLight",[])},useCamera:function(t,n){e.exec(o(n),i(n),"QRScanner","useCamera",[t])},useFrontCamera:function(t){var n=1;t?this.useCamera(n,t):e.exec(null,null,"QRScanner","useCamera",[n])},useBackCamera:function(t){var n=0;t?this.useCamera(n,t):e.exec(null,null,"QRScanner","useCamera",[n])},openSettings:function(t){t?e.exec(o(t),i(t),"QRScanner","openSettings",[]):e.exec(null,null,"QRScanner","openSettings",[])},getStatus:function(t){if(!t)throw new Error("No callback provided to getStatus method.");e.exec(a(t),null,"QRScanner","getStatus",[])}}}},function(e,t){e.exports='!function(t){function e(r){if(n[r])return n[r].exports;var i=n[r]={i:r,l:!1,exports:{}};return t[r].call(i.exports,i,i.exports,e),i.l=!0,i.exports}var n={};return e.m=t,e.c=n,e.i=function(t){return t},e.d=function(t,n,r){e.o(t,n)||Object.defineProperty(t,n,{configurable:!1,enumerable:!0,get:r})},e.n=function(t){var n=t&&t.__esModule?function(){return t.default}:function(){return t};return e.d(n,"a",n),n},e.o=function(t,e){return Object.prototype.hasOwnProperty.call(t,e)},e.p="",e(e.s=19)}([function(t,e,n){"use strict";function r(){this.imagedata=null,this.width=0,this.height=0,this.qrCodeSymbol=null,this.debug=!1,this.callback=null}function i(t,e){return t>=0?t>>e:(t>>e)+(2<<~e)}var o=n(14),a=n(13);n.d(e,"b",function(){return s}),e.a=r,e.c=i;var s={};s.sizeOfDataLengthInfo=[[10,9,8,8],[12,11,16,10],[14,13,16,12]],r.prototype.decode=function(t,e){var n=function(){try{this.error=void 0,this.result=this.process(this.imagedata)}catch(t){this.error=t,this.result=void 0}return null!=this.callback&&this.callback(this.result,this.error),this.result}.bind(this);if(void 0==t){var r=document.getElementById("qr-canvas"),i=r.getContext("2d");this.width=r.width,this.height=r.height,this.imagedata=i.getImageData(0,0,this.width,this.height),n()}else if(void 0!=t.width)this.width=t.width,this.height=t.height,this.imagedata={data:e||t.data},this.imagedata.width=t.width,this.imagedata.height=t.height,n();else{var o=new Image;o.crossOrigin="Anonymous",o.onload=function(){var t=document.createElement("canvas"),e=t.getContext("2d"),r=document.getElementById("out-canvas");if(null!=r){var i=r.getContext("2d");i.clearRect(0,0,320,240),i.drawImage(o,0,0,320,240)}t.width=o.width,t.height=o.height,e.drawImage(o,0,0),this.width=o.width,this.height=o.height;try{this.imagedata=e.getImageData(0,0,o.width,o.height)}catch(t){if(this.result="Cross domain image reading not supported in your browser! Save it to your computer then drag and drop the file!",null!=this.callback)return this.callback(this.result)}n()}.bind(this),o.src=t}},r.prototype.decode_utf8=function(t){return decodeURIComponent(escape(t))},r.prototype.process=function(t){for(var e=(new Date).getTime(),n=this.grayScaleToBitmap(this.grayscale(t)),r=new o.a(n),i=r.detect(),s=a.a.decode(i.bits),h=s.DataByte,f="",w=0;w<h.length;w++)for(var u=0;u<h[w].length;u++)f+=String.fromCharCode(h[w][u]);var l=(new Date).getTime(),c=l-e;return this.debug&&console.log("QR Code processing time (ms): "+c),this.decode_utf8(f)},r.prototype.getPixel=function(t,e,n){if(t.width<e)throw"point error";if(t.height<n)throw"point error";var r=4*e+n*t.width*4;return(33*t.data[r]+34*t.data[r+1]+33*t.data[r+2])/100},r.prototype.binarize=function(t){for(var e=new Array(this.width*this.height),n=0;n<this.height;n++)for(var r=0;r<this.width;r++){var i=this.getPixel(r,n);e[r+n*this.width]=i<=t}return e},r.prototype.getMiddleBrightnessPerArea=function(t){for(var e=4,n=Math.floor(t.width/e),r=Math.floor(t.height/e),i=new Array(e),o=0;o<e;o++){i[o]=new Array(e);for(var a=0;a<e;a++)i[o][a]=[0,0]}for(var s=0;s<e;s++)for(var h=0;h<e;h++){i[h][s][0]=255;for(var f=0;f<r;f++)for(var w=0;w<n;w++){var u=t.data[n*h+w+(r*s+f)*t.width];u<i[h][s][0]&&(i[h][s][0]=u),u>i[h][s][1]&&(i[h][s][1]=u)}}for(var l=new Array(e),c=0;c<e;c++)l[c]=new Array(e);for(var s=0;s<e;s++)for(var h=0;h<e;h++)l[h][s]=Math.floor((i[h][s][0]+i[h][s][1])/2);return l},r.prototype.grayScaleToBitmap=function(t){for(var e=this.getMiddleBrightnessPerArea(t),n=e.length,r=Math.floor(t.width/n),i=Math.floor(t.height/n),o=0;o<n;o++)for(var a=0;a<n;a++)for(var s=0;s<i;s++)for(var h=0;h<r;h++)t.data[r*a+h+(i*o+s)*t.width]=t.data[r*a+h+(i*o+s)*t.width]<e[a][o];return t},r.prototype.grayscale=function(t){for(var e=new Array(t.width*t.height),n=0;n<t.height;n++)for(var r=0;r<t.width;r++){var i=this.getPixel(t,r,n);e[r+n*t.width]=i}return{height:t.height,width:t.width,data:e}}},function(t,e,n){"use strict";function r(t){this.expTable=new Array(256),this.logTable=new Array(256);for(var e=1,n=0;n<256;n++)this.expTable[n]=e,e<<=1,e>=256&&(e^=t);for(var n=0;n<255;n++)this.logTable[this.expTable[n]]=n;var r=new Array(1);r[0]=0,this.zero=new i.a(this,new Array(r));var o=new Array(1);o[0]=1,this.one=new i.a(this,new Array(o))}var i=n(4);e.a=r,Object.defineProperty(r.prototype,"Zero",{get:function(){return this.zero}}),Object.defineProperty(r.prototype,"One",{get:function(){return this.one}}),r.prototype.buildMonomial=function(t,e){if(t<0)throw"System.ArgumentException";if(0==e)return this.zero;for(var n=new Array(t+1),r=0;r<n.length;r++)n[r]=0;return n[0]=e,new i.a(this,n)},r.prototype.exp=function(t){return this.expTable[t]},r.prototype.log=function(t){if(0==t)throw"System.ArgumentException";return this.logTable[t]},r.prototype.inverse=function(t){if(0==t)throw"System.ArithmeticException";return this.expTable[255-this.logTable[t]]},r.prototype.multiply=function(t,e){return 0==t||0==e?0:1==t?e:1==e?t:this.expTable[(this.logTable[t]+this.logTable[e])%255]},r.QR_CODE_FIELD=new r(285),r.DATA_MATRIX_FIELD=new r(301),r.addOrSubtract=function(t,e){return t^e}},function(t,e,n){"use strict";function r(t,e){if(e||(e=t),t<1||e<1)throw"Both dimensions must be greater than 0";this.width=t,this.height=e;var n=t>>5;0!=(31&t)&&n++,this.rowSize=n,this.bits=new Array(n*e);for(var r=0;r<this.bits.length;r++)this.bits[r]=0}var i=n(0);e.a=r,Object.defineProperty(r.prototype,"Dimension",{get:function(){if(this.width!=this.height)throw"Can\'t call getDimension() on a non-square matrix";return this.width}}),r.prototype.get_Renamed=function(t,e){var r=e*this.rowSize+(t>>5);return 0!=(1&n.i(i.c)(this.bits[r],31&t))},r.prototype.set_Renamed=function(t,e){var n=e*this.rowSize+(t>>5);this.bits[n]|=1<<(31&t)},r.prototype.flip=function(t,e){var n=e*this.rowSize+(t>>5);this.bits[n]^=1<<(31&t)},r.prototype.clear=function(){for(var t=this.bits.length,e=0;e<t;e++)this.bits[e]=0},r.prototype.setRegion=function(t,e,n,r){if(e<0||t<0)throw"Left and top must be nonnegative";if(r<1||n<1)throw"Height and width must be at least 1";var i=t+n,o=e+r;if(o>this.height||i>this.width)throw"The region must fit inside the matrix";for(var a=e;a<o;a++)for(var s=a*this.rowSize,h=t;h<i;h++)this.bits[s+(h>>5)]|=1<<(31&h)}},function(t,e,n){"use strict";function r(t){this.errorCorrectionLevel=o.a.forBits(t>>3&3),this.dataMask=7&t}var i=n(0),o=n(15);e.a=r;var a=21522,s=[[21522,0],[20773,1],[24188,2],[23371,3],[17913,4],[16590,5],[20375,6],[19104,7],[30660,8],[29427,9],[32170,10],[30877,11],[26159,12],[25368,13],[27713,14],[26998,15],[5769,16],[5054,17],[7399,18],[6608,19],[1890,20],[597,21],[3340,22],[2107,23],[13663,24],[12392,25],[16177,26],[14854,27],[9396,28],[8579,29],[11994,30],[11245,31]],h=[0,1,1,2,1,2,2,3,1,2,2,3,2,3,3,4];r.prototype.GetHashCode=function(){return this.errorCorrectionLevel.ordinal()<<3|this.dataMask},r.prototype.Equals=function(t){var e=t;return this.errorCorrectionLevel==e.errorCorrectionLevel&&this.dataMask==e.dataMask},r.numBitsDiffering=function(t,e){return t^=e,h[15&t]+h[15&n.i(i.c)(t,4)]+h[15&n.i(i.c)(t,8)]+h[15&n.i(i.c)(t,12)]+h[15&n.i(i.c)(t,16)]+h[15&n.i(i.c)(t,20)]+h[15&n.i(i.c)(t,24)]+h[15&n.i(i.c)(t,28)]},r.decodeFormatInformation=function(t){var e=r.doDecodeFormatInformation(t);return null!=e?e:r.doDecodeFormatInformation(t^a)},r.doDecodeFormatInformation=function(t){for(var e=4294967295,n=0,i=0;i<s.length;i++){var o=s[i],a=o[0];if(a==t)return new r(o[1]);var h=this.numBitsDiffering(t,a);h<e&&(n=o[1],e=h)}return e<=3?new r(n):null}},function(t,e,n){"use strict";function r(t,e){if(null==e||0==e.length)throw"System.ArgumentException";this.field=t;var n=e.length;if(n>1&&0==e[0]){for(var r=1;r<n&&0==e[r];)r++;if(r==n)this.coefficients=t.Zero.coefficients;else{this.coefficients=new Array(n-r);for(var i=0;i<this.coefficients.length;i++)this.coefficients[i]=0;for(var o=0;o<this.coefficients.length;o++)this.coefficients[o]=e[r+o]}}else this.coefficients=e}var i=n(1);e.a=r,Object.defineProperty(r.prototype,"Zero",{get:function(){return 0==this.coefficients[0]}}),Object.defineProperty(r.prototype,"Degree",{get:function(){return this.coefficients.length-1}}),r.prototype.getCoefficient=function(t){return this.coefficients[this.coefficients.length-1-t]},r.prototype.evaluateAt=function(t){if(0==t)return this.getCoefficient(0);var e=this.coefficients.length;if(1==t){for(var n=0,r=0;r<e;r++)n=i.a.addOrSubtract(n,this.coefficients[r]);return n}for(var o=this.coefficients[0],r=1;r<e;r++)o=i.a.addOrSubtract(this.field.multiply(t,o),this.coefficients[r]);return o},r.prototype.addOrSubtract=function(t){if(this.field!=t.field)throw"GF256Polys do not have same GF256 field";if(this.Zero)return t;if(t.Zero)return this;var e=this.coefficients,n=t.coefficients;if(e.length>n.length){var o=e;e=n,n=o}for(var a=new Array(n.length),s=n.length-e.length,h=0;h<s;h++)a[h]=n[h];for(var f=s;f<n.length;f++)a[f]=i.a.addOrSubtract(e[f-s],n[f]);return new r(this.field,a)},r.prototype.multiply1=function(t){if(this.field!=t.field)throw"GF256Polys do not have same GF256 field";if(this.Zero||t.Zero)return this.field.Zero;for(var e=this.coefficients,n=e.length,o=t.coefficients,a=o.length,s=new Array(n+a-1),h=0;h<n;h++)for(var f=e[h],w=0;w<a;w++)s[h+w]=i.a.addOrSubtract(s[h+w],this.field.multiply(f,o[w]));return new r(this.field,s)},r.prototype.multiply2=function(t){if(0==t)return this.field.Zero;if(1==t)return this;for(var e=this.coefficients.length,n=new Array(e),i=0;i<e;i++)n[i]=this.field.multiply(this.coefficients[i],t);return new r(this.field,n)},r.prototype.multiplyByMonomial=function(t,e){if(t<0)throw"System.ArgumentException";if(0==e)return this.field.Zero;for(var n=this.coefficients.length,i=new Array(n+t),o=0;o<i.length;o++)i[o]=0;for(var o=0;o<n;o++)i[o]=this.field.multiply(this.coefficients[o],e);return new r(this.field,i)},r.prototype.divide=function(t){if(this.field!=t.field)throw"GF256Polys do not have same GF256 field";if(t.Zero)throw"Divide by 0";for(var e=this.field.Zero,n=this,r=t.getCoefficient(t.Degree),i=this.field.inverse(r);n.Degree>=t.Degree&&!n.Zero;){var o=n.Degree-t.Degree,a=this.field.multiply(n.getCoefficient(n.Degree),i),s=t.multiplyByMonomial(o,a),h=this.field.buildMonomial(o,a);e=e.addOrSubtract(h),n=n.addOrSubtract(s)}return[e,n]}},function(t,e,n){"use strict";function r(t,e){this.count=t,this.dataCodewords=e}function i(t,e,n){this.ecCodewordsPerBlock=t,n?this.ecBlocks=[e,n]:this.ecBlocks=[e]}function o(t,e,n,r,i,o){this.versionNumber=t,this.alignmentPatternCenters=e,this.ecBlocks=[n,r,i,o];for(var a=0,s=n.ecCodewordsPerBlock,h=n.getECBlocks(),f=0;f<h.length;f++){var w=h[f];a+=w.count*(w.dataCodewords+s)}this.totalCodewords=a}function a(){return[new o(1,[],new i(7,new r(1,19)),new i(10,new r(1,16)),new i(13,new r(1,13)),new i(17,new r(1,9))),new o(2,[6,18],new i(10,new r(1,34)),new i(16,new r(1,28)),new i(22,new r(1,22)),new i(28,new r(1,16))),new o(3,[6,22],new i(15,new r(1,55)),new i(26,new r(1,44)),new i(18,new r(2,17)),new i(22,new r(2,13))),new o(4,[6,26],new i(20,new r(1,80)),new i(18,new r(2,32)),new i(26,new r(2,24)),new i(16,new r(4,9))),new o(5,[6,30],new i(26,new r(1,108)),new i(24,new r(2,43)),new i(18,new r(2,15),new r(2,16)),new i(22,new r(2,11),new r(2,12))),new o(6,[6,34],new i(18,new r(2,68)),new i(16,new r(4,27)),new i(24,new r(4,19)),new i(28,new r(4,15))),new o(7,[6,22,38],new i(20,new r(2,78)),new i(18,new r(4,31)),new i(18,new r(2,14),new r(4,15)),new i(26,new r(4,13),new r(1,14))),new o(8,[6,24,42],new i(24,new r(2,97)),new i(22,new r(2,38),new r(2,39)),new i(22,new r(4,18),new r(2,19)),new i(26,new r(4,14),new r(2,15))),new o(9,[6,26,46],new i(30,new r(2,116)),new i(22,new r(3,36),new r(2,37)),new i(20,new r(4,16),new r(4,17)),new i(24,new r(4,12),new r(4,13))),new o(10,[6,28,50],new i(18,new r(2,68),new r(2,69)),new i(26,new r(4,43),new r(1,44)),new i(24,new r(6,19),new r(2,20)),new i(28,new r(6,15),new r(2,16))),new o(11,[6,30,54],new i(20,new r(4,81)),new i(30,new r(1,50),new r(4,51)),new i(28,new r(4,22),new r(4,23)),new i(24,new r(3,12),new r(8,13))),new o(12,[6,32,58],new i(24,new r(2,92),new r(2,93)),new i(22,new r(6,36),new r(2,37)),new i(26,new r(4,20),new r(6,21)),new i(28,new r(7,14),new r(4,15))),new o(13,[6,34,62],new i(26,new r(4,107)),new i(22,new r(8,37),new r(1,38)),new i(24,new r(8,20),new r(4,21)),new i(22,new r(12,11),new r(4,12))),new o(14,[6,26,46,66],new i(30,new r(3,115),new r(1,116)),new i(24,new r(4,40),new r(5,41)),new i(20,new r(11,16),new r(5,17)),new i(24,new r(11,12),new r(5,13))),new o(15,[6,26,48,70],new i(22,new r(5,87),new r(1,88)),new i(24,new r(5,41),new r(5,42)),new i(30,new r(5,24),new r(7,25)),new i(24,new r(11,12),new r(7,13))),new o(16,[6,26,50,74],new i(24,new r(5,98),new r(1,99)),new i(28,new r(7,45),new r(3,46)),new i(24,new r(15,19),new r(2,20)),new i(30,new r(3,15),new r(13,16))),new o(17,[6,30,54,78],new i(28,new r(1,107),new r(5,108)),new i(28,new r(10,46),new r(1,47)),new i(28,new r(1,22),new r(15,23)),new i(28,new r(2,14),new r(17,15))),new o(18,[6,30,56,82],new i(30,new r(5,120),new r(1,121)),new i(26,new r(9,43),new r(4,44)),new i(28,new r(17,22),new r(1,23)),new i(28,new r(2,14),new r(19,15))),new o(19,[6,30,58,86],new i(28,new r(3,113),new r(4,114)),new i(26,new r(3,44),new r(11,45)),new i(26,new r(17,21),new r(4,22)),new i(26,new r(9,13),new r(16,14))),new o(20,[6,34,62,90],new i(28,new r(3,107),new r(5,108)),new i(26,new r(3,41),new r(13,42)),new i(30,new r(15,24),new r(5,25)),new i(28,new r(15,15),new r(10,16))),new o(21,[6,28,50,72,94],new i(28,new r(4,116),new r(4,117)),new i(26,new r(17,42)),new i(28,new r(17,22),new r(6,23)),new i(30,new r(19,16),new r(6,17))),new o(22,[6,26,50,74,98],new i(28,new r(2,111),new r(7,112)),new i(28,new r(17,46)),new i(30,new r(7,24),new r(16,25)),new i(24,new r(34,13))),new o(23,[6,30,54,74,102],new i(30,new r(4,121),new r(5,122)),new i(28,new r(4,47),new r(14,48)),new i(30,new r(11,24),new r(14,25)),new i(30,new r(16,15),new r(14,16))),new o(24,[6,28,54,80,106],new i(30,new r(6,117),new r(4,118)),new i(28,new r(6,45),new r(14,46)),new i(30,new r(11,24),new r(16,25)),new i(30,new r(30,16),new r(2,17))),new o(25,[6,32,58,84,110],new i(26,new r(8,106),new r(4,107)),new i(28,new r(8,47),new r(13,48)),new i(30,new r(7,24),new r(22,25)),new i(30,new r(22,15),new r(13,16))),new o(26,[6,30,58,86,114],new i(28,new r(10,114),new r(2,115)),new i(28,new r(19,46),new r(4,47)),new i(28,new r(28,22),new r(6,23)),new i(30,new r(33,16),new r(4,17))),new o(27,[6,34,62,90,118],new i(30,new r(8,122),new r(4,123)),new i(28,new r(22,45),new r(3,46)),new i(30,new r(8,23),new r(26,24)),new i(30,new r(12,15),new r(28,16))),new o(28,[6,26,50,74,98,122],new i(30,new r(3,117),new r(10,118)),new i(28,new r(3,45),new r(23,46)),new i(30,new r(4,24),new r(31,25)),new i(30,new r(11,15),new r(31,16))),new o(29,[6,30,54,78,102,126],new i(30,new r(7,116),new r(7,117)),new i(28,new r(21,45),new r(7,46)),new i(30,new r(1,23),new r(37,24)),new i(30,new r(19,15),new r(26,16))),new o(30,[6,26,52,78,104,130],new i(30,new r(5,115),new r(10,116)),new i(28,new r(19,47),new r(10,48)),new i(30,new r(15,24),new r(25,25)),new i(30,new r(23,15),new r(25,16))),new o(31,[6,30,56,82,108,134],new i(30,new r(13,115),new r(3,116)),new i(28,new r(2,46),new r(29,47)),new i(30,new r(42,24),new r(1,25)),new i(30,new r(23,15),new r(28,16))),new o(32,[6,34,60,86,112,138],new i(30,new r(17,115)),new i(28,new r(10,46),new r(23,47)),new i(30,new r(10,24),new r(35,25)),new i(30,new r(19,15),new r(35,16))),new o(33,[6,30,58,86,114,142],new i(30,new r(17,115),new r(1,116)),new i(28,new r(14,46),new r(21,47)),new i(30,new r(29,24),new r(19,25)),new i(30,new r(11,15),new r(46,16))),new o(34,[6,34,62,90,118,146],new i(30,new r(13,115),new r(6,116)),new i(28,new r(14,46),new r(23,47)),new i(30,new r(44,24),new r(7,25)),new i(30,new r(59,16),new r(1,17))),new o(35,[6,30,54,78,102,126,150],new i(30,new r(12,121),new r(7,122)),new i(28,new r(12,47),new r(26,48)),new i(30,new r(39,24),new r(14,25)),new i(30,new r(22,15),new r(41,16))),new o(36,[6,24,50,76,102,128,154],new i(30,new r(6,121),new r(14,122)),new i(28,new r(6,47),new r(34,48)),new i(30,new r(46,24),new r(10,25)),new i(30,new r(2,15),new r(64,16))),new o(37,[6,28,54,80,106,132,158],new i(30,new r(17,122),new r(4,123)),new i(28,new r(29,46),new r(14,47)),new i(30,new r(49,24),new r(10,25)),new i(30,new r(24,15),new r(46,16))),new o(38,[6,32,58,84,110,136,162],new i(30,new r(4,122),new r(18,123)),new i(28,new r(13,46),new r(32,47)),new i(30,new r(48,24),new r(14,25)),new i(30,new r(42,15),new r(32,16))),new o(39,[6,26,54,82,110,138,166],new i(30,new r(20,117),new r(4,118)),new i(28,new r(40,47),new r(7,48)),new i(30,new r(43,24),new r(22,25)),new i(30,new r(10,15),new r(67,16))),new o(40,[6,30,58,86,114,142,170],new i(30,new r(19,118),new r(6,119)),new i(28,new r(18,47),new r(31,48)),new i(30,new r(34,24),new r(34,25)),new i(30,new r(20,15),new r(61,16)))]}var s=n(3),h=n(2);e.a=o,Object.defineProperty(i.prototype,"TotalECCodewords",{get:function(){return this.ecCodewordsPerBlock*this.NumBlocks}}),Object.defineProperty(i.prototype,"NumBlocks",{get:function(){for(var t=0,e=0;e<this.ecBlocks.length;e++)t+=this.ecBlocks[e].length;return t}}),i.prototype.getECBlocks=function(){return this.ecBlocks},Object.defineProperty(o.prototype,"DimensionForVersion",{get:function(){return 17+4*this.versionNumber}}),o.prototype.buildFunctionPattern=function(){var t=this.DimensionForVersion,e=new h.a(t);e.setRegion(0,0,9,9),e.setRegion(t-8,0,8,9),e.setRegion(0,t-8,9,8);for(var n=this.alignmentPatternCenters.length,r=0;r<n;r++)for(var i=this.alignmentPatternCenters[r]-2,o=0;o<n;o++)0==r&&(0==o||o==n-1)||r==n-1&&0==o||e.setRegion(this.alignmentPatternCenters[o]-2,i,5,5);return e.setRegion(6,9,1,t-17),e.setRegion(9,6,t-17,1),this.versionNumber>6&&(e.setRegion(t-11,0,3,6),e.setRegion(0,t-11,6,3)),e},o.prototype.getECBlocksForLevel=function(t){return this.ecBlocks[t.ordinal()]},o.VERSION_DECODE_INFO=[31892,34236,39577,42195,48118,51042,55367,58893,63784,68472,70749,76311,79154,84390,87683,92361,96236,102084,102881,110507,110734,117786,119615,126325,127568,133589,136944,141498,145311,150283,152622,158308,161089,167017],o.VERSIONS=a(),o.getVersionForNumber=function(t){if(t<1||t>40)throw"ArgumentException";return o.VERSIONS[t-1]},o.getProvisionalVersionForDimension=function(t){if(t%4!=1)throw"Error getProvisionalVersionForDimension";try{return o.getVersionForNumber(t-17>>2)}catch(t){throw"Error getVersionForNumber"}},o.decodeVersionInformation=function(t){for(var e=4294967295,n=0,r=0;r<o.VERSION_DECODE_INFO.length;r++){var i=o.VERSION_DECODE_INFO[r];if(i==t)return this.getVersionForNumber(r+7);var a=s.a.numBitsDiffering(t,i);a<e&&(n=r+7,e=a)}return e<=3?this.getVersionForNumber(n):null}},function(t,e,n){"use strict";Object.defineProperty(e,"__esModule",{value:!0});var r=n(0);e.default=r.a},function(t,e){t.exports=function(t){return t.webpackPolyfill||(t.deprecate=function(){},t.paths=[],t.children||(t.children=[]),Object.defineProperty(t,"loaded",{enumerable:!0,get:function(){return t.l}}),Object.defineProperty(t,"id",{enumerable:!0,get:function(){return t.i}}),t.webpackPolyfill=1),t}},function(t,e,n){"use strict";function r(t,e,n){this.x=t,this.y=e,this.count=1,this.estimatedModuleSize=n}function i(t,e,n,r,i,o,a){this.image=t,this.possibleCenters=[],this.startX=e,this.startY=n,this.width=r,this.height=i,this.moduleSize=o,this.crossCheckStateCount=[0,0,0],this.resultPointCallback=a}e.a=i,Object.defineProperty(r.prototype,"X",{get:function(){return Math.floor(this.x)}}),Object.defineProperty(r.prototype,"Y",{get:function(){return Math.floor(this.y)}}),r.prototype.incrementCount=function(){this.count++},r.prototype.aboutEquals=function(t,e,n){if(Math.abs(e-this.y)<=t&&Math.abs(n-this.x)<=t){var r=Math.abs(t-this.estimatedModuleSize);return r<=1||r/this.estimatedModuleSize<=1}return!1},i.prototype.centerFromEnd=function(t,e){return e-t[2]-t[1]/2},i.prototype.foundPatternCross=function(t){for(var e=this.moduleSize,n=e/2,r=0;r<3;r++)if(Math.abs(e-t[r])>=n)return!1;return!0},i.prototype.crossCheckVertical=function(t,e,n,r){var i=this.image,o=i.height,a=this.crossCheckStateCount;a[0]=0,a[1]=0,a[2]=0;for(var s=t;s>=0&&i.data[e+s*i.width]&&a[1]<=n;)a[1]++,s--;if(s<0||a[1]>n)return NaN;for(;s>=0&&!i.data[e+s*i.width]&&a[0]<=n;)a[0]++,s--;if(a[0]>n)return NaN;for(s=t+1;s<o&&i.data[e+s*i.width]&&a[1]<=n;)a[1]++,s++;if(s==o||a[1]>n)return NaN;for(;s<o&&!i.data[e+s*i.width]&&a[2]<=n;)a[2]++,s++;if(a[2]>n)return NaN;var h=a[0]+a[1]+a[2];return 5*Math.abs(h-r)>=2*r?NaN:this.foundPatternCross(a)?this.centerFromEnd(a,s):NaN},i.prototype.handlePossibleCenter=function(t,e,n){var i=t[0]+t[1]+t[2],o=this.centerFromEnd(t,n),a=this.crossCheckVertical(e,Math.floor(o),2*t[1],i);if(!isNaN(a)){for(var s=(t[0]+t[1]+t[2])/3,h=this.possibleCenters.length,f=0;f<h;f++){var w=this.possibleCenters[f];if(w.aboutEquals(s,a,o))return new r(o,a,s)}var u=new r(o,a,s);this.possibleCenters.push(u),null!=this.resultPointCallback&&this.resultPointCallback.foundPossibleResultPoint(u)}return null},i.prototype.find=function(){for(var t=this.image,e=this.startX,n=this.height,r=e+this.width,i=this.startY+(n>>1),o=[0,0,0],a=0;a<n;a++){var s=i+(0==(1&a)?a+1>>1:-(a+1>>1));o[0]=0,o[1]=0,o[2]=0;for(var h=e;h<r&&!t.data[h+t.width*s];)h++;for(var f=0;h<r;){if(t.data[h+s*t.width])if(1==f)o[f]++;else if(2==f){if(this.foundPatternCross(o)){var w=this.handlePossibleCenter(o,s,h);if(null!=w)return w}o[0]=o[2],o[1]=1,o[2]=0,f=1}else o[++f]++;else 1==f&&f++,o[f]++;h++}if(this.foundPatternCross(o)){var w=this.handlePossibleCenter(o,s,r);if(null!=w)return w}}if(0!=this.possibleCenters.length)return this.possibleCenters[0];throw"Couldn\'t find enough alignment patterns"}},function(t,e,n){"use strict";function r(t){var e=t.Dimension;if(e<21||1!=(3&e))throw"Error BitMatrixParser";this.bitMatrix=t,this.parsedVersion=null,this.parsedFormatInfo=null}var i=n(3),o=n(5),a=n(12);e.a=r,r.prototype.copyBit=function(t,e,n){return this.bitMatrix.get_Renamed(t,e)?n<<1|1:n<<1},r.prototype.readFormatInformation=function(){if(null!=this.parsedFormatInfo)return this.parsedFormatInfo;for(var t=0,e=0;e<6;e++)t=this.copyBit(e,8,t);t=this.copyBit(7,8,t),t=this.copyBit(8,8,t),t=this.copyBit(8,7,t);for(var n=5;n>=0;n--)t=this.copyBit(8,n,t);if(this.parsedFormatInfo=i.a.decodeFormatInformation(t),null!=this.parsedFormatInfo)return this.parsedFormatInfo;var r=this.bitMatrix.Dimension;t=0;for(var o=r-8,e=r-1;e>=o;e--)t=this.copyBit(e,8,t);for(var n=r-7;n<r;n++)t=this.copyBit(8,n,t);if(this.parsedFormatInfo=i.a.decodeFormatInformation(t),null!=this.parsedFormatInfo)return this.parsedFormatInfo;throw"Error readFormatInformation"},r.prototype.readVersion=function(){if(null!=this.parsedVersion)return this.parsedVersion;var t=this.bitMatrix.Dimension,e=t-17>>2;if(e<=6)return o.a.getVersionForNumber(e);for(var n=0,r=t-11,i=5;i>=0;i--)for(var a=t-9;a>=r;a--)n=this.copyBit(a,i,n);if(this.parsedVersion=o.a.decodeVersionInformation(n),null!=this.parsedVersion&&this.parsedVersion.DimensionForVersion==t)return this.parsedVersion;n=0;for(var a=5;a>=0;a--)for(var i=t-9;i>=r;i--)n=this.copyBit(a,i,n);if(this.parsedVersion=o.a.decodeVersionInformation(n),null!=this.parsedVersion&&this.parsedVersion.DimensionForVersion==t)return this.parsedVersion;throw"Error readVersion"},r.prototype.readCodewords=function(){var t=this.readFormatInformation(),e=this.readVersion(),n=a.a.forReference(t.dataMask),r=this.bitMatrix.Dimension;n.unmaskBitMatrix(this.bitMatrix,r);for(var i=e.buildFunctionPattern(),o=!0,s=new Array(e.totalCodewords),h=0,f=0,w=0,u=r-1;u>0;u-=2){6==u&&u--;for(var l=0;l<r;l++)for(var c=o?r-1-l:l,d=0;d<2;d++)i.get_Renamed(u-d,c)||(w++,f<<=1,this.bitMatrix.get_Renamed(u-d,c)&&(f|=1),8==w&&(s[h++]=f,w=0,f=0));o^=!0}if(h!=e.totalCodewords)throw"Error readCodewords";return s}},function(t,e,n){"use strict";function r(t,e){this.numDataCodewords=t,this.codewords=e}e.a=r,r.getDataBlocks=function(t,e,n){if(t.length!=e.totalCodewords)throw"ArgumentException";for(var i=e.getECBlocksForLevel(n),o=0,a=i.getECBlocks(),s=0;s<a.length;s++)o+=a[s].count;for(var h=new Array(o),f=0,w=0;w<a.length;w++)for(var u=a[w],s=0;s<u.count;s++){var l=u.dataCodewords,c=i.ecCodewordsPerBlock+l;h[f++]=new r(l,new Array(c))}for(var d=h[0].codewords.length,p=h.length-1;p>=0;){var g=h[p].codewords.length;if(g==d)break;p--}p++;for(var v=d-i.ecCodewordsPerBlock,m=0,s=0;s<v;s++)for(var w=0;w<f;w++)h[w].codewords[s]=t[m++];for(var w=p;w<f;w++)h[w].codewords[v]=t[m++];for(var b=h[0].codewords.length,s=v;s<b;s++)for(var w=0;w<f;w++){var y=w<p?s:s+1;h[w].codewords[y]=t[m++]}return h}},function(t,e,n){"use strict";function r(t,e,n){this.blockPointer=0,this.bitPointer=7,this.dataLength=0,this.blocks=t,this.numErrorCorrectionCode=n,e<=9?this.dataLengthMode=0:e>=10&&e<=26?this.dataLengthMode=1:e>=27&&e<=40&&(this.dataLengthMode=2)}var i=n(0);e.a=r,r.prototype.getNextBits=function(t){var e=0;if(t<this.bitPointer+1){for(var n=0,r=0;r<t;r++)n+=1<<r;return n<<=this.bitPointer-t+1,e=(this.blocks[this.blockPointer]&n)>>this.bitPointer-t+1,this.bitPointer-=t,e}if(t<this.bitPointer+1+8){for(var i=0,r=0;r<this.bitPointer+1;r++)i+=1<<r;return e=(this.blocks[this.blockPointer]&i)<<t-(this.bitPointer+1),this.blockPointer++,e+=this.blocks[this.blockPointer]>>8-(t-(this.bitPointer+1)),this.bitPointer=this.bitPointer-t%8,this.bitPointer<0&&(this.bitPointer=8+this.bitPointer),e}if(t<this.bitPointer+1+16){for(var i=0,o=0,r=0;r<this.bitPointer+1;r++)i+=1<<r;var a=(this.blocks[this.blockPointer]&i)<<t-(this.bitPointer+1);this.blockPointer++;var s=this.blocks[this.blockPointer]<<t-(this.bitPointer+1+8);this.blockPointer++;for(var r=0;r<t-(this.bitPointer+1+8);r++)o+=1<<r;o<<=8-(t-(this.bitPointer+1+8));var h=(this.blocks[this.blockPointer]&o)>>8-(t-(this.bitPointer+1+8));return e=a+s+h,this.bitPointer=this.bitPointer-(t-8)%8,this.bitPointer<0&&(this.bitPointer=8+this.bitPointer),e}return 0},r.prototype.NextMode=function(){return this.blockPointer>this.blocks.length-this.numErrorCorrectionCode-2?0:this.getNextBits(4)},r.prototype.getDataLength=function(t){for(var e=0;;){if(t>>e==1)break;e++}return this.getNextBits(i.b.sizeOfDataLengthInfo[this.dataLengthMode][e])},r.prototype.getRomanAndFigureString=function(t){var e=t,n=0,r="",i=["0","1","2","3","4","5","6","7","8","9","A","B","C","D","E","F","G","H","I","J","K","L","M","N","O","P","Q","R","S","T","U","V","W","X","Y","Z"," ","$","%","*","+","-",".","/",":"];do if(e>1){n=this.getNextBits(11);var o=Math.floor(n/45),a=n%45;r+=i[o],r+=i[a],e-=2}else 1==e&&(n=this.getNextBits(6),r+=i[n],e-=1);while(e>0);return r},r.prototype.getFigureString=function(t){var e=t,n=0,r="";do e>=3?(n=this.getNextBits(10),n<100&&(r+="0"),n<10&&(r+="0"),e-=3):2==e?(n=this.getNextBits(7),n<10&&(r+="0"),e-=2):1==e&&(n=this.getNextBits(4),e-=1),r+=n;while(e>0);return r},r.prototype.get8bitByteArray=function(t){var e=t,n=0,r=[];do n=this.getNextBits(8),r.push(n),e--;while(e>0);return r},r.prototype.getKanjiString=function(t){var e=t,n=0,r="";do{n=this.getNextBits(13);var i=n%192,o=n/192,a=(o<<8)+i,s=0;s=a+33088<=40956?a+33088:a+49472,r+=String.fromCharCode(s),e--}while(e>0);return r},Object.defineProperty(r.prototype,"DataByte",{get:function(){for(var t=[],e=1,n=2,r=4,i=8;;){var o=this.NextMode();if(0==o){if(t.length>0)break;throw"Empty data block"}if(o!=e&&o!=n&&o!=r&&o!=i)throw"Invalid mode: "+o+" in (block:"+this.blockPointer+" bit:"+this.bitPointer+")";var a=this.getDataLength(o);if(a<1)throw"Invalid data length: "+a;switch(o){case e:for(var s=this.getFigureString(a),h=new Array(s.length),f=0;f<s.length;f++)h[f]=s.charCodeAt(f);t.push(h);break;case n:for(var s=this.getRomanAndFigureString(a),h=new Array(s.length),f=0;f<s.length;f++)h[f]=s.charCodeAt(f);t.push(h);break;case r:var w=this.get8bitByteArray(a);t.push(w);break;case i:var s=this.getKanjiString(a);t.push(s)}}return t}})},function(t,e,n){"use strict";function r(){this.unmaskBitMatrix=function(t,e){for(var n=0;n<e;n++)for(var r=0;r<e;r++)this.isMasked(n,r)&&t.flip(r,n)},this.isMasked=function(t,e){return 0==(t+e&1)}}function i(){this.unmaskBitMatrix=function(t,e){for(var n=0;n<e;n++)for(var r=0;r<e;r++)this.isMasked(n,r)&&t.flip(r,n)},this.isMasked=function(t,e){return 0==(1&t)}}function o(){this.unmaskBitMatrix=function(t,e){for(var n=0;n<e;n++)for(var r=0;r<e;r++)this.isMasked(n,r)&&t.flip(r,n)},this.isMasked=function(t,e){return e%3==0}}function a(){this.unmaskBitMatrix=function(t,e){for(var n=0;n<e;n++)for(var r=0;r<e;r++)this.isMasked(n,r)&&t.flip(r,n)},this.isMasked=function(t,e){return(t+e)%3==0}}function s(){this.unmaskBitMatrix=function(t,e){for(var n=0;n<e;n++)for(var r=0;r<e;r++)this.isMasked(n,r)&&t.flip(r,n)},this.isMasked=function(t,e){return 0==(n.i(u.c)(t,1)+e/3&1)}}function h(){this.unmaskBitMatrix=function(t,e){for(var n=0;n<e;n++)for(var r=0;r<e;r++)this.isMasked(n,r)&&t.flip(r,n)},this.isMasked=function(t,e){var n=t*e;return(1&n)+n%3==0}}function f(){this.unmaskBitMatrix=function(t,e){for(var n=0;n<e;n++)for(var r=0;r<e;r++)this.isMasked(n,r)&&t.flip(r,n)},this.isMasked=function(t,e){var n=t*e;return 0==((1&n)+n%3&1)}}function w(){this.unmaskBitMatrix=function(t,e){for(var n=0;n<e;n++)for(var r=0;r<e;r++)this.isMasked(n,r)&&t.flip(r,n)},this.isMasked=function(t,e){return 0==((t+e&1)+t*e%3&1)}}var u=n(0),l={};l.forReference=function(t){if(t<0||t>7)throw"System.ArgumentException";return l.DATA_MASKS[t]},l.DATA_MASKS=[new r,new i,new o,new a,new s,new h,new f,new w],e.a=l},function(t,e,n){"use strict";var r=n(18),i=n(1),o=n(9),a=n(10),s=n(11),h={};h.rsDecoder=new r.a(i.a.QR_CODE_FIELD),h.correctErrors=function(t,e){for(var n=t.length,r=new Array(n),i=0;i<n;i++)r[i]=255&t[i];var o=t.length-e;try{h.rsDecoder.decode(r,o)}catch(t){throw t}for(var i=0;i<e;i++)t[i]=r[i]},h.decode=function(t){for(var e=new o.a(t),n=e.readVersion(),r=e.readFormatInformation().errorCorrectionLevel,i=e.readCodewords(),f=a.a.getDataBlocks(i,n,r),w=0,u=0;u<f.length;u++)w+=f[u].numDataCodewords;for(var l=new Array(w),c=0,d=0;d<f.length;d++){var p=f[d],g=p.codewords,v=p.numDataCodewords;h.correctErrors(g,v);for(var u=0;u<v;u++)l[c++]=g[u]}var m=new s.a(l,n.versionNumber,r.bits);return m},e.a=h},function(t,e,n){"use strict";function r(t,e,n,r,i,o,a,s,h){this.a11=t,this.a12=r,this.a13=a,this.a21=e,this.a22=i,this.a23=s,this.a31=n,this.a32=o,this.a33=h}function i(t,e){this.bits=t,this.points=e}function o(t){this.image=t,this.resultPointCallback=null}var a=n(5),s=n(8),h=n(17),f=n(16);e.a=o,r.prototype.transformPoints1=function(t){for(var e=t.length,n=this.a11,r=this.a12,i=this.a13,o=this.a21,a=this.a22,s=this.a23,h=this.a31,f=this.a32,w=this.a33,u=0;u<e;u+=2){var l=t[u],c=t[u+1],d=i*l+s*c+w;t[u]=(n*l+o*c+h)/d,t[u+1]=(r*l+a*c+f)/d}},r.prototype.transformPoints2=function(t,e){for(var n=t.length,r=0;r<n;r++){var i=t[r],o=e[r],a=this.a13*i+this.a23*o+this.a33;t[r]=(this.a11*i+this.a21*o+this.a31)/a,e[r]=(this.a12*i+this.a22*o+this.a32)/a}},r.prototype.buildAdjoint=function(){return new r(this.a22*this.a33-this.a23*this.a32,this.a23*this.a31-this.a21*this.a33,this.a21*this.a32-this.a22*this.a31,this.a13*this.a32-this.a12*this.a33,this.a11*this.a33-this.a13*this.a31,this.a12*this.a31-this.a11*this.a32,this.a12*this.a23-this.a13*this.a22,this.a13*this.a21-this.a11*this.a23,this.a11*this.a22-this.a12*this.a21)},r.prototype.times=function(t){return new r(this.a11*t.a11+this.a21*t.a12+this.a31*t.a13,this.a11*t.a21+this.a21*t.a22+this.a31*t.a23,this.a11*t.a31+this.a21*t.a32+this.a31*t.a33,this.a12*t.a11+this.a22*t.a12+this.a32*t.a13,this.a12*t.a21+this.a22*t.a22+this.a32*t.a23,this.a12*t.a31+this.a22*t.a32+this.a32*t.a33,this.a13*t.a11+this.a23*t.a12+this.a33*t.a13,this.a13*t.a21+this.a23*t.a22+this.a33*t.a23,this.a13*t.a31+this.a23*t.a32+this.a33*t.a33)},r.quadrilateralToQuadrilateral=function(t,e,n,r,i,o,a,s,h,f,w,u,l,c,d,p){var g=this.quadrilateralToSquare(t,e,n,r,i,o,a,s),v=this.squareToQuadrilateral(h,f,w,u,l,c,d,p);return v.times(g)},r.squareToQuadrilateral=function(t,e,n,i,o,a,s,h){var f=h-a,w=e-i+a-h;if(0==f&&0==w)return new r(n-t,o-n,t,i-e,a-i,e,0,0,1);\nvar u=n-o,l=s-o,c=t-n+o-s,d=i-a,p=u*f-l*d,g=(c*f-l*w)/p,v=(u*w-c*d)/p;return new r(n-t+g*n,s-t+v*s,t,i-e+g*i,h-e+v*h,e,g,v,1)},r.quadrilateralToSquare=function(t,e,n,r,i,o,a,s){return this.squareToQuadrilateral(t,e,n,r,i,o,a,s).buildAdjoint()},o.prototype.sizeOfBlackWhiteBlackRun=function(t,e,n,r){var i=Math.abs(r-e)>Math.abs(n-t);if(i){var o=t;t=e,e=o,o=n,n=r,r=o}for(var a=Math.abs(n-t),s=Math.abs(r-e),h=-a>>1,f=e<r?1:-1,w=t<n?1:-1,u=0,l=t,c=e;l!=n;l+=w){var d=i?c:l,p=i?l:c;if(1==u?this.image.data[d+p*this.image.width]&&u++:this.image.data[d+p*this.image.width]||u++,3==u){var g=l-t,v=c-e;return Math.sqrt(g*g+v*v)}if(h+=s,h>0){if(c==r)break;c+=f,h-=a}}var m=n-t,b=r-e;return Math.sqrt(m*m+b*b)},o.prototype.sizeOfBlackWhiteBlackRunBothWays=function(t,e,n,r){var i=this.sizeOfBlackWhiteBlackRun(t,e,n,r),o=1,a=t-(n-t);a<0?(o=t/(t-a),a=0):a>=this.image.width&&(o=(this.image.width-1-t)/(a-t),a=this.image.width-1);var s=Math.floor(e-(r-e)*o);return o=1,s<0?(o=e/(e-s),s=0):s>=this.image.height&&(o=(this.image.height-1-e)/(s-e),s=this.image.height-1),a=Math.floor(t+(a-t)*o),i+=this.sizeOfBlackWhiteBlackRun(t,e,a,s),i-1},o.prototype.calculateModuleSizeOneWay=function(t,e){var n=this.sizeOfBlackWhiteBlackRunBothWays(Math.floor(t.X),Math.floor(t.Y),Math.floor(e.X),Math.floor(e.Y)),r=this.sizeOfBlackWhiteBlackRunBothWays(Math.floor(e.X),Math.floor(e.Y),Math.floor(t.X),Math.floor(t.Y));return isNaN(n)?r/7:isNaN(r)?n/7:(n+r)/14},o.prototype.calculateModuleSize=function(t,e,n){return(this.calculateModuleSizeOneWay(t,e)+this.calculateModuleSizeOneWay(t,n))/2},o.prototype.distance=function(t,e){var n=t.X-e.X,r=t.Y-e.Y;return Math.sqrt(n*n+r*r)},o.prototype.computeDimension=function(t,e,n,r){var i=Math.round(this.distance(t,e)/r),o=Math.round(this.distance(t,n)/r),a=(i+o>>1)+7;switch(3&a){case 0:a++;break;case 2:a--;break;case 3:throw"Error"}return a},o.prototype.findAlignmentInRegion=function(t,e,n,r){var i=Math.floor(r*t),o=Math.max(0,e-i),a=Math.min(this.image.width-1,e+i);if(a-o<3*t)throw"Error";var h=Math.max(0,n-i),f=Math.min(this.image.height-1,n+i),w=new s.a(this.image,o,h,a-o,f-h,t,this.resultPointCallback);return w.find()},o.prototype.createTransform=function(t,e,n,i,o){var a,s,h,f,w=o-3.5;null!=i?(a=i.X,s=i.Y,h=f=w-3):(a=e.X-t.X+n.X,s=e.Y-t.Y+n.Y,h=f=w);var u=r.quadrilateralToQuadrilateral(3.5,3.5,w,3.5,h,f,3.5,w,t.X,t.Y,e.X,e.Y,a,s,n.X,n.Y);return u},o.prototype.sampleGrid=function(t,e,n){var r=h.a;return r.sampleGrid3(t,n,e)},o.prototype.processFinderPatternInfo=function(t){var e=t.topLeft,n=t.topRight,r=t.bottomLeft,o=this.calculateModuleSize(e,n,r);if(o<1)throw"Error";var s=this.computeDimension(e,n,r,o),h=a.a.getProvisionalVersionForDimension(s),f=h.DimensionForVersion-7,w=null;if(h.alignmentPatternCenters.length>0)for(var u=n.X-e.X+r.X,l=n.Y-e.Y+r.Y,c=1-3/f,d=Math.floor(e.X+c*(u-e.X)),p=Math.floor(e.Y+c*(l-e.Y)),g=4;g<=16;g<<=1){w=this.findAlignmentInRegion(o,d,p,g);break}var v,m=this.createTransform(e,n,r,w,s),b=this.sampleGrid(this.image,m,s);return v=null==w?[r,e,n]:[r,e,n,w],new i(b,v)},o.prototype.detect=function(){var t=(new f.a).findFinderPattern(this.image);return this.processFinderPatternInfo(t)}},function(t,e,n){"use strict";function r(t,e,n){this.ordinal_Renamed_Field=t,this.bits=e,this.name=n}e.a=r,r.prototype.ordinal=function(){return this.ordinal_Renamed_Field},r.forBits=function(t){if(t<0||t>=i.length)throw"ArgumentException";return i[t]};var i=[new r(1,0,"M"),new r(0,1,"L"),new r(3,2,"H"),new r(2,3,"Q")]},function(t,e,n){"use strict";function r(t){function e(t,e){var n=t.X-e.X,r=t.Y-e.Y;return Math.sqrt(n*n+r*r)}function n(t,e,n){var r=e.x,i=e.y;return(n.x-r)*(t.y-i)-(n.y-i)*(t.x-r)}var r,i,o,a=e(t[0],t[1]),s=e(t[1],t[2]),h=e(t[0],t[2]);if(s>=a&&s>=h?(i=t[0],r=t[1],o=t[2]):h>=s&&h>=a?(i=t[1],r=t[0],o=t[2]):(i=t[2],r=t[0],o=t[1]),n(r,i,o)<0){var f=r;r=o,o=f}t[0]=r,t[1]=i,t[2]=o}function i(t,e,n){this.x=t,this.y=e,this.count=1,this.estimatedModuleSize=n}function o(t){this.bottomLeft=t[0],this.topLeft=t[1],this.topRight=t[2]}function a(){this.image=null,this.possibleCenters=[],this.hasSkipped=!1,this.crossCheckStateCount=[0,0,0,0,0],this.resultPointCallback=null}e.a=a;var s=3,h=57,f=8,w=2;Object.defineProperty(i.prototype,"X",{get:function(){return this.x}}),Object.defineProperty(i.prototype,"Y",{get:function(){return this.y}}),i.prototype.incrementCount=function(){this.count++},i.prototype.aboutEquals=function(t,e,n){if(Math.abs(e-this.y)<=t&&Math.abs(n-this.x)<=t){var r=Math.abs(t-this.estimatedModuleSize);return r<=1||r/this.estimatedModuleSize<=1}return!1},Object.defineProperty(a.prototype,"CrossCheckStateCount",{get:function(){return this.crossCheckStateCount[0]=0,this.crossCheckStateCount[1]=0,this.crossCheckStateCount[2]=0,this.crossCheckStateCount[3]=0,this.crossCheckStateCount[4]=0,this.crossCheckStateCount}}),a.prototype.foundPatternCross=function(t){for(var e=0,n=0;n<5;n++){var r=t[n];if(0==r)return!1;e+=r}if(e<7)return!1;var i=Math.floor((e<<f)/7),o=Math.floor(i/2);return Math.abs(i-(t[0]<<f))<o&&Math.abs(i-(t[1]<<f))<o&&Math.abs(3*i-(t[2]<<f))<3*o&&Math.abs(i-(t[3]<<f))<o&&Math.abs(i-(t[4]<<f))<o},a.prototype.centerFromEnd=function(t,e){return e-t[4]-t[3]-t[2]/2},a.prototype.crossCheckVertical=function(t,e,n,r){for(var i=this.image,o=i.height,a=this.CrossCheckStateCount,s=t;s>=0&&i.data[e+s*i.width];)a[2]++,s--;if(s<0)return NaN;for(;s>=0&&!i.data[e+s*i.width]&&a[1]<=n;)a[1]++,s--;if(s<0||a[1]>n)return NaN;for(;s>=0&&i.data[e+s*i.width]&&a[0]<=n;)a[0]++,s--;if(a[0]>n)return NaN;for(s=t+1;s<o&&i.data[e+s*i.width];)a[2]++,s++;if(s==o)return NaN;for(;s<o&&!i.data[e+s*i.width]&&a[3]<n;)a[3]++,s++;if(s==o||a[3]>=n)return NaN;for(;s<o&&i.data[e+s*i.width]&&a[4]<n;)a[4]++,s++;if(a[4]>=n)return NaN;var h=a[0]+a[1]+a[2]+a[3]+a[4];return 5*Math.abs(h-r)>=2*r?NaN:this.foundPatternCross(a)?this.centerFromEnd(a,s):NaN},a.prototype.crossCheckHorizontal=function(t,e,n,r){for(var i=this.image,o=i.width,a=this.CrossCheckStateCount,s=t;s>=0&&i.data[s+e*i.width];)a[2]++,s--;if(s<0)return NaN;for(;s>=0&&!i.data[s+e*i.width]&&a[1]<=n;)a[1]++,s--;if(s<0||a[1]>n)return NaN;for(;s>=0&&i.data[s+e*i.width]&&a[0]<=n;)a[0]++,s--;if(a[0]>n)return NaN;for(s=t+1;s<o&&i.data[s+e*i.width];)a[2]++,s++;if(s==o)return NaN;for(;s<o&&!i.data[s+e*i.width]&&a[3]<n;)a[3]++,s++;if(s==o||a[3]>=n)return NaN;for(;s<o&&i.data[s+e*i.width]&&a[4]<n;)a[4]++,s++;if(a[4]>=n)return NaN;var h=a[0]+a[1]+a[2]+a[3]+a[4];return 5*Math.abs(h-r)>=r?NaN:this.foundPatternCross(a)?this.centerFromEnd(a,s):NaN},a.prototype.handlePossibleCenter=function(t,e,n){var r=t[0]+t[1]+t[2]+t[3]+t[4],o=this.centerFromEnd(t,n),a=this.crossCheckVertical(e,Math.floor(o),t[2],r);if(!isNaN(a)&&(o=this.crossCheckHorizontal(Math.floor(o),Math.floor(a),t[2],r),!isNaN(o))){for(var s=r/7,h=!1,f=this.possibleCenters.length,w=0;w<f;w++){var u=this.possibleCenters[w];if(u.aboutEquals(s,a,o)){u.incrementCount(),h=!0;break}}if(!h){var l=new i(o,a,s);this.possibleCenters.push(l),null!=this.resultPointCallback&&this.resultPointCallback.foundPossibleResultPoint(l)}return!0}return!1},a.prototype.selectBestPatterns=function(){var t=this.possibleCenters.length;if(t<3)throw"Couldn\'t find enough finder patterns:"+t+" patterns found";if(t>3){for(var e=0,n=0,r=0;r<t;r++){var i=this.possibleCenters[r].estimatedModuleSize;e+=i,n+=i*i}var o=e/t;this.possibleCenters.sort(function(t,e){var n=Math.abs(e.estimatedModuleSize-o),r=Math.abs(t.estimatedModuleSize-o);return n<r?-1:n==r?0:1});for(var a=Math.sqrt(n/t-o*o),s=Math.max(.2*o,a),r=this.possibleCenters-1;r>=0;r--){var h=this.possibleCenters[r];Math.abs(h.estimatedModuleSize-o)>s&&this.possibleCenters.splice(r,1)}}return this.possibleCenters.length>3&&this.possibleCenters.sort(function(t,e){return t.count>e.count?-1:t.count<e.count?1:0}),[this.possibleCenters[0],this.possibleCenters[1],this.possibleCenters[2]]},a.prototype.findRowSkip=function(){var t=this.possibleCenters.length;if(t<=1)return 0;for(var e=null,n=0;n<t;n++){var r=this.possibleCenters[n];if(r.count>=w){if(null!=e)return this.hasSkipped=!0,Math.floor((Math.abs(e.X-r.X)-Math.abs(e.Y-r.Y))/2);e=r}}return 0},a.prototype.haveMultiplyConfirmedCenters=function(){for(var t=0,e=0,n=this.possibleCenters.length,r=0;r<n;r++){var i=this.possibleCenters[r];i.count>=w&&(t++,e+=i.estimatedModuleSize)}if(t<3)return!1;for(var o=e/n,a=0,r=0;r<n;r++)i=this.possibleCenters[r],a+=Math.abs(i.estimatedModuleSize-o);return a<=.05*e},a.prototype.findFinderPattern=function(t){var e=!1;this.image=t;var n=t.height,i=t.width,a=Math.floor(3*n/(4*h));(a<s||e)&&(a=s);for(var f=!1,w=new Array(5),u=a-1;u<n&&!f;u+=a){w[0]=0,w[1]=0,w[2]=0,w[3]=0,w[4]=0;for(var l=0,c=0;c<i;c++)if(t.data[c+u*t.width])1==(1&l)&&l++,w[l]++;else if(0==(1&l))if(4==l)if(this.foundPatternCross(w)){var d=this.handlePossibleCenter(w,u,c);if(d)if(a=2,this.hasSkipped)f=this.haveMultiplyConfirmedCenters();else{var p=this.findRowSkip();p>w[2]&&(u+=p-w[2]-a,c=i-1)}else{do c++;while(c<i&&!t.data[c+u*t.width]);c--}l=0,w[0]=0,w[1]=0,w[2]=0,w[3]=0,w[4]=0}else w[0]=w[2],w[1]=w[3],w[2]=w[4],w[3]=1,w[4]=0,l=3;else w[++l]++;else w[l]++;if(this.foundPatternCross(w)){var d=this.handlePossibleCenter(w,u,i);d&&(a=w[0],this.hasSkipped&&(f=this.haveMultiplyConfirmedCenters()))}}var g=this.selectBestPatterns();return r(g),new o(g)}},function(t,e,n){"use strict";var r=n(2),i={};i.checkAndNudgePoints=function(t,e){for(var n=t.width,r=t.height,i=!0,o=0;o<e.length&&i;o+=2){var a=Math.floor(e[o]),s=Math.floor(e[o+1]);if(a<-1||a>n||s<-1||s>r)throw"Error.checkAndNudgePoints ";i=!1,a==-1?(e[o]=0,i=!0):a==n&&(e[o]=n-1,i=!0),s==-1?(e[o+1]=0,i=!0):s==r&&(e[o+1]=r-1,i=!0)}i=!0;for(var o=e.length-2;o>=0&&i;o-=2){var a=Math.floor(e[o]),s=Math.floor(e[o+1]);if(a<-1||a>n||s<-1||s>r)throw"Error.checkAndNudgePoints ";i=!1,a==-1?(e[o]=0,i=!0):a==n&&(e[o]=n-1,i=!0),s==-1?(e[o+1]=0,i=!0):s==r&&(e[o+1]=r-1,i=!0)}},i.sampleGrid3=function(t,e,n){for(var o=new r.a(e),a=new Array(e<<1),s=0;s<e;s++){for(var h=a.length,f=s+.5,w=0;w<h;w+=2)a[w]=(w>>1)+.5,a[w+1]=f;n.transformPoints1(a),i.checkAndNudgePoints(t,a);try{for(var w=0;w<h;w+=2){var u=t.data[Math.floor(a[w])+t.width*Math.floor(a[w+1])];u&&o.set_Renamed(w>>1,s)}}catch(t){throw"Error.checkAndNudgePoints"}}return o},e.a=i},function(t,e,n){"use strict";function r(t){this.field=t}var i=n(1),o=n(4);e.a=r,r.prototype.decode=function(t,e){for(var n=new o.a(this.field,t),r=new Array(e),a=0;a<r.length;a++)r[a]=0;for(var s=!1,h=!0,a=0;a<e;a++){var f=n.evaluateAt(this.field.exp(s?a+1:a));r[r.length-1-a]=f,0!=f&&(h=!1)}if(!h)for(var w=new o.a(this.field,r),u=this.runEuclideanAlgorithm(this.field.buildMonomial(e,1),w,e),l=u[0],c=u[1],d=this.findErrorLocations(l),p=this.findErrorMagnitudes(c,d,s),a=0;a<d.length;a++){var g=t.length-1-this.field.log(d[a]);if(g<0)throw"ReedSolomonException Bad error location";t[g]=i.a.addOrSubtract(t[g],p[a])}},r.prototype.runEuclideanAlgorithm=function(t,e,n){if(t.Degree<e.Degree){var r=t;t=e,e=r}for(var i=t,o=e,a=this.field.One,s=this.field.Zero,h=this.field.Zero,f=this.field.One;o.Degree>=Math.floor(n/2);){var w=i,u=a,l=h;if(i=o,a=s,h=f,i.Zero)throw"r_{i-1} was zero";o=w;for(var c=this.field.Zero,d=i.getCoefficient(i.Degree),p=this.field.inverse(d);o.Degree>=i.Degree&&!o.Zero;){var g=o.Degree-i.Degree,v=this.field.multiply(o.getCoefficient(o.Degree),p);c=c.addOrSubtract(this.field.buildMonomial(g,v)),o=o.addOrSubtract(i.multiplyByMonomial(g,v))}s=c.multiply1(a).addOrSubtract(u),f=c.multiply1(h).addOrSubtract(l)}var m=f.getCoefficient(0);if(0==m)throw"ReedSolomonException sigmaTilde(0) was zero";var b=this.field.inverse(m),y=f.multiply2(b),C=o.multiply2(b);return[y,C]},r.prototype.findErrorLocations=function(t){var e=t.Degree;if(1==e)return new Array(t.getCoefficient(1));for(var n=new Array(e),r=0,i=1;i<256&&r<e;i++)0==t.evaluateAt(i)&&(n[r]=this.field.inverse(i),r++);if(r!=e)throw"Error locator degree does not match number of roots";return n},r.prototype.findErrorMagnitudes=function(t,e,n){for(var r=e.length,o=new Array(r),a=0;a<r;a++){for(var s=this.field.inverse(e[a]),h=1,f=0;f<r;f++)a!=f&&(h=this.field.multiply(h,i.a.addOrSubtract(1,this.field.multiply(e[f],s))));o[a]=this.field.multiply(t.evaluateAt(s),this.field.inverse(h)),n&&(o[a]=this.field.multiply(o[a],s))}return o}},function(t,e,n){(function(t){t={};var e=n(6).default,r=new e;r.callback=function(t,e){postMessage({result:t,err:e})},onmessage=function(t){var e=t.data;r.decode(e)}}).call(e,n(7)(t))}]);';
},function(e,t,n){"use strict";var r={};r.generateIdentifier=function(){return Math.random().toString(36).substr(2,10)},r.localCName=r.generateIdentifier(),r.splitLines=function(e){return e.trim().split("\n").map(function(e){return e.trim()})},r.splitSections=function(e){var t=e.split("\nm=");return t.map(function(e,t){return(t>0?"m="+e:e).trim()+"\r\n"})},r.matchPrefix=function(e,t){return r.splitLines(e).filter(function(e){return 0===e.indexOf(t)})},r.parseCandidate=function(e){var t;t=0===e.indexOf("a=candidate:")?e.substring(12).split(" "):e.substring(10).split(" ");for(var n={foundation:t[0],component:t[1],protocol:t[2].toLowerCase(),priority:parseInt(t[3],10),ip:t[4],port:parseInt(t[5],10),type:t[7]},r=8;r<t.length;r+=2)switch(t[r]){case"raddr":n.relatedAddress=t[r+1];break;case"rport":n.relatedPort=parseInt(t[r+1],10);break;case"tcptype":n.tcpType=t[r+1]}return n},r.writeCandidate=function(e){var t=[];t.push(e.foundation),t.push(e.component),t.push(e.protocol.toUpperCase()),t.push(e.priority),t.push(e.ip),t.push(e.port);var n=e.type;return t.push("typ"),t.push(n),"host"!==n&&e.relatedAddress&&e.relatedPort&&(t.push("raddr"),t.push(e.relatedAddress),t.push("rport"),t.push(e.relatedPort)),e.tcpType&&"tcp"===e.protocol.toLowerCase()&&(t.push("tcptype"),t.push(e.tcpType)),"candidate:"+t.join(" ")},r.parseRtpMap=function(e){var t=e.substr(9).split(" "),n={payloadType:parseInt(t.shift(),10)};return t=t[0].split("/"),n.name=t[0],n.clockRate=parseInt(t[1],10),n.numChannels=3===t.length?parseInt(t[2],10):1,n},r.writeRtpMap=function(e){var t=e.payloadType;return void 0!==e.preferredPayloadType&&(t=e.preferredPayloadType),"a=rtpmap:"+t+" "+e.name+"/"+e.clockRate+(1!==e.numChannels?"/"+e.numChannels:"")+"\r\n"},r.parseExtmap=function(e){var t=e.substr(9).split(" ");return{id:parseInt(t[0],10),uri:t[1]}},r.writeExtmap=function(e){return"a=extmap:"+(e.id||e.preferredId)+" "+e.uri+"\r\n"},r.parseFmtp=function(e){for(var t,n={},r=e.substr(e.indexOf(" ")+1).split(";"),i=0;i<r.length;i++)t=r[i].trim().split("="),n[t[0].trim()]=t[1];return n},r.writeFmtp=function(e){var t="",n=e.payloadType;if(void 0!==e.preferredPayloadType&&(n=e.preferredPayloadType),e.parameters&&Object.keys(e.parameters).length){var r=[];Object.keys(e.parameters).forEach(function(t){r.push(t+"="+e.parameters[t])}),t+="a=fmtp:"+n+" "+r.join(";")+"\r\n"}return t},r.parseRtcpFb=function(e){var t=e.substr(e.indexOf(" ")+1).split(" ");return{type:t.shift(),parameter:t.join(" ")}},r.writeRtcpFb=function(e){var t="",n=e.payloadType;return void 0!==e.preferredPayloadType&&(n=e.preferredPayloadType),e.rtcpFeedback&&e.rtcpFeedback.length&&e.rtcpFeedback.forEach(function(e){t+="a=rtcp-fb:"+n+" "+e.type+(e.parameter&&e.parameter.length?" "+e.parameter:"")+"\r\n"}),t},r.parseSsrcMedia=function(e){var t=e.indexOf(" "),n={ssrc:parseInt(e.substr(7,t-7),10)},r=e.indexOf(":",t);return r>-1?(n.attribute=e.substr(t+1,r-t-1),n.value=e.substr(r+1)):n.attribute=e.substr(t+1),n},r.getDtlsParameters=function(e,t){var n=r.splitLines(e);n=n.concat(r.splitLines(t));var i=n.filter(function(e){return 0===e.indexOf("a=fingerprint:")})[0].substr(14),o={role:"auto",fingerprints:[{algorithm:i.split(" ")[0],value:i.split(" ")[1]}]};return o},r.writeDtlsParameters=function(e,t){var n="a=setup:"+t+"\r\n";return e.fingerprints.forEach(function(e){n+="a=fingerprint:"+e.algorithm+" "+e.value+"\r\n"}),n},r.getIceParameters=function(e,t){var n=r.splitLines(e);n=n.concat(r.splitLines(t));var i={usernameFragment:n.filter(function(e){return 0===e.indexOf("a=ice-ufrag:")})[0].substr(12),password:n.filter(function(e){return 0===e.indexOf("a=ice-pwd:")})[0].substr(10)};return i},r.writeIceParameters=function(e){return"a=ice-ufrag:"+e.usernameFragment+"\r\na=ice-pwd:"+e.password+"\r\n"},r.parseRtpParameters=function(e){for(var t={codecs:[],headerExtensions:[],fecMechanisms:[],rtcp:[]},n=r.splitLines(e),i=n[0].split(" "),o=3;o<i.length;o++){var a=i[o],s=r.matchPrefix(e,"a=rtpmap:"+a+" ")[0];if(s){var c=r.parseRtpMap(s),d=r.matchPrefix(e,"a=fmtp:"+a+" ");switch(c.parameters=d.length?r.parseFmtp(d[0]):{},c.rtcpFeedback=r.matchPrefix(e,"a=rtcp-fb:"+a+" ").map(r.parseRtcpFb),t.codecs.push(c),c.name.toUpperCase()){case"RED":case"ULPFEC":t.fecMechanisms.push(c.name.toUpperCase())}}}return r.matchPrefix(e,"a=extmap:").forEach(function(e){t.headerExtensions.push(r.parseExtmap(e))}),t},r.writeRtpDescription=function(e,t){var n="";n+="m="+e+" ",n+=t.codecs.length>0?"9":"0",n+=" UDP/TLS/RTP/SAVPF ",n+=t.codecs.map(function(e){return void 0!==e.preferredPayloadType?e.preferredPayloadType:e.payloadType}).join(" ")+"\r\n",n+="c=IN IP4 0.0.0.0\r\n",n+="a=rtcp:9 IN IP4 0.0.0.0\r\n",t.codecs.forEach(function(e){n+=r.writeRtpMap(e),n+=r.writeFmtp(e),n+=r.writeRtcpFb(e)});var i=0;return t.codecs.forEach(function(e){e.maxptime>i&&(i=e.maxptime)}),i>0&&(n+="a=maxptime:"+i+"\r\n"),n+="a=rtcp-mux\r\n",t.headerExtensions.forEach(function(e){n+=r.writeExtmap(e)}),n},r.parseRtpEncodingParameters=function(e){var t,n=[],i=r.parseRtpParameters(e),o=i.fecMechanisms.indexOf("RED")!==-1,a=i.fecMechanisms.indexOf("ULPFEC")!==-1,s=r.matchPrefix(e,"a=ssrc:").map(function(e){return r.parseSsrcMedia(e)}).filter(function(e){return"cname"===e.attribute}),c=s.length>0&&s[0].ssrc,d=r.matchPrefix(e,"a=ssrc-group:FID").map(function(e){var t=e.split(" ");return t.shift(),t.map(function(e){return parseInt(e,10)})});d.length>0&&d[0].length>1&&d[0][0]===c&&(t=d[0][1]),i.codecs.forEach(function(e){if("RTX"===e.name.toUpperCase()&&e.parameters.apt){var r={ssrc:c,codecPayloadType:parseInt(e.parameters.apt,10),rtx:{ssrc:t}};n.push(r),o&&(r=JSON.parse(JSON.stringify(r)),r.fec={ssrc:t,mechanism:a?"red+ulpfec":"red"},n.push(r))}}),0===n.length&&c&&n.push({ssrc:c});var u=r.matchPrefix(e,"b=");return u.length&&(0===u[0].indexOf("b=TIAS:")?u=parseInt(u[0].substr(7),10):0===u[0].indexOf("b=AS:")&&(u=parseInt(u[0].substr(5),10)),n.forEach(function(e){e.maxBitrate=u})),n},r.parseMsid=function(e){var t,n=r.matchPrefix(e,"a=msid:");if(1===n.length)return t=n[0].substr(7).split(" "),{stream:t[0],track:t[1]};var i=r.matchPrefix(e,"a=ssrc:").map(function(e){return r.parseSsrcMedia(e)}).filter(function(e){return"msid"===e.attribute});return i.length>0?(t=i[0].value.split(" "),{stream:t[0],track:t[1]}):void 0},r.writeSessionBoilerplate=function(){return"v=0\r\no=thisisadapterortc 8169639915646943137 2 IN IP4 127.0.0.1\r\ns=-\r\nt=0 0\r\n"},r.writeMediaSection=function(e,t,n,i){var o=r.writeRtpDescription(e.kind,t);if(o+=r.writeIceParameters(e.iceGatherer.getLocalParameters()),o+=r.writeDtlsParameters(e.dtlsTransport.getLocalParameters(),"offer"===n?"actpass":"active"),o+="a=mid:"+e.mid+"\r\n",o+=e.rtpSender&&e.rtpReceiver?"a=sendrecv\r\n":e.rtpSender?"a=sendonly\r\n":e.rtpReceiver?"a=recvonly\r\n":"a=inactive\r\n",e.rtpSender){var a="msid:"+i.id+" "+e.rtpSender.track.id+"\r\n";o+="a="+a,o+="a=ssrc:"+e.sendEncodingParameters[0].ssrc+" "+a,e.sendEncodingParameters[0].rtx&&(o+="a=ssrc:"+e.sendEncodingParameters[0].rtx.ssrc+" "+a,o+="a=ssrc-group:FID "+e.sendEncodingParameters[0].ssrc+" "+e.sendEncodingParameters[0].rtx.ssrc+"\r\n")}return o+="a=ssrc:"+e.sendEncodingParameters[0].ssrc+" cname:"+r.localCName+"\r\n",e.rtpSender&&e.sendEncodingParameters[0].rtx&&(o+="a=ssrc:"+e.sendEncodingParameters[0].rtx.ssrc+" cname:"+r.localCName+"\r\n"),o},r.getDirection=function(e,t){for(var n=r.splitLines(e),i=0;i<n.length;i++)switch(n[i]){case"a=sendrecv":case"a=sendonly":case"a=recvonly":case"a=inactive":return n[i].substr(2)}return t?r.getDirection(t):"sendrecv"},r.getKind=function(e){var t=r.splitLines(e),n=t[0].split(" ");return n[0].substr(2)},e.exports=r},function(e,t,n){"use strict";!function(){var t=n(0),r=t.log,i=t.browserDetails;e.exports.browserDetails=i,e.exports.extractVersion=t.extractVersion,e.exports.disableLog=t.disableLog;var o=n(6)||null,a=n(8)||null,s=n(10)||null,c=n(12)||null;switch(i.browser){case"chrome":if(!o||!o.shimPeerConnection)return void r("Chrome shim is not included in this adapter release.");r("adapter.js shimming chrome."),e.exports.browserShim=o,o.shimGetUserMedia(),o.shimMediaStream(),t.shimCreateObjectURL(),o.shimSourceObject(),o.shimPeerConnection(),o.shimOnTrack(),o.shimGetSendersWithDtmf();break;case"firefox":if(!s||!s.shimPeerConnection)return void r("Firefox shim is not included in this adapter release.");r("adapter.js shimming firefox."),e.exports.browserShim=s,s.shimGetUserMedia(),t.shimCreateObjectURL(),s.shimSourceObject(),s.shimPeerConnection(),s.shimOnTrack();break;case"edge":if(!a||!a.shimPeerConnection)return void r("MS edge shim is not included in this adapter release.");r("adapter.js shimming edge."),e.exports.browserShim=a,a.shimGetUserMedia(),t.shimCreateObjectURL(),a.shimPeerConnection();break;case"safari":if(!c)return void r("Safari shim is not included in this adapter release.");r("adapter.js shimming safari."),e.exports.browserShim=c,c.shimGetUserMedia();break;default:r("Unsupported browser!")}}()},function(e,t,n){"use strict";var r=n(0).log,i=n(0).browserDetails,o={shimMediaStream:function(){window.MediaStream=window.MediaStream||window.webkitMediaStream},shimOnTrack:function(){"object"!=typeof window||!window.RTCPeerConnection||"ontrack"in window.RTCPeerConnection.prototype||Object.defineProperty(window.RTCPeerConnection.prototype,"ontrack",{get:function(){return this._ontrack},set:function(e){var t=this;this._ontrack&&(this.removeEventListener("track",this._ontrack),this.removeEventListener("addstream",this._ontrackpoly)),this.addEventListener("track",this._ontrack=e),this.addEventListener("addstream",this._ontrackpoly=function(e){e.stream.addEventListener("addtrack",function(n){var r=new Event("track");r.track=n.track,r.receiver={track:n.track},r.streams=[e.stream],t.dispatchEvent(r)}),e.stream.getTracks().forEach(function(t){var n=new Event("track");n.track=t,n.receiver={track:t},n.streams=[e.stream],this.dispatchEvent(n)}.bind(this))}.bind(this))}})},shimGetSendersWithDtmf:function(){if("object"==typeof window&&window.RTCPeerConnection&&!("getSenders"in RTCPeerConnection.prototype)&&"createDTMFSender"in RTCPeerConnection.prototype){RTCPeerConnection.prototype.getSenders=function(){return this._senders};var e=RTCPeerConnection.prototype.addStream;RTCPeerConnection.prototype.addStream=function(t){var n=this;n._senders=n._senders||[],e.apply(n,[t]),t.getTracks().forEach(function(e){n._senders.push({track:e,get dtmf(){return this._dtmf||(this._dtmf=n.createDTMFSender(e)),this._dtmf}})})}}},shimSourceObject:function(){"object"==typeof window&&(!window.HTMLMediaElement||"srcObject"in window.HTMLMediaElement.prototype||Object.defineProperty(window.HTMLMediaElement.prototype,"srcObject",{get:function(){return this._srcObject},set:function(e){var t=this;return this._srcObject=e,this.src&&URL.revokeObjectURL(this.src),e?(this.src=URL.createObjectURL(e),e.addEventListener("addtrack",function(){t.src&&URL.revokeObjectURL(t.src),t.src=URL.createObjectURL(e)}),void e.addEventListener("removetrack",function(){t.src&&URL.revokeObjectURL(t.src),t.src=URL.createObjectURL(e)})):void(this.src="")}}))},shimPeerConnection:function(){window.RTCPeerConnection||(window.RTCPeerConnection=function(e,t){return r("PeerConnection"),e&&e.iceTransportPolicy&&(e.iceTransports=e.iceTransportPolicy),new webkitRTCPeerConnection(e,t)},window.RTCPeerConnection.prototype=webkitRTCPeerConnection.prototype,webkitRTCPeerConnection.generateCertificate&&Object.defineProperty(window.RTCPeerConnection,"generateCertificate",{get:function(){return webkitRTCPeerConnection.generateCertificate}}));var e=RTCPeerConnection.prototype.getStats;RTCPeerConnection.prototype.getStats=function(t,n,r){var i=this,o=arguments;if(arguments.length>0&&"function"==typeof t)return e.apply(this,arguments);if(0===e.length&&(0===arguments.length||"function"!=typeof arguments[0]))return e.apply(this,[]);var a=function(e){var t={},n=e.result();return n.forEach(function(e){var n={id:e.id,timestamp:e.timestamp,type:{localcandidate:"local-candidate",remotecandidate:"remote-candidate"}[e.type]||e.type};e.names().forEach(function(t){n[t]=e.stat(t)}),t[n.id]=n}),t},s=function(e){return new Map(Object.keys(e).map(function(t){return[t,e[t]]}))};if(arguments.length>=2){var c=function(e){o[1](s(a(e)))};return e.apply(this,[c,arguments[0]])}return new Promise(function(t,n){e.apply(i,[function(e){t(s(a(e)))},n])}).then(n,r)},i.version<51&&["setLocalDescription","setRemoteDescription","addIceCandidate"].forEach(function(e){var t=RTCPeerConnection.prototype[e];RTCPeerConnection.prototype[e]=function(){var e=arguments,n=this,r=new Promise(function(r,i){t.apply(n,[e[0],r,i])});return e.length<2?r:r.then(function(){e[1].apply(null,[])},function(t){e.length>=3&&e[2].apply(null,[t])})}}),i.version<52&&["createOffer","createAnswer"].forEach(function(e){var t=RTCPeerConnection.prototype[e];RTCPeerConnection.prototype[e]=function(){var e=this;if(arguments.length<1||1===arguments.length&&"object"==typeof arguments[0]){var n=1===arguments.length?arguments[0]:void 0;return new Promise(function(r,i){t.apply(e,[r,i,n])})}return t.apply(this,arguments)}}),["setLocalDescription","setRemoteDescription","addIceCandidate"].forEach(function(e){var t=RTCPeerConnection.prototype[e];RTCPeerConnection.prototype[e]=function(){return arguments[0]=new("addIceCandidate"===e?RTCIceCandidate:RTCSessionDescription)(arguments[0]),t.apply(this,arguments)}});var t=RTCPeerConnection.prototype.addIceCandidate;RTCPeerConnection.prototype.addIceCandidate=function(){return arguments[0]?t.apply(this,arguments):(arguments[1]&&arguments[1].apply(null),Promise.resolve())}}};e.exports={shimMediaStream:o.shimMediaStream,shimOnTrack:o.shimOnTrack,shimGetSendersWithDtmf:o.shimGetSendersWithDtmf,shimSourceObject:o.shimSourceObject,shimPeerConnection:o.shimPeerConnection,shimGetUserMedia:n(7)}},function(e,t,n){"use strict";var r=n(0).log;e.exports=function(){var e=function(e){if("object"!=typeof e||e.mandatory||e.optional)return e;var t={};return Object.keys(e).forEach(function(n){if("require"!==n&&"advanced"!==n&&"mediaSource"!==n){var r="object"==typeof e[n]?e[n]:{ideal:e[n]};void 0!==r.exact&&"number"==typeof r.exact&&(r.min=r.max=r.exact);var i=function(e,t){return e?e+t.charAt(0).toUpperCase()+t.slice(1):"deviceId"===t?"sourceId":t};if(void 0!==r.ideal){t.optional=t.optional||[];var o={};"number"==typeof r.ideal?(o[i("min",n)]=r.ideal,t.optional.push(o),o={},o[i("max",n)]=r.ideal,t.optional.push(o)):(o[i("",n)]=r.ideal,t.optional.push(o))}void 0!==r.exact&&"number"!=typeof r.exact?(t.mandatory=t.mandatory||{},t.mandatory[i("",n)]=r.exact):["min","max"].forEach(function(e){void 0!==r[e]&&(t.mandatory=t.mandatory||{},t.mandatory[i(e,n)]=r[e])})}}),e.advanced&&(t.optional=(t.optional||[]).concat(e.advanced)),t},t=function(t,n){if(t=JSON.parse(JSON.stringify(t)),t&&t.audio&&(t.audio=e(t.audio)),t&&"object"==typeof t.video){var i=t.video.facingMode;if(i=i&&("object"==typeof i?i:{ideal:i}),i&&("user"===i.exact||"environment"===i.exact||"user"===i.ideal||"environment"===i.ideal)&&(!navigator.mediaDevices.getSupportedConstraints||!navigator.mediaDevices.getSupportedConstraints().facingMode)&&(delete t.video.facingMode,"environment"===i.exact||"environment"===i.ideal))return navigator.mediaDevices.enumerateDevices().then(function(o){o=o.filter(function(e){return"videoinput"===e.kind});var a=o.find(function(e){return e.label.toLowerCase().indexOf("back")!==-1})||o.length&&o[o.length-1];return a&&(t.video.deviceId=i.exact?{exact:a.deviceId}:{ideal:a.deviceId}),t.video=e(t.video),r("chrome: "+JSON.stringify(t)),n(t)});t.video=e(t.video)}return r("chrome: "+JSON.stringify(t)),n(t)},n=function(e){return{name:{PermissionDeniedError:"NotAllowedError",ConstraintNotSatisfiedError:"OverconstrainedError"}[e.name]||e.name,message:e.message,constraint:e.constraintName,toString:function(){return this.name+(this.message&&": ")+this.message}}},i=function(e,r,i){t(e,function(e){navigator.webkitGetUserMedia(e,r,function(e){i(n(e))})})};navigator.getUserMedia=i;var o=function(e){return new Promise(function(t,n){navigator.getUserMedia(e,t,n)})};if(navigator.mediaDevices||(navigator.mediaDevices={getUserMedia:o,enumerateDevices:function(){return new Promise(function(e){var t={audio:"audioinput",video:"videoinput"};return MediaStreamTrack.getSources(function(n){e(n.map(function(e){return{label:e.label,kind:t[e.kind],deviceId:e.id,groupId:""}}))})})}}),navigator.mediaDevices.getUserMedia){var a=navigator.mediaDevices.getUserMedia.bind(navigator.mediaDevices);navigator.mediaDevices.getUserMedia=function(e){return t(e,function(e){return a(e).then(function(t){if(e.audio&&!t.getAudioTracks().length||e.video&&!t.getVideoTracks().length)throw t.getTracks().forEach(function(e){e.stop()}),new DOMException("","NotFoundError");return t},function(e){return Promise.reject(n(e))})})}}else navigator.mediaDevices.getUserMedia=function(e){return o(e)};"undefined"==typeof navigator.mediaDevices.addEventListener&&(navigator.mediaDevices.addEventListener=function(){r("Dummy mediaDevices.addEventListener called.")}),"undefined"==typeof navigator.mediaDevices.removeEventListener&&(navigator.mediaDevices.removeEventListener=function(){r("Dummy mediaDevices.removeEventListener called.")})}},function(e,t,n){"use strict";var r=n(4),i=n(0).browserDetails,o={shimPeerConnection:function(){if(window.RTCIceGatherer&&(window.RTCIceCandidate||(window.RTCIceCandidate=function(e){return e}),window.RTCSessionDescription||(window.RTCSessionDescription=function(e){return e}),i.version<15025)){var e=Object.getOwnPropertyDescriptor(MediaStreamTrack.prototype,"enabled");Object.defineProperty(MediaStreamTrack.prototype,"enabled",{set:function(t){e.set.call(this,t);var n=new Event("enabled");n.enabled=t,this.dispatchEvent(n)}})}window.RTCPeerConnection=function(e){var t=this,n=document.createDocumentFragment();if(["addEventListener","removeEventListener","dispatchEvent"].forEach(function(e){t[e]=n[e].bind(n)}),this.onicecandidate=null,this.onaddstream=null,this.ontrack=null,this.onremovestream=null,this.onsignalingstatechange=null,this.oniceconnectionstatechange=null,this.onicegatheringstatechange=null,this.onnegotiationneeded=null,this.ondatachannel=null,this.localStreams=[],this.remoteStreams=[],this.getLocalStreams=function(){return t.localStreams},this.getRemoteStreams=function(){return t.remoteStreams},this.localDescription=new RTCSessionDescription({type:"",sdp:""}),this.remoteDescription=new RTCSessionDescription({type:"",sdp:""}),this.signalingState="stable",this.iceConnectionState="new",this.iceGatheringState="new",this.iceOptions={gatherPolicy:"all",iceServers:[]},e&&e.iceTransportPolicy)switch(e.iceTransportPolicy){case"all":case"relay":this.iceOptions.gatherPolicy=e.iceTransportPolicy;break;case"none":throw new TypeError('iceTransportPolicy "none" not supported')}if(this.usingBundle=e&&"max-bundle"===e.bundlePolicy,e&&e.iceServers){var r=JSON.parse(JSON.stringify(e.iceServers));this.iceOptions.iceServers=r.filter(function(e){if(e&&e.urls){var t=e.urls;return"string"==typeof t&&(t=[t]),t=t.filter(function(e){return 0===e.indexOf("turn:")&&e.indexOf("transport=udp")!==-1&&e.indexOf("turn:[")===-1||0===e.indexOf("stun:")&&i.version>=14393})[0],!!t}return!1})}this._config=e,this.transceivers=[],this._localIceCandidatesBuffer=[]},window.RTCPeerConnection.prototype._emitGatheringStateChange=function(){var e=new Event("icegatheringstatechange");this.dispatchEvent(e),null!==this.onicegatheringstatechange&&this.onicegatheringstatechange(e)},window.RTCPeerConnection.prototype._emitBufferedCandidates=function(){var e=this,t=r.splitSections(e.localDescription.sdp);this._localIceCandidatesBuffer.forEach(function(n){var r=!n.candidate||0===Object.keys(n.candidate).length;if(r)for(var i=1;i<t.length;i++)t[i].indexOf("\r\na=end-of-candidates\r\n")===-1&&(t[i]+="a=end-of-candidates\r\n");else t[n.candidate.sdpMLineIndex+1]+="a="+n.candidate.candidate+"\r\n";if(e.localDescription.sdp=t.join(""),e.dispatchEvent(n),null!==e.onicecandidate&&e.onicecandidate(n),!n.candidate&&"complete"!==e.iceGatheringState){var o=e.transceivers.every(function(e){return e.iceGatherer&&"completed"===e.iceGatherer.state});o&&"complete"!==e.iceGatheringStateChange&&(e.iceGatheringState="complete",e._emitGatheringStateChange())}}),this._localIceCandidatesBuffer=[]},window.RTCPeerConnection.prototype.getConfiguration=function(){return this._config},window.RTCPeerConnection.prototype.addStream=function(e){if(i.version>=15025)this.localStreams.push(e);else{var t=e.clone();e.getTracks().forEach(function(e,n){var r=t.getTracks()[n];e.addEventListener("enabled",function(e){r.enabled=e.enabled})}),this.localStreams.push(t)}this._maybeFireNegotiationNeeded()},window.RTCPeerConnection.prototype.removeStream=function(e){var t=this.localStreams.indexOf(e);t>-1&&(this.localStreams.splice(t,1),this._maybeFireNegotiationNeeded())},window.RTCPeerConnection.prototype.getSenders=function(){return this.transceivers.filter(function(e){return!!e.rtpSender}).map(function(e){return e.rtpSender})},window.RTCPeerConnection.prototype.getReceivers=function(){return this.transceivers.filter(function(e){return!!e.rtpReceiver}).map(function(e){return e.rtpReceiver})},window.RTCPeerConnection.prototype._getCommonCapabilities=function(e,t){var n={codecs:[],headerExtensions:[],fecMechanisms:[]};return e.codecs.forEach(function(e){for(var r=0;r<t.codecs.length;r++){var i=t.codecs[r];if(e.name.toLowerCase()===i.name.toLowerCase()&&e.clockRate===i.clockRate){i.numChannels=Math.min(e.numChannels,i.numChannels),n.codecs.push(i),i.rtcpFeedback=i.rtcpFeedback.filter(function(t){for(var n=0;n<e.rtcpFeedback.length;n++)if(e.rtcpFeedback[n].type===t.type&&e.rtcpFeedback[n].parameter===t.parameter)return!0;return!1});break}}}),e.headerExtensions.forEach(function(e){for(var r=0;r<t.headerExtensions.length;r++){var i=t.headerExtensions[r];if(e.uri===i.uri){n.headerExtensions.push(i);break}}}),n},window.RTCPeerConnection.prototype._createIceAndDtlsTransports=function(e,t){var n=this,i=new RTCIceGatherer(n.iceOptions),o=new RTCIceTransport(i);i.onlocalcandidate=function(a){var s=new Event("icecandidate");s.candidate={sdpMid:e,sdpMLineIndex:t};var c=a.candidate,d=!c||0===Object.keys(c).length;d?void 0===i.state&&(i.state="completed"):(c.component="RTCP"===o.component?2:1,s.candidate.candidate=r.writeCandidate(c));var u=r.splitSections(n.localDescription.sdp);d?u[s.candidate.sdpMLineIndex+1]+="a=end-of-candidates\r\n":u[s.candidate.sdpMLineIndex+1]+="a="+s.candidate.candidate+"\r\n",n.localDescription.sdp=u.join("");var h=n._pendingOffer?n._pendingOffer:n.transceivers,f=h.every(function(e){return e.iceGatherer&&"completed"===e.iceGatherer.state});switch(n.iceGatheringState){case"new":d||n._localIceCandidatesBuffer.push(s),d&&f&&n._localIceCandidatesBuffer.push(new Event("icecandidate"));break;case"gathering":n._emitBufferedCandidates(),d||(n.dispatchEvent(s),null!==n.onicecandidate&&n.onicecandidate(s)),f&&(n.dispatchEvent(new Event("icecandidate")),null!==n.onicecandidate&&n.onicecandidate(new Event("icecandidate")),n.iceGatheringState="complete",n._emitGatheringStateChange());break;case"complete":}},o.onicestatechange=function(){n._updateConnectionState()};var a=new RTCDtlsTransport(o);return a.ondtlsstatechange=function(){n._updateConnectionState()},a.onerror=function(){a.state="failed",n._updateConnectionState()},{iceGatherer:i,iceTransport:o,dtlsTransport:a}},window.RTCPeerConnection.prototype._transceive=function(e,t,n){var i=this._getCommonCapabilities(e.localCapabilities,e.remoteCapabilities);t&&e.rtpSender&&(i.encodings=e.sendEncodingParameters,i.rtcp={cname:r.localCName},e.recvEncodingParameters.length&&(i.rtcp.ssrc=e.recvEncodingParameters[0].ssrc),e.rtpSender.send(i)),n&&e.rtpReceiver&&("video"===e.kind&&e.recvEncodingParameters&&e.recvEncodingParameters.forEach(function(e){delete e.rtx}),i.encodings=e.recvEncodingParameters,i.rtcp={cname:e.cname},e.sendEncodingParameters.length&&(i.rtcp.ssrc=e.sendEncodingParameters[0].ssrc),e.rtpReceiver.receive(i))},window.RTCPeerConnection.prototype.setLocalDescription=function(e){var t,n,i=this;if("offer"===e.type)this._pendingOffer&&(t=r.splitSections(e.sdp),n=t.shift(),t.forEach(function(e,t){var n=r.parseRtpParameters(e);i._pendingOffer[t].localCapabilities=n}),this.transceivers=this._pendingOffer,delete this._pendingOffer);else if("answer"===e.type){t=r.splitSections(i.remoteDescription.sdp),n=t.shift();var o=r.matchPrefix(n,"a=ice-lite").length>0;t.forEach(function(e,t){var a=i.transceivers[t],s=a.iceGatherer,c=a.iceTransport,d=a.dtlsTransport,u=a.localCapabilities,h=a.remoteCapabilities,f="0"===e.split("\n",1)[0].split(" ",2)[1];if(!f&&!a.isDatachannel){var l=r.getIceParameters(e,n),p=r.getDtlsParameters(e,n);o&&(p.role="server"),i.usingBundle&&0!==t||(c.start(s,l,o?"controlling":"controlled"),d.start(p));var w=i._getCommonCapabilities(u,h);i._transceive(a,w.codecs.length>0,!1)}})}switch(this.localDescription={type:e.type,sdp:e.sdp},e.type){case"offer":this._updateSignalingState("have-local-offer");break;case"answer":this._updateSignalingState("stable");break;default:throw new TypeError('unsupported type "'+e.type+'"')}var a=arguments.length>1&&"function"==typeof arguments[1];if(a){var s=arguments[1];window.setTimeout(function(){s(),"new"===i.iceGatheringState&&(i.iceGatheringState="gathering"),i._emitBufferedCandidates()},0)}var c=Promise.resolve();return c.then(function(){a||("new"===i.iceGatheringState&&(i.iceGatheringState="gathering"),window.setTimeout(i._emitBufferedCandidates.bind(i),500))}),c},window.RTCPeerConnection.prototype.setRemoteDescription=function(e){var t=this,n=new MediaStream,i=[],o=r.splitSections(e.sdp),a=o.shift(),s=r.matchPrefix(a,"a=ice-lite").length>0;switch(this.usingBundle=r.matchPrefix(a,"a=group:BUNDLE ").length>0,o.forEach(function(o,c){var d=r.splitLines(o),u=d[0].substr(2).split(" "),h=u[0],f="0"===u[1],l=r.getDirection(o,a),p=r.matchPrefix(o,"a=mid:");if(p=p.length?p[0].substr(6):r.generateIdentifier(),"application"===h&&"DTLS/SCTP"===u[2])return void(t.transceivers[c]={mid:p,isDatachannel:!0});var w,v,m,g,b,y,C,P,S,k,E,T,R=r.parseRtpParameters(o);f||(E=r.getIceParameters(o,a),T=r.getDtlsParameters(o,a),T.role="client"),P=r.parseRtpEncodingParameters(o);var M,x=r.matchPrefix(o,"a=ssrc:").map(function(e){return r.parseSsrcMedia(e)}).filter(function(e){return"cname"===e.attribute})[0];x&&(M=x.value);var D=r.matchPrefix(o,"a=end-of-candidates",a).length>0,O=r.matchPrefix(o,"a=candidate:").map(function(e){return r.parseCandidate(e)}).filter(function(e){return"1"===e.component});if("offer"!==e.type||f)"answer"!==e.type||f||(w=t.transceivers[c],v=w.iceGatherer,m=w.iceTransport,g=w.dtlsTransport,b=w.rtpSender,y=w.rtpReceiver,C=w.sendEncodingParameters,S=w.localCapabilities,t.transceivers[c].recvEncodingParameters=P,t.transceivers[c].remoteCapabilities=R,t.transceivers[c].cname=M,(s||D)&&O.length&&m.setRemoteCandidates(O),t.usingBundle&&0!==c||(m.start(v,E,"controlling"),g.start(T)),t._transceive(w,"sendrecv"===l||"recvonly"===l,"sendrecv"===l||"sendonly"===l),!y||"sendrecv"!==l&&"sendonly"!==l?delete w.rtpReceiver:(k=y.track,i.push([k,y]),n.addTrack(k)));else{var L=t.usingBundle&&c>0?{iceGatherer:t.transceivers[0].iceGatherer,iceTransport:t.transceivers[0].iceTransport,dtlsTransport:t.transceivers[0].dtlsTransport}:t._createIceAndDtlsTransports(p,c);if(!D||t.usingBundle&&0!==c||L.iceTransport.setRemoteCandidates(O),S=RTCRtpReceiver.getCapabilities(h),S.codecs=S.codecs.filter(function(e){return"rtx"!==e.name}),C=[{ssrc:1001*(2*c+2)}],y=new RTCRtpReceiver(L.dtlsTransport,h),k=y.track,i.push([k,y]),n.addTrack(k),t.localStreams.length>0&&t.localStreams[0].getTracks().length>=c){var I;"audio"===h?I=t.localStreams[0].getAudioTracks()[0]:"video"===h&&(I=t.localStreams[0].getVideoTracks()[0]),I&&(b=new RTCRtpSender(I,L.dtlsTransport))}t.transceivers[c]={iceGatherer:L.iceGatherer,iceTransport:L.iceTransport,dtlsTransport:L.dtlsTransport,localCapabilities:S,remoteCapabilities:R,rtpSender:b,rtpReceiver:y,kind:h,mid:p,cname:M,sendEncodingParameters:C,recvEncodingParameters:P},t._transceive(t.transceivers[c],!1,"sendrecv"===l||"sendonly"===l)}}),this.remoteDescription={type:e.type,sdp:e.sdp},e.type){case"offer":this._updateSignalingState("have-remote-offer");break;case"answer":this._updateSignalingState("stable");break;default:throw new TypeError('unsupported type "'+e.type+'"')}return n.getTracks().length&&(t.remoteStreams.push(n),window.setTimeout(function(){var e=new Event("addstream");e.stream=n,t.dispatchEvent(e),null!==t.onaddstream&&window.setTimeout(function(){t.onaddstream(e)},0),i.forEach(function(e){var r=e[0],i=e[1],o=new Event("track");o.track=r,o.receiver=i,o.streams=[n],t.dispatchEvent(o),null!==t.ontrack&&window.setTimeout(function(){t.ontrack(o)},0)})},0)),arguments.length>1&&"function"==typeof arguments[1]&&window.setTimeout(arguments[1],0),Promise.resolve()},window.RTCPeerConnection.prototype.close=function(){this.transceivers.forEach(function(e){e.iceTransport&&e.iceTransport.stop(),e.dtlsTransport&&e.dtlsTransport.stop(),e.rtpSender&&e.rtpSender.stop(),e.rtpReceiver&&e.rtpReceiver.stop()}),this._updateSignalingState("closed")},window.RTCPeerConnection.prototype._updateSignalingState=function(e){this.signalingState=e;var t=new Event("signalingstatechange");this.dispatchEvent(t),null!==this.onsignalingstatechange&&this.onsignalingstatechange(t)},window.RTCPeerConnection.prototype._maybeFireNegotiationNeeded=function(){var e=new Event("negotiationneeded");this.dispatchEvent(e),null!==this.onnegotiationneeded&&this.onnegotiationneeded(e)},window.RTCPeerConnection.prototype._updateConnectionState=function(){var e,t=this,n={new:0,closed:0,connecting:0,checking:0,connected:0,completed:0,failed:0};if(this.transceivers.forEach(function(e){n[e.iceTransport.state]++,n[e.dtlsTransport.state]++}),n.connected+=n.completed,e="new",n.failed>0?e="failed":n.connecting>0||n.checking>0?e="connecting":n.disconnected>0?e="disconnected":n.new>0?e="new":(n.connected>0||n.completed>0)&&(e="connected"),e!==t.iceConnectionState){t.iceConnectionState=e;var r=new Event("iceconnectionstatechange");this.dispatchEvent(r),null!==this.oniceconnectionstatechange&&this.oniceconnectionstatechange(r)}},window.RTCPeerConnection.prototype.createOffer=function(){var e=this;if(this._pendingOffer)throw new Error("createOffer called while there is a pending offer.");var t;1===arguments.length&&"function"!=typeof arguments[0]?t=arguments[0]:3===arguments.length&&(t=arguments[2]);var n=[],i=0,o=0;if(this.localStreams.length&&(i=this.localStreams[0].getAudioTracks().length,o=this.localStreams[0].getVideoTracks().length),t){if(t.mandatory||t.optional)throw new TypeError("Legacy mandatory/optional constraints not supported.");void 0!==t.offerToReceiveAudio&&(i=t.offerToReceiveAudio),void 0!==t.offerToReceiveVideo&&(o=t.offerToReceiveVideo)}for(this.localStreams.length&&this.localStreams[0].getTracks().forEach(function(e){n.push({kind:e.kind,track:e,wantReceive:"audio"===e.kind?i>0:o>0}),"audio"===e.kind?i--:"video"===e.kind&&o--});i>0||o>0;)i>0&&(n.push({kind:"audio",wantReceive:!0}),i--),o>0&&(n.push({kind:"video",wantReceive:!0}),o--);var a=r.writeSessionBoilerplate(),s=[];n.forEach(function(t,n){var i=t.track,o=t.kind,a=r.generateIdentifier(),c=e.usingBundle&&n>0?{iceGatherer:s[0].iceGatherer,iceTransport:s[0].iceTransport,dtlsTransport:s[0].dtlsTransport}:e._createIceAndDtlsTransports(a,n),d=RTCRtpSender.getCapabilities(o);d.codecs=d.codecs.filter(function(e){return"rtx"!==e.name}),d.codecs.forEach(function(e){"H264"===e.name&&void 0===e.parameters["level-asymmetry-allowed"]&&(e.parameters["level-asymmetry-allowed"]="1")});var u,h,f=[{ssrc:1001*(2*n+1)}];i&&(u=new RTCRtpSender(i,c.dtlsTransport)),t.wantReceive&&(h=new RTCRtpReceiver(c.dtlsTransport,o)),s[n]={iceGatherer:c.iceGatherer,iceTransport:c.iceTransport,dtlsTransport:c.dtlsTransport,localCapabilities:d,remoteCapabilities:null,rtpSender:u,rtpReceiver:h,kind:o,mid:a,
sendEncodingParameters:f,recvEncodingParameters:null}}),this.usingBundle&&(a+="a=group:BUNDLE "+s.map(function(e){return e.mid}).join(" ")+"\r\n"),n.forEach(function(t,n){var i=s[n];a+=r.writeMediaSection(i,i.localCapabilities,"offer",e.localStreams[0])}),this._pendingOffer=s;var c=new RTCSessionDescription({type:"offer",sdp:a});return arguments.length&&"function"==typeof arguments[0]&&window.setTimeout(arguments[0],0,c),Promise.resolve(c)},window.RTCPeerConnection.prototype.createAnswer=function(){var e=this,t=r.writeSessionBoilerplate();this.usingBundle&&(t+="a=group:BUNDLE "+this.transceivers.map(function(e){return e.mid}).join(" ")+"\r\n"),this.transceivers.forEach(function(n){if(n.isDatachannel)return void(t+="m=application 0 DTLS/SCTP 5000\r\nc=IN IP4 0.0.0.0\r\na=mid:"+n.mid+"\r\n");var i=e._getCommonCapabilities(n.localCapabilities,n.remoteCapabilities);t+=r.writeMediaSection(n,i,"answer",e.localStreams[0])});var n=new RTCSessionDescription({type:"answer",sdp:t});return arguments.length&&"function"==typeof arguments[0]&&window.setTimeout(arguments[0],0,n),Promise.resolve(n)},window.RTCPeerConnection.prototype.addIceCandidate=function(e){if(e){var t=e.sdpMLineIndex;if(e.sdpMid)for(var n=0;n<this.transceivers.length;n++)if(this.transceivers[n].mid===e.sdpMid){t=n;break}var i=this.transceivers[t];if(i){var o=Object.keys(e.candidate).length>0?r.parseCandidate(e.candidate):{};if("tcp"===o.protocol&&(0===o.port||9===o.port))return Promise.resolve();if("1"!==o.component)return Promise.resolve();i.iceTransport.addRemoteCandidate(o);var a=r.splitSections(this.remoteDescription.sdp);a[t+1]+=(o.type?e.candidate.trim():"a=end-of-candidates")+"\r\n",this.remoteDescription.sdp=a.join("")}}else for(var s=0;s<this.transceivers.length;s++)if(this.transceivers[s].iceTransport.addRemoteCandidate({}),this.usingBundle)return Promise.resolve();return arguments.length>1&&"function"==typeof arguments[1]&&window.setTimeout(arguments[1],0),Promise.resolve()},window.RTCPeerConnection.prototype.getStats=function(){var e=[];this.transceivers.forEach(function(t){["rtpSender","rtpReceiver","iceGatherer","iceTransport","dtlsTransport"].forEach(function(n){t[n]&&e.push(t[n].getStats())})});var t=arguments.length>1&&"function"==typeof arguments[1]&&arguments[1],n=function(e){return e.type={inboundrtp:"inbound-rtp",outboundrtp:"outbound-rtp",candidatepair:"candidate-pair",localcandidate:"local-candidate",remotecandidate:"remote-candidate"}[e.type]||e.type,e};return new Promise(function(r){var i=new Map;Promise.all(e).then(function(e){e.forEach(function(e){Object.keys(e).forEach(function(t){e[t].type=n(e[t]),i.set(t,e[t])})}),t&&window.setTimeout(t,0,i),r(i)})})}}};e.exports={shimPeerConnection:o.shimPeerConnection,shimGetUserMedia:n(9)}},function(e,t,n){"use strict";e.exports=function(){var e=function(e){return{name:{PermissionDeniedError:"NotAllowedError"}[e.name]||e.name,message:e.message,constraint:e.constraint,toString:function(){return this.name}}},t=navigator.mediaDevices.getUserMedia.bind(navigator.mediaDevices);navigator.mediaDevices.getUserMedia=function(n){return t(n).catch(function(t){return Promise.reject(e(t))})}}},function(e,t,n){"use strict";var r=n(0).browserDetails,i={shimOnTrack:function(){"object"!=typeof window||!window.RTCPeerConnection||"ontrack"in window.RTCPeerConnection.prototype||Object.defineProperty(window.RTCPeerConnection.prototype,"ontrack",{get:function(){return this._ontrack},set:function(e){this._ontrack&&(this.removeEventListener("track",this._ontrack),this.removeEventListener("addstream",this._ontrackpoly)),this.addEventListener("track",this._ontrack=e),this.addEventListener("addstream",this._ontrackpoly=function(e){e.stream.getTracks().forEach(function(t){var n=new Event("track");n.track=t,n.receiver={track:t},n.streams=[e.stream],this.dispatchEvent(n)}.bind(this))}.bind(this))}})},shimSourceObject:function(){"object"==typeof window&&(!window.HTMLMediaElement||"srcObject"in window.HTMLMediaElement.prototype||Object.defineProperty(window.HTMLMediaElement.prototype,"srcObject",{get:function(){return this.mozSrcObject},set:function(e){this.mozSrcObject=e}}))},shimPeerConnection:function(){if("object"==typeof window&&(window.RTCPeerConnection||window.mozRTCPeerConnection)){window.RTCPeerConnection||(window.RTCPeerConnection=function(e,t){if(r.version<38&&e&&e.iceServers){for(var n=[],i=0;i<e.iceServers.length;i++){var o=e.iceServers[i];if(o.hasOwnProperty("urls"))for(var a=0;a<o.urls.length;a++){var s={url:o.urls[a]};0===o.urls[a].indexOf("turn")&&(s.username=o.username,s.credential=o.credential),n.push(s)}else n.push(e.iceServers[i])}e.iceServers=n}return new mozRTCPeerConnection(e,t)},window.RTCPeerConnection.prototype=mozRTCPeerConnection.prototype,mozRTCPeerConnection.generateCertificate&&Object.defineProperty(window.RTCPeerConnection,"generateCertificate",{get:function(){return mozRTCPeerConnection.generateCertificate}}),window.RTCSessionDescription=mozRTCSessionDescription,window.RTCIceCandidate=mozRTCIceCandidate),["setLocalDescription","setRemoteDescription","addIceCandidate"].forEach(function(e){var t=RTCPeerConnection.prototype[e];RTCPeerConnection.prototype[e]=function(){return arguments[0]=new("addIceCandidate"===e?RTCIceCandidate:RTCSessionDescription)(arguments[0]),t.apply(this,arguments)}});var e=RTCPeerConnection.prototype.addIceCandidate;RTCPeerConnection.prototype.addIceCandidate=function(){return arguments[0]?e.apply(this,arguments):(arguments[1]&&arguments[1].apply(null),Promise.resolve())};var t=function(e){var t=new Map;return Object.keys(e).forEach(function(n){t.set(n,e[n]),t[n]=e[n]}),t},n={inboundrtp:"inbound-rtp",outboundrtp:"outbound-rtp",candidatepair:"candidate-pair",localcandidate:"local-candidate",remotecandidate:"remote-candidate"},i=RTCPeerConnection.prototype.getStats;RTCPeerConnection.prototype.getStats=function(e,o,a){return i.apply(this,[e||null]).then(function(e){if(r.version<48&&(e=t(e)),r.version<53&&!o)try{e.forEach(function(e){e.type=n[e.type]||e.type})}catch(t){if("TypeError"!==t.name)throw t;e.forEach(function(t,r){e.set(r,Object.assign({},t,{type:n[t.type]||t.type}))})}return e}).then(o,a)}}}};e.exports={shimOnTrack:i.shimOnTrack,shimSourceObject:i.shimSourceObject,shimPeerConnection:i.shimPeerConnection,shimGetUserMedia:n(11)}},function(e,t,n){"use strict";var r=n(0).log,i=n(0).browserDetails;e.exports=function(){var e=function(e){return{name:{SecurityError:"NotAllowedError",PermissionDeniedError:"NotAllowedError"}[e.name]||e.name,message:{"The operation is insecure.":"The request is not allowed by the user agent or the platform in the current context."}[e.message]||e.message,constraint:e.constraint,toString:function(){return this.name+(this.message&&": ")+this.message}}},t=function(t,n,o){var a=function(e){if("object"!=typeof e||e.require)return e;var t=[];return Object.keys(e).forEach(function(n){if("require"!==n&&"advanced"!==n&&"mediaSource"!==n){var r=e[n]="object"==typeof e[n]?e[n]:{ideal:e[n]};if(void 0===r.min&&void 0===r.max&&void 0===r.exact||t.push(n),void 0!==r.exact&&("number"==typeof r.exact?r.min=r.max=r.exact:e[n]=r.exact,delete r.exact),void 0!==r.ideal){e.advanced=e.advanced||[];var i={};"number"==typeof r.ideal?i[n]={min:r.ideal,max:r.ideal}:i[n]=r.ideal,e.advanced.push(i),delete r.ideal,Object.keys(r).length||delete e[n]}}}),t.length&&(e.require=t),e};return t=JSON.parse(JSON.stringify(t)),i.version<38&&(r("spec: "+JSON.stringify(t)),t.audio&&(t.audio=a(t.audio)),t.video&&(t.video=a(t.video)),r("ff37: "+JSON.stringify(t))),navigator.mozGetUserMedia(t,n,function(t){o(e(t))})},n=function(e){return new Promise(function(n,r){t(e,n,r)})};if(navigator.mediaDevices||(navigator.mediaDevices={getUserMedia:n,addEventListener:function(){},removeEventListener:function(){}}),navigator.mediaDevices.enumerateDevices=navigator.mediaDevices.enumerateDevices||function(){return new Promise(function(e){var t=[{kind:"audioinput",deviceId:"default",label:"",groupId:""},{kind:"videoinput",deviceId:"default",label:"",groupId:""}];e(t)})},i.version<41){var o=navigator.mediaDevices.enumerateDevices.bind(navigator.mediaDevices);navigator.mediaDevices.enumerateDevices=function(){return o().then(void 0,function(e){if("NotFoundError"===e.name)return[];throw e})}}if(i.version<49){var a=navigator.mediaDevices.getUserMedia.bind(navigator.mediaDevices);navigator.mediaDevices.getUserMedia=function(t){return a(t).then(function(e){if(t.audio&&!e.getAudioTracks().length||t.video&&!e.getVideoTracks().length)throw e.getTracks().forEach(function(e){e.stop()}),new DOMException("The object can not be found here.","NotFoundError");return e},function(t){return Promise.reject(e(t))})}}navigator.getUserMedia=function(e,n,r){return i.version<44?t(e,n,r):(console.warn("navigator.getUserMedia has been replaced by navigator.mediaDevices.getUserMedia"),void navigator.mediaDevices.getUserMedia(e).then(n,r))}}},function(e,t,n){"use strict";var r={shimGetUserMedia:function(){navigator.getUserMedia||(navigator.webkitGetUserMedia?navigator.getUserMedia=navigator.webkitGetUserMedia.bind(navigator):navigator.mediaDevices&&navigator.mediaDevices.getUserMedia&&(navigator.getUserMedia=function(e,t,n){navigator.mediaDevices.getUserMedia(e).then(t,n)}.bind(navigator)))}};e.exports={shimGetUserMedia:r.shimGetUserMedia}},function(e,t,n){function r(){function e(e){return"function"==typeof e?e:function(){}}var t=n(2),r=n(1),i=r(),o={prepare:i.prepare,show:i.show,hide:i.hide,scan:i.scan,cancelScan:i.cancelScan,pausePreview:i.pausePreview,resumePreview:i.resumePreview,enableLight:i.enableLight,disableLight:i.disableLight,useCamera:i.useCamera,openSettings:i.openSettings,getStatus:i.getStatus,destroy:i.destroy},a={exec:function(t,n,r,i,a){return"QRScanner"===r&&o[i]?void(a?o[i](e(t),e(n),a):o[i](e(t),e(n))):n(0)}},s=t(a);return s}e.exports=new r}])});
//# sourceMappingURL=cordova-plugin-qrscanner-lib.min.js.map